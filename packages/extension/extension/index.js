var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
import { a as getAugmentedNamespace, c as commonjsGlobal, g as getDefaultExportFromCjs } from "./popup.js";
import { t as tslib_es6 } from "./tslib.es6.js";
import { r as requireEvents } from "./events.js";
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var lib$5 = {};
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
var factory = {};
var events = {};
var uiRequest = {};
(function(exports$12) {
  Object.defineProperty(exports$12, "__esModule", {
    value: true
  });
  exports$12.createUiMessage = exports$12.UI_REQUEST = exports$12.UI_EVENT = void 0;
  exports$12.UI_EVENT = "UI_EVENT";
  exports$12.UI_REQUEST = {
    TRANSPORT: "ui-no_transport",
    BOOTLOADER: "ui-device_bootloader_mode",
    NOT_IN_BOOTLOADER: "ui-device_not_in_bootloader_mode",
    REQUIRE_MODE: "ui-device_require_mode",
    INITIALIZE: "ui-device_not_initialized",
    SEEDLESS: "ui-device_seedless",
    FIRMWARE_OLD: "ui-device_firmware_old",
    FIRMWARE_OUTDATED: "ui-device_firmware_outdated",
    FIRMWARE_NOT_SUPPORTED: "ui-device_firmware_unsupported",
    FIRMWARE_NOT_COMPATIBLE: "ui-device_firmware_not_compatible",
    FIRMWARE_NOT_INSTALLED: "ui-device_firmware_not_installed",
    FIRMWARE_PROGRESS: "ui-firmware-progress",
    FIRMWARE_PROGRESS_UNEXPECTED_DELAY: "ui-firmware-progress-unexpected-delay",
    FIRMWARE_RECONNECT: "ui-firmware_reconnect",
    FIRMWARE_DISCONNECT: "ui-firmware_disconnect",
    FIRMWARE_DOWNLOADED: "ui-firmware_downloaded",
    DEVICE_NEEDS_BACKUP: "ui-device_needs_backup",
    REQUEST_UI_WINDOW: "ui-request_window",
    CLOSE_UI_WINDOW: "ui-close_window",
    REQUEST_PERMISSION: "ui-request_permission",
    REQUEST_CONFIRMATION: "ui-request_confirmation",
    REQUEST_PIN: "ui-request_pin",
    INVALID_PIN: "ui-invalid_pin",
    INVALID_PIN_ATTEMPTS_DEPLETED: "ui-invalid_pin_attempts_depleted",
    REQUEST_PASSPHRASE: "ui-request_passphrase",
    REQUEST_PASSPHRASE_ON_DEVICE: "ui-request_passphrase_on_device",
    INVALID_PASSPHRASE: "ui-invalid_passphrase",
    REQUEST_THP_PAIRING: "ui-request_thp_pairing",
    CONNECT: "ui-connect",
    LOADING: "ui-loading",
    SET_OPERATION: "ui-set_operation",
    SELECT_DEVICE: "ui-select_device",
    SELECT_ACCOUNT: "ui-select_account",
    SELECT_FEE: "ui-select_fee",
    UPDATE_CUSTOM_FEE: "ui-update_custom_fee",
    INSUFFICIENT_FUNDS: "ui-insufficient_funds",
    REQUEST_BUTTON: "ui-button",
    REQUEST_WORD: "ui-request_word",
    LOGIN_CHALLENGE_REQUEST: "ui-login_challenge_request",
    BUNDLE_PROGRESS: "ui-bundle_progress",
    ADDRESS_VALIDATION: "ui-address_validation"
  };
  const createUiMessage = (type2, payload) => ({
    event: exports$12.UI_EVENT,
    type: type2,
    payload
  });
  exports$12.createUiMessage = createUiMessage;
})(uiRequest);
var uiResponse = {};
Object.defineProperty(uiResponse, "__esModule", {
  value: true
});
uiResponse.createUiResponse = uiResponse.UI_RESPONSE = void 0;
const ui_request_1 = uiRequest;
uiResponse.UI_RESPONSE = {
  RECEIVE_PERMISSION: "ui-receive_permission",
  RECEIVE_CONFIRMATION: "ui-receive_confirmation",
  RECEIVE_FIRMWARE: "ui-receive_firmware",
  RECEIVE_PIN: "ui-receive_pin",
  RECEIVE_PASSPHRASE: "ui-receive_passphrase",
  RECEIVE_THP_PAIRING_TAG: "ui-receive_thp_pairing_tag",
  RECEIVE_DEVICE: "ui-receive_device",
  RECEIVE_ACCOUNT: "ui-receive_account",
  RECEIVE_FEE: "ui-receive_fee",
  RECEIVE_WORD: "ui-receive_word",
  INVALID_PASSPHRASE_ACTION: "ui-invalid_passphrase_action",
  CHANGE_SETTINGS: "ui-change_settings",
  LOGIN_CHALLENGE_RESPONSE: "ui-login_challenge_response"
};
const createUiResponse = (type2, payload) => ({
  event: ui_request_1.UI_EVENT,
  type: type2,
  payload
});
uiResponse.createUiResponse = createUiResponse;
var blockchain = {};
var hasRequiredBlockchain;
function requireBlockchain() {
  if (hasRequiredBlockchain) return blockchain;
  hasRequiredBlockchain = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.createBlockchainMessage = exports$12.BLOCKCHAIN = exports$12.BLOCKCHAIN_EVENT = void 0;
    exports$12.BLOCKCHAIN_EVENT = "BLOCKCHAIN_EVENT";
    exports$12.BLOCKCHAIN = {
      CONNECT: "blockchain-connect",
      RECONNECTING: "blockchain-reconnecting",
      ERROR: "blockchain-error",
      BLOCK: "blockchain-block",
      NOTIFICATION: "blockchain-notification",
      FIAT_RATES_UPDATE: "fiat-rates-update"
    };
    const createBlockchainMessage = (type2, payload) => ({
      event: exports$12.BLOCKCHAIN_EVENT,
      type: type2,
      payload
    });
    exports$12.createBlockchainMessage = createBlockchainMessage;
  })(blockchain);
  return blockchain;
}
var call = {};
var errors$4 = {};
var hasRequiredErrors$4;
function requireErrors$4() {
  if (hasRequiredErrors$4) return errors$4;
  hasRequiredErrors$4 = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.LIBUSB_ERROR_MESSAGE = exports$12.serializeError = exports$12.TypedError = exports$12.TransportError = exports$12.nestError = exports$12.TrezorError = exports$12.ERROR_CODES = void 0;
    exports$12.ERROR_CODES = {
      Init_NotInitialized: "TrezorConnect not initialized",
      Init_AlreadyInitialized: "TrezorConnect has been already initialized",
      Init_IframeBlocked: "Iframe blocked",
      Init_IframeTimeout: "Iframe timeout",
      Init_ManifestMissing: "Manifest not set. Read more at https://github.com/trezor/trezor-suite/blob/develop/docs/packages/connect/index.md",
      Popup_ConnectionMissing: "Unable to establish connection with iframe",
      Desktop_ConnectionMissing: "Unable to establish connection with Suite",
      Transport_Missing: "Transport is missing",
      Method_InvalidPackage: "This package is not suitable to work with browser. Use @trezor/connect-web package instead",
      Method_InvalidParameter: "",
      Method_NotAllowed: "Method not allowed for this configuration",
      Method_PermissionsNotGranted: "Permissions not granted",
      Method_Cancel: "Canceled",
      Method_Interrupted: "Popup closed",
      Method_UnknownCoin: "Coin not found",
      Method_AddressNotMatch: "Addresses do not match",
      Method_Discovery_BundleException: "",
      Method_Override: "override",
      Method_NoResponse: "Call resolved without response",
      Method_Unsupported: "Unsupported method",
      Backend_NotSupported: "BlockchainLink settings not found in coins.json",
      Backend_WorkerMissing: "",
      Backend_Disconnected: "Backend disconnected",
      Backend_Invalid: "Invalid backend",
      Backend_Error: "",
      Runtime: "",
      Device_NotFound: "Device not found",
      Device_InitializeFailed: "",
      Device_FwException: "",
      Device_ModeException: "",
      Device_Disconnected: "Device disconnected",
      Device_UsedElsewhere: "Device is used in another window",
      Device_InvalidState: "Passphrase is incorrect",
      Device_CallInProgress: "Device call in progress",
      Device_MultipleNotSupported: "Multiple devices are not supported",
      Device_MissingCapability: "Device is missing capability",
      Device_MissingCapabilityBtcOnly: "Device is missing capability (BTC only)",
      Device_ThpPairingTagInvalid: "Pairing tag mismatch",
      Device_ThpStateMissing: "ThpState missing",
      Device_ThpPairingMethodsException: "No common pairing methods",
      Failure_UnknownCode: "Unknown error",
      Failure_EntropyCheck: "",
      Deeplink_VersionMismatch: "Not compatible with current version of the app",
      Browser_LocalNetworkPermissionMissing: "Local network permission is missing. Please allow local network access in browser settings."
    };
    class TrezorError extends Error {
      constructor(code, message2, options) {
        super(message2, options);
        __publicField(this, "code");
        __publicField(this, "message");
        this.code = code;
        this.message = message2;
      }
      toString() {
        return `${this.name} (code: ${this.code}): ${this.message}`;
      }
    }
    exports$12.TrezorError = TrezorError;
    const nestError = (cause) => cause instanceof TrezorError ? new TrezorError(cause.code, cause.message, {
      cause
    }) : new Error(cause.message, {
      cause
    });
    exports$12.nestError = nestError;
    class TransportError extends Error {
    }
    exports$12.TransportError = TransportError;
    const TypedError = (id, message2) => new TrezorError(id, message2 || exports$12.ERROR_CODES[id] || id);
    exports$12.TypedError = TypedError;
    const serializeError2 = (payload) => {
      const error2 = (payload == null ? void 0 : payload.error) instanceof Error ? payload.error : payload;
      return error2 instanceof Error ? {
        error: error2.message,
        code: "code" in error2 ? error2.code : "Failure_UnknownCode"
      } : {
        ...payload
      };
    };
    exports$12.serializeError = serializeError2;
    exports$12.LIBUSB_ERROR_MESSAGE = "LIBUSB_ERROR";
  })(errors$4);
  return errors$4;
}
var hasRequiredCall;
function requireCall() {
  if (hasRequiredCall) return call;
  hasRequiredCall = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.createResponseMessage = exports$12.RESPONSE_EVENT = void 0;
    const errors_1 = requireErrors$4();
    exports$12.RESPONSE_EVENT = "RESPONSE_EVENT";
    const createResponseMessage = (id, success, payload, device2) => ({
      event: exports$12.RESPONSE_EVENT,
      type: exports$12.RESPONSE_EVENT,
      id,
      success,
      payload: success ? payload : (0, errors_1.serializeError)(payload),
      device: device2 ? {
        path: device2 == null ? void 0 : device2.getUniquePath(),
        state: device2 == null ? void 0 : device2.getState(),
        instance: device2 == null ? void 0 : device2.getInstance()
      } : void 0
    });
    exports$12.createResponseMessage = createResponseMessage;
  })(call);
  return call;
}
var core = {};
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core;
  hasRequiredCore = 1;
  Object.defineProperty(core, "__esModule", {
    value: true
  });
  core.createErrorMessage = core.parseMessage = core.CORE_EVENT = void 0;
  core.CORE_EVENT = "CORE_EVENT";
  const parseMessage = (messageData) => {
    const message2 = {
      event: messageData.event,
      type: messageData.type,
      payload: messageData.payload,
      device: messageData.device
    };
    if (typeof messageData.id === "number") {
      message2.id = messageData.id;
    }
    if (typeof messageData.success === "boolean") {
      message2.success = messageData.success;
    }
    return message2;
  };
  core.parseMessage = parseMessage;
  const createErrorMessage = (error2) => ({
    success: false,
    payload: {
      error: error2.message,
      code: error2.code
    }
  });
  core.createErrorMessage = createErrorMessage;
  return core;
}
var device$1 = {};
var protocolTpn = {};
var decode$1 = {};
var errors$3 = {};
var hasRequiredErrors$3;
function requireErrors$3() {
  if (hasRequiredErrors$3) return errors$3;
  hasRequiredErrors$3 = 1;
  Object.defineProperty(errors$3, "__esModule", {
    value: true
  });
  errors$3.PROTOCOL_MISSMATCH_VERSION = errors$3.PROTOCOL_MALFORMED = void 0;
  errors$3.PROTOCOL_MALFORMED = "Malformed protocol format";
  errors$3.PROTOCOL_MISSMATCH_VERSION = "Protocol missmatch version";
  return errors$3;
}
var constants$2 = {};
var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$2;
  hasRequiredConstants$1 = 1;
  Object.defineProperty(constants$2, "__esModule", {
    value: true
  });
  constants$2.TPN_VERSION = constants$2.MESSAGE_LENGTH = void 0;
  constants$2.MESSAGE_LENGTH = 3;
  constants$2.TPN_VERSION = 1;
  return constants$2;
}
var hasRequiredDecode$1;
function requireDecode$1() {
  if (hasRequiredDecode$1) return decode$1;
  hasRequiredDecode$1 = 1;
  Object.defineProperty(decode$1, "__esModule", {
    value: true
  });
  decode$1.decode = decode$1.TrezorPushNotificationMode = decode$1.TrezorPushNotificationType = decode$1.Version = void 0;
  const errors_1 = requireErrors$3();
  const constants_12 = requireConstants$1();
  var Version;
  (function(Version2) {
    Version2[Version2["v1"] = 1] = "v1";
  })(Version || (decode$1.Version = Version = {}));
  var TrezorPushNotificationType;
  (function(TrezorPushNotificationType2) {
    TrezorPushNotificationType2[TrezorPushNotificationType2["BOOT"] = 0] = "BOOT";
    TrezorPushNotificationType2[TrezorPushNotificationType2["UNLOCK"] = 1] = "UNLOCK";
    TrezorPushNotificationType2[TrezorPushNotificationType2["LOCK"] = 2] = "LOCK";
    TrezorPushNotificationType2[TrezorPushNotificationType2["DISCONNECT"] = 3] = "DISCONNECT";
    TrezorPushNotificationType2[TrezorPushNotificationType2["SETTING_CHANGE"] = 4] = "SETTING_CHANGE";
    TrezorPushNotificationType2[TrezorPushNotificationType2["SOFTLOCK"] = 5] = "SOFTLOCK";
    TrezorPushNotificationType2[TrezorPushNotificationType2["SOFTUNLOCK"] = 6] = "SOFTUNLOCK";
    TrezorPushNotificationType2[TrezorPushNotificationType2["PIN_CHANGE"] = 7] = "PIN_CHANGE";
    TrezorPushNotificationType2[TrezorPushNotificationType2["WIPE"] = 8] = "WIPE";
    TrezorPushNotificationType2[TrezorPushNotificationType2["UNPAIR"] = 9] = "UNPAIR";
    TrezorPushNotificationType2[TrezorPushNotificationType2["NOTIFY_POWER_STATUS_CHANGE"] = 10] = "NOTIFY_POWER_STATUS_CHANGE";
  })(TrezorPushNotificationType || (decode$1.TrezorPushNotificationType = TrezorPushNotificationType = {}));
  var TrezorPushNotificationMode;
  (function(TrezorPushNotificationMode2) {
    TrezorPushNotificationMode2[TrezorPushNotificationMode2["NormalMode"] = 0] = "NormalMode";
    TrezorPushNotificationMode2[TrezorPushNotificationMode2["BootloaderMode"] = 1] = "BootloaderMode";
  })(TrezorPushNotificationMode || (decode$1.TrezorPushNotificationMode = TrezorPushNotificationMode = {}));
  const decode2 = (message2) => {
    const [version2, type2, mode] = message2;
    if (!version2 || version2 !== constants_12.TPN_VERSION) {
      return {
        success: false,
        error: errors_1.PROTOCOL_MISSMATCH_VERSION
      };
    }
    if (message2.length < constants_12.MESSAGE_LENGTH || !Object.values(Version).includes(version2) || !Object.values(TrezorPushNotificationType).includes(type2) || !Object.values(TrezorPushNotificationMode).includes(mode)) {
      return {
        success: false,
        error: errors_1.PROTOCOL_MALFORMED
      };
    }
    return {
      success: true,
      payload: {
        type: type2,
        mode
      }
    };
  };
  decode$1.decode = decode2;
  return decode$1;
}
var hasRequiredProtocolTpn;
function requireProtocolTpn() {
  if (hasRequiredProtocolTpn) return protocolTpn;
  hasRequiredProtocolTpn = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    const tslib_12 = require$$0$1;
    tslib_12.__exportStar(requireDecode$1(), exports$12);
  })(protocolTpn);
  return protocolTpn;
}
var hasRequiredDevice$1;
function requireDevice$1() {
  if (hasRequiredDevice$1) return device$1;
  hasRequiredDevice$1 = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.createDeviceMessage = exports$12.DEVICE = exports$12.DEVICE_EVENT = exports$12.TrezorPushNotificationType = exports$12.TrezorPushNotificationMode = void 0;
    var protocol_tpn_1 = requireProtocolTpn();
    Object.defineProperty(exports$12, "TrezorPushNotificationMode", {
      enumerable: true,
      get: function() {
        return protocol_tpn_1.TrezorPushNotificationMode;
      }
    });
    Object.defineProperty(exports$12, "TrezorPushNotificationType", {
      enumerable: true,
      get: function() {
        return protocol_tpn_1.TrezorPushNotificationType;
      }
    });
    exports$12.DEVICE_EVENT = "DEVICE_EVENT";
    exports$12.DEVICE = {
      CONNECT: "device-connect",
      CONNECT_UNACQUIRED: "device-connect_unacquired",
      DISCONNECT: "device-disconnect",
      CHANGED: "device-changed",
      FIRMWARE_VERSION_CHANGED: "device-firmware_version_changed",
      TREZOR_PUSH_NOTIFICATION: "device-trezor_push_notification",
      THP_CREDENTIALS_CHANGED: "device-thp_credentials_changed",
      BUTTON: "button",
      PIN: "pin",
      PASSPHRASE: "passphrase",
      PASSPHRASE_ON_DEVICE: "passphrase_on_device",
      WORD: "word",
      THP_PAIRING: "thp_pairing"
    };
    const createDeviceMessage = (type2, payload) => ({
      event: exports$12.DEVICE_EVENT,
      type: type2,
      payload
    });
    exports$12.createDeviceMessage = createDeviceMessage;
  })(device$1);
  return device$1;
}
var iframe$2 = {};
var hasRequiredIframe$1;
function requireIframe$1() {
  if (hasRequiredIframe$1) return iframe$2;
  hasRequiredIframe$1 = 1;
  Object.defineProperty(iframe$2, "__esModule", {
    value: true
  });
  iframe$2.createIFrameMessage = iframe$2.IFRAME = void 0;
  const ui_request_12 = uiRequest;
  iframe$2.IFRAME = {
    BOOTSTRAP: "iframe-bootstrap",
    LOADED: "iframe-loaded",
    INIT: "iframe-init",
    ERROR: "iframe-error",
    CALL: "iframe-call",
    LOG: "iframe-log"
  };
  const createIFrameMessage = (type2, payload) => ({
    event: ui_request_12.UI_EVENT,
    type: type2,
    payload
  });
  iframe$2.createIFrameMessage = createIFrameMessage;
  return iframe$2;
}
var popup$3 = {};
var hasRequiredPopup$1;
function requirePopup$1() {
  if (hasRequiredPopup$1) return popup$3;
  hasRequiredPopup$1 = 1;
  Object.defineProperty(popup$3, "__esModule", {
    value: true
  });
  popup$3.createPopupMessage = popup$3.POPUP = void 0;
  const ui_request_12 = uiRequest;
  popup$3.POPUP = {
    BOOTSTRAP: "popup-bootstrap",
    LOADED: "popup-loaded",
    CORE_LOADED: "popup-core-loaded",
    INIT: "popup-init",
    ERROR: "popup-error",
    EXTENSION_USB_PERMISSIONS: "open-usb-permissions",
    HANDSHAKE: "popup-handshake",
    CLOSED: "popup-closed",
    CANCEL_POPUP_REQUEST: "ui-cancel-popup-request",
    CLOSE_WINDOW: "window.close",
    ANALYTICS_RESPONSE: "popup-analytics-response",
    CONTENT_SCRIPT_LOADED: "popup-content-script-loaded",
    METHOD_INFO: "popup-method-info"
  };
  const createPopupMessage = (type2, payload) => ({
    event: ui_request_12.UI_EVENT,
    type: type2,
    payload
  });
  popup$3.createPopupMessage = createPopupMessage;
  return popup$3;
}
var transport = {};
var udevInfo = {};
var hasRequiredUdevInfo;
function requireUdevInfo() {
  if (hasRequiredUdevInfo) return udevInfo;
  hasRequiredUdevInfo = 1;
  Object.defineProperty(udevInfo, "__esModule", {
    value: true
  });
  udevInfo.suggestUdevInstaller = void 0;
  const info = {
    packages: [{
      name: "RPM package",
      platform: ["rpm32", "rpm64"],
      url: "/udev/trezor-udev-2-1.noarch.rpm"
    }, {
      name: "DEB package",
      platform: ["deb32", "deb64"],
      url: "/udev/trezor-udev_2_all.deb",
      preferred: true
    }]
  };
  const suggestUdevInstaller = (platform) => {
    if (platform !== void 0) {
      return {
        packages: info.packages.map((it) => ({
          ...it,
          preferred: it.platform.indexOf(platform) >= 0
        }))
      };
    }
    return info;
  };
  udevInfo.suggestUdevInstaller = suggestUdevInstaller;
  return udevInfo;
}
var constants$1 = {};
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants$1;
  hasRequiredConstants = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.DEVICE_TYPE = exports$12.TRANSPORT = exports$12.ACTION_TIMEOUT = exports$12.TREZOR_USB_DESCRIPTORS = exports$12.WEBUSB_BOOTLOADER_PRODUCT = exports$12.T1_HID_PRODUCT = exports$12.T1_HID_VENDOR = exports$12.DEBUGLINK_ENDPOINT_ID = exports$12.DEBUGLINK_INTERFACE_ID = exports$12.ENDPOINT_ID = exports$12.INTERFACE_ID = exports$12.CONFIGURATION_ID = void 0;
    exports$12.CONFIGURATION_ID = 1;
    exports$12.INTERFACE_ID = 0;
    exports$12.ENDPOINT_ID = 1;
    exports$12.DEBUGLINK_INTERFACE_ID = 1;
    exports$12.DEBUGLINK_ENDPOINT_ID = 2;
    exports$12.T1_HID_VENDOR = 21324;
    exports$12.T1_HID_PRODUCT = 1;
    const WEBUSB_FIRMWARE_PRODUCT = 21441;
    exports$12.WEBUSB_BOOTLOADER_PRODUCT = 21440;
    exports$12.TREZOR_USB_DESCRIPTORS = [{
      vendorId: 21324,
      productId: exports$12.T1_HID_PRODUCT
    }, {
      vendorId: 4617,
      productId: exports$12.WEBUSB_BOOTLOADER_PRODUCT
    }, {
      vendorId: 4617,
      productId: WEBUSB_FIRMWARE_PRODUCT
    }];
    exports$12.ACTION_TIMEOUT = 1e4;
    exports$12.TRANSPORT = {
      START: "transport-start",
      ERROR: "transport-error",
      STOPPED: "transport-stopped",
      DEVICE_CONNECTED: "transport-device_connected",
      DEVICE_DISCONNECTED: "transport-device_disconnected",
      DEVICE_SESSION_CHANGED: "transport-device_session_changed",
      DEVICE_REQUEST_RELEASE: "transport-device_request_release",
      SEND_MESSAGE_PROGRESS: "transport-send_message_progress",
      TREZOR_PUSH_NOTIFICATION: "trezor-push-notification",
      BATTERY_LEVEL: "battery-level",
      DISABLE_WEBUSB: "transport-disable_webusb",
      REQUEST_DEVICE: "transport-request_device",
      GET_INFO: "transport-get_info",
      SET_TRANSPORTS: "transport-set_transports"
    };
    var DEVICE_TYPE;
    (function(DEVICE_TYPE2) {
      DEVICE_TYPE2[DEVICE_TYPE2["TypeT1Hid"] = 0] = "TypeT1Hid";
      DEVICE_TYPE2[DEVICE_TYPE2["TypeT1Webusb"] = 1] = "TypeT1Webusb";
      DEVICE_TYPE2[DEVICE_TYPE2["TypeT1WebusbBoot"] = 2] = "TypeT1WebusbBoot";
      DEVICE_TYPE2[DEVICE_TYPE2["TypeT2"] = 3] = "TypeT2";
      DEVICE_TYPE2[DEVICE_TYPE2["TypeT2Boot"] = 4] = "TypeT2Boot";
      DEVICE_TYPE2[DEVICE_TYPE2["TypeEmulator"] = 5] = "TypeEmulator";
      DEVICE_TYPE2[DEVICE_TYPE2["TypeBluetooth"] = 6] = "TypeBluetooth";
    })(DEVICE_TYPE || (exports$12.DEVICE_TYPE = DEVICE_TYPE = {}));
  })(constants$1);
  return constants$1;
}
var hasRequiredTransport;
function requireTransport() {
  if (hasRequiredTransport) return transport;
  hasRequiredTransport = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.createTransportMessage = exports$12.TRANSPORT_EVENT = exports$12.TRANSPORT = void 0;
    const errors_1 = requireErrors$4();
    const udevInfo_1 = requireUdevInfo();
    var constants_12 = requireConstants();
    Object.defineProperty(exports$12, "TRANSPORT", {
      enumerable: true,
      get: function() {
        return constants_12.TRANSPORT;
      }
    });
    exports$12.TRANSPORT_EVENT = "TRANSPORT_EVENT";
    const createTransportMessage = (type2, payload) => ({
      event: exports$12.TRANSPORT_EVENT,
      type: type2,
      payload: "error" in payload ? (0, errors_1.serializeError)(payload) : {
        ...payload,
        udev: (0, udevInfo_1.suggestUdevInstaller)()
      }
    });
    exports$12.createTransportMessage = createTransportMessage;
  })(transport);
  return transport;
}
var uiPromise = {};
var hasRequiredUiPromise;
function requireUiPromise() {
  if (hasRequiredUiPromise) return uiPromise;
  hasRequiredUiPromise = 1;
  Object.defineProperty(uiPromise, "__esModule", {
    value: true
  });
  return uiPromise;
}
var webextension = {};
var hasRequiredWebextension;
function requireWebextension() {
  if (hasRequiredWebextension) return webextension;
  hasRequiredWebextension = 1;
  Object.defineProperty(webextension, "__esModule", {
    value: true
  });
  webextension.WEBEXTENSION = void 0;
  webextension.WEBEXTENSION = {
    USB_PERMISSIONS_BROADCAST: "usb-permissions",
    USB_PERMISSIONS_INIT: "usb-permissions-init",
    USB_PERMISSIONS_CLOSE: "usb-permissions-close",
    USB_PERMISSIONS_FINISHED: "usb-permissions-finished",
    CHANNEL_HANDSHAKE_CONFIRM: "channel-handshake-confirm"
  };
  return webextension;
}
(function(exports$12) {
  Object.defineProperty(exports$12, "__esModule", {
    value: true
  });
  exports$12.UI = void 0;
  const tslib_12 = require$$0$1;
  const ui_request_12 = uiRequest;
  const ui_response_1 = uiResponse;
  tslib_12.__exportStar(requireBlockchain(), exports$12);
  tslib_12.__exportStar(requireCall(), exports$12);
  tslib_12.__exportStar(requireCore(), exports$12);
  tslib_12.__exportStar(requireDevice$1(), exports$12);
  tslib_12.__exportStar(requireIframe$1(), exports$12);
  tslib_12.__exportStar(requirePopup$1(), exports$12);
  tslib_12.__exportStar(requireTransport(), exports$12);
  tslib_12.__exportStar(requireUiPromise(), exports$12);
  tslib_12.__exportStar(uiRequest, exports$12);
  tslib_12.__exportStar(uiResponse, exports$12);
  tslib_12.__exportStar(requireWebextension(), exports$12);
  exports$12.UI = {
    ...ui_request_12.UI_REQUEST,
    ...ui_response_1.UI_RESPONSE
  };
})(events);
(function(exports$12) {
  Object.defineProperty(exports$12, "__esModule", {
    value: true
  });
  exports$12.factory = exports$12.connectCallableMethods = void 0;
  const events_12 = events;
  exports$12.connectCallableMethods = ["applyFlags", "applySettings", "authenticateDevice", "authorizeCoinjoin", "backupDevice", "bleUnpair", "blockchainDisconnect", "blockchainEstimateFee", "blockchainEvmRpcCall", "blockchainGetAccountBalanceHistory", "blockchainGetCurrentFiatRates", "blockchainGetFiatRatesForTimestamps", "blockchainGetInfo", "blockchainGetTransactions", "blockchainSetCustomBackend", "blockchainSubscribe", "blockchainSubscribeFiatRates", "blockchainUnsubscribe", "blockchainUnsubscribeFiatRates", "cancelCoinjoinAuthorization", "cardanoComposeTransaction", "cardanoGetAddress", "cardanoGetNativeScriptHash", "cardanoGetPublicKey", "cardanoSignMessage", "cardanoSignTransaction", "changeLanguage", "changePin", "changeWipeCode", "cipherKeyValue", "composeTransaction", "discoverAccounts", "eosGetPublicKey", "eosSignTransaction", "ethereumGetAddress", "ethereumGetPublicKey", "ethereumSignMessage", "ethereumSignTransaction", "ethereumSignTypedData", "ethereumVerifyMessage", "evoluGetDelegatedIdentityKey", "evoluGetNode", "evoluSignRegistrationRequest", "firmwareUpdate", "getAccountDescriptor", "getAccountInfo", "getAddress", "getCoinInfo", "getDeviceState", "getFeatures", "getFirmwareHash", "getNonce", "getOwnershipId", "getOwnershipProof", "getPublicKey", "getSettings", "loadDevice", "moneroGetAddress", "moneroGetWatchKey", "moneroKeyImageSync", "moneroSignTransaction", "nemGetAddress", "nemSignTransaction", "pushTransaction", "recoveryDevice", "requestLogin", "resetDevice", "rippleGetAddress", "rippleSignTransaction", "setBrightness", "setBusy", "setProxy", "showDeviceTutorial", "signMessage", "signTransaction", "solanaComposeTransaction", "solanaGetAddress", "solanaGetPublicKey", "solanaSignTransaction", "stellarGetAddress", "stellarSignTransaction", "tezosGetAddress", "tezosGetPublicKey", "tezosSignTransaction", "thpGetCredentials", "thpRemoveCredentials", "unlockPath", "verifyMessage", "wipeDevice"];
  const factory2 = ({
    eventEmitter,
    manifest,
    init,
    call: call2,
    setTransports,
    uiResponse: uiResponse2,
    cancel,
    dispose
  }, extraMethods = {}) => {
    const callableMethods = Object.fromEntries(exports$12.connectCallableMethods.map((method2) => [method2, (params2) => call2({
      ...params2,
      method: method2,
      useEventListener: method2.toLowerCase().endsWith("getaddress") ? eventEmitter.listenerCount(events_12.UI.ADDRESS_VALIDATION) > 0 : void 0
    })]));
    return {
      manifest,
      init,
      setTransports,
      on: (type2, fn) => {
        eventEmitter.on(type2, fn);
      },
      off: (type2, fn) => {
        eventEmitter.removeListener(type2, fn);
      },
      removeAllListeners: (type2) => {
        if (typeof type2 === "string") {
          eventEmitter.removeAllListeners(type2);
        } else {
          eventEmitter.removeAllListeners();
        }
      },
      uiResponse: uiResponse2,
      call: call2,
      dispose,
      cancel,
      ...callableMethods,
      ...extraMethods
    };
  };
  exports$12.factory = factory2;
})(factory);
var dynamic = {};
var lib$4 = {};
var bufferUtils = {};
var hasRequiredBufferUtils;
function requireBufferUtils() {
  if (hasRequiredBufferUtils) return bufferUtils;
  hasRequiredBufferUtils = 1;
  Object.defineProperty(bufferUtils, "__esModule", {
    value: true
  });
  bufferUtils.getChunkSize = bufferUtils.reverseBuffer = void 0;
  const reverseBuffer = (src) => {
    if (src.length < 1) return src;
    const buffer2 = Buffer.alloc(src.length);
    let j = buffer2.length - 1;
    for (let i = 0; i < buffer2.length / 2; i++) {
      buffer2[i] = src[j];
      buffer2[j] = src[i];
      j--;
    }
    return buffer2;
  };
  bufferUtils.reverseBuffer = reverseBuffer;
  const getChunkSize = (n) => {
    const buf = Buffer.allocUnsafe(1);
    buf.writeUInt8(n);
    return buf;
  };
  bufferUtils.getChunkSize = getChunkSize;
  return bufferUtils;
}
var enumUtils = {};
var hasRequiredEnumUtils;
function requireEnumUtils() {
  if (hasRequiredEnumUtils) return enumUtils;
  hasRequiredEnumUtils = 1;
  Object.defineProperty(enumUtils, "__esModule", {
    value: true
  });
  enumUtils.getKeyByValue = getKeyByValue;
  enumUtils.getValueByKey = getValueByKey;
  function getKeyByValue(obj, value2) {
    return obj && Object.keys(obj).find((x) => obj[x] === value2);
  }
  function getValueByKey(obj, enumKey) {
    const key = obj && Object.keys(obj).find((x) => x === enumKey);
    return key && obj[key];
  }
  return enumUtils;
}
var versionUtils = {};
var throwError = {};
var hasRequiredThrowError;
function requireThrowError() {
  if (hasRequiredThrowError) return throwError;
  hasRequiredThrowError = 1;
  Object.defineProperty(throwError, "__esModule", {
    value: true
  });
  throwError.throwError = void 0;
  const throwError$1 = (reason) => {
    throw new Error(reason);
  };
  throwError.throwError = throwError$1;
  return throwError;
}
var hasRequiredVersionUtils;
function requireVersionUtils() {
  if (hasRequiredVersionUtils) return versionUtils;
  hasRequiredVersionUtils = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.normalizeVersion = exports$12.isNewerOrEqual = exports$12.isEqual = exports$12.isNewer = exports$12.tryParse = exports$12.isVersionArray = void 0;
    const throwError_1 = requireThrowError();
    const isVersionArray = (arr) => Array.isArray(arr) && arr.length === 3 && arr.every((number2) => typeof number2 === "number" && number2 >= 0);
    exports$12.isVersionArray = isVersionArray;
    const tryParse = (version2) => {
      var _a;
      return (_a = version2.match(/^(\d+)\.(\d+)\.(\d+)([+-].*)?$/)) == null ? void 0 : _a.slice(1, 4).map((n) => Number(n));
    };
    exports$12.tryParse = tryParse;
    const validateArray = (version2) => (0, exports$12.isVersionArray)(version2) ? version2 : null;
    const ensureArray = (version2) => (typeof version2 === "string" ? (0, exports$12.tryParse)(version2) : validateArray(version2)) ?? (0, throwError_1.throwError)(`version string is in wrong format: ${version2}`);
    const compare = ([majorX, minorX, patchX], [majorY, minorY, patchY]) => majorX - majorY || minorX - minorY || patchX - patchY;
    const isNewer = (versionX, versionY) => compare(ensureArray(versionX), ensureArray(versionY)) > 0;
    exports$12.isNewer = isNewer;
    const isEqual = (versionX, versionY) => compare(ensureArray(versionX), ensureArray(versionY)) === 0;
    exports$12.isEqual = isEqual;
    const isNewerOrEqual = (versionX, versionY) => compare(ensureArray(versionX), ensureArray(versionY)) >= 0;
    exports$12.isNewerOrEqual = isNewerOrEqual;
    const normalizeVersion = (version2) => version2.replace(/\b0+(\d)/g, "$1");
    exports$12.normalizeVersion = normalizeVersion;
  })(versionUtils);
  return versionUtils;
}
var xssFilters = {};
var hasRequiredXssFilters;
function requireXssFilters() {
  if (hasRequiredXssFilters) return xssFilters;
  hasRequiredXssFilters = 1;
  Object.defineProperty(xssFilters, "__esModule", {
    value: true
  });
  xssFilters.inDoubleQuotes = xssFilters.inSingleQuotes = xssFilters.inHTML = void 0;
  const LT = /</g;
  const SQUOT = /'/g;
  const QUOT = /"/g;
  const inHTML = (value2) => value2.replace(LT, "&lt;");
  xssFilters.inHTML = inHTML;
  const inSingleQuotes = (value2) => value2.replace(SQUOT, "&#39;");
  xssFilters.inSingleQuotes = inSingleQuotes;
  const inDoubleQuotes = (value2) => value2.replace(QUOT, "&quot;");
  xssFilters.inDoubleQuotes = inDoubleQuotes;
  return xssFilters;
}
var addDashesToSpaces = {};
var hasRequiredAddDashesToSpaces;
function requireAddDashesToSpaces() {
  if (hasRequiredAddDashesToSpaces) return addDashesToSpaces;
  hasRequiredAddDashesToSpaces = 1;
  Object.defineProperty(addDashesToSpaces, "__esModule", {
    value: true
  });
  addDashesToSpaces.addDashesToSpaces = void 0;
  const addDashesToSpaces$1 = (inputString) => inputString.replace(/\s+/g, "-");
  addDashesToSpaces.addDashesToSpaces = addDashesToSpaces$1;
  return addDashesToSpaces;
}
var arrayDistinct = {};
var hasRequiredArrayDistinct;
function requireArrayDistinct() {
  if (hasRequiredArrayDistinct) return arrayDistinct;
  hasRequiredArrayDistinct = 1;
  Object.defineProperty(arrayDistinct, "__esModule", {
    value: true
  });
  arrayDistinct.arrayDistinct = void 0;
  const arrayDistinct$1 = (item, index2, self2) => self2.indexOf(item) === index2;
  arrayDistinct.arrayDistinct = arrayDistinct$1;
  return arrayDistinct;
}
var arrayPartition = {};
var hasRequiredArrayPartition;
function requireArrayPartition() {
  if (hasRequiredArrayPartition) return arrayPartition;
  hasRequiredArrayPartition = 1;
  Object.defineProperty(arrayPartition, "__esModule", {
    value: true
  });
  arrayPartition.arrayPartition = void 0;
  const arrayPartition$1 = (array2, condition) => array2.reduce(([pass, fail], elem) => condition(elem) ? [[...pass, elem], fail] : [pass, [...fail, elem]], [[], []]);
  arrayPartition.arrayPartition = arrayPartition$1;
  return arrayPartition;
}
var arrayShuffle = {};
var hasRequiredArrayShuffle;
function requireArrayShuffle() {
  if (hasRequiredArrayShuffle) return arrayShuffle;
  hasRequiredArrayShuffle = 1;
  Object.defineProperty(arrayShuffle, "__esModule", {
    value: true
  });
  arrayShuffle.arrayShuffle = void 0;
  const arrayShuffle$1 = (array2, {
    randomInt
  }) => {
    const shuffled = array2.slice();
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = randomInt(0, i + 1);
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  };
  arrayShuffle.arrayShuffle = arrayShuffle$1;
  return arrayShuffle;
}
var arrayToDictionary = {};
var hasRequiredArrayToDictionary;
function requireArrayToDictionary() {
  if (hasRequiredArrayToDictionary) return arrayToDictionary;
  hasRequiredArrayToDictionary = 1;
  Object.defineProperty(arrayToDictionary, "__esModule", {
    value: true
  });
  arrayToDictionary.arrayToDictionary = void 0;
  const validateKey = (key) => {
    if (["string", "number"].includes(typeof key)) {
      return true;
    }
    return false;
  };
  const arrayToDictionary$1 = (array2, getKey, multiple) => multiple ? array2.reduce((prev, cur) => {
    const key = getKey(cur);
    if (validateKey(key)) {
      return {
        ...prev,
        [key]: [...prev[key] ?? [], cur]
      };
    }
    return prev;
  }, {}) : array2.reduce((prev, cur) => {
    const key = getKey(cur);
    if (validateKey(key)) {
      return {
        ...prev,
        [key]: cur
      };
    }
    return prev;
  }, {});
  arrayToDictionary.arrayToDictionary = arrayToDictionary$1;
  return arrayToDictionary;
}
var asciiUtils = {};
var hasRequiredAsciiUtils;
function requireAsciiUtils() {
  if (hasRequiredAsciiUtils) return asciiUtils;
  hasRequiredAsciiUtils = 1;
  Object.defineProperty(asciiUtils, "__esModule", {
    value: true
  });
  asciiUtils.isAscii = isAscii;
  asciiUtils.getNonAsciiChars = getNonAsciiChars;
  const ASCII_RANGE = "[^ -~]";
  const nonAsciiPattern = new RegExp(ASCII_RANGE);
  const nonAsciiPatternGlobal = new RegExp(ASCII_RANGE, "g");
  function isAscii(value2) {
    if (!value2) return true;
    return !nonAsciiPattern.test(value2);
  }
  function getNonAsciiChars(value2) {
    if (!value2) return null;
    return value2.match(nonAsciiPatternGlobal);
  }
  return asciiUtils;
}
var bigNumber = {};
var bignumber = { exports: {} };
var hasRequiredBignumber;
function requireBignumber() {
  if (hasRequiredBignumber) return bignumber.exports;
  hasRequiredBignumber = 1;
  (function(module) {
    (function(globalObject) {
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone2(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "Â ",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++) ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0) e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0) i += LOG_BASE;
              if (i < len) {
                if (i) x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0") ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone2;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object") FORMAT = v;
                else throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out: if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1) return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1) i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
                if (n !== 0) return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15) c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--) ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
              if (i < LOG_BASE) e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; ) sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; ) ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry) x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return Â±0 if x is Â±0 or y is Â±Infinity, or return Â±Infinity as y is Â±0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++) ;
            if (yc[i] > (xc[i] || 0)) e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base) n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format2(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++) ;
              str = toExponential(str, e);
            } else {
              i -= ne + (id === 2 && e > ne);
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0) for (str += "."; i--; str += "0") ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len) str += ".";
                  for (; i--; str += "0") ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n) {
          var k, y, i = 1, x = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            y = new BigNumber2(args[i]);
            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
              x = y;
            }
          }
          return x;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop()) ;
          for (j = c[0]; j >= 10; j /= 10, i++) ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s) return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++) ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++) ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop()) ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null) return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0) x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c)) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
          if (n < 0) n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null) m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp) x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1) k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0) break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0) break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0)) ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0) for (; b--; xc[i++] = 0) ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b) ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0)) ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c)) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--) ;
            for (v = c[0]; v >= 10; v /= 10, n++) ;
          }
          if (sd && x.e + 1 > n) n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e) --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format2(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format2(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format22) {
          var str, x = this;
          if (format22 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format22 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format22 = dp;
              dp = rm = null;
            } else {
              format22 = FORMAT;
            }
          } else if (typeof format22 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format22);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format22.groupSize, g2 = +format22.secondaryGroupSize, groupSeparator = format22.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format22.decimalSeparator || "") + ((g2 = +format22.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format22.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format22.prefix || "") + str + (format22.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc) return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format2(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s) ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; ) ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b) return a ? b ? 0 : -j : i;
        if (i != j) return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z) ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone2();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(commonjsGlobal);
  })(bignumber);
  return bignumber.exports;
}
var hasRequiredBigNumber;
function requireBigNumber() {
  if (hasRequiredBigNumber) return bigNumber;
  hasRequiredBigNumber = 1;
  Object.defineProperty(bigNumber, "__esModule", {
    value: true
  });
  bigNumber.BigNumber = void 0;
  const tslib_12 = require$$0$1;
  const bignumber_js_1 = tslib_12.__importDefault(requireBignumber());
  bigNumber.BigNumber = bignumber_js_1.default.clone({
    EXPONENTIAL_AT: 1e9
  });
  return bigNumber;
}
var bytesToHumanReadable = {};
var hasRequiredBytesToHumanReadable;
function requireBytesToHumanReadable() {
  if (hasRequiredBytesToHumanReadable) return bytesToHumanReadable;
  hasRequiredBytesToHumanReadable = 1;
  Object.defineProperty(bytesToHumanReadable, "__esModule", {
    value: true
  });
  bytesToHumanReadable.bytesToHumanReadable = void 0;
  const units = ["B", "KB", "MB", "GB", "TB"];
  const bytesToHumanReadable$1 = (bytes) => {
    let size = Math.abs(bytes);
    let i = 0;
    while (size >= 1024 || i >= units.length) {
      size /= 1024;
      i++;
    }
    return `${size.toFixed(1)} ${units[i]}`;
  };
  bytesToHumanReadable.bytesToHumanReadable = bytesToHumanReadable$1;
  return bytesToHumanReadable;
}
var cache = {};
var hasRequiredCache;
function requireCache() {
  if (hasRequiredCache) return cache;
  hasRequiredCache = 1;
  Object.defineProperty(cache, "__esModule", {
    value: true
  });
  cache.Cache = void 0;
  class Cache {
    constructor() {
      __publicField(this, "store");
      this.store = /* @__PURE__ */ new Map();
    }
    set(key, value2, ttl) {
      this.store.set(key, {
        value: value2,
        ttl: Date.now() + ttl
      });
    }
    get(key) {
      const entry = this.store.get(key);
      if (!entry) return;
      if (entry.ttl < Date.now()) {
        this.store.delete(key);
        return;
      }
      return entry.value;
    }
    delete(key) {
      this.store.delete(key);
    }
  }
  cache.Cache = Cache;
  return cache;
}
var capitalizeFirstLetter = {};
var hasRequiredCapitalizeFirstLetter;
function requireCapitalizeFirstLetter() {
  if (hasRequiredCapitalizeFirstLetter) return capitalizeFirstLetter;
  hasRequiredCapitalizeFirstLetter = 1;
  Object.defineProperty(capitalizeFirstLetter, "__esModule", {
    value: true
  });
  capitalizeFirstLetter.capitalizeFirstLetter = void 0;
  const capitalizeFirstLetter$1 = (str) => str.charAt(0).toUpperCase() + str.slice(1);
  capitalizeFirstLetter.capitalizeFirstLetter = capitalizeFirstLetter$1;
  return capitalizeFirstLetter;
}
var cloneObject = {};
var hasRequiredCloneObject;
function requireCloneObject() {
  if (hasRequiredCloneObject) return cloneObject;
  hasRequiredCloneObject = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.cloneObject = void 0;
    const cloneObject2 = (obj, seen = /* @__PURE__ */ new WeakMap()) => {
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      if (seen.has(obj)) {
        return seen.get(obj);
      }
      if (obj instanceof ArrayBuffer) {
        return obj.slice(0);
      }
      if (ArrayBuffer.isView(obj)) {
        const TypedArrayConstructor = obj.constructor;
        return new TypedArrayConstructor(obj);
      }
      const clone2 = Array.isArray(obj) ? [] : {};
      seen.set(obj, clone2);
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          const value2 = obj[key];
          if (typeof value2 === "function" || typeof value2 === "symbol") {
            continue;
          }
          clone2[key] = (0, exports$12.cloneObject)(value2, seen);
        }
      }
      return clone2;
    };
    exports$12.cloneObject = cloneObject2;
  })(cloneObject);
  return cloneObject;
}
var comparison = {};
var hasRequiredComparison;
function requireComparison() {
  if (hasRequiredComparison) return comparison;
  hasRequiredComparison = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.isChanged = exports$12.deepEqual = void 0;
    const deepEqual = (a, b) => {
      if (a === b) return true;
      if (typeof a !== typeof b) return false;
      if (a === null || b === null) return false;
      if (typeof a !== "object") return false;
      if (Array.isArray(a) !== Array.isArray(b)) return false;
      if (Array.isArray(a)) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) {
          if (!(0, exports$12.deepEqual)(a[i], b[i])) return false;
        }
        return true;
      }
      const keysA = Object.keys(a);
      const keysB = Object.keys(b);
      if (keysA.length !== keysB.length) return false;
      for (const key of keysA) {
        if (!Object.prototype.hasOwnProperty.call(b, key)) return false;
        if (!(0, exports$12.deepEqual)(a[key], b[key])) return false;
      }
      return true;
    };
    exports$12.deepEqual = deepEqual;
    const isChanged = (prev, current, filter) => {
      if (prev === current) return false;
      if (!prev || !current) return true;
      const prevType = Object.prototype.toString.call(prev);
      const currentType = Object.prototype.toString.call(current);
      if (prevType !== currentType) return true;
      if (currentType === "[object Array]") {
        if (prev.length !== current.length) return true;
        for (let i = 0; i < current.length; i++) {
          if ((0, exports$12.isChanged)(prev[i], current[i], filter)) return true;
        }
      } else if (currentType === "[object Object]") {
        const prevKeys = Object.keys(prev);
        const currentKeys = Object.keys(current);
        if (prevKeys.length !== currentKeys.length) return true;
        const prevDifference = prevKeys.find((k) => currentKeys.indexOf(k) < 0);
        if (prevDifference) return true;
        for (let i = 0; i < currentKeys.length; i++) {
          const key = currentKeys[i];
          if (filter && Object.prototype.hasOwnProperty.call(filter, key) && prev[key] && current[key]) {
            const prevFiltered = {};
            const currentFiltered = {};
            for (let i2 = 0; i2 < filter[key].length; i2++) {
              const field2 = filter[key][i2];
              prevFiltered[field2] = prev[key][field2];
              currentFiltered[field2] = current[key][field2];
            }
            if ((0, exports$12.isChanged)(prevFiltered, currentFiltered)) return true;
          } else if ((0, exports$12.isChanged)(prev[key], current[key])) {
            return true;
          }
        }
      } else if (prev !== current) {
        return true;
      }
      return false;
    };
    exports$12.isChanged = isChanged;
  })(comparison);
  return comparison;
}
var convertTaprootXpub = {};
var hasRequiredConvertTaprootXpub;
function requireConvertTaprootXpub() {
  if (hasRequiredConvertTaprootXpub) return convertTaprootXpub;
  hasRequiredConvertTaprootXpub = 1;
  Object.defineProperty(convertTaprootXpub, "__esModule", {
    value: true
  });
  convertTaprootXpub.convertTaprootXpub = void 0;
  const convertTaprootXpub$1 = ({
    xpub,
    direction
  }) => {
    const find = direction === "h-to-apostrophe" ? "h" : "'";
    const replace = direction === "h-to-apostrophe" ? "'" : "h";
    const openingSquareBracketSplit = xpub.split("[");
    if (openingSquareBracketSplit.length === 2) {
      const [beforeOpeningBracket, afterOpeningBracket] = openingSquareBracketSplit;
      const closingSquareBracketSplit = afterOpeningBracket.split("]");
      if (closingSquareBracketSplit.length === 2) {
        const [path2, afterClosingBracket] = closingSquareBracketSplit;
        const correctedPath = path2.replace(new RegExp(find, "g"), replace);
        return `${beforeOpeningBracket}[${correctedPath}]${afterClosingBracket}`;
      }
    }
    return null;
  };
  convertTaprootXpub.convertTaprootXpub = convertTaprootXpub$1;
  return convertTaprootXpub;
}
var countBytesInString = {};
var hasRequiredCountBytesInString;
function requireCountBytesInString() {
  if (hasRequiredCountBytesInString) return countBytesInString;
  hasRequiredCountBytesInString = 1;
  Object.defineProperty(countBytesInString, "__esModule", {
    value: true
  });
  countBytesInString.countBytesInString = void 0;
  const countBytesInString$1 = (input) => encodeURI(input).split(/%..|./).length - 1;
  countBytesInString.countBytesInString = countBytesInString$1;
  return countBytesInString;
}
var createCooldown = {};
var hasRequiredCreateCooldown;
function requireCreateCooldown() {
  if (hasRequiredCreateCooldown) return createCooldown;
  hasRequiredCreateCooldown = 1;
  Object.defineProperty(createCooldown, "__esModule", {
    value: true
  });
  createCooldown.createCooldown = void 0;
  const createCooldown$1 = (cooldownMs) => {
    let last = 0;
    return () => {
      const now = Date.now();
      if (now - last >= cooldownMs) {
        last = now;
        return true;
      }
      return false;
    };
  };
  createCooldown.createCooldown = createCooldown$1;
  return createCooldown;
}
var createDeferred = {};
var hasRequiredCreateDeferred;
function requireCreateDeferred() {
  if (hasRequiredCreateDeferred) return createDeferred;
  hasRequiredCreateDeferred = 1;
  Object.defineProperty(createDeferred, "__esModule", {
    value: true
  });
  createDeferred.createDeferred = void 0;
  const createDeferred$1 = (id) => {
    let localResolve = () => {
    };
    let localReject = () => {
    };
    const promise2 = new Promise((resolve, reject) => {
      localResolve = resolve;
      localReject = reject;
    });
    return {
      id,
      resolve: localResolve,
      reject: localReject,
      promise: promise2
    };
  };
  createDeferred.createDeferred = createDeferred$1;
  return createDeferred;
}
var createDeferredManager = {};
var hasRequiredCreateDeferredManager;
function requireCreateDeferredManager() {
  if (hasRequiredCreateDeferredManager) return createDeferredManager;
  hasRequiredCreateDeferredManager = 1;
  Object.defineProperty(createDeferredManager, "__esModule", {
    value: true
  });
  createDeferredManager.createDeferredManager = void 0;
  const createDeferred_1 = requireCreateDeferred();
  const createDeferredManager$1 = (options) => {
    const {
      initialId = 0,
      timeout: defaultTimeout = 0,
      onTimeout
    } = options ?? {};
    const promises = [];
    let ID = initialId;
    let timeoutHandle;
    const length = () => promises.length;
    const nextId = () => ID;
    const replanTimeout = () => {
      const now = Date.now();
      const nearestDeadline = promises.reduce((prev, {
        deadline
      }) => (prev && deadline ? Math.min : Math.max)(prev, deadline), 0);
      if (timeoutHandle) clearTimeout(timeoutHandle);
      timeoutHandle = nearestDeadline ? setTimeout(timeoutCallback, Math.max(nearestDeadline - now, 0)) : void 0;
    };
    const timeoutCallback = () => {
      const now = Date.now();
      promises.filter((promise2) => promise2.deadline && promise2.deadline <= now).forEach((promise2) => {
        onTimeout == null ? void 0 : onTimeout(promise2.id);
        promise2.deadline = 0;
      });
      replanTimeout();
    };
    const create2 = (timeout = defaultTimeout) => {
      const promiseId = ID++;
      const deferred = (0, createDeferred_1.createDeferred)(promiseId);
      const deadline = timeout && Date.now() + timeout;
      promises.push({
        ...deferred,
        deadline
      });
      if (timeout) replanTimeout();
      return {
        promiseId,
        promise: deferred.promise
      };
    };
    const extract2 = (promiseId) => {
      const index2 = promises.findIndex(({
        id
      }) => id === promiseId);
      const [promise2] = index2 >= 0 ? promises.splice(index2, 1) : [void 0];
      if (promise2 == null ? void 0 : promise2.deadline) replanTimeout();
      return promise2;
    };
    const resolve = (promiseId, value2) => {
      const promise2 = extract2(promiseId);
      promise2 == null ? void 0 : promise2.resolve(value2);
      return !!promise2;
    };
    const reject = (promiseId, error2) => {
      const promise2 = extract2(promiseId);
      promise2 == null ? void 0 : promise2.reject(error2);
      return !!promise2;
    };
    const rejectAll = (error2) => {
      promises.forEach((promise2) => promise2.reject(error2));
      const deleted = promises.splice(0, promises.length);
      if (deleted.length) replanTimeout();
    };
    return {
      length,
      nextId,
      create: create2,
      resolve,
      reject,
      rejectAll
    };
  };
  createDeferredManager.createDeferredManager = createDeferredManager$1;
  return createDeferredManager;
}
var createLazy = {};
var hasRequiredCreateLazy;
function requireCreateLazy() {
  if (hasRequiredCreateLazy) return createLazy;
  hasRequiredCreateLazy = 1;
  Object.defineProperty(createLazy, "__esModule", {
    value: true
  });
  createLazy.createLazy = void 0;
  const createDeferred_1 = requireCreateDeferred();
  const createLazy$1 = (initLazy, disposeLazy) => {
    let value2;
    let valuePromise;
    const get = () => value2;
    const getPending = () => valuePromise == null ? void 0 : valuePromise.promise;
    const dispose = () => {
      if (valuePromise) {
        valuePromise.reject(new Error("Disposed during initialization"));
        valuePromise = void 0;
      }
      if (value2 !== void 0) {
        disposeLazy == null ? void 0 : disposeLazy(value2);
        value2 = void 0;
      }
    };
    const getOrInit = (...args) => {
      if (value2 !== void 0) return Promise.resolve(value2);
      if (!valuePromise) {
        const deferred = (0, createDeferred_1.createDeferred)();
        valuePromise = deferred;
        initLazy(...args).then((val) => {
          value2 = val;
          valuePromise = void 0;
          deferred.resolve(val);
        }).catch((err) => {
          valuePromise = void 0;
          deferred.reject(err);
        });
      }
      return valuePromise.promise;
    };
    return {
      get,
      getPending,
      getOrInit,
      dispose
    };
  };
  createLazy.createLazy = createLazy$1;
  return createLazy;
}
var extractUrlsFromText = {};
var hasRequiredExtractUrlsFromText;
function requireExtractUrlsFromText() {
  if (hasRequiredExtractUrlsFromText) return extractUrlsFromText;
  hasRequiredExtractUrlsFromText = 1;
  Object.defineProperty(extractUrlsFromText, "__esModule", {
    value: true
  });
  extractUrlsFromText.extractUrlsFromText = void 0;
  const URL_REGEX = /\b(?:https?:\/\/|www\.)[a-zA-Z0-9-._~:/?#[\]@!$&'()*+,;=%]+\b|(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}(?=\b|\s|$|\])/gi;
  const extractUrlsFromText$1 = (text) => {
    const urls = [];
    const textParts = [];
    let lastIndex = 0;
    const matches = [...text.matchAll(URL_REGEX)];
    matches.forEach((match) => {
      const url = match[0];
      const index2 = match.index !== void 0 ? match.index : -1;
      if (lastIndex < index2) {
        textParts.push(text.slice(lastIndex, index2));
      }
      urls.push(url);
      lastIndex = index2 + url.length;
    });
    if (lastIndex < text.length) {
      textParts.push(text.slice(lastIndex));
    }
    if (textParts.length === 0 && urls.length > 0) {
      textParts.push("");
    }
    return {
      textParts,
      urls
    };
  };
  extractUrlsFromText.extractUrlsFromText = extractUrlsFromText$1;
  return extractUrlsFromText;
}
var getLocaleSeparators = {};
var hasRequiredGetLocaleSeparators;
function requireGetLocaleSeparators() {
  if (hasRequiredGetLocaleSeparators) return getLocaleSeparators;
  hasRequiredGetLocaleSeparators = 1;
  Object.defineProperty(getLocaleSeparators, "__esModule", {
    value: true
  });
  getLocaleSeparators.getLocaleSeparators = void 0;
  const getLocaleSeparators$1 = (locale) => {
    var _a, _b;
    const numberFormat = new Intl.NumberFormat(locale);
    const parts = numberFormat.formatToParts(10000.1);
    const decimalSeparator = (_a = parts.find(({
      type: type2
    }) => type2 === "decimal")) == null ? void 0 : _a.value;
    const thousandsSeparator = (_b = parts.find(({
      type: type2
    }) => type2 === "group")) == null ? void 0 : _b.value;
    return {
      decimalSeparator,
      thousandsSeparator
    };
  };
  getLocaleSeparators.getLocaleSeparators = getLocaleSeparators$1;
  return getLocaleSeparators;
}
var getRandomInt = {};
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredGetRandomInt;
function requireGetRandomInt() {
  if (hasRequiredGetRandomInt) return getRandomInt;
  hasRequiredGetRandomInt = 1;
  Object.defineProperty(getRandomInt, "__esModule", {
    value: true
  });
  getRandomInt.getRandomInt = void 0;
  const crypto_1 = require$$0;
  const getRandomInt$1 = (min, max) => {
    if (!Number.isSafeInteger(min)) {
      throw new RangeError(`The "min" argument must be a safe integer. Received type ${typeof min} (${min})`);
    }
    if (!Number.isSafeInteger(max)) {
      throw new RangeError(`The "max" argument must be a safe integer. Received type ${typeof max} (${max})`);
    }
    if (min >= max) {
      throw new RangeError(`The value of "max" is out of range. It must be greater than the value of "min" (${min}). Received ${max}`);
    }
    const MAX_RANGE_32_BITS = 4294967295 + 1;
    const range = max - min;
    if (range > MAX_RANGE_32_BITS) {
      throw new RangeError(`This function only provide 32 bits of entropy, therefore range cannot be more then 2^32.`);
    }
    const getRandomValues = typeof window !== "undefined" ? (array3) => window.crypto.getRandomValues(array3) : (array3) => (0, crypto_1.getRandomValues)(array3);
    const array2 = new Uint32Array(1);
    const maxRange = MAX_RANGE_32_BITS - MAX_RANGE_32_BITS % range;
    let randomValue;
    do {
      getRandomValues(array2);
      randomValue = array2[0];
    } while (randomValue >= maxRange);
    return min + randomValue % range;
  };
  getRandomInt.getRandomInt = getRandomInt$1;
  return getRandomInt;
}
var getSynchronize = {};
var getMutex = {};
var hasRequiredGetMutex;
function requireGetMutex() {
  if (hasRequiredGetMutex) return getMutex;
  hasRequiredGetMutex = 1;
  Object.defineProperty(getMutex, "__esModule", {
    value: true
  });
  getMutex.getMutex = void 0;
  const getMutex$1 = () => {
    const DEFAULT_ID = Symbol();
    const locks = {};
    return async (lockId = DEFAULT_ID) => {
      while (locks[lockId]) {
        await locks[lockId];
      }
      let resolve = () => {
      };
      locks[lockId] = new Promise((res) => {
        resolve = res;
      }).finally(() => {
        delete locks[lockId];
      });
      return resolve;
    };
  };
  getMutex.getMutex = getMutex$1;
  return getMutex;
}
var hasRequiredGetSynchronize;
function requireGetSynchronize() {
  if (hasRequiredGetSynchronize) return getSynchronize;
  hasRequiredGetSynchronize = 1;
  Object.defineProperty(getSynchronize, "__esModule", {
    value: true
  });
  getSynchronize.getSynchronize = void 0;
  const getMutex_1 = requireGetMutex();
  const getSynchronize$1 = (mutex) => {
    const lock = mutex ?? (0, getMutex_1.getMutex)();
    return (action, lockId) => lock(lockId).then((unlock) => Promise.resolve().then(action).finally(unlock));
  };
  getSynchronize.getSynchronize = getSynchronize$1;
  return getSynchronize;
}
var getWeakRandomId = {};
var hasRequiredGetWeakRandomId;
function requireGetWeakRandomId() {
  if (hasRequiredGetWeakRandomId) return getWeakRandomId;
  hasRequiredGetWeakRandomId = 1;
  Object.defineProperty(getWeakRandomId, "__esModule", {
    value: true
  });
  getWeakRandomId.getWeakRandomId = void 0;
  const getWeakRandomId$1 = (length) => {
    let id = "";
    const list = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (let i = 0; i < length; i++) {
      id += list.charAt(Math.floor(Math.random() * list.length));
    }
    return id;
  };
  getWeakRandomId.getWeakRandomId = getWeakRandomId$1;
  return getWeakRandomId;
}
var getWeakRandomInt = {};
var hasRequiredGetWeakRandomInt;
function requireGetWeakRandomInt() {
  if (hasRequiredGetWeakRandomInt) return getWeakRandomInt;
  hasRequiredGetWeakRandomInt = 1;
  Object.defineProperty(getWeakRandomInt, "__esModule", {
    value: true
  });
  getWeakRandomInt.getWeakRandomInt = void 0;
  const getWeakRandomInt$1 = (min, max) => {
    if (min >= max) {
      throw new RangeError(`The value of "max" is out of range. It must be greater than the value of "min" (${min}). Received ${max}`);
    }
    return Math.floor(Math.random() * (max - min) + min);
  };
  getWeakRandomInt.getWeakRandomInt = getWeakRandomInt$1;
  return getWeakRandomInt;
}
var getWeakRandomNumberInRange = {};
var hasRequiredGetWeakRandomNumberInRange;
function requireGetWeakRandomNumberInRange() {
  if (hasRequiredGetWeakRandomNumberInRange) return getWeakRandomNumberInRange;
  hasRequiredGetWeakRandomNumberInRange = 1;
  Object.defineProperty(getWeakRandomNumberInRange, "__esModule", {
    value: true
  });
  getWeakRandomNumberInRange.getWeakRandomNumberInRange = void 0;
  const getWeakRandomNumberInRange$1 = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  getWeakRandomNumberInRange.getWeakRandomNumberInRange = getWeakRandomNumberInRange$1;
  return getWeakRandomNumberInRange;
}
var hexToRgba = {};
var hasRequiredHexToRgba;
function requireHexToRgba() {
  if (hasRequiredHexToRgba) return hexToRgba;
  hasRequiredHexToRgba = 1;
  Object.defineProperty(hexToRgba, "__esModule", {
    value: true
  });
  hexToRgba.hexToRgba = hexToRgba$1;
  function hexToRgba$1(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    if (alpha && alpha > 0) {
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    return `rgb(${r}, ${g}, ${b})`;
  }
  return hexToRgba;
}
var hexToRgbaArray = {};
var hasRequiredHexToRgbaArray;
function requireHexToRgbaArray() {
  if (hasRequiredHexToRgbaArray) return hexToRgbaArray;
  hasRequiredHexToRgbaArray = 1;
  Object.defineProperty(hexToRgbaArray, "__esModule", {
    value: true
  });
  hexToRgbaArray.hexToRgbaArray = void 0;
  const hexToRgbaArray$1 = (hex) => {
    const norm = hex.replace("#", "");
    const full = norm.length === 6 ? norm + "FF" : norm;
    return [parseInt(full.slice(0, 2), 16) / 255, parseInt(full.slice(2, 4), 16) / 255, parseInt(full.slice(4, 6), 16) / 255, parseInt(full.slice(6, 8), 16) / 255];
  };
  hexToRgbaArray.hexToRgbaArray = hexToRgbaArray$1;
  return hexToRgbaArray;
}
var isApproximatelyEqual = {};
var hasRequiredIsApproximatelyEqual;
function requireIsApproximatelyEqual() {
  if (hasRequiredIsApproximatelyEqual) return isApproximatelyEqual;
  hasRequiredIsApproximatelyEqual = 1;
  Object.defineProperty(isApproximatelyEqual, "__esModule", {
    value: true
  });
  isApproximatelyEqual.isApproximatelyEqual = void 0;
  const bigNumber_1 = requireBigNumber();
  const isApproximatelyEqual$1 = (value1, value2, relativeTolerance) => {
    value1 = new bigNumber_1.BigNumber(value1);
    value2 = new bigNumber_1.BigNumber(value2);
    relativeTolerance = new bigNumber_1.BigNumber(relativeTolerance);
    if (value1.eq(0)) return value1.eq(value2);
    const relativeDifference = value2.minus(value1).abs().dividedBy(value1);
    return relativeDifference.lte(relativeTolerance);
  };
  isApproximatelyEqual.isApproximatelyEqual = isApproximatelyEqual$1;
  return isApproximatelyEqual;
}
var isArrayMember = {};
var hasRequiredIsArrayMember;
function requireIsArrayMember() {
  if (hasRequiredIsArrayMember) return isArrayMember;
  hasRequiredIsArrayMember = 1;
  Object.defineProperty(isArrayMember, "__esModule", {
    value: true
  });
  isArrayMember.isArrayMember = void 0;
  const isArrayMember$1 = (value2, arr) => arr.some((v) => v === value2);
  isArrayMember.isArrayMember = isArrayMember$1;
  return isArrayMember;
}
var isFullPath = {};
var hasRequiredIsFullPath;
function requireIsFullPath() {
  if (hasRequiredIsFullPath) return isFullPath;
  hasRequiredIsFullPath = 1;
  Object.defineProperty(isFullPath, "__esModule", {
    value: true
  });
  isFullPath.isFullPath = void 0;
  const isFullPath$1 = (path2) => {
    const fullPathPattern = /^(\/|([a-zA-Z]:\\))/;
    return fullPathPattern.test(path2);
  };
  isFullPath.isFullPath = isFullPath$1;
  return isFullPath;
}
var isHex = {};
var hasRequiredIsHex;
function requireIsHex() {
  if (hasRequiredIsHex) return isHex;
  hasRequiredIsHex = 1;
  Object.defineProperty(isHex, "__esModule", {
    value: true
  });
  isHex.isHex = void 0;
  const isHex$1 = (str) => {
    const regExp = /^(0x|0X)?[0-9A-Fa-f]+$/g;
    return regExp.test(str);
  };
  isHex.isHex = isHex$1;
  return isHex;
}
var isNotUndefined = {};
var hasRequiredIsNotUndefined;
function requireIsNotUndefined() {
  if (hasRequiredIsNotUndefined) return isNotUndefined;
  hasRequiredIsNotUndefined = 1;
  Object.defineProperty(isNotUndefined, "__esModule", {
    value: true
  });
  isNotUndefined.isNotUndefined = void 0;
  const isNotUndefined$1 = (item) => typeof item !== "undefined";
  isNotUndefined.isNotUndefined = isNotUndefined$1;
  return isNotUndefined;
}
var isUrl = {};
var hasRequiredIsUrl;
function requireIsUrl() {
  if (hasRequiredIsUrl) return isUrl;
  hasRequiredIsUrl = 1;
  Object.defineProperty(isUrl, "__esModule", {
    value: true
  });
  isUrl.isUrlWithQuery = isUrl.isUrl = void 0;
  const URL_REGEXP = /^(http|ws)s?:\/\/[a-z0-9]([a-z0-9.-]+)?(:[0-9]{1,5})?(\/[a-z0-9-_]+)*\/?$/i;
  const URL_WITH_QUERY_REGEXP = /^(http|ws)s?:\/\/[a-z0-9]([a-z0-9.-]+)?(:[0-9]{1,5})?(\/[a-z0-9-_]+)*\/?(\?[a-z0-9-_]+=[a-z0-9-_]+(&[a-z0-9-_]+=[a-z0-9-_]+)*)?$/i;
  const isUrl$1 = (value2) => URL_REGEXP.test(value2);
  isUrl.isUrl = isUrl$1;
  const isUrlWithQuery = (value2) => URL_WITH_QUERY_REGEXP.test(value2);
  isUrl.isUrlWithQuery = isUrlWithQuery;
  return isUrl;
}
var isWhitelistedHost = {};
var hasRequiredIsWhitelistedHost;
function requireIsWhitelistedHost() {
  if (hasRequiredIsWhitelistedHost) return isWhitelistedHost;
  hasRequiredIsWhitelistedHost = 1;
  Object.defineProperty(isWhitelistedHost, "__esModule", {
    value: true
  });
  isWhitelistedHost.isWhitelistedHost = void 0;
  const isWhitelistedHost$1 = (hostname, whitelist = ["127.0.0.1", "localhost"]) => {
    if (typeof hostname !== "string") {
      return false;
    }
    if (hostname.trim() === "") {
      return false;
    }
    return whitelist.some((whitelistedUrl) => whitelistedUrl === hostname || hostname.endsWith(`.${whitelistedUrl}`));
  };
  isWhitelistedHost.isWhitelistedHost = isWhitelistedHost$1;
  return isWhitelistedHost;
}
var logs = {};
var hasRequiredLogs;
function requireLogs() {
  if (hasRequiredLogs) return logs;
  hasRequiredLogs = 1;
  Object.defineProperty(logs, "__esModule", {
    value: true
  });
  logs.Log = void 0;
  class Log {
    constructor(prefix, enabled, logWriter) {
      __publicField(this, "prefix");
      __publicField(this, "enabled");
      __publicField(this, "css", "");
      __publicField(this, "messages");
      __publicField(this, "logWriter");
      __publicField(this, "MAX_ENTRIES", 100);
      this.prefix = prefix;
      this.enabled = enabled;
      this.messages = [];
      if (logWriter) {
        this.logWriter = logWriter;
      }
    }
    setColors(colors) {
      this.css = typeof window !== "undefined" && colors[this.prefix] ? colors[this.prefix] : "";
    }
    addMessage({
      level,
      prefix,
      timestamp
    }, ...args) {
      const message2 = {
        level,
        prefix,
        css: this.css,
        message: args,
        timestamp: timestamp || Date.now()
      };
      this.messages.push(message2);
      if (this.logWriter) {
        try {
          this.logWriter.add(message2);
        } catch (err) {
          console.error("There was an error adding log message", err, message2);
        }
      }
      if (this.messages.length > this.MAX_ENTRIES) {
        this.messages.shift();
      }
    }
    setWriter(logWriter) {
      this.logWriter = logWriter;
    }
    log(...args) {
      this.addMessage({
        level: "log",
        prefix: this.prefix
      }, ...args);
      if (this.enabled) {
        console.log(`%c${this.prefix}`, this.css, ...args);
      }
    }
    error(...args) {
      this.addMessage({
        level: "error",
        prefix: this.prefix
      }, ...args);
      if (this.enabled) {
        console.error(`%c${this.prefix}`, this.css, ...args);
      }
    }
    info(...args) {
      this.addMessage({
        level: "info",
        prefix: this.prefix
      }, ...args);
      if (this.enabled) {
        console.info(`%c${this.prefix}`, this.css, ...args);
      }
    }
    warn(...args) {
      this.addMessage({
        level: "warn",
        prefix: this.prefix
      }, ...args);
      if (this.enabled) {
        console.warn(`%c${this.prefix}`, this.css, ...args);
      }
    }
    debug(...args) {
      this.addMessage({
        level: "debug",
        prefix: this.prefix
      }, ...args);
      if (this.enabled) {
        if (this.css) {
          console.log(`%c${this.prefix}`, this.css, ...args);
        } else {
          console.log(this.prefix, ...args);
        }
      }
    }
    getLog() {
      return this.messages;
    }
  }
  logs.Log = Log;
  return logs;
}
var logsManager = {};
var hasRequiredLogsManager;
function requireLogsManager() {
  if (hasRequiredLogsManager) return logsManager;
  hasRequiredLogsManager = 1;
  Object.defineProperty(logsManager, "__esModule", {
    value: true
  });
  logsManager.LogsManager = void 0;
  const logs_1 = requireLogs();
  class LogsManager {
    constructor({
      colors
    }) {
      __publicField(this, "logs", {});
      __publicField(this, "writer");
      __publicField(this, "colors", {});
      this.colors = colors;
    }
    initLog(prefix, enabled, logWriter) {
      const instanceWriter = logWriter || this.writer;
      const instance = new logs_1.Log(prefix, !!enabled, instanceWriter);
      if (this.colors) {
        instance.setColors(this.colors);
      }
      this.logs[prefix] = instance;
      return instance;
    }
    setLogWriter(logWriterFactory) {
      Object.keys(this.logs).forEach((key) => {
        this.writer = logWriterFactory();
        if (this.writer) {
          this.logs[key].setWriter(this.writer);
          const {
            messages: messages2
          } = this.logs[key];
          messages2.forEach((message2) => {
            var _a;
            (_a = this.writer) == null ? void 0 : _a.add(message2);
          });
        }
      });
    }
    enableLog(enabled) {
      Object.keys(this.logs).forEach((key) => {
        this.logs[key].enabled = !!enabled;
      });
    }
    enableLogByPrefix(prefix, enabled) {
      if (this.logs[prefix]) {
        this.logs[prefix].enabled = enabled;
      }
    }
    getLog() {
      let logs2 = [];
      Object.keys(this.logs).forEach((key) => {
        logs2 = logs2.concat(this.logs[key].messages);
      });
      logs2.sort((a, b) => a.timestamp - b.timestamp);
      return logs2;
    }
  }
  logsManager.LogsManager = LogsManager;
  return logsManager;
}
var mergeDeepObject = {};
var hasRequiredMergeDeepObject;
function requireMergeDeepObject() {
  if (hasRequiredMergeDeepObject) return mergeDeepObject;
  hasRequiredMergeDeepObject = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.mergeDeepObject = void 0;
    const isObject = (obj) => {
      if (typeof obj === "object" && obj !== null) {
        if (typeof Object.getPrototypeOf === "function") {
          const prototype = Object.getPrototypeOf(obj);
          return prototype === Object.prototype || prototype === null;
        }
        return Object.prototype.toString.call(obj) === "[object Object]";
      }
      return false;
    };
    const mergeValuesWithPath = (target, value2, [key, ...rest2]) => {
      if (key === void 0) {
        return mergeValues(target, value2);
      } else if (!isObject(target)) {
        return {
          [key]: mergeValuesWithPath({}, value2, rest2)
        };
      } else {
        return {
          ...target,
          [key]: mergeValuesWithPath(target[key], value2, rest2)
        };
      }
    };
    const mergeValues = (target, value2) => {
      if (Array.isArray(target) && Array.isArray(value2)) {
        return exports$12.mergeDeepObject.options.mergeArrays ? Array.from(new Set(target.concat(value2))) : value2;
      } else if (isObject(target) && isObject(value2)) {
        return (0, exports$12.mergeDeepObject)(target, value2);
      } else {
        return value2;
      }
    };
    const mergeDeepObject2 = (...objects) => objects.reduce((result, current) => {
      if (Array.isArray(current)) {
        throw new TypeError("Arguments provided to ts-deepmerge must be objects, not arrays.");
      }
      Object.keys(current).forEach((key) => {
        if (["__proto__", "constructor", "prototype"].includes(key)) {
          return;
        }
        if (exports$12.mergeDeepObject.options.dotNotation) {
          const [first, ...rest2] = key.split(".");
          result[first] = mergeValuesWithPath(result[first], current[key], rest2);
        } else {
          result[key] = mergeValues(result[key], current[key]);
        }
      });
      return result;
    }, {});
    exports$12.mergeDeepObject = mergeDeepObject2;
    const defaultOptions = {
      mergeArrays: true,
      dotNotation: false
    };
    exports$12.mergeDeepObject.options = defaultOptions;
    exports$12.mergeDeepObject.withOptions = (options, ...objects) => {
      exports$12.mergeDeepObject.options = {
        ...defaultOptions,
        ...options
      };
      const result = (0, exports$12.mergeDeepObject)(...objects);
      exports$12.mergeDeepObject.options = defaultOptions;
      return result;
    };
  })(mergeDeepObject);
  return mergeDeepObject;
}
var objectPartition = {};
var hasRequiredObjectPartition;
function requireObjectPartition() {
  if (hasRequiredObjectPartition) return objectPartition;
  hasRequiredObjectPartition = 1;
  Object.defineProperty(objectPartition, "__esModule", {
    value: true
  });
  objectPartition.objectPartition = void 0;
  const objectPartition$1 = (obj, keys) => keys.reduce(([included, excluded], key) => {
    const {
      [key]: value2,
      ...rest2
    } = excluded;
    return typeof value2 !== "undefined" ? [{
      ...included,
      [key]: value2
    }, rest2] : [included, excluded];
  }, [{}, obj]);
  objectPartition.objectPartition = objectPartition$1;
  return objectPartition;
}
var parseElectrumUrl = {};
var hasRequiredParseElectrumUrl;
function requireParseElectrumUrl() {
  if (hasRequiredParseElectrumUrl) return parseElectrumUrl;
  hasRequiredParseElectrumUrl = 1;
  Object.defineProperty(parseElectrumUrl, "__esModule", {
    value: true
  });
  parseElectrumUrl.parseElectrumUrl = void 0;
  const ELECTRUM_URL_REGEX = /^(?:([a-zA-Z0-9.-]+)|\[([a-f0-9:]+)\]):([0-9]{1,5}):([ts])$/;
  const parseElectrumUrl$1 = (url) => {
    const match = url.match(ELECTRUM_URL_REGEX);
    if (!match) return void 0;
    return {
      host: match[1] ?? match[2],
      port: Number.parseInt(match[3], 10),
      protocol: match[4]
    };
  };
  parseElectrumUrl.parseElectrumUrl = parseElectrumUrl$1;
  return parseElectrumUrl;
}
var parseHostname = {};
var hasRequiredParseHostname;
function requireParseHostname() {
  if (hasRequiredParseHostname) return parseHostname;
  hasRequiredParseHostname = 1;
  Object.defineProperty(parseHostname, "__esModule", {
    value: true
  });
  parseHostname.parseHostname = void 0;
  const HOSTNAME_REGEX = /^([a-z0-9.+-]+:\/\/)?([a-z0-9.-]+)([:/][^:/]+)*\/?$/i;
  const parseHostname$1 = (url) => {
    var _a, _b;
    return (_b = (_a = url.match(HOSTNAME_REGEX)) == null ? void 0 : _a[2]) == null ? void 0 : _b.toLowerCase();
  };
  parseHostname.parseHostname = parseHostname$1;
  return parseHostname;
}
var promiseAllSequence = {};
var hasRequiredPromiseAllSequence;
function requirePromiseAllSequence() {
  if (hasRequiredPromiseAllSequence) return promiseAllSequence;
  hasRequiredPromiseAllSequence = 1;
  Object.defineProperty(promiseAllSequence, "__esModule", {
    value: true
  });
  promiseAllSequence.promiseAllSequence = void 0;
  const promiseAllSequence$1 = async (actions) => {
    const results = [];
    for (let i = 0; i < actions.length; ++i) {
      const result = await actions[i]();
      results.push(result);
    }
    return results;
  };
  promiseAllSequence.promiseAllSequence = promiseAllSequence$1;
  return promiseAllSequence;
}
var redactUserPath = {};
var hasRequiredRedactUserPath;
function requireRedactUserPath() {
  if (hasRequiredRedactUserPath) return redactUserPath;
  hasRequiredRedactUserPath = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.redactUserPathFromString = exports$12.startOfUserPathRegex = void 0;
    exports$12.startOfUserPathRegex = /([/\\][Uu]sers[/\\]{1,4})([^"^'^[^\]^/^\\]*)/g;
    const redactUserPathFromString = (text) => text.replace(exports$12.startOfUserPathRegex, "$1[*]");
    exports$12.redactUserPathFromString = redactUserPathFromString;
  })(redactUserPath);
  return redactUserPath;
}
var resolveAfter = {};
var hasRequiredResolveAfter;
function requireResolveAfter() {
  if (hasRequiredResolveAfter) return resolveAfter;
  hasRequiredResolveAfter = 1;
  Object.defineProperty(resolveAfter, "__esModule", {
    value: true
  });
  resolveAfter.resolveAfter = void 0;
  const createDeferred_1 = requireCreateDeferred();
  const resolveAfter$1 = (msec, signal, value2) => {
    const {
      promise: promise2,
      reject,
      resolve
    } = (0, createDeferred_1.createDeferred)();
    const timeout = setTimeout(resolve, msec, value2);
    const onAbort = () => reject(signal == null ? void 0 : signal.reason);
    signal == null ? void 0 : signal.addEventListener("abort", onAbort);
    if (signal == null ? void 0 : signal.aborted) onAbort();
    return promise2.finally(() => {
      clearTimeout(timeout);
      signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
    });
  };
  resolveAfter.resolveAfter = resolveAfter$1;
  return resolveAfter;
}
var scheduleAction = {};
var hasRequiredScheduleAction;
function requireScheduleAction() {
  if (hasRequiredScheduleAction) return scheduleAction;
  hasRequiredScheduleAction = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.scheduleAction = exports$12.ScheduleActionDeadlineError = exports$12.SCHEDULE_ACTION_DEADLINE_ERROR_MESSAGE = exports$12.ScheduleActionTimeoutError = exports$12.SCHEDULE_ACTION_TIMEOUT_ERROR_MESSAGE = exports$12.RejectWhenAbortedError = exports$12.SCHEDULE_ACTION_ABORTED_ERROR_MESSAGE = void 0;
    exports$12.SCHEDULE_ACTION_ABORTED_ERROR_MESSAGE = "Aborted by signal";
    class RejectWhenAbortedError extends Error {
      constructor() {
        super(exports$12.SCHEDULE_ACTION_ABORTED_ERROR_MESSAGE);
      }
    }
    exports$12.RejectWhenAbortedError = RejectWhenAbortedError;
    const isArray = (attempts) => Array.isArray(attempts);
    const resolveAfterMs = (ms, clear) => new Promise((resolve, reject) => {
      const errorSignal = new RejectWhenAbortedError();
      if (clear.aborted) return reject(errorSignal);
      if (ms === void 0) return resolve();
      let timeout;
      const onClear = () => {
        clearTimeout(timeout);
        clear.removeEventListener("abort", onClear);
        reject(errorSignal);
      };
      timeout = setTimeout(() => {
        clear.removeEventListener("abort", onClear);
        resolve();
      }, ms);
      clear.addEventListener("abort", onClear);
    });
    const rejectAfterMs = (ms, reason, clear) => new Promise((_, reject) => {
      const errorSignal = new RejectWhenAbortedError();
      if (clear.aborted) return reject(errorSignal);
      let timeout;
      const onClear = () => {
        clearTimeout(timeout);
        clear.removeEventListener("abort", onClear);
        reject(errorSignal);
      };
      timeout = setTimeout(() => {
        clear.removeEventListener("abort", onClear);
        reject(reason);
      }, ms);
      clear.addEventListener("abort", onClear);
    });
    const maybeRejectAfterMs = (ms, reason, clear) => ms === void 0 ? [] : [rejectAfterMs(ms, reason, clear)];
    const rejectWhenAborted = (signal, clear) => new Promise((_, reject) => {
      const errorSignal = new RejectWhenAbortedError();
      if (clear.aborted) return reject(errorSignal);
      if (signal == null ? void 0 : signal.aborted) return reject(errorSignal);
      const onAbort = () => reject(errorSignal);
      signal == null ? void 0 : signal.addEventListener("abort", onAbort);
      const onClear = () => {
        signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
        clear.removeEventListener("abort", onClear);
        reject(errorSignal);
      };
      clear.addEventListener("abort", onClear);
    });
    const resolveAction = async (action, clear) => {
      const aborter = new AbortController();
      if (clear.aborted) aborter.abort();
      const onClear = () => {
        clear.removeEventListener("abort", onClear);
        aborter.abort();
      };
      clear.addEventListener("abort", onClear);
      try {
        return await new Promise((resolve) => resolve(action(aborter.signal)));
      } finally {
        if (!clear.aborted) clear.removeEventListener("abort", onClear);
      }
    };
    const attemptLoop = async (attempts, attempt, failure, clear) => {
      for (let a = 0; a < attempts - 1; a++) {
        if (clear.aborted) break;
        const aborter = new AbortController();
        const onClear = () => aborter.abort();
        clear.addEventListener("abort", onClear);
        try {
          return await attempt(a, aborter.signal);
        } catch (error2) {
          onClear();
          await failure(a, error2);
        } finally {
          clear.removeEventListener("abort", onClear);
        }
      }
      return clear.aborted ? Promise.reject(new RejectWhenAbortedError()) : attempt(attempts - 1, clear);
    };
    exports$12.SCHEDULE_ACTION_TIMEOUT_ERROR_MESSAGE = "Aborted by timeout";
    class ScheduleActionTimeoutError extends Error {
      constructor() {
        super(exports$12.SCHEDULE_ACTION_TIMEOUT_ERROR_MESSAGE);
      }
    }
    exports$12.ScheduleActionTimeoutError = ScheduleActionTimeoutError;
    exports$12.SCHEDULE_ACTION_DEADLINE_ERROR_MESSAGE = "Aborted by deadline";
    class ScheduleActionDeadlineError extends Error {
      constructor() {
        super(exports$12.SCHEDULE_ACTION_DEADLINE_ERROR_MESSAGE);
      }
    }
    exports$12.ScheduleActionDeadlineError = ScheduleActionDeadlineError;
    const scheduleAction2 = async (action, params2) => {
      const {
        signal,
        delay,
        attempts,
        timeout,
        deadline,
        gap,
        attemptFailureHandler
      } = params2;
      const deadlineMs = deadline && deadline - Date.now();
      const attemptCount = isArray(attempts) ? attempts.length : attempts ?? (deadline ? Infinity : 1);
      const clearAborter = new AbortController();
      const clear = clearAborter.signal;
      const getParams = isArray(attempts) ? (attempt) => attempts[attempt] : () => ({
        timeout,
        gap
      });
      const errorDeadline = new ScheduleActionDeadlineError();
      const errorTimeout = new ScheduleActionTimeoutError();
      const graceful = params2.graceful && signal;
      const actionAborter = new AbortController();
      if (graceful) {
        if (signal.aborted) {
          actionAborter.abort();
        } else {
          const onAbort = () => {
            signal.removeEventListener("abort", onAbort);
            clear.removeEventListener("abort", onAbort);
            actionAborter.abort();
          };
          signal.addEventListener("abort", onAbort);
          clear.addEventListener("abort", onAbort);
        }
      }
      try {
        return await Promise.race([...graceful ? [] : [rejectWhenAborted(signal, clear)], ...maybeRejectAfterMs(deadlineMs, errorDeadline, clear), resolveAfterMs(delay, clear).then(() => attemptLoop(attemptCount, (attempt, abort) => Promise.race([...maybeRejectAfterMs(getParams(attempt).timeout, errorTimeout, clear), resolveAction(action, abort)]), (attempt, error2) => {
          const errorHandlerResult = attemptFailureHandler == null ? void 0 : attemptFailureHandler(error2);
          return errorHandlerResult ? Promise.reject(errorHandlerResult) : resolveAfterMs(getParams(attempt).gap ?? 0, clear);
        }, graceful ? actionAborter.signal : clear))]);
      } finally {
        clearAborter.abort();
      }
    };
    exports$12.scheduleAction = scheduleAction2;
  })(scheduleAction);
  return scheduleAction;
}
var serializeError = {};
var hasRequiredSerializeError;
function requireSerializeError() {
  if (hasRequiredSerializeError) return serializeError;
  hasRequiredSerializeError = 1;
  Object.defineProperty(serializeError, "__esModule", {
    value: true
  });
  serializeError.serializeError = void 0;
  const serializeError$1 = (error2) => {
    if (error2 instanceof Error) {
      return JSON.stringify({
        message: error2.toString(),
        stackTrace: error2.stack
      });
    }
    if (typeof error2 === "object") {
      return JSON.stringify(error2);
    }
    return `${error2}`;
  };
  serializeError.serializeError = serializeError$1;
  return serializeError;
}
var splitStringEveryNCharacters = {};
var hasRequiredSplitStringEveryNCharacters;
function requireSplitStringEveryNCharacters() {
  if (hasRequiredSplitStringEveryNCharacters) return splitStringEveryNCharacters;
  hasRequiredSplitStringEveryNCharacters = 1;
  Object.defineProperty(splitStringEveryNCharacters, "__esModule", {
    value: true
  });
  splitStringEveryNCharacters.splitStringEveryNCharacters = splitStringEveryNCharacters$1;
  function splitStringEveryNCharacters$1(value2, n) {
    if (n === 0) {
      return [];
    }
    const regex = new RegExp(`.{1,${n}}`, "g");
    return value2.match(regex) ?? [];
  }
  return splitStringEveryNCharacters;
}
var throttler = {};
var hasRequiredThrottler;
function requireThrottler() {
  if (hasRequiredThrottler) return throttler;
  hasRequiredThrottler = 1;
  Object.defineProperty(throttler, "__esModule", {
    value: true
  });
  throttler.Throttler = void 0;
  class Throttler {
    constructor(delay) {
      __publicField(this, "delay");
      __publicField(this, "intervals");
      __publicField(this, "callbacks");
      this.delay = delay;
      this.intervals = {};
      this.callbacks = {};
    }
    throttle(id, callback) {
      if (this.intervals[id]) {
        this.callbacks[id] = callback;
      } else {
        callback();
        this.intervals[id] = setInterval(() => this.tick(id), this.delay);
      }
    }
    tick(id) {
      if (this.callbacks[id]) {
        this.callbacks[id]();
        delete this.callbacks[id];
      } else {
        this.cancel(id);
      }
    }
    cancel(id) {
      clearInterval(this.intervals[id]);
      delete this.intervals[id];
      delete this.callbacks[id];
    }
    dispose() {
      Object.keys(this.intervals).forEach(this.cancel, this);
    }
  }
  throttler.Throttler = Throttler;
  return throttler;
}
var topologicalSort = {};
var hasRequiredTopologicalSort;
function requireTopologicalSort() {
  if (hasRequiredTopologicalSort) return topologicalSort;
  hasRequiredTopologicalSort = 1;
  Object.defineProperty(topologicalSort, "__esModule", {
    value: true
  });
  topologicalSort.topologicalSort = void 0;
  const arrayPartition_1 = requireArrayPartition();
  const topologicalSort$1 = (elements, precedes, tie) => {
    const result = [];
    const filterRoots = (verts) => (0, arrayPartition_1.arrayPartition)(verts, (succ) => !verts.some((pred) => precedes(pred, succ)));
    let elem = elements;
    while (elem.length) {
      const [roots2, rest2] = filterRoots(elem);
      if (!roots2.length) throw new Error("Cycle detected");
      result.push(...tie ? roots2.sort(tie) : roots2);
      elem = rest2;
    }
    return result;
  };
  topologicalSort.topologicalSort = topologicalSort$1;
  return topologicalSort;
}
var typedObject = {};
var hasRequiredTypedObject;
function requireTypedObject() {
  if (hasRequiredTypedObject) return typedObject;
  hasRequiredTypedObject = 1;
  Object.defineProperty(typedObject, "__esModule", {
    value: true
  });
  typedObject.typedObjectValues = typedObject.typedObjectKeys = typedObject.typedObjectEntries = void 0;
  typedObject.typedObjectFromEntries = typedObjectFromEntries;
  const typedObjectEntries = (obj) => Object.entries(obj);
  typedObject.typedObjectEntries = typedObjectEntries;
  function typedObjectFromEntries(entries) {
    return Object.fromEntries(entries);
  }
  const typedObjectKeys = (obj) => Object.keys(obj);
  typedObject.typedObjectKeys = typedObjectKeys;
  const typedObjectValues = (obj) => Object.values(obj);
  typedObject.typedObjectValues = typedObjectValues;
  return typedObject;
}
var typedEventEmitter = {};
var hasRequiredTypedEventEmitter;
function requireTypedEventEmitter() {
  if (hasRequiredTypedEventEmitter) return typedEventEmitter;
  hasRequiredTypedEventEmitter = 1;
  Object.defineProperty(typedEventEmitter, "__esModule", {
    value: true
  });
  typedEventEmitter.TypedEmitter = void 0;
  const events_12 = requireEvents();
  class TypedEmitter extends events_12.EventEmitter {
    listenerCount(eventName) {
      return super.listenerCount(eventName);
    }
  }
  typedEventEmitter.TypedEmitter = TypedEmitter;
  return typedEventEmitter;
}
var urlToOnion = {};
var hasRequiredUrlToOnion;
function requireUrlToOnion() {
  if (hasRequiredUrlToOnion) return urlToOnion;
  hasRequiredUrlToOnion = 1;
  Object.defineProperty(urlToOnion, "__esModule", {
    value: true
  });
  urlToOnion.urlToOnion = void 0;
  const urlToOnion$1 = (url, onionDomains) => {
    const [, protocol, subdomain, domain, rest2] = url.match(/^(http|ws)s?:\/\/([^:/]+\.)?([^/.]+\.[^/.]+)(\/.*)?$/i) ?? [];
    if (!domain || !onionDomains[domain]) return;
    return `${protocol}://${subdomain ?? ""}${onionDomains[domain]}${rest2 ?? ""}`;
  };
  urlToOnion.urlToOnion = urlToOnion$1;
  return urlToOnion;
}
var zip = {};
var hasRequiredZip;
function requireZip() {
  if (hasRequiredZip) return zip;
  hasRequiredZip = 1;
  Object.defineProperty(zip, "__esModule", {
    value: true
  });
  zip.createZip = void 0;
  const createZip = (buffers) => {
    const fileEntries = [];
    const centralDirectory = [];
    let offset = 0;
    buffers.forEach(({
      name,
      content
    }) => {
      const fileData = content;
      const fileHeader = new Uint8Array(30 + name.length);
      const localFileHeader = new DataView(fileHeader.buffer);
      localFileHeader.setUint32(0, 67324752, true);
      localFileHeader.setUint16(4, 0, true);
      localFileHeader.setUint16(6, 0, true);
      localFileHeader.setUint16(8, 0, true);
      localFileHeader.setUint16(10, 0, true);
      localFileHeader.setUint16(12, 0, true);
      localFileHeader.setUint32(14, 0, true);
      localFileHeader.setUint32(18, fileData.byteLength, true);
      localFileHeader.setUint32(22, fileData.byteLength, true);
      localFileHeader.setUint16(26, name.length, true);
      fileHeader.set(new TextEncoder().encode(name), 30);
      fileEntries.push(fileHeader, fileData);
      const centralHeader = new Uint8Array(46 + name.length);
      const centralView = new DataView(centralHeader.buffer);
      centralView.setUint32(0, 33639248, true);
      centralView.setUint16(4, 0, true);
      centralView.setUint16(6, 0, true);
      centralView.setUint16(8, 0, true);
      centralView.setUint16(10, 0, true);
      centralView.setUint16(12, 0, true);
      centralView.setUint16(14, 0, true);
      centralView.setUint32(16, 0, true);
      centralView.setUint32(20, fileData.byteLength, true);
      centralView.setUint32(24, fileData.byteLength, true);
      centralView.setUint16(28, name.length, true);
      centralView.setUint32(42, offset, true);
      centralHeader.set(new TextEncoder().encode(name), 46);
      centralDirectory.push(centralHeader);
      offset += fileHeader.length + fileData.byteLength;
    });
    const eocd = new Uint8Array(22);
    const eocdView = new DataView(eocd.buffer);
    eocdView.setUint32(0, 101010256, true);
    eocdView.setUint16(8, centralDirectory.length, true);
    eocdView.setUint16(10, centralDirectory.length, true);
    eocdView.setUint32(12, centralDirectory.reduce((sum, cd) => sum + cd.byteLength, 0), true);
    eocdView.setUint32(16, offset, true);
    return new Blob([...fileEntries, ...centralDirectory, eocd], {
      type: "application/zip"
    });
  };
  zip.createZip = createZip;
  return zip;
}
var removeTrailingSlashes = {};
var hasRequiredRemoveTrailingSlashes;
function requireRemoveTrailingSlashes() {
  if (hasRequiredRemoveTrailingSlashes) return removeTrailingSlashes;
  hasRequiredRemoveTrailingSlashes = 1;
  Object.defineProperty(removeTrailingSlashes, "__esModule", {
    value: true
  });
  removeTrailingSlashes.removeTrailingSlashes = void 0;
  const removeTrailingSlashes$1 = (input) => {
    if (!input) {
      return input || "";
    }
    let i = input.length;
    while (i > 0 && input[i - 1] === "/") {
      i--;
    }
    return input.substring(0, i);
  };
  removeTrailingSlashes.removeTrailingSlashes = removeTrailingSlashes$1;
  return removeTrailingSlashes;
}
var getIntegerInRangeFromString = {};
var hasRequiredGetIntegerInRangeFromString;
function requireGetIntegerInRangeFromString() {
  if (hasRequiredGetIntegerInRangeFromString) return getIntegerInRangeFromString;
  hasRequiredGetIntegerInRangeFromString = 1;
  Object.defineProperty(getIntegerInRangeFromString, "__esModule", {
    value: true
  });
  getIntegerInRangeFromString.getIntegerInRangeFromString = void 0;
  const getIntegerInRangeFromString$1 = (input, max) => {
    let hash2 = 0;
    if (input.length === 0) {
      return 0;
    }
    for (let i = 0; i < input.length; i++) {
      const char = input.charCodeAt(i);
      hash2 = (hash2 << 5) - hash2 + char;
      hash2 |= 0;
    }
    return Math.abs(hash2 % max);
  };
  getIntegerInRangeFromString.getIntegerInRangeFromString = getIntegerInRangeFromString$1;
  return getIntegerInRangeFromString;
}
var safeBigIntStringify = {};
var hasRequiredSafeBigIntStringify;
function requireSafeBigIntStringify() {
  if (hasRequiredSafeBigIntStringify) return safeBigIntStringify;
  hasRequiredSafeBigIntStringify = 1;
  Object.defineProperty(safeBigIntStringify, "__esModule", {
    value: true
  });
  safeBigIntStringify.safeBigIntStringify = void 0;
  const safeBigIntStringify$1 = (v) => JSON.stringify(v, (_k, val) => typeof val === "bigint" ? val.toString() : val);
  safeBigIntStringify.safeBigIntStringify = safeBigIntStringify$1;
  return safeBigIntStringify;
}
var union$3 = {};
var hasRequiredUnion$3;
function requireUnion$3() {
  if (hasRequiredUnion$3) return union$3;
  hasRequiredUnion$3 = 1;
  Object.defineProperty(union$3, "__esModule", {
    value: true
  });
  union$3.union = union2;
  function union2(data) {
    return [...new Set(data)];
  }
  return union$3;
}
var isInt = {};
var hasRequiredIsInt;
function requireIsInt() {
  if (hasRequiredIsInt) return isInt;
  hasRequiredIsInt = 1;
  Object.defineProperty(isInt, "__esModule", {
    value: true
  });
  isInt.isInt = isInt$1;
  function isInt$1(value2) {
    return Number.isInteger(value2);
  }
  return isInt;
}
var number$2 = {};
var hasRequiredNumber$2;
function requireNumber$2() {
  if (hasRequiredNumber$2) return number$2;
  hasRequiredNumber$2 = 1;
  Object.defineProperty(number$2, "__esModule", {
    value: true
  });
  number$2.roundTo = roundTo;
  function roundTo(value2, precision = 2) {
    const x = 10 ** precision;
    return Math.round(value2 * x) / x;
  }
  return number$2;
}
var sanitizeFilename = {};
var hasRequiredSanitizeFilename;
function requireSanitizeFilename() {
  if (hasRequiredSanitizeFilename) return sanitizeFilename;
  hasRequiredSanitizeFilename = 1;
  Object.defineProperty(sanitizeFilename, "__esModule", {
    value: true
  });
  sanitizeFilename.sanitizeFilename = void 0;
  const MAX_FILENAME_LENGTH = 250;
  const sanitizeFilename$1 = (filename, replacement = "_") => {
    if (!filename || filename.trim().length === 0) {
      return void 0;
    }
    const illegalRe = /[<>:"\/\\|?*\x00-\x1F]/g;
    let safeName = filename.replace(illegalRe, replacement);
    if (safeName.length > MAX_FILENAME_LENGTH) {
      safeName = safeName.substring(0, MAX_FILENAME_LENGTH);
    }
    safeName = safeName.replace(/[. ]+$/, "");
    const reservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])$/i;
    if (reservedRe.test(safeName)) {
      safeName = `${safeName}${replacement}`;
    }
    return safeName || void 0;
  };
  sanitizeFilename.sanitizeFilename = sanitizeFilename$1;
  return sanitizeFilename;
}
(function(exports$12) {
  Object.defineProperty(exports$12, "__esModule", {
    value: true
  });
  exports$12.isApproximatelyEqual = exports$12.hexToRgbaArray = exports$12.hexToRgba = exports$12.xssFilters = exports$12.versionUtils = exports$12.enumUtils = exports$12.bufferUtils = void 0;
  const tslib_12 = require$$0$1;
  exports$12.bufferUtils = tslib_12.__importStar(requireBufferUtils());
  exports$12.enumUtils = tslib_12.__importStar(requireEnumUtils());
  exports$12.versionUtils = tslib_12.__importStar(requireVersionUtils());
  exports$12.xssFilters = tslib_12.__importStar(requireXssFilters());
  tslib_12.__exportStar(requireAddDashesToSpaces(), exports$12);
  tslib_12.__exportStar(requireArrayDistinct(), exports$12);
  tslib_12.__exportStar(requireArrayPartition(), exports$12);
  tslib_12.__exportStar(requireArrayShuffle(), exports$12);
  tslib_12.__exportStar(requireArrayToDictionary(), exports$12);
  tslib_12.__exportStar(requireAsciiUtils(), exports$12);
  tslib_12.__exportStar(requireBigNumber(), exports$12);
  tslib_12.__exportStar(requireBytesToHumanReadable(), exports$12);
  tslib_12.__exportStar(requireCache(), exports$12);
  tslib_12.__exportStar(requireCapitalizeFirstLetter(), exports$12);
  tslib_12.__exportStar(requireCloneObject(), exports$12);
  tslib_12.__exportStar(requireComparison(), exports$12);
  tslib_12.__exportStar(requireConvertTaprootXpub(), exports$12);
  tslib_12.__exportStar(requireCountBytesInString(), exports$12);
  tslib_12.__exportStar(requireCreateCooldown(), exports$12);
  tslib_12.__exportStar(requireCreateDeferred(), exports$12);
  tslib_12.__exportStar(requireCreateDeferredManager(), exports$12);
  tslib_12.__exportStar(requireCreateLazy(), exports$12);
  tslib_12.__exportStar(requireExtractUrlsFromText(), exports$12);
  tslib_12.__exportStar(requireGetLocaleSeparators(), exports$12);
  tslib_12.__exportStar(requireGetRandomInt(), exports$12);
  tslib_12.__exportStar(requireGetSynchronize(), exports$12);
  tslib_12.__exportStar(requireGetWeakRandomId(), exports$12);
  tslib_12.__exportStar(requireGetWeakRandomInt(), exports$12);
  tslib_12.__exportStar(requireGetWeakRandomNumberInRange(), exports$12);
  var hexToRgba_1 = requireHexToRgba();
  Object.defineProperty(exports$12, "hexToRgba", {
    enumerable: true,
    get: function() {
      return hexToRgba_1.hexToRgba;
    }
  });
  var hexToRgbaArray_1 = requireHexToRgbaArray();
  Object.defineProperty(exports$12, "hexToRgbaArray", {
    enumerable: true,
    get: function() {
      return hexToRgbaArray_1.hexToRgbaArray;
    }
  });
  var isApproximatelyEqual_1 = requireIsApproximatelyEqual();
  Object.defineProperty(exports$12, "isApproximatelyEqual", {
    enumerable: true,
    get: function() {
      return isApproximatelyEqual_1.isApproximatelyEqual;
    }
  });
  tslib_12.__exportStar(requireIsArrayMember(), exports$12);
  tslib_12.__exportStar(requireIsFullPath(), exports$12);
  tslib_12.__exportStar(requireIsHex(), exports$12);
  tslib_12.__exportStar(requireIsNotUndefined(), exports$12);
  tslib_12.__exportStar(requireIsUrl(), exports$12);
  tslib_12.__exportStar(requireIsWhitelistedHost(), exports$12);
  tslib_12.__exportStar(requireLogs(), exports$12);
  tslib_12.__exportStar(requireLogsManager(), exports$12);
  tslib_12.__exportStar(requireMergeDeepObject(), exports$12);
  tslib_12.__exportStar(requireObjectPartition(), exports$12);
  tslib_12.__exportStar(requireParseElectrumUrl(), exports$12);
  tslib_12.__exportStar(requireParseHostname(), exports$12);
  tslib_12.__exportStar(requirePromiseAllSequence(), exports$12);
  tslib_12.__exportStar(requireRedactUserPath(), exports$12);
  tslib_12.__exportStar(requireResolveAfter(), exports$12);
  tslib_12.__exportStar(requireScheduleAction(), exports$12);
  tslib_12.__exportStar(requireSerializeError(), exports$12);
  tslib_12.__exportStar(requireSplitStringEveryNCharacters(), exports$12);
  tslib_12.__exportStar(requireThrottler(), exports$12);
  tslib_12.__exportStar(requireThrowError(), exports$12);
  tslib_12.__exportStar(requireTopologicalSort(), exports$12);
  tslib_12.__exportStar(requireTypedObject(), exports$12);
  tslib_12.__exportStar(requireTypedEventEmitter(), exports$12);
  tslib_12.__exportStar(requireUrlToOnion(), exports$12);
  tslib_12.__exportStar(requireZip(), exports$12);
  tslib_12.__exportStar(requireRemoveTrailingSlashes(), exports$12);
  tslib_12.__exportStar(requireGetIntegerInRangeFromString(), exports$12);
  tslib_12.__exportStar(requireSafeBigIntStringify(), exports$12);
  tslib_12.__exportStar(requireUnion$3(), exports$12);
  tslib_12.__exportStar(requireIsInt(), exports$12);
  tslib_12.__exportStar(requireNumber$2(), exports$12);
  tslib_12.__exportStar(requireSanitizeFilename(), exports$12);
})(lib$4);
var constants = {};
var network = {};
var hasRequiredNetwork;
function requireNetwork() {
  if (hasRequiredNetwork) return network;
  hasRequiredNetwork = 1;
  Object.defineProperty(network, "__esModule", {
    value: true
  });
  network.MODULES = network.TYPES = void 0;
  network.TYPES = {
    bitcoin: "Bitcoin",
    ethereum: "Ethereum",
    eos: "Eos",
    nem: "NEM",
    stellar: "Stellar",
    cardano: "Cardano",
    ripple: "Ripple",
    tezos: "Tezos",
    binance: "Binance",
    solana: "Solana"
  };
  network.MODULES = ["cardano", "eos", "ethereum", "monero", "nem", "ripple", "solana", "stellar", "tezos"];
  return network;
}
var cardano$1 = {};
var hasRequiredCardano$1;
function requireCardano$1() {
  if (hasRequiredCardano$1) return cardano$1;
  hasRequiredCardano$1 = 1;
  Object.defineProperty(cardano$1, "__esModule", {
    value: true
  });
  cardano$1.ALGORITHM_IDS = cardano$1.NETWORK_IDS = cardano$1.PROTOCOL_MAGICS = void 0;
  var PROTOCOL_MAGICS;
  (function(PROTOCOL_MAGICS2) {
    PROTOCOL_MAGICS2[PROTOCOL_MAGICS2["mainnet"] = 764824073] = "mainnet";
    PROTOCOL_MAGICS2[PROTOCOL_MAGICS2["testnet_preprod"] = 1] = "testnet_preprod";
    PROTOCOL_MAGICS2[PROTOCOL_MAGICS2["testnet_preview"] = 2] = "testnet_preview";
    PROTOCOL_MAGICS2[PROTOCOL_MAGICS2["testnet_legacy"] = 1097911063] = "testnet_legacy";
  })(PROTOCOL_MAGICS || (cardano$1.PROTOCOL_MAGICS = PROTOCOL_MAGICS = {}));
  var NETWORK_IDS;
  (function(NETWORK_IDS2) {
    NETWORK_IDS2[NETWORK_IDS2["mainnet"] = 1] = "mainnet";
    NETWORK_IDS2[NETWORK_IDS2["testnet"] = 0] = "testnet";
  })(NETWORK_IDS || (cardano$1.NETWORK_IDS = NETWORK_IDS = {}));
  var ALGORITHM_IDS;
  (function(ALGORITHM_IDS2) {
    ALGORITHM_IDS2[ALGORITHM_IDS2["EdDSA"] = -8] = "EdDSA";
  })(ALGORITHM_IDS || (cardano$1.ALGORITHM_IDS = ALGORITHM_IDS = {}));
  return cardano$1;
}
var nem = {};
var lib$3 = {};
var cjs = {};
var clone = {};
var type$6 = {};
var value$1 = {};
var value = {};
var hasRequiredValue$1;
function requireValue$1() {
  if (hasRequiredValue$1) return value;
  hasRequiredValue$1 = 1;
  Object.defineProperty(value, "__esModule", { value: true });
  value.HasPropertyKey = HasPropertyKey;
  value.IsAsyncIterator = IsAsyncIterator;
  value.IsArray = IsArray;
  value.IsBigInt = IsBigInt;
  value.IsBoolean = IsBoolean;
  value.IsDate = IsDate;
  value.IsFunction = IsFunction;
  value.IsIterator = IsIterator;
  value.IsNull = IsNull;
  value.IsNumber = IsNumber;
  value.IsObject = IsObject;
  value.IsRegExp = IsRegExp;
  value.IsString = IsString;
  value.IsSymbol = IsSymbol;
  value.IsUint8Array = IsUint8Array;
  value.IsUndefined = IsUndefined;
  function HasPropertyKey(value2, key) {
    return key in value2;
  }
  function IsAsyncIterator(value2) {
    return IsObject(value2) && !IsArray(value2) && !IsUint8Array(value2) && Symbol.asyncIterator in value2;
  }
  function IsArray(value2) {
    return Array.isArray(value2);
  }
  function IsBigInt(value2) {
    return typeof value2 === "bigint";
  }
  function IsBoolean(value2) {
    return typeof value2 === "boolean";
  }
  function IsDate(value2) {
    return value2 instanceof globalThis.Date;
  }
  function IsFunction(value2) {
    return typeof value2 === "function";
  }
  function IsIterator(value2) {
    return IsObject(value2) && !IsArray(value2) && !IsUint8Array(value2) && Symbol.iterator in value2;
  }
  function IsNull(value2) {
    return value2 === null;
  }
  function IsNumber(value2) {
    return typeof value2 === "number";
  }
  function IsObject(value2) {
    return typeof value2 === "object" && value2 !== null;
  }
  function IsRegExp(value2) {
    return value2 instanceof globalThis.RegExp;
  }
  function IsString(value2) {
    return typeof value2 === "string";
  }
  function IsSymbol(value2) {
    return typeof value2 === "symbol";
  }
  function IsUint8Array(value2) {
    return value2 instanceof globalThis.Uint8Array;
  }
  function IsUndefined(value2) {
    return value2 === void 0;
  }
  return value;
}
var hasRequiredValue;
function requireValue() {
  if (hasRequiredValue) return value$1;
  hasRequiredValue = 1;
  Object.defineProperty(value$1, "__esModule", { value: true });
  value$1.Clone = Clone;
  const ValueGuard = requireValue$1();
  function ArrayType(value2) {
    return value2.map((value3) => Visit(value3));
  }
  function DateType(value2) {
    return new Date(value2.getTime());
  }
  function Uint8ArrayType(value2) {
    return new Uint8Array(value2);
  }
  function RegExpType(value2) {
    return new RegExp(value2.source, value2.flags);
  }
  function ObjectType(value2) {
    const result = {};
    for (const key of Object.getOwnPropertyNames(value2)) {
      result[key] = Visit(value2[key]);
    }
    for (const key of Object.getOwnPropertySymbols(value2)) {
      result[key] = Visit(value2[key]);
    }
    return result;
  }
  function Visit(value2) {
    return ValueGuard.IsArray(value2) ? ArrayType(value2) : ValueGuard.IsDate(value2) ? DateType(value2) : ValueGuard.IsUint8Array(value2) ? Uint8ArrayType(value2) : ValueGuard.IsRegExp(value2) ? RegExpType(value2) : ValueGuard.IsObject(value2) ? ObjectType(value2) : value2;
  }
  function Clone(value2) {
    return Visit(value2);
  }
  return value$1;
}
var hasRequiredType$6;
function requireType$6() {
  if (hasRequiredType$6) return type$6;
  hasRequiredType$6 = 1;
  Object.defineProperty(type$6, "__esModule", { value: true });
  type$6.CloneRest = CloneRest;
  type$6.CloneType = CloneType;
  const value_1 = requireValue();
  function CloneRest(schemas) {
    return schemas.map((schema2) => CloneType(schema2));
  }
  function CloneType(schema2, options) {
    return options === void 0 ? (0, value_1.Clone)(schema2) : (0, value_1.Clone)({ ...options, ...schema2 });
  }
  return type$6;
}
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone;
  hasRequiredClone = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireType$6(), exports$12);
    __exportStar(requireValue(), exports$12);
  })(clone);
  return clone;
}
var create = {};
var type$5 = {};
var policy = {};
var guard$2 = {};
var guard$1 = {};
var hasRequiredGuard$2;
function requireGuard$2() {
  if (hasRequiredGuard$2) return guard$1;
  hasRequiredGuard$2 = 1;
  Object.defineProperty(guard$1, "__esModule", { value: true });
  guard$1.IsAsyncIterator = IsAsyncIterator;
  guard$1.IsIterator = IsIterator;
  guard$1.IsStandardObject = IsStandardObject;
  guard$1.IsInstanceObject = IsInstanceObject;
  guard$1.IsPromise = IsPromise;
  guard$1.IsDate = IsDate;
  guard$1.IsMap = IsMap;
  guard$1.IsSet = IsSet;
  guard$1.IsRegExp = IsRegExp;
  guard$1.IsTypedArray = IsTypedArray;
  guard$1.IsInt8Array = IsInt8Array;
  guard$1.IsUint8Array = IsUint8Array;
  guard$1.IsUint8ClampedArray = IsUint8ClampedArray;
  guard$1.IsInt16Array = IsInt16Array;
  guard$1.IsUint16Array = IsUint16Array;
  guard$1.IsInt32Array = IsInt32Array;
  guard$1.IsUint32Array = IsUint32Array;
  guard$1.IsFloat32Array = IsFloat32Array;
  guard$1.IsFloat64Array = IsFloat64Array;
  guard$1.IsBigInt64Array = IsBigInt64Array;
  guard$1.IsBigUint64Array = IsBigUint64Array;
  guard$1.HasPropertyKey = HasPropertyKey;
  guard$1.IsObject = IsObject;
  guard$1.IsArray = IsArray;
  guard$1.IsUndefined = IsUndefined;
  guard$1.IsNull = IsNull;
  guard$1.IsBoolean = IsBoolean;
  guard$1.IsNumber = IsNumber;
  guard$1.IsInteger = IsInteger;
  guard$1.IsBigInt = IsBigInt;
  guard$1.IsString = IsString;
  guard$1.IsFunction = IsFunction;
  guard$1.IsSymbol = IsSymbol;
  guard$1.IsValueType = IsValueType;
  function IsAsyncIterator(value2) {
    return IsObject(value2) && Symbol.asyncIterator in value2;
  }
  function IsIterator(value2) {
    return IsObject(value2) && Symbol.iterator in value2;
  }
  function IsStandardObject(value2) {
    return IsObject(value2) && (Object.getPrototypeOf(value2) === Object.prototype || Object.getPrototypeOf(value2) === null);
  }
  function IsInstanceObject(value2) {
    return IsObject(value2) && !IsArray(value2) && IsFunction(value2.constructor) && value2.constructor.name !== "Object";
  }
  function IsPromise(value2) {
    return value2 instanceof Promise;
  }
  function IsDate(value2) {
    return value2 instanceof Date && Number.isFinite(value2.getTime());
  }
  function IsMap(value2) {
    return value2 instanceof globalThis.Map;
  }
  function IsSet(value2) {
    return value2 instanceof globalThis.Set;
  }
  function IsRegExp(value2) {
    return value2 instanceof globalThis.RegExp;
  }
  function IsTypedArray(value2) {
    return ArrayBuffer.isView(value2);
  }
  function IsInt8Array(value2) {
    return value2 instanceof globalThis.Int8Array;
  }
  function IsUint8Array(value2) {
    return value2 instanceof globalThis.Uint8Array;
  }
  function IsUint8ClampedArray(value2) {
    return value2 instanceof globalThis.Uint8ClampedArray;
  }
  function IsInt16Array(value2) {
    return value2 instanceof globalThis.Int16Array;
  }
  function IsUint16Array(value2) {
    return value2 instanceof globalThis.Uint16Array;
  }
  function IsInt32Array(value2) {
    return value2 instanceof globalThis.Int32Array;
  }
  function IsUint32Array(value2) {
    return value2 instanceof globalThis.Uint32Array;
  }
  function IsFloat32Array(value2) {
    return value2 instanceof globalThis.Float32Array;
  }
  function IsFloat64Array(value2) {
    return value2 instanceof globalThis.Float64Array;
  }
  function IsBigInt64Array(value2) {
    return value2 instanceof globalThis.BigInt64Array;
  }
  function IsBigUint64Array(value2) {
    return value2 instanceof globalThis.BigUint64Array;
  }
  function HasPropertyKey(value2, key) {
    return key in value2;
  }
  function IsObject(value2) {
    return value2 !== null && typeof value2 === "object";
  }
  function IsArray(value2) {
    return Array.isArray(value2) && !ArrayBuffer.isView(value2);
  }
  function IsUndefined(value2) {
    return value2 === void 0;
  }
  function IsNull(value2) {
    return value2 === null;
  }
  function IsBoolean(value2) {
    return typeof value2 === "boolean";
  }
  function IsNumber(value2) {
    return typeof value2 === "number";
  }
  function IsInteger(value2) {
    return Number.isInteger(value2);
  }
  function IsBigInt(value2) {
    return typeof value2 === "bigint";
  }
  function IsString(value2) {
    return typeof value2 === "string";
  }
  function IsFunction(value2) {
    return typeof value2 === "function";
  }
  function IsSymbol(value2) {
    return typeof value2 === "symbol";
  }
  function IsValueType(value2) {
    return IsBigInt(value2) || IsBoolean(value2) || IsNull(value2) || IsNumber(value2) || IsString(value2) || IsSymbol(value2) || IsUndefined(value2);
  }
  return guard$1;
}
var hasRequiredGuard$1;
function requireGuard$1() {
  if (hasRequiredGuard$1) return guard$2;
  hasRequiredGuard$1 = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireGuard$2(), exports$12);
  })(guard$2);
  return guard$2;
}
var hasRequiredPolicy;
function requirePolicy() {
  if (hasRequiredPolicy) return policy;
  hasRequiredPolicy = 1;
  Object.defineProperty(policy, "__esModule", { value: true });
  policy.TypeSystemPolicy = void 0;
  const index_1 = requireGuard$1();
  var TypeSystemPolicy;
  (function(TypeSystemPolicy2) {
    TypeSystemPolicy2.InstanceMode = "default";
    TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
    TypeSystemPolicy2.AllowArrayObject = false;
    TypeSystemPolicy2.AllowNaN = false;
    TypeSystemPolicy2.AllowNullVoid = false;
    function IsExactOptionalProperty(value2, key) {
      return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value2 : value2[key] !== void 0;
    }
    TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value2) {
      const isObject = (0, index_1.IsObject)(value2);
      return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !(0, index_1.IsArray)(value2);
    }
    TypeSystemPolicy2.IsObjectLike = IsObjectLike;
    function IsRecordLike(value2) {
      return IsObjectLike(value2) && !(value2 instanceof Date) && !(value2 instanceof Uint8Array);
    }
    TypeSystemPolicy2.IsRecordLike = IsRecordLike;
    function IsNumberLike(value2) {
      return TypeSystemPolicy2.AllowNaN ? (0, index_1.IsNumber)(value2) : Number.isFinite(value2);
    }
    TypeSystemPolicy2.IsNumberLike = IsNumberLike;
    function IsVoidLike(value2) {
      const isUndefined = (0, index_1.IsUndefined)(value2);
      return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value2 === null : isUndefined;
    }
    TypeSystemPolicy2.IsVoidLike = IsVoidLike;
  })(TypeSystemPolicy || (policy.TypeSystemPolicy = TypeSystemPolicy = {}));
  return policy;
}
var immutable = {};
var hasRequiredImmutable;
function requireImmutable() {
  if (hasRequiredImmutable) return immutable;
  hasRequiredImmutable = 1;
  Object.defineProperty(immutable, "__esModule", { value: true });
  immutable.Immutable = Immutable;
  const ValueGuard = requireValue$1();
  function ImmutableArray(value2) {
    return globalThis.Object.freeze(value2).map((value22) => Immutable(value22));
  }
  function ImmutableDate(value2) {
    return value2;
  }
  function ImmutableUint8Array(value2) {
    return value2;
  }
  function ImmutableRegExp(value2) {
    return value2;
  }
  function ImmutableObject(value2) {
    const result = {};
    for (const key of Object.getOwnPropertyNames(value2)) {
      result[key] = Immutable(value2[key]);
    }
    for (const key of Object.getOwnPropertySymbols(value2)) {
      result[key] = Immutable(value2[key]);
    }
    return globalThis.Object.freeze(result);
  }
  function Immutable(value2) {
    return ValueGuard.IsArray(value2) ? ImmutableArray(value2) : ValueGuard.IsDate(value2) ? ImmutableDate(value2) : ValueGuard.IsUint8Array(value2) ? ImmutableUint8Array(value2) : ValueGuard.IsRegExp(value2) ? ImmutableRegExp(value2) : ValueGuard.IsObject(value2) ? ImmutableObject(value2) : value2;
  }
  return immutable;
}
var hasRequiredType$5;
function requireType$5() {
  if (hasRequiredType$5) return type$5;
  hasRequiredType$5 = 1;
  Object.defineProperty(type$5, "__esModule", { value: true });
  type$5.CreateType = CreateType;
  const policy_1 = requirePolicy();
  const immutable_1 = requireImmutable();
  const value_1 = requireValue();
  function CreateType(schema2, options) {
    const result = options !== void 0 ? { ...options, ...schema2 } : schema2;
    switch (policy_1.TypeSystemPolicy.InstanceMode) {
      case "freeze":
        return (0, immutable_1.Immutable)(result);
      case "clone":
        return (0, value_1.Clone)(result);
      default:
        return result;
    }
  }
  return type$5;
}
var hasRequiredCreate;
function requireCreate() {
  if (hasRequiredCreate) return create;
  hasRequiredCreate = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireType$5(), exports$12);
  })(create);
  return create;
}
var error$1 = {};
var error = {};
var hasRequiredError$1;
function requireError$1() {
  if (hasRequiredError$1) return error;
  hasRequiredError$1 = 1;
  Object.defineProperty(error, "__esModule", { value: true });
  error.TypeBoxError = void 0;
  class TypeBoxError extends Error {
    constructor(message2) {
      super(message2);
    }
  }
  error.TypeBoxError = TypeBoxError;
  return error;
}
var hasRequiredError;
function requireError() {
  if (hasRequiredError) return error$1;
  hasRequiredError = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireError$1(), exports$12);
  })(error$1);
  return error$1;
}
var guard = {};
var kind = {};
var symbols$1 = {};
var symbols = {};
var hasRequiredSymbols$1;
function requireSymbols$1() {
  if (hasRequiredSymbols$1) return symbols;
  hasRequiredSymbols$1 = 1;
  Object.defineProperty(symbols, "__esModule", { value: true });
  symbols.Kind = symbols.Hint = symbols.OptionalKind = symbols.ReadonlyKind = symbols.TransformKind = void 0;
  symbols.TransformKind = Symbol.for("TypeBox.Transform");
  symbols.ReadonlyKind = Symbol.for("TypeBox.Readonly");
  symbols.OptionalKind = Symbol.for("TypeBox.Optional");
  symbols.Hint = Symbol.for("TypeBox.Hint");
  symbols.Kind = Symbol.for("TypeBox.Kind");
  return symbols;
}
var hasRequiredSymbols;
function requireSymbols() {
  if (hasRequiredSymbols) return symbols$1;
  hasRequiredSymbols = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireSymbols$1(), exports$12);
  })(symbols$1);
  return symbols$1;
}
var hasRequiredKind;
function requireKind() {
  if (hasRequiredKind) return kind;
  hasRequiredKind = 1;
  Object.defineProperty(kind, "__esModule", { value: true });
  kind.IsReadonly = IsReadonly;
  kind.IsOptional = IsOptional;
  kind.IsAny = IsAny;
  kind.IsArray = IsArray;
  kind.IsAsyncIterator = IsAsyncIterator;
  kind.IsBigInt = IsBigInt;
  kind.IsBoolean = IsBoolean;
  kind.IsConstructor = IsConstructor;
  kind.IsDate = IsDate;
  kind.IsFunction = IsFunction;
  kind.IsInteger = IsInteger;
  kind.IsProperties = IsProperties;
  kind.IsIntersect = IsIntersect;
  kind.IsIterator = IsIterator;
  kind.IsKindOf = IsKindOf;
  kind.IsLiteralString = IsLiteralString;
  kind.IsLiteralNumber = IsLiteralNumber;
  kind.IsLiteralBoolean = IsLiteralBoolean;
  kind.IsLiteral = IsLiteral;
  kind.IsMappedKey = IsMappedKey;
  kind.IsMappedResult = IsMappedResult;
  kind.IsNever = IsNever;
  kind.IsNot = IsNot;
  kind.IsNull = IsNull;
  kind.IsNumber = IsNumber;
  kind.IsObject = IsObject;
  kind.IsPromise = IsPromise;
  kind.IsRecord = IsRecord;
  kind.IsRecursive = IsRecursive;
  kind.IsRef = IsRef;
  kind.IsRegExp = IsRegExp;
  kind.IsString = IsString;
  kind.IsSymbol = IsSymbol;
  kind.IsTemplateLiteral = IsTemplateLiteral;
  kind.IsThis = IsThis;
  kind.IsTransform = IsTransform;
  kind.IsTuple = IsTuple;
  kind.IsUndefined = IsUndefined;
  kind.IsUnion = IsUnion;
  kind.IsUint8Array = IsUint8Array;
  kind.IsUnknown = IsUnknown;
  kind.IsUnsafe = IsUnsafe;
  kind.IsVoid = IsVoid;
  kind.IsKind = IsKind;
  kind.IsSchema = IsSchema;
  const ValueGuard = requireValue$1();
  const index_1 = requireSymbols();
  function IsReadonly(value2) {
    return ValueGuard.IsObject(value2) && value2[index_1.ReadonlyKind] === "Readonly";
  }
  function IsOptional(value2) {
    return ValueGuard.IsObject(value2) && value2[index_1.OptionalKind] === "Optional";
  }
  function IsAny(value2) {
    return IsKindOf(value2, "Any");
  }
  function IsArray(value2) {
    return IsKindOf(value2, "Array");
  }
  function IsAsyncIterator(value2) {
    return IsKindOf(value2, "AsyncIterator");
  }
  function IsBigInt(value2) {
    return IsKindOf(value2, "BigInt");
  }
  function IsBoolean(value2) {
    return IsKindOf(value2, "Boolean");
  }
  function IsConstructor(value2) {
    return IsKindOf(value2, "Constructor");
  }
  function IsDate(value2) {
    return IsKindOf(value2, "Date");
  }
  function IsFunction(value2) {
    return IsKindOf(value2, "Function");
  }
  function IsInteger(value2) {
    return IsKindOf(value2, "Integer");
  }
  function IsProperties(value2) {
    return ValueGuard.IsObject(value2);
  }
  function IsIntersect(value2) {
    return IsKindOf(value2, "Intersect");
  }
  function IsIterator(value2) {
    return IsKindOf(value2, "Iterator");
  }
  function IsKindOf(value2, kind2) {
    return ValueGuard.IsObject(value2) && index_1.Kind in value2 && value2[index_1.Kind] === kind2;
  }
  function IsLiteralString(value2) {
    return IsLiteral(value2) && ValueGuard.IsString(value2.const);
  }
  function IsLiteralNumber(value2) {
    return IsLiteral(value2) && ValueGuard.IsNumber(value2.const);
  }
  function IsLiteralBoolean(value2) {
    return IsLiteral(value2) && ValueGuard.IsBoolean(value2.const);
  }
  function IsLiteral(value2) {
    return IsKindOf(value2, "Literal");
  }
  function IsMappedKey(value2) {
    return IsKindOf(value2, "MappedKey");
  }
  function IsMappedResult(value2) {
    return IsKindOf(value2, "MappedResult");
  }
  function IsNever(value2) {
    return IsKindOf(value2, "Never");
  }
  function IsNot(value2) {
    return IsKindOf(value2, "Not");
  }
  function IsNull(value2) {
    return IsKindOf(value2, "Null");
  }
  function IsNumber(value2) {
    return IsKindOf(value2, "Number");
  }
  function IsObject(value2) {
    return IsKindOf(value2, "Object");
  }
  function IsPromise(value2) {
    return IsKindOf(value2, "Promise");
  }
  function IsRecord(value2) {
    return IsKindOf(value2, "Record");
  }
  function IsRecursive(value2) {
    return ValueGuard.IsObject(value2) && index_1.Hint in value2 && value2[index_1.Hint] === "Recursive";
  }
  function IsRef(value2) {
    return IsKindOf(value2, "Ref");
  }
  function IsRegExp(value2) {
    return IsKindOf(value2, "RegExp");
  }
  function IsString(value2) {
    return IsKindOf(value2, "String");
  }
  function IsSymbol(value2) {
    return IsKindOf(value2, "Symbol");
  }
  function IsTemplateLiteral(value2) {
    return IsKindOf(value2, "TemplateLiteral");
  }
  function IsThis(value2) {
    return IsKindOf(value2, "This");
  }
  function IsTransform(value2) {
    return ValueGuard.IsObject(value2) && index_1.TransformKind in value2;
  }
  function IsTuple(value2) {
    return IsKindOf(value2, "Tuple");
  }
  function IsUndefined(value2) {
    return IsKindOf(value2, "Undefined");
  }
  function IsUnion(value2) {
    return IsKindOf(value2, "Union");
  }
  function IsUint8Array(value2) {
    return IsKindOf(value2, "Uint8Array");
  }
  function IsUnknown(value2) {
    return IsKindOf(value2, "Unknown");
  }
  function IsUnsafe(value2) {
    return IsKindOf(value2, "Unsafe");
  }
  function IsVoid(value2) {
    return IsKindOf(value2, "Void");
  }
  function IsKind(value2) {
    return ValueGuard.IsObject(value2) && index_1.Kind in value2 && ValueGuard.IsString(value2[index_1.Kind]);
  }
  function IsSchema(value2) {
    return IsAny(value2) || IsArray(value2) || IsBoolean(value2) || IsBigInt(value2) || IsAsyncIterator(value2) || IsConstructor(value2) || IsDate(value2) || IsFunction(value2) || IsInteger(value2) || IsIntersect(value2) || IsIterator(value2) || IsLiteral(value2) || IsMappedKey(value2) || IsMappedResult(value2) || IsNever(value2) || IsNot(value2) || IsNull(value2) || IsNumber(value2) || IsObject(value2) || IsPromise(value2) || IsRecord(value2) || IsRef(value2) || IsRegExp(value2) || IsString(value2) || IsSymbol(value2) || IsTemplateLiteral(value2) || IsThis(value2) || IsTuple(value2) || IsUndefined(value2) || IsUnion(value2) || IsUint8Array(value2) || IsUnknown(value2) || IsUnsafe(value2) || IsVoid(value2) || IsKind(value2);
  }
  return kind;
}
var type$4 = {};
var hasRequiredType$4;
function requireType$4() {
  if (hasRequiredType$4) return type$4;
  hasRequiredType$4 = 1;
  Object.defineProperty(type$4, "__esModule", { value: true });
  type$4.TypeGuardUnknownTypeError = void 0;
  type$4.IsReadonly = IsReadonly;
  type$4.IsOptional = IsOptional;
  type$4.IsAny = IsAny;
  type$4.IsArray = IsArray;
  type$4.IsAsyncIterator = IsAsyncIterator;
  type$4.IsBigInt = IsBigInt;
  type$4.IsBoolean = IsBoolean;
  type$4.IsConstructor = IsConstructor;
  type$4.IsDate = IsDate;
  type$4.IsFunction = IsFunction;
  type$4.IsInteger = IsInteger;
  type$4.IsProperties = IsProperties;
  type$4.IsIntersect = IsIntersect;
  type$4.IsIterator = IsIterator;
  type$4.IsKindOf = IsKindOf;
  type$4.IsLiteralString = IsLiteralString;
  type$4.IsLiteralNumber = IsLiteralNumber;
  type$4.IsLiteralBoolean = IsLiteralBoolean;
  type$4.IsLiteral = IsLiteral;
  type$4.IsLiteralValue = IsLiteralValue;
  type$4.IsMappedKey = IsMappedKey;
  type$4.IsMappedResult = IsMappedResult;
  type$4.IsNever = IsNever;
  type$4.IsNot = IsNot;
  type$4.IsNull = IsNull;
  type$4.IsNumber = IsNumber;
  type$4.IsObject = IsObject;
  type$4.IsPromise = IsPromise;
  type$4.IsRecord = IsRecord;
  type$4.IsRecursive = IsRecursive;
  type$4.IsRef = IsRef;
  type$4.IsRegExp = IsRegExp;
  type$4.IsString = IsString;
  type$4.IsSymbol = IsSymbol;
  type$4.IsTemplateLiteral = IsTemplateLiteral;
  type$4.IsThis = IsThis;
  type$4.IsTransform = IsTransform;
  type$4.IsTuple = IsTuple;
  type$4.IsUndefined = IsUndefined;
  type$4.IsUnionLiteral = IsUnionLiteral;
  type$4.IsUnion = IsUnion;
  type$4.IsUint8Array = IsUint8Array;
  type$4.IsUnknown = IsUnknown;
  type$4.IsUnsafe = IsUnsafe;
  type$4.IsVoid = IsVoid;
  type$4.IsKind = IsKind;
  type$4.IsSchema = IsSchema;
  const ValueGuard = requireValue$1();
  const index_1 = requireSymbols();
  const index_2 = requireError();
  class TypeGuardUnknownTypeError extends index_2.TypeBoxError {
  }
  type$4.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
  const KnownTypes = [
    "Any",
    "Array",
    "AsyncIterator",
    "BigInt",
    "Boolean",
    "Constructor",
    "Date",
    "Enum",
    "Function",
    "Integer",
    "Intersect",
    "Iterator",
    "Literal",
    "MappedKey",
    "MappedResult",
    "Not",
    "Null",
    "Number",
    "Object",
    "Promise",
    "Record",
    "Ref",
    "RegExp",
    "String",
    "Symbol",
    "TemplateLiteral",
    "This",
    "Tuple",
    "Undefined",
    "Union",
    "Uint8Array",
    "Unknown",
    "Void"
  ];
  function IsPattern(value2) {
    try {
      new RegExp(value2);
      return true;
    } catch {
      return false;
    }
  }
  function IsControlCharacterFree(value2) {
    if (!ValueGuard.IsString(value2))
      return false;
    for (let i = 0; i < value2.length; i++) {
      const code = value2.charCodeAt(i);
      if (code >= 7 && code <= 13 || code === 27 || code === 127) {
        return false;
      }
    }
    return true;
  }
  function IsAdditionalProperties(value2) {
    return IsOptionalBoolean(value2) || IsSchema(value2);
  }
  function IsOptionalBigInt(value2) {
    return ValueGuard.IsUndefined(value2) || ValueGuard.IsBigInt(value2);
  }
  function IsOptionalNumber(value2) {
    return ValueGuard.IsUndefined(value2) || ValueGuard.IsNumber(value2);
  }
  function IsOptionalBoolean(value2) {
    return ValueGuard.IsUndefined(value2) || ValueGuard.IsBoolean(value2);
  }
  function IsOptionalString(value2) {
    return ValueGuard.IsUndefined(value2) || ValueGuard.IsString(value2);
  }
  function IsOptionalPattern(value2) {
    return ValueGuard.IsUndefined(value2) || ValueGuard.IsString(value2) && IsControlCharacterFree(value2) && IsPattern(value2);
  }
  function IsOptionalFormat(value2) {
    return ValueGuard.IsUndefined(value2) || ValueGuard.IsString(value2) && IsControlCharacterFree(value2);
  }
  function IsOptionalSchema(value2) {
    return ValueGuard.IsUndefined(value2) || IsSchema(value2);
  }
  function IsReadonly(value2) {
    return ValueGuard.IsObject(value2) && value2[index_1.ReadonlyKind] === "Readonly";
  }
  function IsOptional(value2) {
    return ValueGuard.IsObject(value2) && value2[index_1.OptionalKind] === "Optional";
  }
  function IsAny(value2) {
    return IsKindOf(value2, "Any") && IsOptionalString(value2.$id);
  }
  function IsArray(value2) {
    return IsKindOf(value2, "Array") && value2.type === "array" && IsOptionalString(value2.$id) && IsSchema(value2.items) && IsOptionalNumber(value2.minItems) && IsOptionalNumber(value2.maxItems) && IsOptionalBoolean(value2.uniqueItems) && IsOptionalSchema(value2.contains) && IsOptionalNumber(value2.minContains) && IsOptionalNumber(value2.maxContains);
  }
  function IsAsyncIterator(value2) {
    return IsKindOf(value2, "AsyncIterator") && value2.type === "AsyncIterator" && IsOptionalString(value2.$id) && IsSchema(value2.items);
  }
  function IsBigInt(value2) {
    return IsKindOf(value2, "BigInt") && value2.type === "bigint" && IsOptionalString(value2.$id) && IsOptionalBigInt(value2.exclusiveMaximum) && IsOptionalBigInt(value2.exclusiveMinimum) && IsOptionalBigInt(value2.maximum) && IsOptionalBigInt(value2.minimum) && IsOptionalBigInt(value2.multipleOf);
  }
  function IsBoolean(value2) {
    return IsKindOf(value2, "Boolean") && value2.type === "boolean" && IsOptionalString(value2.$id);
  }
  function IsConstructor(value2) {
    return IsKindOf(value2, "Constructor") && value2.type === "Constructor" && IsOptionalString(value2.$id) && ValueGuard.IsArray(value2.parameters) && value2.parameters.every((schema2) => IsSchema(schema2)) && IsSchema(value2.returns);
  }
  function IsDate(value2) {
    return IsKindOf(value2, "Date") && value2.type === "Date" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximumTimestamp) && IsOptionalNumber(value2.exclusiveMinimumTimestamp) && IsOptionalNumber(value2.maximumTimestamp) && IsOptionalNumber(value2.minimumTimestamp) && IsOptionalNumber(value2.multipleOfTimestamp);
  }
  function IsFunction(value2) {
    return IsKindOf(value2, "Function") && value2.type === "Function" && IsOptionalString(value2.$id) && ValueGuard.IsArray(value2.parameters) && value2.parameters.every((schema2) => IsSchema(schema2)) && IsSchema(value2.returns);
  }
  function IsInteger(value2) {
    return IsKindOf(value2, "Integer") && value2.type === "integer" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximum) && IsOptionalNumber(value2.exclusiveMinimum) && IsOptionalNumber(value2.maximum) && IsOptionalNumber(value2.minimum) && IsOptionalNumber(value2.multipleOf);
  }
  function IsProperties(value2) {
    return ValueGuard.IsObject(value2) && Object.entries(value2).every(([key, schema2]) => IsControlCharacterFree(key) && IsSchema(schema2));
  }
  function IsIntersect(value2) {
    return IsKindOf(value2, "Intersect") && (ValueGuard.IsString(value2.type) && value2.type !== "object" ? false : true) && ValueGuard.IsArray(value2.allOf) && value2.allOf.every((schema2) => IsSchema(schema2) && !IsTransform(schema2)) && IsOptionalString(value2.type) && (IsOptionalBoolean(value2.unevaluatedProperties) || IsOptionalSchema(value2.unevaluatedProperties)) && IsOptionalString(value2.$id);
  }
  function IsIterator(value2) {
    return IsKindOf(value2, "Iterator") && value2.type === "Iterator" && IsOptionalString(value2.$id) && IsSchema(value2.items);
  }
  function IsKindOf(value2, kind2) {
    return ValueGuard.IsObject(value2) && index_1.Kind in value2 && value2[index_1.Kind] === kind2;
  }
  function IsLiteralString(value2) {
    return IsLiteral(value2) && ValueGuard.IsString(value2.const);
  }
  function IsLiteralNumber(value2) {
    return IsLiteral(value2) && ValueGuard.IsNumber(value2.const);
  }
  function IsLiteralBoolean(value2) {
    return IsLiteral(value2) && ValueGuard.IsBoolean(value2.const);
  }
  function IsLiteral(value2) {
    return IsKindOf(value2, "Literal") && IsOptionalString(value2.$id) && IsLiteralValue(value2.const);
  }
  function IsLiteralValue(value2) {
    return ValueGuard.IsBoolean(value2) || ValueGuard.IsNumber(value2) || ValueGuard.IsString(value2);
  }
  function IsMappedKey(value2) {
    return IsKindOf(value2, "MappedKey") && ValueGuard.IsArray(value2.keys) && value2.keys.every((key) => ValueGuard.IsNumber(key) || ValueGuard.IsString(key));
  }
  function IsMappedResult(value2) {
    return IsKindOf(value2, "MappedResult") && IsProperties(value2.properties);
  }
  function IsNever(value2) {
    return IsKindOf(value2, "Never") && ValueGuard.IsObject(value2.not) && Object.getOwnPropertyNames(value2.not).length === 0;
  }
  function IsNot(value2) {
    return IsKindOf(value2, "Not") && IsSchema(value2.not);
  }
  function IsNull(value2) {
    return IsKindOf(value2, "Null") && value2.type === "null" && IsOptionalString(value2.$id);
  }
  function IsNumber(value2) {
    return IsKindOf(value2, "Number") && value2.type === "number" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximum) && IsOptionalNumber(value2.exclusiveMinimum) && IsOptionalNumber(value2.maximum) && IsOptionalNumber(value2.minimum) && IsOptionalNumber(value2.multipleOf);
  }
  function IsObject(value2) {
    return IsKindOf(value2, "Object") && value2.type === "object" && IsOptionalString(value2.$id) && IsProperties(value2.properties) && IsAdditionalProperties(value2.additionalProperties) && IsOptionalNumber(value2.minProperties) && IsOptionalNumber(value2.maxProperties);
  }
  function IsPromise(value2) {
    return IsKindOf(value2, "Promise") && value2.type === "Promise" && IsOptionalString(value2.$id) && IsSchema(value2.item);
  }
  function IsRecord(value2) {
    return IsKindOf(value2, "Record") && value2.type === "object" && IsOptionalString(value2.$id) && IsAdditionalProperties(value2.additionalProperties) && ValueGuard.IsObject(value2.patternProperties) && ((schema2) => {
      const keys = Object.getOwnPropertyNames(schema2.patternProperties);
      return keys.length === 1 && IsPattern(keys[0]) && ValueGuard.IsObject(schema2.patternProperties) && IsSchema(schema2.patternProperties[keys[0]]);
    })(value2);
  }
  function IsRecursive(value2) {
    return ValueGuard.IsObject(value2) && index_1.Hint in value2 && value2[index_1.Hint] === "Recursive";
  }
  function IsRef(value2) {
    return IsKindOf(value2, "Ref") && IsOptionalString(value2.$id) && ValueGuard.IsString(value2.$ref);
  }
  function IsRegExp(value2) {
    return IsKindOf(value2, "RegExp") && IsOptionalString(value2.$id) && ValueGuard.IsString(value2.source) && ValueGuard.IsString(value2.flags) && IsOptionalNumber(value2.maxLength) && IsOptionalNumber(value2.minLength);
  }
  function IsString(value2) {
    return IsKindOf(value2, "String") && value2.type === "string" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.minLength) && IsOptionalNumber(value2.maxLength) && IsOptionalPattern(value2.pattern) && IsOptionalFormat(value2.format);
  }
  function IsSymbol(value2) {
    return IsKindOf(value2, "Symbol") && value2.type === "symbol" && IsOptionalString(value2.$id);
  }
  function IsTemplateLiteral(value2) {
    return IsKindOf(value2, "TemplateLiteral") && value2.type === "string" && ValueGuard.IsString(value2.pattern) && value2.pattern[0] === "^" && value2.pattern[value2.pattern.length - 1] === "$";
  }
  function IsThis(value2) {
    return IsKindOf(value2, "This") && IsOptionalString(value2.$id) && ValueGuard.IsString(value2.$ref);
  }
  function IsTransform(value2) {
    return ValueGuard.IsObject(value2) && index_1.TransformKind in value2;
  }
  function IsTuple(value2) {
    return IsKindOf(value2, "Tuple") && value2.type === "array" && IsOptionalString(value2.$id) && ValueGuard.IsNumber(value2.minItems) && ValueGuard.IsNumber(value2.maxItems) && value2.minItems === value2.maxItems && // empty
    (ValueGuard.IsUndefined(value2.items) && ValueGuard.IsUndefined(value2.additionalItems) && value2.minItems === 0 || ValueGuard.IsArray(value2.items) && value2.items.every((schema2) => IsSchema(schema2)));
  }
  function IsUndefined(value2) {
    return IsKindOf(value2, "Undefined") && value2.type === "undefined" && IsOptionalString(value2.$id);
  }
  function IsUnionLiteral(value2) {
    return IsUnion(value2) && value2.anyOf.every((schema2) => IsLiteralString(schema2) || IsLiteralNumber(schema2));
  }
  function IsUnion(value2) {
    return IsKindOf(value2, "Union") && IsOptionalString(value2.$id) && ValueGuard.IsObject(value2) && ValueGuard.IsArray(value2.anyOf) && value2.anyOf.every((schema2) => IsSchema(schema2));
  }
  function IsUint8Array(value2) {
    return IsKindOf(value2, "Uint8Array") && value2.type === "Uint8Array" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.minByteLength) && IsOptionalNumber(value2.maxByteLength);
  }
  function IsUnknown(value2) {
    return IsKindOf(value2, "Unknown") && IsOptionalString(value2.$id);
  }
  function IsUnsafe(value2) {
    return IsKindOf(value2, "Unsafe");
  }
  function IsVoid(value2) {
    return IsKindOf(value2, "Void") && value2.type === "void" && IsOptionalString(value2.$id);
  }
  function IsKind(value2) {
    return ValueGuard.IsObject(value2) && index_1.Kind in value2 && ValueGuard.IsString(value2[index_1.Kind]) && !KnownTypes.includes(value2[index_1.Kind]);
  }
  function IsSchema(value2) {
    return ValueGuard.IsObject(value2) && (IsAny(value2) || IsArray(value2) || IsBoolean(value2) || IsBigInt(value2) || IsAsyncIterator(value2) || IsConstructor(value2) || IsDate(value2) || IsFunction(value2) || IsInteger(value2) || IsIntersect(value2) || IsIterator(value2) || IsLiteral(value2) || IsMappedKey(value2) || IsMappedResult(value2) || IsNever(value2) || IsNot(value2) || IsNull(value2) || IsNumber(value2) || IsObject(value2) || IsPromise(value2) || IsRecord(value2) || IsRef(value2) || IsRegExp(value2) || IsString(value2) || IsSymbol(value2) || IsTemplateLiteral(value2) || IsThis(value2) || IsTuple(value2) || IsUndefined(value2) || IsUnion(value2) || IsUint8Array(value2) || IsUnknown(value2) || IsUnsafe(value2) || IsVoid(value2) || IsKind(value2));
  }
  return type$4;
}
var hasRequiredGuard;
function requireGuard() {
  if (hasRequiredGuard) return guard;
  hasRequiredGuard = 1;
  Object.defineProperty(guard, "__esModule", { value: true });
  guard.ValueGuard = guard.TypeGuard = guard.KindGuard = void 0;
  guard.KindGuard = requireKind();
  guard.TypeGuard = requireType$4();
  guard.ValueGuard = requireValue$1();
  return guard;
}
var helpers$1 = {};
var helpers = {};
var hasRequiredHelpers$1;
function requireHelpers$1() {
  if (hasRequiredHelpers$1) return helpers;
  hasRequiredHelpers$1 = 1;
  Object.defineProperty(helpers, "__esModule", { value: true });
  helpers.Increment = Increment;
  function Increment(T) {
    return (parseInt(T) + 1).toString();
  }
  return helpers;
}
var hasRequiredHelpers;
function requireHelpers() {
  if (hasRequiredHelpers) return helpers$1;
  hasRequiredHelpers = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireHelpers$1(), exports$12);
  })(helpers$1);
  return helpers$1;
}
var patterns$1 = {};
var patterns = {};
var hasRequiredPatterns$1;
function requirePatterns$1() {
  if (hasRequiredPatterns$1) return patterns;
  hasRequiredPatterns$1 = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", { value: true });
    exports$12.PatternNeverExact = exports$12.PatternStringExact = exports$12.PatternNumberExact = exports$12.PatternBooleanExact = exports$12.PatternNever = exports$12.PatternString = exports$12.PatternNumber = exports$12.PatternBoolean = void 0;
    exports$12.PatternBoolean = "(true|false)";
    exports$12.PatternNumber = "(0|[1-9][0-9]*)";
    exports$12.PatternString = "(.*)";
    exports$12.PatternNever = "(?!.*)";
    exports$12.PatternBooleanExact = `^${exports$12.PatternBoolean}$`;
    exports$12.PatternNumberExact = `^${exports$12.PatternNumber}$`;
    exports$12.PatternStringExact = `^${exports$12.PatternString}$`;
    exports$12.PatternNeverExact = `^${exports$12.PatternNever}$`;
  })(patterns);
  return patterns;
}
var hasRequiredPatterns;
function requirePatterns() {
  if (hasRequiredPatterns) return patterns$1;
  hasRequiredPatterns = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requirePatterns$1(), exports$12);
  })(patterns$1);
  return patterns$1;
}
var registry = {};
var format = {};
var hasRequiredFormat;
function requireFormat() {
  if (hasRequiredFormat) return format;
  hasRequiredFormat = 1;
  Object.defineProperty(format, "__esModule", { value: true });
  format.Entries = Entries;
  format.Clear = Clear;
  format.Delete = Delete;
  format.Has = Has;
  format.Set = Set2;
  format.Get = Get;
  const map = /* @__PURE__ */ new Map();
  function Entries() {
    return new Map(map);
  }
  function Clear() {
    return map.clear();
  }
  function Delete(format2) {
    return map.delete(format2);
  }
  function Has(format2) {
    return map.has(format2);
  }
  function Set2(format2, func) {
    map.set(format2, func);
  }
  function Get(format2) {
    return map.get(format2);
  }
  return format;
}
var type$3 = {};
var hasRequiredType$3;
function requireType$3() {
  if (hasRequiredType$3) return type$3;
  hasRequiredType$3 = 1;
  Object.defineProperty(type$3, "__esModule", { value: true });
  type$3.Entries = Entries;
  type$3.Clear = Clear;
  type$3.Delete = Delete;
  type$3.Has = Has;
  type$3.Set = Set2;
  type$3.Get = Get;
  const map = /* @__PURE__ */ new Map();
  function Entries() {
    return new Map(map);
  }
  function Clear() {
    return map.clear();
  }
  function Delete(kind2) {
    return map.delete(kind2);
  }
  function Has(kind2) {
    return map.has(kind2);
  }
  function Set2(kind2, func) {
    map.set(kind2, func);
  }
  function Get(kind2) {
    return map.get(kind2);
  }
  return type$3;
}
var hasRequiredRegistry;
function requireRegistry() {
  if (hasRequiredRegistry) return registry;
  hasRequiredRegistry = 1;
  Object.defineProperty(registry, "__esModule", { value: true });
  registry.TypeRegistry = registry.FormatRegistry = void 0;
  registry.FormatRegistry = requireFormat();
  registry.TypeRegistry = requireType$3();
  return registry;
}
var sets = {};
var set = {};
var hasRequiredSet;
function requireSet() {
  if (hasRequiredSet) return set;
  hasRequiredSet = 1;
  Object.defineProperty(set, "__esModule", { value: true });
  set.SetIncludes = SetIncludes;
  set.SetIsSubset = SetIsSubset;
  set.SetDistinct = SetDistinct;
  set.SetIntersect = SetIntersect;
  set.SetUnion = SetUnion;
  set.SetComplement = SetComplement;
  set.SetIntersectMany = SetIntersectMany;
  set.SetUnionMany = SetUnionMany;
  function SetIncludes(T, S) {
    return T.includes(S);
  }
  function SetIsSubset(T, S) {
    return T.every((L) => SetIncludes(S, L));
  }
  function SetDistinct(T) {
    return [...new Set(T)];
  }
  function SetIntersect(T, S) {
    return T.filter((L) => S.includes(L));
  }
  function SetUnion(T, S) {
    return [...T, ...S];
  }
  function SetComplement(T, S) {
    return T.filter((L) => !S.includes(L));
  }
  function SetIntersectManyResolve(T, Init) {
    return T.reduce((Acc, L) => {
      return SetIntersect(Acc, L);
    }, Init);
  }
  function SetIntersectMany(T) {
    return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
  }
  function SetUnionMany(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(...L);
    return Acc;
  }
  return set;
}
var hasRequiredSets;
function requireSets() {
  if (hasRequiredSets) return sets;
  hasRequiredSets = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireSet(), exports$12);
  })(sets);
  return sets;
}
var any$1 = {};
var any = {};
var hasRequiredAny$1;
function requireAny$1() {
  if (hasRequiredAny$1) return any;
  hasRequiredAny$1 = 1;
  Object.defineProperty(any, "__esModule", { value: true });
  any.Any = Any;
  const index_1 = requireCreate();
  const index_2 = requireSymbols();
  function Any(options) {
    return (0, index_1.CreateType)({ [index_2.Kind]: "Any" }, options);
  }
  return any;
}
var hasRequiredAny;
function requireAny() {
  if (hasRequiredAny) return any$1;
  hasRequiredAny = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireAny$1(), exports$12);
  })(any$1);
  return any$1;
}
var array$1 = {};
var array = {};
var hasRequiredArray$1;
function requireArray$1() {
  if (hasRequiredArray$1) return array;
  hasRequiredArray$1 = 1;
  Object.defineProperty(array, "__esModule", { value: true });
  array.Array = Array2;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Array2(items, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Array", type: "array", items }, options);
  }
  return array;
}
var hasRequiredArray;
function requireArray() {
  if (hasRequiredArray) return array$1;
  hasRequiredArray = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireArray$1(), exports$12);
  })(array$1);
  return array$1;
}
var asyncIterator$1 = {};
var asyncIterator = {};
var hasRequiredAsyncIterator$1;
function requireAsyncIterator$1() {
  if (hasRequiredAsyncIterator$1) return asyncIterator;
  hasRequiredAsyncIterator$1 = 1;
  Object.defineProperty(asyncIterator, "__esModule", { value: true });
  asyncIterator.AsyncIterator = AsyncIterator;
  const index_1 = requireSymbols();
  const type_1 = requireType$5();
  function AsyncIterator(items, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "AsyncIterator", type: "AsyncIterator", items }, options);
  }
  return asyncIterator;
}
var hasRequiredAsyncIterator;
function requireAsyncIterator() {
  if (hasRequiredAsyncIterator) return asyncIterator$1;
  hasRequiredAsyncIterator = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireAsyncIterator$1(), exports$12);
  })(asyncIterator$1);
  return asyncIterator$1;
}
var awaited$1 = {};
var awaited = {};
var intersect$1 = {};
var intersectEvaluated = {};
var discard$1 = {};
var discard = {};
var hasRequiredDiscard$1;
function requireDiscard$1() {
  if (hasRequiredDiscard$1) return discard;
  hasRequiredDiscard$1 = 1;
  Object.defineProperty(discard, "__esModule", { value: true });
  discard.Discard = Discard;
  function DiscardKey(value2, key) {
    const { [key]: _, ...rest2 } = value2;
    return rest2;
  }
  function Discard(value2, keys) {
    return keys.reduce((acc, key) => DiscardKey(acc, key), value2);
  }
  return discard;
}
var hasRequiredDiscard;
function requireDiscard() {
  if (hasRequiredDiscard) return discard$1;
  hasRequiredDiscard = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireDiscard$1(), exports$12);
  })(discard$1);
  return discard$1;
}
var never$1 = {};
var never = {};
var hasRequiredNever$1;
function requireNever$1() {
  if (hasRequiredNever$1) return never;
  hasRequiredNever$1 = 1;
  Object.defineProperty(never, "__esModule", { value: true });
  never.Never = Never;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Never(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Never", not: {} }, options);
  }
  return never;
}
var hasRequiredNever;
function requireNever() {
  if (hasRequiredNever) return never$1;
  hasRequiredNever = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireNever$1(), exports$12);
  })(never$1);
  return never$1;
}
var optional$1 = {};
var optionalFromMappedResult = {};
var mapped$1 = {};
var mappedKey = {};
var hasRequiredMappedKey;
function requireMappedKey() {
  if (hasRequiredMappedKey) return mappedKey;
  hasRequiredMappedKey = 1;
  Object.defineProperty(mappedKey, "__esModule", { value: true });
  mappedKey.MappedKey = MappedKey;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function MappedKey(T) {
    return (0, type_1.CreateType)({
      [index_1.Kind]: "MappedKey",
      keys: T
    });
  }
  return mappedKey;
}
var mappedResult = {};
var hasRequiredMappedResult;
function requireMappedResult() {
  if (hasRequiredMappedResult) return mappedResult;
  hasRequiredMappedResult = 1;
  Object.defineProperty(mappedResult, "__esModule", { value: true });
  mappedResult.MappedResult = MappedResult;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function MappedResult(properties) {
    return (0, type_1.CreateType)({
      [index_1.Kind]: "MappedResult",
      properties
    });
  }
  return mappedResult;
}
var mapped = {};
var constructor$1 = {};
var constructor = {};
var hasRequiredConstructor$1;
function requireConstructor$1() {
  if (hasRequiredConstructor$1) return constructor;
  hasRequiredConstructor$1 = 1;
  Object.defineProperty(constructor, "__esModule", { value: true });
  constructor.Constructor = Constructor;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Constructor(parameters2, returns, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Constructor", type: "Constructor", parameters: parameters2, returns }, options);
  }
  return constructor;
}
var hasRequiredConstructor;
function requireConstructor() {
  if (hasRequiredConstructor) return constructor$1;
  hasRequiredConstructor = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireConstructor$1(), exports$12);
  })(constructor$1);
  return constructor$1;
}
var _function$2 = {};
var _function$1 = {};
var hasRequired_function$2;
function require_function$2() {
  if (hasRequired_function$2) return _function$1;
  hasRequired_function$2 = 1;
  Object.defineProperty(_function$1, "__esModule", { value: true });
  _function$1.Function = Function2;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Function2(parameters2, returns, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Function", type: "Function", parameters: parameters2, returns }, options);
  }
  return _function$1;
}
var hasRequired_function$1;
function require_function$1() {
  if (hasRequired_function$1) return _function$2;
  hasRequired_function$1 = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(require_function$2(), exports$12);
  })(_function$2);
  return _function$2;
}
var indexed$1 = {};
var indexedFromMappedKey = {};
var indexed = {};
var union$2 = {};
var unionEvaluated = {};
var unionCreate = {};
var hasRequiredUnionCreate;
function requireUnionCreate() {
  if (hasRequiredUnionCreate) return unionCreate;
  hasRequiredUnionCreate = 1;
  Object.defineProperty(unionCreate, "__esModule", { value: true });
  unionCreate.UnionCreate = UnionCreate;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function UnionCreate(T, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Union", anyOf: T }, options);
  }
  return unionCreate;
}
var hasRequiredUnionEvaluated;
function requireUnionEvaluated() {
  if (hasRequiredUnionEvaluated) return unionEvaluated;
  hasRequiredUnionEvaluated = 1;
  Object.defineProperty(unionEvaluated, "__esModule", { value: true });
  unionEvaluated.UnionEvaluated = UnionEvaluated;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  const index_2 = requireDiscard();
  const index_3 = requireNever();
  const index_4 = requireOptional();
  const union_create_1 = requireUnionCreate();
  const kind_1 = requireKind();
  function IsUnionOptional(T) {
    return T.some((L) => (0, kind_1.IsOptional)(L));
  }
  function RemoveOptionalFromRest(T) {
    return T.map((L) => (0, kind_1.IsOptional)(L) ? RemoveOptionalFromType(L) : L);
  }
  function RemoveOptionalFromType(T) {
    return (0, index_2.Discard)(T, [index_1.OptionalKind]);
  }
  function ResolveUnion(T, options) {
    return IsUnionOptional(T) ? (0, index_4.Optional)((0, union_create_1.UnionCreate)(RemoveOptionalFromRest(T), options)) : (0, union_create_1.UnionCreate)(RemoveOptionalFromRest(T), options);
  }
  function UnionEvaluated(T, options) {
    return T.length === 0 ? (0, index_3.Never)(options) : T.length === 1 ? (0, type_1.CreateType)(T[0], options) : ResolveUnion(T, options);
  }
  return unionEvaluated;
}
var unionType = {};
var hasRequiredUnionType;
function requireUnionType() {
  if (hasRequiredUnionType) return unionType;
  hasRequiredUnionType = 1;
  Object.defineProperty(unionType, "__esModule", { value: true });
  requireSymbols();
  return unionType;
}
var union$1 = {};
var hasRequiredUnion$2;
function requireUnion$2() {
  if (hasRequiredUnion$2) return union$1;
  hasRequiredUnion$2 = 1;
  Object.defineProperty(union$1, "__esModule", { value: true });
  union$1.Union = Union;
  const index_1 = requireNever();
  const type_1 = requireType$5();
  const union_create_1 = requireUnionCreate();
  function Union(T, options) {
    return T.length === 0 ? (0, index_1.Never)(options) : T.length === 1 ? (0, type_1.CreateType)(T[0], options) : (0, union_create_1.UnionCreate)(T, options);
  }
  return union$1;
}
var hasRequiredUnion$1;
function requireUnion$1() {
  if (hasRequiredUnion$1) return union$2;
  hasRequiredUnion$1 = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireUnionEvaluated(), exports$12);
    __exportStar(requireUnionType(), exports$12);
    __exportStar(requireUnion$2(), exports$12);
  })(union$2);
  return union$2;
}
var indexedPropertyKeys = {};
var templateLiteral$1 = {};
var finite = {};
var parse = {};
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  Object.defineProperty(parse, "__esModule", { value: true });
  parse.TemplateLiteralParserError = void 0;
  parse.TemplateLiteralParse = TemplateLiteralParse;
  parse.TemplateLiteralParseExact = TemplateLiteralParseExact;
  const index_1 = requireError();
  class TemplateLiteralParserError extends index_1.TypeBoxError {
  }
  parse.TemplateLiteralParserError = TemplateLiteralParserError;
  function Unescape(pattern2) {
    return pattern2.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
  }
  function IsNonEscaped(pattern2, index2, char) {
    return pattern2[index2] === char && pattern2.charCodeAt(index2 - 1) !== 92;
  }
  function IsOpenParen(pattern2, index2) {
    return IsNonEscaped(pattern2, index2, "(");
  }
  function IsCloseParen(pattern2, index2) {
    return IsNonEscaped(pattern2, index2, ")");
  }
  function IsSeparator(pattern2, index2) {
    return IsNonEscaped(pattern2, index2, "|");
  }
  function IsGroup(pattern2) {
    if (!(IsOpenParen(pattern2, 0) && IsCloseParen(pattern2, pattern2.length - 1)))
      return false;
    let count = 0;
    for (let index2 = 0; index2 < pattern2.length; index2++) {
      if (IsOpenParen(pattern2, index2))
        count += 1;
      if (IsCloseParen(pattern2, index2))
        count -= 1;
      if (count === 0 && index2 !== pattern2.length - 1)
        return false;
    }
    return true;
  }
  function InGroup(pattern2) {
    return pattern2.slice(1, pattern2.length - 1);
  }
  function IsPrecedenceOr(pattern2) {
    let count = 0;
    for (let index2 = 0; index2 < pattern2.length; index2++) {
      if (IsOpenParen(pattern2, index2))
        count += 1;
      if (IsCloseParen(pattern2, index2))
        count -= 1;
      if (IsSeparator(pattern2, index2) && count === 0)
        return true;
    }
    return false;
  }
  function IsPrecedenceAnd(pattern2) {
    for (let index2 = 0; index2 < pattern2.length; index2++) {
      if (IsOpenParen(pattern2, index2))
        return true;
    }
    return false;
  }
  function Or(pattern2) {
    let [count, start] = [0, 0];
    const expressions = [];
    for (let index2 = 0; index2 < pattern2.length; index2++) {
      if (IsOpenParen(pattern2, index2))
        count += 1;
      if (IsCloseParen(pattern2, index2))
        count -= 1;
      if (IsSeparator(pattern2, index2) && count === 0) {
        const range2 = pattern2.slice(start, index2);
        if (range2.length > 0)
          expressions.push(TemplateLiteralParse(range2));
        start = index2 + 1;
      }
    }
    const range = pattern2.slice(start);
    if (range.length > 0)
      expressions.push(TemplateLiteralParse(range));
    if (expressions.length === 0)
      return { type: "const", const: "" };
    if (expressions.length === 1)
      return expressions[0];
    return { type: "or", expr: expressions };
  }
  function And(pattern2) {
    function Group(value2, index2) {
      if (!IsOpenParen(value2, index2))
        throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
      let count = 0;
      for (let scan = index2; scan < value2.length; scan++) {
        if (IsOpenParen(value2, scan))
          count += 1;
        if (IsCloseParen(value2, scan))
          count -= 1;
        if (count === 0)
          return [index2, scan];
      }
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
    }
    function Range(pattern3, index2) {
      for (let scan = index2; scan < pattern3.length; scan++) {
        if (IsOpenParen(pattern3, scan))
          return [index2, scan];
      }
      return [index2, pattern3.length];
    }
    const expressions = [];
    for (let index2 = 0; index2 < pattern2.length; index2++) {
      if (IsOpenParen(pattern2, index2)) {
        const [start, end] = Group(pattern2, index2);
        const range = pattern2.slice(start, end + 1);
        expressions.push(TemplateLiteralParse(range));
        index2 = end;
      } else {
        const [start, end] = Range(pattern2, index2);
        const range = pattern2.slice(start, end);
        if (range.length > 0)
          expressions.push(TemplateLiteralParse(range));
        index2 = end - 1;
      }
    }
    return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
  }
  function TemplateLiteralParse(pattern2) {
    return IsGroup(pattern2) ? TemplateLiteralParse(InGroup(pattern2)) : IsPrecedenceOr(pattern2) ? Or(pattern2) : IsPrecedenceAnd(pattern2) ? And(pattern2) : { type: "const", const: Unescape(pattern2) };
  }
  function TemplateLiteralParseExact(pattern2) {
    return TemplateLiteralParse(pattern2.slice(1, pattern2.length - 1));
  }
  return parse;
}
var hasRequiredFinite;
function requireFinite() {
  if (hasRequiredFinite) return finite;
  hasRequiredFinite = 1;
  Object.defineProperty(finite, "__esModule", { value: true });
  finite.TemplateLiteralFiniteError = void 0;
  finite.IsTemplateLiteralExpressionFinite = IsTemplateLiteralExpressionFinite;
  finite.IsTemplateLiteralFinite = IsTemplateLiteralFinite;
  const parse_1 = requireParse();
  const index_1 = requireError();
  class TemplateLiteralFiniteError extends index_1.TypeBoxError {
  }
  finite.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
  function IsNumberExpression(expression) {
    return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
  }
  function IsBooleanExpression(expression) {
    return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
  }
  function IsStringExpression(expression) {
    return expression.type === "const" && expression.const === ".*";
  }
  function IsTemplateLiteralExpressionFinite(expression) {
    return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
      throw new TemplateLiteralFiniteError(`Unknown expression type`);
    })();
  }
  function IsTemplateLiteralFinite(schema2) {
    const expression = (0, parse_1.TemplateLiteralParseExact)(schema2.pattern);
    return IsTemplateLiteralExpressionFinite(expression);
  }
  return finite;
}
var generate = {};
var hasRequiredGenerate;
function requireGenerate() {
  if (hasRequiredGenerate) return generate;
  hasRequiredGenerate = 1;
  Object.defineProperty(generate, "__esModule", { value: true });
  generate.TemplateLiteralGenerateError = void 0;
  generate.TemplateLiteralExpressionGenerate = TemplateLiteralExpressionGenerate;
  generate.TemplateLiteralGenerate = TemplateLiteralGenerate;
  const finite_1 = requireFinite();
  const parse_1 = requireParse();
  const index_1 = requireError();
  class TemplateLiteralGenerateError extends index_1.TypeBoxError {
  }
  generate.TemplateLiteralGenerateError = TemplateLiteralGenerateError;
  function* GenerateReduce(buffer2) {
    if (buffer2.length === 1)
      return yield* buffer2[0];
    for (const left of buffer2[0]) {
      for (const right of GenerateReduce(buffer2.slice(1))) {
        yield `${left}${right}`;
      }
    }
  }
  function* GenerateAnd(expression) {
    return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
  }
  function* GenerateOr(expression) {
    for (const expr of expression.expr)
      yield* TemplateLiteralExpressionGenerate(expr);
  }
  function* GenerateConst(expression) {
    return yield expression.const;
  }
  function* TemplateLiteralExpressionGenerate(expression) {
    return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
      throw new TemplateLiteralGenerateError("Unknown expression");
    })();
  }
  function TemplateLiteralGenerate(schema2) {
    const expression = (0, parse_1.TemplateLiteralParseExact)(schema2.pattern);
    return (0, finite_1.IsTemplateLiteralExpressionFinite)(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
  }
  return generate;
}
var syntax = {};
var literal$1 = {};
var literal = {};
var hasRequiredLiteral$1;
function requireLiteral$1() {
  if (hasRequiredLiteral$1) return literal;
  hasRequiredLiteral$1 = 1;
  Object.defineProperty(literal, "__esModule", { value: true });
  literal.Literal = Literal;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Literal(value2, options) {
    return (0, type_1.CreateType)({
      [index_1.Kind]: "Literal",
      const: value2,
      type: typeof value2
    }, options);
  }
  return literal;
}
var hasRequiredLiteral;
function requireLiteral() {
  if (hasRequiredLiteral) return literal$1;
  hasRequiredLiteral = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireLiteral$1(), exports$12);
  })(literal$1);
  return literal$1;
}
var boolean$1 = {};
var boolean = {};
var hasRequiredBoolean$1;
function requireBoolean$1() {
  if (hasRequiredBoolean$1) return boolean;
  hasRequiredBoolean$1 = 1;
  Object.defineProperty(boolean, "__esModule", { value: true });
  boolean.Boolean = Boolean2;
  const index_1 = requireSymbols();
  const index_2 = requireCreate();
  function Boolean2(options) {
    return (0, index_2.CreateType)({ [index_1.Kind]: "Boolean", type: "boolean" }, options);
  }
  return boolean;
}
var hasRequiredBoolean;
function requireBoolean() {
  if (hasRequiredBoolean) return boolean$1;
  hasRequiredBoolean = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireBoolean$1(), exports$12);
  })(boolean$1);
  return boolean$1;
}
var bigint$1 = {};
var bigint = {};
var hasRequiredBigint$1;
function requireBigint$1() {
  if (hasRequiredBigint$1) return bigint;
  hasRequiredBigint$1 = 1;
  Object.defineProperty(bigint, "__esModule", { value: true });
  bigint.BigInt = BigInt2;
  const index_1 = requireSymbols();
  const index_2 = requireCreate();
  function BigInt2(options) {
    return (0, index_2.CreateType)({ [index_1.Kind]: "BigInt", type: "bigint" }, options);
  }
  return bigint;
}
var hasRequiredBigint;
function requireBigint() {
  if (hasRequiredBigint) return bigint$1;
  hasRequiredBigint = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireBigint$1(), exports$12);
  })(bigint$1);
  return bigint$1;
}
var number$1 = {};
var number = {};
var hasRequiredNumber$1;
function requireNumber$1() {
  if (hasRequiredNumber$1) return number;
  hasRequiredNumber$1 = 1;
  Object.defineProperty(number, "__esModule", { value: true });
  number.Number = Number2;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Number2(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Number", type: "number" }, options);
  }
  return number;
}
var hasRequiredNumber;
function requireNumber() {
  if (hasRequiredNumber) return number$1;
  hasRequiredNumber = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireNumber$1(), exports$12);
  })(number$1);
  return number$1;
}
var string$1 = {};
var string = {};
var hasRequiredString$1;
function requireString$1() {
  if (hasRequiredString$1) return string;
  hasRequiredString$1 = 1;
  Object.defineProperty(string, "__esModule", { value: true });
  string.String = String2;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function String2(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "String", type: "string" }, options);
  }
  return string;
}
var hasRequiredString;
function requireString() {
  if (hasRequiredString) return string$1;
  hasRequiredString = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireString$1(), exports$12);
  })(string$1);
  return string$1;
}
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  Object.defineProperty(syntax, "__esModule", { value: true });
  syntax.TemplateLiteralSyntax = TemplateLiteralSyntax;
  const index_1 = requireLiteral();
  const index_2 = requireBoolean();
  const index_3 = requireBigint();
  const index_4 = requireNumber();
  const index_5 = requireString();
  const index_6 = requireUnion$1();
  const index_7 = requireNever();
  function* FromUnion(syntax2) {
    const trim = syntax2.trim().replace(/"|'/g, "");
    return trim === "boolean" ? yield (0, index_2.Boolean)() : trim === "number" ? yield (0, index_4.Number)() : trim === "bigint" ? yield (0, index_3.BigInt)() : trim === "string" ? yield (0, index_5.String)() : yield (() => {
      const literals = trim.split("|").map((literal2) => (0, index_1.Literal)(literal2.trim()));
      return literals.length === 0 ? (0, index_7.Never)() : literals.length === 1 ? literals[0] : (0, index_6.UnionEvaluated)(literals);
    })();
  }
  function* FromTerminal(syntax2) {
    if (syntax2[1] !== "{") {
      const L = (0, index_1.Literal)("$");
      const R = FromSyntax(syntax2.slice(1));
      return yield* [L, ...R];
    }
    for (let i = 2; i < syntax2.length; i++) {
      if (syntax2[i] === "}") {
        const L = FromUnion(syntax2.slice(2, i));
        const R = FromSyntax(syntax2.slice(i + 1));
        return yield* [...L, ...R];
      }
    }
    yield (0, index_1.Literal)(syntax2);
  }
  function* FromSyntax(syntax2) {
    for (let i = 0; i < syntax2.length; i++) {
      if (syntax2[i] === "$") {
        const L = (0, index_1.Literal)(syntax2.slice(0, i));
        const R = FromTerminal(syntax2.slice(i));
        return yield* [L, ...R];
      }
    }
    yield (0, index_1.Literal)(syntax2);
  }
  function TemplateLiteralSyntax(syntax2) {
    return [...FromSyntax(syntax2)];
  }
  return syntax;
}
var pattern = {};
var hasRequiredPattern;
function requirePattern() {
  if (hasRequiredPattern) return pattern;
  hasRequiredPattern = 1;
  Object.defineProperty(pattern, "__esModule", { value: true });
  pattern.TemplateLiteralPatternError = void 0;
  pattern.TemplateLiteralPattern = TemplateLiteralPattern;
  const index_1 = requirePatterns();
  const index_2 = requireSymbols();
  const index_3 = requireError();
  const kind_1 = requireKind();
  class TemplateLiteralPatternError extends index_3.TypeBoxError {
  }
  pattern.TemplateLiteralPatternError = TemplateLiteralPatternError;
  function Escape(value2) {
    return value2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function Visit(schema2, acc) {
    return (0, kind_1.IsTemplateLiteral)(schema2) ? schema2.pattern.slice(1, schema2.pattern.length - 1) : (0, kind_1.IsUnion)(schema2) ? `(${schema2.anyOf.map((schema3) => Visit(schema3, acc)).join("|")})` : (0, kind_1.IsNumber)(schema2) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsInteger)(schema2) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsBigInt)(schema2) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsString)(schema2) ? `${acc}${index_1.PatternString}` : (0, kind_1.IsLiteral)(schema2) ? `${acc}${Escape(schema2.const.toString())}` : (0, kind_1.IsBoolean)(schema2) ? `${acc}${index_1.PatternBoolean}` : (() => {
      throw new TemplateLiteralPatternError(`Unexpected Kind '${schema2[index_2.Kind]}'`);
    })();
  }
  function TemplateLiteralPattern(kinds) {
    return `^${kinds.map((schema2) => Visit(schema2, "")).join("")}$`;
  }
  return pattern;
}
var union = {};
var hasRequiredUnion;
function requireUnion() {
  if (hasRequiredUnion) return union;
  hasRequiredUnion = 1;
  Object.defineProperty(union, "__esModule", { value: true });
  union.TemplateLiteralToUnion = TemplateLiteralToUnion;
  const index_1 = requireUnion$1();
  const index_2 = requireLiteral();
  const generate_1 = requireGenerate();
  function TemplateLiteralToUnion(schema2) {
    const R = (0, generate_1.TemplateLiteralGenerate)(schema2);
    const L = R.map((S) => (0, index_2.Literal)(S));
    return (0, index_1.UnionEvaluated)(L);
  }
  return union;
}
var templateLiteral = {};
var hasRequiredTemplateLiteral$1;
function requireTemplateLiteral$1() {
  if (hasRequiredTemplateLiteral$1) return templateLiteral;
  hasRequiredTemplateLiteral$1 = 1;
  Object.defineProperty(templateLiteral, "__esModule", { value: true });
  templateLiteral.TemplateLiteral = TemplateLiteral;
  const type_1 = requireType$5();
  const syntax_1 = requireSyntax();
  const pattern_1 = requirePattern();
  const value_1 = requireValue$1();
  const index_1 = requireSymbols();
  function TemplateLiteral(unresolved, options) {
    const pattern2 = (0, value_1.IsString)(unresolved) ? (0, pattern_1.TemplateLiteralPattern)((0, syntax_1.TemplateLiteralSyntax)(unresolved)) : (0, pattern_1.TemplateLiteralPattern)(unresolved);
    return (0, type_1.CreateType)({ [index_1.Kind]: "TemplateLiteral", type: "string", pattern: pattern2 }, options);
  }
  return templateLiteral;
}
var hasRequiredTemplateLiteral;
function requireTemplateLiteral() {
  if (hasRequiredTemplateLiteral) return templateLiteral$1;
  hasRequiredTemplateLiteral = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireFinite(), exports$12);
    __exportStar(requireGenerate(), exports$12);
    __exportStar(requireSyntax(), exports$12);
    __exportStar(requireParse(), exports$12);
    __exportStar(requirePattern(), exports$12);
    __exportStar(requireUnion(), exports$12);
    __exportStar(requireTemplateLiteral$1(), exports$12);
  })(templateLiteral$1);
  return templateLiteral$1;
}
var hasRequiredIndexedPropertyKeys;
function requireIndexedPropertyKeys() {
  if (hasRequiredIndexedPropertyKeys) return indexedPropertyKeys;
  hasRequiredIndexedPropertyKeys = 1;
  Object.defineProperty(indexedPropertyKeys, "__esModule", { value: true });
  indexedPropertyKeys.IndexPropertyKeys = IndexPropertyKeys;
  const index_1 = requireTemplateLiteral();
  const kind_1 = requireKind();
  function FromTemplateLiteral(T) {
    const R = (0, index_1.TemplateLiteralGenerate)(T);
    return R.map((S) => S.toString());
  }
  function FromUnion(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(...IndexPropertyKeys(L));
    return Acc;
  }
  function FromLiteral(T) {
    return [T.toString()];
  }
  function IndexPropertyKeys(T) {
    return [...new Set((0, kind_1.IsTemplateLiteral)(T) ? FromTemplateLiteral(T) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf) : (0, kind_1.IsLiteral)(T) ? FromLiteral(T.const) : (0, kind_1.IsNumber)(T) ? ["[number]"] : (0, kind_1.IsInteger)(T) ? ["[number]"] : [])];
  }
  return indexedPropertyKeys;
}
var indexedFromMappedResult = {};
var hasRequiredIndexedFromMappedResult;
function requireIndexedFromMappedResult() {
  if (hasRequiredIndexedFromMappedResult) return indexedFromMappedResult;
  hasRequiredIndexedFromMappedResult = 1;
  Object.defineProperty(indexedFromMappedResult, "__esModule", { value: true });
  indexedFromMappedResult.IndexFromMappedResult = IndexFromMappedResult;
  const index_1 = requireMapped();
  const indexed_property_keys_1 = requireIndexedPropertyKeys();
  const index_2 = requireIndexed();
  function FromProperties(T, P, options) {
    const Acc = {};
    for (const K2 of Object.getOwnPropertyNames(P)) {
      Acc[K2] = (0, index_2.Index)(T, (0, indexed_property_keys_1.IndexPropertyKeys)(P[K2]), options);
    }
    return Acc;
  }
  function FromMappedResult(T, R, options) {
    return FromProperties(T, R.properties, options);
  }
  function IndexFromMappedResult(T, R, options) {
    const P = FromMappedResult(T, R, options);
    return (0, index_1.MappedResult)(P);
  }
  return indexedFromMappedResult;
}
var hasRequiredIndexed$1;
function requireIndexed$1() {
  if (hasRequiredIndexed$1) return indexed;
  hasRequiredIndexed$1 = 1;
  Object.defineProperty(indexed, "__esModule", { value: true });
  indexed.IndexFromPropertyKey = IndexFromPropertyKey;
  indexed.IndexFromPropertyKeys = IndexFromPropertyKeys;
  indexed.Index = Index;
  const type_1 = requireType$5();
  const index_1 = requireNever();
  const index_2 = requireIntersect();
  const index_3 = requireUnion$1();
  const indexed_property_keys_1 = requireIndexedPropertyKeys();
  const indexed_from_mapped_key_1 = requireIndexedFromMappedKey();
  const indexed_from_mapped_result_1 = requireIndexedFromMappedResult();
  const kind_1 = requireKind();
  function FromRest(T, K) {
    return T.map((L) => IndexFromPropertyKey(L, K));
  }
  function FromIntersectRest(T) {
    return T.filter((L) => !(0, kind_1.IsNever)(L));
  }
  function FromIntersect(T, K) {
    return (0, index_2.IntersectEvaluated)(FromIntersectRest(FromRest(T, K)));
  }
  function FromUnionRest(T) {
    return T.some((L) => (0, kind_1.IsNever)(L)) ? [] : T;
  }
  function FromUnion(T, K) {
    return (0, index_3.UnionEvaluated)(FromUnionRest(FromRest(T, K)));
  }
  function FromTuple(T, K) {
    return K in T ? T[K] : K === "[number]" ? (0, index_3.UnionEvaluated)(T) : (0, index_1.Never)();
  }
  function FromArray(T, K) {
    return K === "[number]" ? T : (0, index_1.Never)();
  }
  function FromProperty(T, K) {
    return K in T ? T[K] : (0, index_1.Never)();
  }
  function IndexFromPropertyKey(T, K) {
    return (0, kind_1.IsIntersect)(T) ? FromIntersect(T.allOf, K) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf, K) : (0, kind_1.IsTuple)(T) ? FromTuple(T.items ?? [], K) : (0, kind_1.IsArray)(T) ? FromArray(T.items, K) : (0, kind_1.IsObject)(T) ? FromProperty(T.properties, K) : (0, index_1.Never)();
  }
  function IndexFromPropertyKeys(T, K) {
    return K.map((L) => IndexFromPropertyKey(T, L));
  }
  function FromSchema(T, K) {
    return (0, index_3.UnionEvaluated)(IndexFromPropertyKeys(T, K));
  }
  function Index(T, K, options) {
    if ((0, kind_1.IsMappedResult)(K))
      return (0, indexed_from_mapped_result_1.IndexFromMappedResult)(T, K, options);
    if ((0, kind_1.IsMappedKey)(K))
      return (0, indexed_from_mapped_key_1.IndexFromMappedKey)(T, K, options);
    return (0, type_1.CreateType)((0, kind_1.IsSchema)(K) ? FromSchema(T, (0, indexed_property_keys_1.IndexPropertyKeys)(K)) : FromSchema(T, K), options);
  }
  return indexed;
}
var hasRequiredIndexedFromMappedKey;
function requireIndexedFromMappedKey() {
  if (hasRequiredIndexedFromMappedKey) return indexedFromMappedKey;
  hasRequiredIndexedFromMappedKey = 1;
  Object.defineProperty(indexedFromMappedKey, "__esModule", { value: true });
  indexedFromMappedKey.IndexFromMappedKey = IndexFromMappedKey;
  const indexed_1 = requireIndexed$1();
  const index_1 = requireMapped();
  const value_1 = requireValue();
  function MappedIndexPropertyKey(T, K, options) {
    return { [K]: (0, indexed_1.Index)(T, [K], (0, value_1.Clone)(options)) };
  }
  function MappedIndexPropertyKeys(T, K, options) {
    return K.reduce((Acc, L) => {
      return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
    }, {});
  }
  function MappedIndexProperties(T, K, options) {
    return MappedIndexPropertyKeys(T, K.keys, options);
  }
  function IndexFromMappedKey(T, K, options) {
    const P = MappedIndexProperties(T, K, options);
    return (0, index_1.MappedResult)(P);
  }
  return indexedFromMappedKey;
}
var hasRequiredIndexed;
function requireIndexed() {
  if (hasRequiredIndexed) return indexed$1;
  hasRequiredIndexed = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireIndexedFromMappedKey(), exports$12);
    __exportStar(requireIndexedFromMappedResult(), exports$12);
    __exportStar(requireIndexedPropertyKeys(), exports$12);
    __exportStar(requireIndexed$1(), exports$12);
  })(indexed$1);
  return indexed$1;
}
var iterator$1 = {};
var iterator = {};
var hasRequiredIterator$1;
function requireIterator$1() {
  if (hasRequiredIterator$1) return iterator;
  hasRequiredIterator$1 = 1;
  Object.defineProperty(iterator, "__esModule", { value: true });
  iterator.Iterator = Iterator;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Iterator(items, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Iterator", type: "Iterator", items }, options);
  }
  return iterator;
}
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator) return iterator$1;
  hasRequiredIterator = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireIterator$1(), exports$12);
  })(iterator$1);
  return iterator$1;
}
var object$2 = {};
var object$1 = {};
var hasRequiredObject$2;
function requireObject$2() {
  if (hasRequiredObject$2) return object$1;
  hasRequiredObject$2 = 1;
  Object.defineProperty(object$1, "__esModule", { value: true });
  object$1.Object = void 0;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  const kind_1 = requireKind();
  function RequiredKeys(properties) {
    const keys = [];
    for (let key in properties) {
      if (!(0, kind_1.IsOptional)(properties[key]))
        keys.push(key);
    }
    return keys;
  }
  function _Object(properties, options) {
    const required2 = RequiredKeys(properties);
    const schematic = required2.length > 0 ? { [index_1.Kind]: "Object", type: "object", properties, required: required2 } : { [index_1.Kind]: "Object", type: "object", properties };
    return (0, type_1.CreateType)(schematic, options);
  }
  object$1.Object = _Object;
  return object$1;
}
var hasRequiredObject$1;
function requireObject$1() {
  if (hasRequiredObject$1) return object$2;
  hasRequiredObject$1 = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireObject$2(), exports$12);
  })(object$2);
  return object$2;
}
var promise$1 = {};
var promise = {};
var hasRequiredPromise$1;
function requirePromise$1() {
  if (hasRequiredPromise$1) return promise;
  hasRequiredPromise$1 = 1;
  Object.defineProperty(promise, "__esModule", { value: true });
  promise.Promise = Promise2;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Promise2(item, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Promise", type: "Promise", item }, options);
  }
  return promise;
}
var hasRequiredPromise;
function requirePromise() {
  if (hasRequiredPromise) return promise$1;
  hasRequiredPromise = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requirePromise$1(), exports$12);
  })(promise$1);
  return promise$1;
}
var readonly$1 = {};
var readonlyFromMappedResult = {};
var readonly = {};
var hasRequiredReadonly$1;
function requireReadonly$1() {
  if (hasRequiredReadonly$1) return readonly;
  hasRequiredReadonly$1 = 1;
  Object.defineProperty(readonly, "__esModule", { value: true });
  readonly.Readonly = Readonly;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  const index_2 = requireDiscard();
  const readonly_from_mapped_result_1 = requireReadonlyFromMappedResult();
  const kind_1 = requireKind();
  function RemoveReadonly(schema2) {
    return (0, type_1.CreateType)((0, index_2.Discard)(schema2, [index_1.ReadonlyKind]));
  }
  function AddReadonly(schema2) {
    return (0, type_1.CreateType)({ ...schema2, [index_1.ReadonlyKind]: "Readonly" });
  }
  function ReadonlyWithFlag(schema2, F) {
    return F === false ? RemoveReadonly(schema2) : AddReadonly(schema2);
  }
  function Readonly(schema2, enable) {
    const F = enable ?? true;
    return (0, kind_1.IsMappedResult)(schema2) ? (0, readonly_from_mapped_result_1.ReadonlyFromMappedResult)(schema2, F) : ReadonlyWithFlag(schema2, F);
  }
  return readonly;
}
var hasRequiredReadonlyFromMappedResult;
function requireReadonlyFromMappedResult() {
  if (hasRequiredReadonlyFromMappedResult) return readonlyFromMappedResult;
  hasRequiredReadonlyFromMappedResult = 1;
  Object.defineProperty(readonlyFromMappedResult, "__esModule", { value: true });
  readonlyFromMappedResult.ReadonlyFromMappedResult = ReadonlyFromMappedResult;
  const index_1 = requireMapped();
  const readonly_1 = requireReadonly$1();
  function FromProperties(K, F) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
      Acc[K2] = (0, readonly_1.Readonly)(K[K2], F);
    return Acc;
  }
  function FromMappedResult(R, F) {
    return FromProperties(R.properties, F);
  }
  function ReadonlyFromMappedResult(R, F) {
    const P = FromMappedResult(R, F);
    return (0, index_1.MappedResult)(P);
  }
  return readonlyFromMappedResult;
}
var hasRequiredReadonly;
function requireReadonly() {
  if (hasRequiredReadonly) return readonly$1;
  hasRequiredReadonly = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireReadonlyFromMappedResult(), exports$12);
    __exportStar(requireReadonly$1(), exports$12);
  })(readonly$1);
  return readonly$1;
}
var tuple$1 = {};
var tuple = {};
var hasRequiredTuple$1;
function requireTuple$1() {
  if (hasRequiredTuple$1) return tuple;
  hasRequiredTuple$1 = 1;
  Object.defineProperty(tuple, "__esModule", { value: true });
  tuple.Tuple = Tuple;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Tuple(items, options) {
    return (0, type_1.CreateType)(items.length > 0 ? { [index_1.Kind]: "Tuple", type: "array", items, additionalItems: false, minItems: items.length, maxItems: items.length } : { [index_1.Kind]: "Tuple", type: "array", minItems: items.length, maxItems: items.length }, options);
  }
  return tuple;
}
var hasRequiredTuple;
function requireTuple() {
  if (hasRequiredTuple) return tuple$1;
  hasRequiredTuple = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireTuple$1(), exports$12);
  })(tuple$1);
  return tuple$1;
}
var hasRequiredMapped$1;
function requireMapped$1() {
  if (hasRequiredMapped$1) return mapped;
  hasRequiredMapped$1 = 1;
  Object.defineProperty(mapped, "__esModule", { value: true });
  mapped.MappedFunctionReturnType = MappedFunctionReturnType;
  mapped.Mapped = Mapped;
  const index_1 = requireSymbols();
  const index_2 = requireDiscard();
  const index_3 = requireArray();
  const index_4 = requireAsyncIterator();
  const index_5 = requireConstructor();
  const index_6 = require_function$1();
  const index_7 = requireIndexed();
  const index_8 = requireIntersect();
  const index_9 = requireIterator();
  const index_10 = requireLiteral();
  const index_11 = requireObject$1();
  const index_12 = requireOptional();
  const index_13 = requirePromise();
  const index_14 = requireReadonly();
  const index_15 = requireTuple();
  const index_16 = requireUnion$1();
  const index_17 = requireSets();
  const mapped_result_1 = requireMappedResult();
  const kind_1 = requireKind();
  function FromMappedResult(K, P) {
    return K in P ? FromSchemaType(K, P[K]) : (0, mapped_result_1.MappedResult)(P);
  }
  function MappedKeyToKnownMappedResultProperties(K) {
    return { [K]: (0, index_10.Literal)(K) };
  }
  function MappedKeyToUnknownMappedResultProperties(P) {
    const Acc = {};
    for (const L of P)
      Acc[L] = (0, index_10.Literal)(L);
    return Acc;
  }
  function MappedKeyToMappedResultProperties(K, P) {
    return (0, index_17.SetIncludes)(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
  }
  function FromMappedKey(K, P) {
    const R = MappedKeyToMappedResultProperties(K, P);
    return FromMappedResult(K, R);
  }
  function FromRest(K, T) {
    return T.map((L) => FromSchemaType(K, L));
  }
  function FromProperties(K, T) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(T))
      Acc[K2] = FromSchemaType(K, T[K2]);
    return Acc;
  }
  function FromSchemaType(K, T) {
    const options = { ...T };
    return (
      // unevaluated modifier types
      (0, kind_1.IsOptional)(T) ? (0, index_12.Optional)(FromSchemaType(K, (0, index_2.Discard)(T, [index_1.OptionalKind]))) : (0, kind_1.IsReadonly)(T) ? (0, index_14.Readonly)(FromSchemaType(K, (0, index_2.Discard)(T, [index_1.ReadonlyKind]))) : (
        // unevaluated mapped types
        (0, kind_1.IsMappedResult)(T) ? FromMappedResult(K, T.properties) : (0, kind_1.IsMappedKey)(T) ? FromMappedKey(K, T.keys) : (
          // unevaluated types
          (0, kind_1.IsConstructor)(T) ? (0, index_5.Constructor)(FromRest(K, T.parameters), FromSchemaType(K, T.returns), options) : (0, kind_1.IsFunction)(T) ? (0, index_6.Function)(FromRest(K, T.parameters), FromSchemaType(K, T.returns), options) : (0, kind_1.IsAsyncIterator)(T) ? (0, index_4.AsyncIterator)(FromSchemaType(K, T.items), options) : (0, kind_1.IsIterator)(T) ? (0, index_9.Iterator)(FromSchemaType(K, T.items), options) : (0, kind_1.IsIntersect)(T) ? (0, index_8.Intersect)(FromRest(K, T.allOf), options) : (0, kind_1.IsUnion)(T) ? (0, index_16.Union)(FromRest(K, T.anyOf), options) : (0, kind_1.IsTuple)(T) ? (0, index_15.Tuple)(FromRest(K, T.items ?? []), options) : (0, kind_1.IsObject)(T) ? (0, index_11.Object)(FromProperties(K, T.properties), options) : (0, kind_1.IsArray)(T) ? (0, index_3.Array)(FromSchemaType(K, T.items), options) : (0, kind_1.IsPromise)(T) ? (0, index_13.Promise)(FromSchemaType(K, T.item), options) : T
        )
      )
    );
  }
  function MappedFunctionReturnType(K, T) {
    const Acc = {};
    for (const L of K)
      Acc[L] = FromSchemaType(L, T);
    return Acc;
  }
  function Mapped(key, map, options) {
    const K = (0, kind_1.IsSchema)(key) ? (0, index_7.IndexPropertyKeys)(key) : key;
    const RT = map({ [index_1.Kind]: "MappedKey", keys: K });
    const R = MappedFunctionReturnType(K, RT);
    return (0, index_11.Object)(R, options);
  }
  return mapped;
}
var hasRequiredMapped;
function requireMapped() {
  if (hasRequiredMapped) return mapped$1;
  hasRequiredMapped = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireMappedKey(), exports$12);
    __exportStar(requireMappedResult(), exports$12);
    __exportStar(requireMapped$1(), exports$12);
  })(mapped$1);
  return mapped$1;
}
var optional = {};
var hasRequiredOptional$1;
function requireOptional$1() {
  if (hasRequiredOptional$1) return optional;
  hasRequiredOptional$1 = 1;
  Object.defineProperty(optional, "__esModule", { value: true });
  optional.Optional = Optional;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  const index_2 = requireDiscard();
  const optional_from_mapped_result_1 = requireOptionalFromMappedResult();
  const kind_1 = requireKind();
  function RemoveOptional(schema2) {
    return (0, type_1.CreateType)((0, index_2.Discard)(schema2, [index_1.OptionalKind]));
  }
  function AddOptional(schema2) {
    return (0, type_1.CreateType)({ ...schema2, [index_1.OptionalKind]: "Optional" });
  }
  function OptionalWithFlag(schema2, F) {
    return F === false ? RemoveOptional(schema2) : AddOptional(schema2);
  }
  function Optional(schema2, enable) {
    const F = enable ?? true;
    return (0, kind_1.IsMappedResult)(schema2) ? (0, optional_from_mapped_result_1.OptionalFromMappedResult)(schema2, F) : OptionalWithFlag(schema2, F);
  }
  return optional;
}
var hasRequiredOptionalFromMappedResult;
function requireOptionalFromMappedResult() {
  if (hasRequiredOptionalFromMappedResult) return optionalFromMappedResult;
  hasRequiredOptionalFromMappedResult = 1;
  Object.defineProperty(optionalFromMappedResult, "__esModule", { value: true });
  optionalFromMappedResult.OptionalFromMappedResult = OptionalFromMappedResult;
  const index_1 = requireMapped();
  const optional_1 = requireOptional$1();
  function FromProperties(P, F) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, optional_1.Optional)(P[K2], F);
    return Acc;
  }
  function FromMappedResult(R, F) {
    return FromProperties(R.properties, F);
  }
  function OptionalFromMappedResult(R, F) {
    const P = FromMappedResult(R, F);
    return (0, index_1.MappedResult)(P);
  }
  return optionalFromMappedResult;
}
var hasRequiredOptional;
function requireOptional() {
  if (hasRequiredOptional) return optional$1;
  hasRequiredOptional = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireOptionalFromMappedResult(), exports$12);
    __exportStar(requireOptional$1(), exports$12);
  })(optional$1);
  return optional$1;
}
var intersectCreate = {};
var hasRequiredIntersectCreate;
function requireIntersectCreate() {
  if (hasRequiredIntersectCreate) return intersectCreate;
  hasRequiredIntersectCreate = 1;
  Object.defineProperty(intersectCreate, "__esModule", { value: true });
  intersectCreate.IntersectCreate = IntersectCreate;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  const kind_1 = requireKind();
  function IntersectCreate(T, options = {}) {
    const allObjects = T.every((schema2) => (0, kind_1.IsObject)(schema2));
    const clonedUnevaluatedProperties = (0, kind_1.IsSchema)(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
    return (0, type_1.CreateType)(options.unevaluatedProperties === false || (0, kind_1.IsSchema)(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [index_1.Kind]: "Intersect", type: "object", allOf: T } : { ...clonedUnevaluatedProperties, [index_1.Kind]: "Intersect", allOf: T }, options);
  }
  return intersectCreate;
}
var hasRequiredIntersectEvaluated;
function requireIntersectEvaluated() {
  if (hasRequiredIntersectEvaluated) return intersectEvaluated;
  hasRequiredIntersectEvaluated = 1;
  Object.defineProperty(intersectEvaluated, "__esModule", { value: true });
  intersectEvaluated.IntersectEvaluated = IntersectEvaluated;
  const index_1 = requireSymbols();
  const type_1 = requireType$5();
  const index_2 = requireDiscard();
  const index_3 = requireNever();
  const index_4 = requireOptional();
  const intersect_create_1 = requireIntersectCreate();
  const kind_1 = requireKind();
  function IsIntersectOptional(T) {
    return T.every((L) => (0, kind_1.IsOptional)(L));
  }
  function RemoveOptionalFromType(T) {
    return (0, index_2.Discard)(T, [index_1.OptionalKind]);
  }
  function RemoveOptionalFromRest(T) {
    return T.map((L) => (0, kind_1.IsOptional)(L) ? RemoveOptionalFromType(L) : L);
  }
  function ResolveIntersect(T, options) {
    return IsIntersectOptional(T) ? (0, index_4.Optional)((0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest(T), options)) : (0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest(T), options);
  }
  function IntersectEvaluated(T, options = {}) {
    if (T.length === 0)
      return (0, index_3.Never)(options);
    if (T.length === 1)
      return (0, type_1.CreateType)(T[0], options);
    if (T.some((schema2) => (0, kind_1.IsTransform)(schema2)))
      throw new Error("Cannot intersect transform types");
    return ResolveIntersect(T, options);
  }
  return intersectEvaluated;
}
var intersectType = {};
var hasRequiredIntersectType;
function requireIntersectType() {
  if (hasRequiredIntersectType) return intersectType;
  hasRequiredIntersectType = 1;
  Object.defineProperty(intersectType, "__esModule", { value: true });
  requireSymbols();
  return intersectType;
}
var intersect = {};
var hasRequiredIntersect$1;
function requireIntersect$1() {
  if (hasRequiredIntersect$1) return intersect;
  hasRequiredIntersect$1 = 1;
  Object.defineProperty(intersect, "__esModule", { value: true });
  intersect.Intersect = Intersect;
  const type_1 = requireType$5();
  const index_1 = requireNever();
  const intersect_create_1 = requireIntersectCreate();
  const kind_1 = requireKind();
  function Intersect(T, options) {
    if (T.length === 0)
      return (0, index_1.Never)(options);
    if (T.length === 1)
      return (0, type_1.CreateType)(T[0], options);
    if (T.some((schema2) => (0, kind_1.IsTransform)(schema2)))
      throw new Error("Cannot intersect transform types");
    return (0, intersect_create_1.IntersectCreate)(T, options);
  }
  return intersect;
}
var hasRequiredIntersect;
function requireIntersect() {
  if (hasRequiredIntersect) return intersect$1;
  hasRequiredIntersect = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireIntersectEvaluated(), exports$12);
    __exportStar(requireIntersectType(), exports$12);
    __exportStar(requireIntersect$1(), exports$12);
  })(intersect$1);
  return intersect$1;
}
var hasRequiredAwaited$1;
function requireAwaited$1() {
  if (hasRequiredAwaited$1) return awaited;
  hasRequiredAwaited$1 = 1;
  Object.defineProperty(awaited, "__esModule", { value: true });
  awaited.Awaited = Awaited;
  const index_1 = requireIntersect();
  const index_2 = requireUnion$1();
  const type_1 = requireType$5();
  const kind_1 = requireKind();
  function FromRest(T) {
    return T.map((L) => AwaitedResolve(L));
  }
  function FromIntersect(T) {
    return (0, index_1.Intersect)(FromRest(T));
  }
  function FromUnion(T) {
    return (0, index_2.Union)(FromRest(T));
  }
  function FromPromise(T) {
    return AwaitedResolve(T);
  }
  function AwaitedResolve(T) {
    return (0, kind_1.IsIntersect)(T) ? FromIntersect(T.allOf) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf) : (0, kind_1.IsPromise)(T) ? FromPromise(T.item) : T;
  }
  function Awaited(T, options) {
    return (0, type_1.CreateType)(AwaitedResolve(T), options);
  }
  return awaited;
}
var hasRequiredAwaited;
function requireAwaited() {
  if (hasRequiredAwaited) return awaited$1;
  hasRequiredAwaited = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireAwaited$1(), exports$12);
  })(awaited$1);
  return awaited$1;
}
var composite$1 = {};
var composite = {};
var keyof$1 = {};
var keyofFromMappedResult = {};
var keyof = {};
var keyofPropertyKeys = {};
var hasRequiredKeyofPropertyKeys;
function requireKeyofPropertyKeys() {
  if (hasRequiredKeyofPropertyKeys) return keyofPropertyKeys;
  hasRequiredKeyofPropertyKeys = 1;
  Object.defineProperty(keyofPropertyKeys, "__esModule", { value: true });
  keyofPropertyKeys.KeyOfPropertyKeys = KeyOfPropertyKeys;
  keyofPropertyKeys.KeyOfPattern = KeyOfPattern;
  const index_1 = requireSets();
  const kind_1 = requireKind();
  function FromRest(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(KeyOfPropertyKeys(L));
    return Acc;
  }
  function FromIntersect(T) {
    const C = FromRest(T);
    const R = (0, index_1.SetUnionMany)(C);
    return R;
  }
  function FromUnion(T) {
    const C = FromRest(T);
    const R = (0, index_1.SetIntersectMany)(C);
    return R;
  }
  function FromTuple(T) {
    return T.map((_, I) => I.toString());
  }
  function FromArray(_) {
    return ["[number]"];
  }
  function FromProperties(T) {
    return globalThis.Object.getOwnPropertyNames(T);
  }
  function FromPatternProperties(patternProperties) {
    if (!includePatternProperties)
      return [];
    const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
    return patternPropertyKeys.map((key) => {
      return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
    });
  }
  function KeyOfPropertyKeys(T) {
    return (0, kind_1.IsIntersect)(T) ? FromIntersect(T.allOf) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf) : (0, kind_1.IsTuple)(T) ? FromTuple(T.items ?? []) : (0, kind_1.IsArray)(T) ? FromArray(T.items) : (0, kind_1.IsObject)(T) ? FromProperties(T.properties) : (0, kind_1.IsRecord)(T) ? FromPatternProperties(T.patternProperties) : [];
  }
  let includePatternProperties = false;
  function KeyOfPattern(schema2) {
    includePatternProperties = true;
    const keys = KeyOfPropertyKeys(schema2);
    includePatternProperties = false;
    const pattern2 = keys.map((key) => `(${key})`);
    return `^(${pattern2.join("|")})$`;
  }
  return keyofPropertyKeys;
}
var hasRequiredKeyof$1;
function requireKeyof$1() {
  if (hasRequiredKeyof$1) return keyof;
  hasRequiredKeyof$1 = 1;
  Object.defineProperty(keyof, "__esModule", { value: true });
  keyof.KeyOfPropertyKeysToRest = KeyOfPropertyKeysToRest;
  keyof.KeyOf = KeyOf;
  const type_1 = requireType$5();
  const index_1 = requireLiteral();
  const index_2 = requireNumber();
  const keyof_property_keys_1 = requireKeyofPropertyKeys();
  const index_3 = requireUnion$1();
  const keyof_from_mapped_result_1 = requireKeyofFromMappedResult();
  const kind_1 = requireKind();
  function KeyOfPropertyKeysToRest(T) {
    return T.map((L) => L === "[number]" ? (0, index_2.Number)() : (0, index_1.Literal)(L));
  }
  function KeyOf(T, options) {
    if ((0, kind_1.IsMappedResult)(T)) {
      return (0, keyof_from_mapped_result_1.KeyOfFromMappedResult)(T, options);
    } else {
      const K = (0, keyof_property_keys_1.KeyOfPropertyKeys)(T);
      const S = KeyOfPropertyKeysToRest(K);
      const U = (0, index_3.UnionEvaluated)(S);
      return (0, type_1.CreateType)(U, options);
    }
  }
  return keyof;
}
var hasRequiredKeyofFromMappedResult;
function requireKeyofFromMappedResult() {
  if (hasRequiredKeyofFromMappedResult) return keyofFromMappedResult;
  hasRequiredKeyofFromMappedResult = 1;
  Object.defineProperty(keyofFromMappedResult, "__esModule", { value: true });
  keyofFromMappedResult.KeyOfFromMappedResult = KeyOfFromMappedResult;
  const index_1 = requireMapped();
  const keyof_1 = requireKeyof$1();
  const value_1 = requireValue();
  function FromProperties(K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
      Acc[K2] = (0, keyof_1.KeyOf)(K[K2], (0, value_1.Clone)(options));
    return Acc;
  }
  function FromMappedResult(R, options) {
    return FromProperties(R.properties, options);
  }
  function KeyOfFromMappedResult(R, options) {
    const P = FromMappedResult(R, options);
    return (0, index_1.MappedResult)(P);
  }
  return keyofFromMappedResult;
}
var keyofPropertyEntries = {};
var hasRequiredKeyofPropertyEntries;
function requireKeyofPropertyEntries() {
  if (hasRequiredKeyofPropertyEntries) return keyofPropertyEntries;
  hasRequiredKeyofPropertyEntries = 1;
  Object.defineProperty(keyofPropertyEntries, "__esModule", { value: true });
  keyofPropertyEntries.KeyOfPropertyEntries = KeyOfPropertyEntries;
  const indexed_1 = requireIndexed$1();
  const keyof_property_keys_1 = requireKeyofPropertyKeys();
  function KeyOfPropertyEntries(schema2) {
    const keys = (0, keyof_property_keys_1.KeyOfPropertyKeys)(schema2);
    const schemas = (0, indexed_1.IndexFromPropertyKeys)(schema2, keys);
    return keys.map((_, index2) => [keys[index2], schemas[index2]]);
  }
  return keyofPropertyEntries;
}
var hasRequiredKeyof;
function requireKeyof() {
  if (hasRequiredKeyof) return keyof$1;
  hasRequiredKeyof = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireKeyofFromMappedResult(), exports$12);
    __exportStar(requireKeyofPropertyEntries(), exports$12);
    __exportStar(requireKeyofPropertyKeys(), exports$12);
    __exportStar(requireKeyof$1(), exports$12);
  })(keyof$1);
  return keyof$1;
}
var hasRequiredComposite$1;
function requireComposite$1() {
  if (hasRequiredComposite$1) return composite;
  hasRequiredComposite$1 = 1;
  Object.defineProperty(composite, "__esModule", { value: true });
  composite.Composite = Composite;
  const index_1 = requireIntersect();
  const index_2 = requireIndexed();
  const index_3 = requireKeyof();
  const index_4 = requireObject$1();
  const index_5 = requireSets();
  const kind_1 = requireKind();
  function CompositeKeys(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(...(0, index_3.KeyOfPropertyKeys)(L));
    return (0, index_5.SetDistinct)(Acc);
  }
  function FilterNever(T) {
    return T.filter((L) => !(0, kind_1.IsNever)(L));
  }
  function CompositeProperty(T, K) {
    const Acc = [];
    for (const L of T)
      Acc.push(...(0, index_2.IndexFromPropertyKeys)(L, [K]));
    return FilterNever(Acc);
  }
  function CompositeProperties(T, K) {
    const Acc = {};
    for (const L of K) {
      Acc[L] = (0, index_1.IntersectEvaluated)(CompositeProperty(T, L));
    }
    return Acc;
  }
  function Composite(T, options) {
    const K = CompositeKeys(T);
    const P = CompositeProperties(T, K);
    const R = (0, index_4.Object)(P, options);
    return R;
  }
  return composite;
}
var hasRequiredComposite;
function requireComposite() {
  if (hasRequiredComposite) return composite$1;
  hasRequiredComposite = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireComposite$1(), exports$12);
  })(composite$1);
  return composite$1;
}
var _const$1 = {};
var _const = {};
var date$1 = {};
var date = {};
var hasRequiredDate$1;
function requireDate$1() {
  if (hasRequiredDate$1) return date;
  hasRequiredDate$1 = 1;
  Object.defineProperty(date, "__esModule", { value: true });
  date.Date = Date2;
  const index_1 = requireSymbols();
  const type_1 = requireType$5();
  function Date2(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Date", type: "Date" }, options);
  }
  return date;
}
var hasRequiredDate;
function requireDate() {
  if (hasRequiredDate) return date$1;
  hasRequiredDate = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireDate$1(), exports$12);
  })(date$1);
  return date$1;
}
var _null$1 = {};
var _null = {};
var hasRequired_null$1;
function require_null$1() {
  if (hasRequired_null$1) return _null;
  hasRequired_null$1 = 1;
  Object.defineProperty(_null, "__esModule", { value: true });
  _null.Null = Null;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Null(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Null", type: "null" }, options);
  }
  return _null;
}
var hasRequired_null;
function require_null() {
  if (hasRequired_null) return _null$1;
  hasRequired_null = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(require_null$1(), exports$12);
  })(_null$1);
  return _null$1;
}
var symbol$1 = {};
var symbol = {};
var hasRequiredSymbol$1;
function requireSymbol$1() {
  if (hasRequiredSymbol$1) return symbol;
  hasRequiredSymbol$1 = 1;
  Object.defineProperty(symbol, "__esModule", { value: true });
  symbol.Symbol = Symbol2;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Symbol2(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Symbol", type: "symbol" }, options);
  }
  return symbol;
}
var hasRequiredSymbol;
function requireSymbol() {
  if (hasRequiredSymbol) return symbol$1;
  hasRequiredSymbol = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireSymbol$1(), exports$12);
  })(symbol$1);
  return symbol$1;
}
var _undefined$1 = {};
var _undefined = {};
var hasRequired_undefined$1;
function require_undefined$1() {
  if (hasRequired_undefined$1) return _undefined;
  hasRequired_undefined$1 = 1;
  Object.defineProperty(_undefined, "__esModule", { value: true });
  _undefined.Undefined = Undefined;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Undefined(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Undefined", type: "undefined" }, options);
  }
  return _undefined;
}
var hasRequired_undefined;
function require_undefined() {
  if (hasRequired_undefined) return _undefined$1;
  hasRequired_undefined = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(require_undefined$1(), exports$12);
  })(_undefined$1);
  return _undefined$1;
}
var uint8array$1 = {};
var uint8array = {};
var hasRequiredUint8array$1;
function requireUint8array$1() {
  if (hasRequiredUint8array$1) return uint8array;
  hasRequiredUint8array$1 = 1;
  Object.defineProperty(uint8array, "__esModule", { value: true });
  uint8array.Uint8Array = Uint8Array2;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Uint8Array2(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Uint8Array", type: "Uint8Array" }, options);
  }
  return uint8array;
}
var hasRequiredUint8array;
function requireUint8array() {
  if (hasRequiredUint8array) return uint8array$1;
  hasRequiredUint8array = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireUint8array$1(), exports$12);
  })(uint8array$1);
  return uint8array$1;
}
var unknown$1 = {};
var unknown = {};
var hasRequiredUnknown$1;
function requireUnknown$1() {
  if (hasRequiredUnknown$1) return unknown;
  hasRequiredUnknown$1 = 1;
  Object.defineProperty(unknown, "__esModule", { value: true });
  unknown.Unknown = Unknown;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Unknown(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Unknown" }, options);
  }
  return unknown;
}
var hasRequiredUnknown;
function requireUnknown() {
  if (hasRequiredUnknown) return unknown$1;
  hasRequiredUnknown = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireUnknown$1(), exports$12);
  })(unknown$1);
  return unknown$1;
}
var hasRequired_const$1;
function require_const$1() {
  if (hasRequired_const$1) return _const;
  hasRequired_const$1 = 1;
  Object.defineProperty(_const, "__esModule", { value: true });
  _const.Const = Const;
  const index_1 = requireAny();
  const index_2 = requireBigint();
  const index_3 = requireDate();
  const index_4 = require_function$1();
  const index_5 = requireLiteral();
  const index_6 = require_null();
  const index_7 = requireObject$1();
  const index_8 = requireSymbol();
  const index_9 = requireTuple();
  const index_10 = requireReadonly();
  const index_11 = require_undefined();
  const index_12 = requireUint8array();
  const index_13 = requireUnknown();
  const index_14 = requireCreate();
  const value_1 = requireValue$1();
  function FromArray(T) {
    return T.map((L) => FromValue(L, false));
  }
  function FromProperties(value2) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(value2))
      Acc[K] = (0, index_10.Readonly)(FromValue(value2[K], false));
    return Acc;
  }
  function ConditionalReadonly(T, root2) {
    return root2 === true ? T : (0, index_10.Readonly)(T);
  }
  function FromValue(value2, root2) {
    return (0, value_1.IsAsyncIterator)(value2) ? ConditionalReadonly((0, index_1.Any)(), root2) : (0, value_1.IsIterator)(value2) ? ConditionalReadonly((0, index_1.Any)(), root2) : (0, value_1.IsArray)(value2) ? (0, index_10.Readonly)((0, index_9.Tuple)(FromArray(value2))) : (0, value_1.IsUint8Array)(value2) ? (0, index_12.Uint8Array)() : (0, value_1.IsDate)(value2) ? (0, index_3.Date)() : (0, value_1.IsObject)(value2) ? ConditionalReadonly((0, index_7.Object)(FromProperties(value2)), root2) : (0, value_1.IsFunction)(value2) ? ConditionalReadonly((0, index_4.Function)([], (0, index_13.Unknown)()), root2) : (0, value_1.IsUndefined)(value2) ? (0, index_11.Undefined)() : (0, value_1.IsNull)(value2) ? (0, index_6.Null)() : (0, value_1.IsSymbol)(value2) ? (0, index_8.Symbol)() : (0, value_1.IsBigInt)(value2) ? (0, index_2.BigInt)() : (0, value_1.IsNumber)(value2) ? (0, index_5.Literal)(value2) : (0, value_1.IsBoolean)(value2) ? (0, index_5.Literal)(value2) : (0, value_1.IsString)(value2) ? (0, index_5.Literal)(value2) : (0, index_7.Object)({});
  }
  function Const(T, options) {
    return (0, index_14.CreateType)(FromValue(T, true), options);
  }
  return _const;
}
var hasRequired_const;
function require_const() {
  if (hasRequired_const) return _const$1;
  hasRequired_const = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(require_const$1(), exports$12);
  })(_const$1);
  return _const$1;
}
var constructorParameters$1 = {};
var constructorParameters = {};
var hasRequiredConstructorParameters$1;
function requireConstructorParameters$1() {
  if (hasRequiredConstructorParameters$1) return constructorParameters;
  hasRequiredConstructorParameters$1 = 1;
  Object.defineProperty(constructorParameters, "__esModule", { value: true });
  constructorParameters.ConstructorParameters = ConstructorParameters;
  const index_1 = requireTuple();
  function ConstructorParameters(schema2, options) {
    return (0, index_1.Tuple)(schema2.parameters, options);
  }
  return constructorParameters;
}
var hasRequiredConstructorParameters;
function requireConstructorParameters() {
  if (hasRequiredConstructorParameters) return constructorParameters$1;
  hasRequiredConstructorParameters = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireConstructorParameters$1(), exports$12);
  })(constructorParameters$1);
  return constructorParameters$1;
}
var deref$3 = {};
var deref$2 = {};
var hasRequiredDeref$3;
function requireDeref$3() {
  if (hasRequiredDeref$3) return deref$2;
  hasRequiredDeref$3 = 1;
  Object.defineProperty(deref$2, "__esModule", { value: true });
  deref$2.Deref = Deref;
  const type_1 = requireType$6();
  const index_1 = requireDiscard();
  const value_1 = requireValue$1();
  const kind_1 = requireKind();
  function FromRest(schema2, references) {
    return schema2.map((schema22) => Deref(schema22, references));
  }
  function FromProperties(properties, references) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(properties)) {
      Acc[K] = Deref(properties[K], references);
    }
    return Acc;
  }
  function FromConstructor(schema2, references) {
    schema2.parameters = FromRest(schema2.parameters, references);
    schema2.returns = Deref(schema2.returns, references);
    return schema2;
  }
  function FromFunction(schema2, references) {
    schema2.parameters = FromRest(schema2.parameters, references);
    schema2.returns = Deref(schema2.returns, references);
    return schema2;
  }
  function FromIntersect(schema2, references) {
    schema2.allOf = FromRest(schema2.allOf, references);
    return schema2;
  }
  function FromUnion(schema2, references) {
    schema2.anyOf = FromRest(schema2.anyOf, references);
    return schema2;
  }
  function FromTuple(schema2, references) {
    if ((0, value_1.IsUndefined)(schema2.items))
      return schema2;
    schema2.items = FromRest(schema2.items, references);
    return schema2;
  }
  function FromArray(schema2, references) {
    schema2.items = Deref(schema2.items, references);
    return schema2;
  }
  function FromObject(schema2, references) {
    schema2.properties = FromProperties(schema2.properties, references);
    return schema2;
  }
  function FromPromise(schema2, references) {
    schema2.item = Deref(schema2.item, references);
    return schema2;
  }
  function FromAsyncIterator(schema2, references) {
    schema2.items = Deref(schema2.items, references);
    return schema2;
  }
  function FromIterator(schema2, references) {
    schema2.items = Deref(schema2.items, references);
    return schema2;
  }
  function FromRef(schema2, references) {
    const target = references.find((remote) => remote.$id === schema2.$ref);
    if (target === void 0)
      throw Error(`Unable to dereference schema with $id ${schema2.$ref}`);
    const discard2 = (0, index_1.Discard)(target, ["$id"]);
    return Deref(discard2, references);
  }
  function DerefResolve(schema2, references) {
    return (0, kind_1.IsConstructor)(schema2) ? FromConstructor(schema2, references) : (0, kind_1.IsFunction)(schema2) ? FromFunction(schema2, references) : (0, kind_1.IsIntersect)(schema2) ? FromIntersect(schema2, references) : (0, kind_1.IsUnion)(schema2) ? FromUnion(schema2, references) : (0, kind_1.IsTuple)(schema2) ? FromTuple(schema2, references) : (0, kind_1.IsArray)(schema2) ? FromArray(schema2, references) : (0, kind_1.IsObject)(schema2) ? FromObject(schema2, references) : (0, kind_1.IsPromise)(schema2) ? FromPromise(schema2, references) : (0, kind_1.IsAsyncIterator)(schema2) ? FromAsyncIterator(schema2, references) : (0, kind_1.IsIterator)(schema2) ? FromIterator(schema2, references) : (0, kind_1.IsRef)(schema2) ? FromRef(schema2, references) : schema2;
  }
  function Deref(schema2, references) {
    return DerefResolve((0, type_1.CloneType)(schema2), (0, type_1.CloneRest)(references));
  }
  return deref$2;
}
var hasRequiredDeref$2;
function requireDeref$2() {
  if (hasRequiredDeref$2) return deref$3;
  hasRequiredDeref$2 = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireDeref$3(), exports$12);
  })(deref$3);
  return deref$3;
}
var _enum$2 = {};
var _enum$1 = {};
var hasRequired_enum$2;
function require_enum$2() {
  if (hasRequired_enum$2) return _enum$1;
  hasRequired_enum$2 = 1;
  Object.defineProperty(_enum$1, "__esModule", { value: true });
  _enum$1.Enum = Enum;
  const index_1 = requireLiteral();
  const index_2 = requireSymbols();
  const index_3 = requireUnion$1();
  const value_1 = requireValue$1();
  function Enum(item, options) {
    if ((0, value_1.IsUndefined)(item))
      throw new Error("Enum undefined or empty");
    const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
    const values2 = [...new Set(values1)];
    const anyOf = values2.map((value2) => (0, index_1.Literal)(value2));
    return (0, index_3.Union)(anyOf, { ...options, [index_2.Hint]: "Enum" });
  }
  return _enum$1;
}
var hasRequired_enum$1;
function require_enum$1() {
  if (hasRequired_enum$1) return _enum$2;
  hasRequired_enum$1 = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(require_enum$2(), exports$12);
  })(_enum$2);
  return _enum$2;
}
var exclude$1 = {};
var excludeFromMappedResult = {};
var exclude = {};
var _extends$1 = {};
var extendsCheck = {};
var hasRequiredExtendsCheck;
function requireExtendsCheck() {
  if (hasRequiredExtendsCheck) return extendsCheck;
  hasRequiredExtendsCheck = 1;
  Object.defineProperty(extendsCheck, "__esModule", { value: true });
  extendsCheck.ExtendsResult = extendsCheck.ExtendsResolverError = void 0;
  extendsCheck.ExtendsCheck = ExtendsCheck;
  const index_1 = requireAny();
  const index_2 = require_function$1();
  const index_3 = requireNumber();
  const index_4 = requireString();
  const index_5 = requireUnknown();
  const index_6 = requireTemplateLiteral();
  const index_7 = requirePatterns();
  const index_8 = requireSymbols();
  const index_9 = requireError();
  const index_10 = requireGuard();
  class ExtendsResolverError extends index_9.TypeBoxError {
  }
  extendsCheck.ExtendsResolverError = ExtendsResolverError;
  var ExtendsResult;
  (function(ExtendsResult2) {
    ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
    ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
    ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
  })(ExtendsResult || (extendsCheck.ExtendsResult = ExtendsResult = {}));
  function IntoBooleanResult(result) {
    return result === ExtendsResult.False ? result : ExtendsResult.True;
  }
  function Throw(message2) {
    throw new ExtendsResolverError(message2);
  }
  function IsStructuralRight(right) {
    return index_10.TypeGuard.IsNever(right) || index_10.TypeGuard.IsIntersect(right) || index_10.TypeGuard.IsUnion(right) || index_10.TypeGuard.IsUnknown(right) || index_10.TypeGuard.IsAny(right);
  }
  function StructuralRight(left, right) {
    return index_10.TypeGuard.IsNever(right) ? FromNeverRight() : index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight() : index_10.TypeGuard.IsAny(right) ? FromAnyRight() : Throw("StructuralRight");
  }
  function FromAnyRight(left, right) {
    return ExtendsResult.True;
  }
  function FromAny(left, right) {
    return index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) && right.anyOf.some((schema2) => index_10.TypeGuard.IsAny(schema2) || index_10.TypeGuard.IsUnknown(schema2)) ? ExtendsResult.True : index_10.TypeGuard.IsUnion(right) ? ExtendsResult.Union : index_10.TypeGuard.IsUnknown(right) ? ExtendsResult.True : index_10.TypeGuard.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
  }
  function FromArrayRight(left, right) {
    return index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union : index_10.TypeGuard.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromArray(left, right) {
    return index_10.TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !index_10.TypeGuard.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
  }
  function FromAsyncIterator(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : !index_10.TypeGuard.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
  }
  function FromBigInt(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromBooleanRight(left, right) {
    return index_10.TypeGuard.IsLiteralBoolean(left) ? ExtendsResult.True : index_10.TypeGuard.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromBoolean(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromConstructor(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !index_10.TypeGuard.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema2, index2) => IntoBooleanResult(Visit(right.parameters[index2], schema2)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
  }
  function FromDate(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromFunction(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !index_10.TypeGuard.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema2, index2) => IntoBooleanResult(Visit(right.parameters[index2], schema2)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
  }
  function FromIntegerRight(left, right) {
    return index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsNumber(left.const) ? ExtendsResult.True : index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromInteger(left, right) {
    return index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
  }
  function FromIntersectRight(left, right) {
    return right.allOf.every((schema2) => Visit(left, schema2) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromIntersect(left, right) {
    return left.allOf.some((schema2) => Visit(schema2, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromIterator(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : !index_10.TypeGuard.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
  }
  function FromLiteral(left, right) {
    return index_10.TypeGuard.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsString(right) ? FromStringRight(left) : index_10.TypeGuard.IsNumber(right) ? FromNumberRight(left) : index_10.TypeGuard.IsInteger(right) ? FromIntegerRight(left) : index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight(left) : ExtendsResult.False;
  }
  function FromNeverRight(left, right) {
    return ExtendsResult.False;
  }
  function FromNever(left, right) {
    return ExtendsResult.True;
  }
  function UnwrapTNot(schema2) {
    let [current, depth] = [schema2, 0];
    while (true) {
      if (!index_10.TypeGuard.IsNot(current))
        break;
      current = current.not;
      depth += 1;
    }
    return depth % 2 === 0 ? current : (0, index_5.Unknown)();
  }
  function FromNot(left, right) {
    return index_10.TypeGuard.IsNot(left) ? Visit(UnwrapTNot(left), right) : index_10.TypeGuard.IsNot(right) ? Visit(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
  }
  function FromNull(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromNumberRight(left, right) {
    return index_10.TypeGuard.IsLiteralNumber(left) ? ExtendsResult.True : index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromNumber(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function IsObjectPropertyCount(schema2, count) {
    return Object.getOwnPropertyNames(schema2.properties).length === count;
  }
  function IsObjectStringLike(schema2) {
    return IsObjectArrayLike(schema2);
  }
  function IsObjectSymbolLike(schema2) {
    return IsObjectPropertyCount(schema2, 0) || IsObjectPropertyCount(schema2, 1) && "description" in schema2.properties && index_10.TypeGuard.IsUnion(schema2.properties.description) && schema2.properties.description.anyOf.length === 2 && (index_10.TypeGuard.IsString(schema2.properties.description.anyOf[0]) && index_10.TypeGuard.IsUndefined(schema2.properties.description.anyOf[1]) || index_10.TypeGuard.IsString(schema2.properties.description.anyOf[1]) && index_10.TypeGuard.IsUndefined(schema2.properties.description.anyOf[0]));
  }
  function IsObjectNumberLike(schema2) {
    return IsObjectPropertyCount(schema2, 0);
  }
  function IsObjectBooleanLike(schema2) {
    return IsObjectPropertyCount(schema2, 0);
  }
  function IsObjectBigIntLike(schema2) {
    return IsObjectPropertyCount(schema2, 0);
  }
  function IsObjectDateLike(schema2) {
    return IsObjectPropertyCount(schema2, 0);
  }
  function IsObjectUint8ArrayLike(schema2) {
    return IsObjectArrayLike(schema2);
  }
  function IsObjectFunctionLike(schema2) {
    const length = (0, index_3.Number)();
    return IsObjectPropertyCount(schema2, 0) || IsObjectPropertyCount(schema2, 1) && "length" in schema2.properties && IntoBooleanResult(Visit(schema2.properties["length"], length)) === ExtendsResult.True;
  }
  function IsObjectConstructorLike(schema2) {
    return IsObjectPropertyCount(schema2, 0);
  }
  function IsObjectArrayLike(schema2) {
    const length = (0, index_3.Number)();
    return IsObjectPropertyCount(schema2, 0) || IsObjectPropertyCount(schema2, 1) && "length" in schema2.properties && IntoBooleanResult(Visit(schema2.properties["length"], length)) === ExtendsResult.True;
  }
  function IsObjectPromiseLike(schema2) {
    const then = (0, index_2.Function)([(0, index_1.Any)()], (0, index_1.Any)());
    return IsObjectPropertyCount(schema2, 0) || IsObjectPropertyCount(schema2, 1) && "then" in schema2.properties && IntoBooleanResult(Visit(schema2.properties["then"], then)) === ExtendsResult.True;
  }
  function Property(left, right) {
    return Visit(left, right) === ExtendsResult.False ? ExtendsResult.False : index_10.TypeGuard.IsOptional(left) && !index_10.TypeGuard.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
  }
  function FromObjectRight(left, right) {
    return index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union : index_10.TypeGuard.IsNever(left) || index_10.TypeGuard.IsLiteralString(left) && IsObjectStringLike(right) || index_10.TypeGuard.IsLiteralNumber(left) && IsObjectNumberLike(right) || index_10.TypeGuard.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right) || index_10.TypeGuard.IsBigInt(left) && IsObjectBigIntLike(right) || index_10.TypeGuard.IsString(left) && IsObjectStringLike(right) || index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right) || index_10.TypeGuard.IsNumber(left) && IsObjectNumberLike(right) || index_10.TypeGuard.IsInteger(left) && IsObjectNumberLike(right) || index_10.TypeGuard.IsBoolean(left) && IsObjectBooleanLike(right) || index_10.TypeGuard.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || index_10.TypeGuard.IsDate(left) && IsObjectDateLike(right) || index_10.TypeGuard.IsConstructor(left) && IsObjectConstructorLike(right) || index_10.TypeGuard.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsString(RecordKey(left)) ? (() => {
      return right[index_8.Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
    })() : index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsNumber(RecordKey(left)) ? (() => {
      return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
    })() : ExtendsResult.False;
  }
  function FromObject(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : !index_10.TypeGuard.IsObject(right) ? ExtendsResult.False : (() => {
      for (const key of Object.getOwnPropertyNames(right.properties)) {
        if (!(key in left.properties) && !index_10.TypeGuard.IsOptional(right.properties[key])) {
          return ExtendsResult.False;
        }
        if (index_10.TypeGuard.IsOptional(right.properties[key])) {
          return ExtendsResult.True;
        }
        if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
          return ExtendsResult.False;
        }
      }
      return ExtendsResult.True;
    })();
  }
  function FromPromise(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !index_10.TypeGuard.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.item, right.item));
  }
  function RecordKey(schema2) {
    return index_7.PatternNumberExact in schema2.patternProperties ? (0, index_3.Number)() : index_7.PatternStringExact in schema2.patternProperties ? (0, index_4.String)() : Throw("Unknown record key pattern");
  }
  function RecordValue(schema2) {
    return index_7.PatternNumberExact in schema2.patternProperties ? schema2.patternProperties[index_7.PatternNumberExact] : index_7.PatternStringExact in schema2.patternProperties ? schema2.patternProperties[index_7.PatternStringExact] : Throw("Unable to get record value schema");
  }
  function FromRecordRight(left, right) {
    const [Key, Value] = [RecordKey(right), RecordValue(right)];
    return index_10.TypeGuard.IsLiteralString(left) && index_10.TypeGuard.IsNumber(Key) && IntoBooleanResult(Visit(left, Value)) === ExtendsResult.True ? ExtendsResult.True : index_10.TypeGuard.IsUint8Array(left) && index_10.TypeGuard.IsNumber(Key) ? Visit(left, Value) : index_10.TypeGuard.IsString(left) && index_10.TypeGuard.IsNumber(Key) ? Visit(left, Value) : index_10.TypeGuard.IsArray(left) && index_10.TypeGuard.IsNumber(Key) ? Visit(left, Value) : index_10.TypeGuard.IsObject(left) ? (() => {
      for (const key of Object.getOwnPropertyNames(left.properties)) {
        if (Property(Value, left.properties[key]) === ExtendsResult.False) {
          return ExtendsResult.False;
        }
      }
      return ExtendsResult.True;
    })() : ExtendsResult.False;
  }
  function FromRecord(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !index_10.TypeGuard.IsRecord(right) ? ExtendsResult.False : Visit(RecordValue(left), RecordValue(right));
  }
  function FromRegExp(left, right) {
    const L = index_10.TypeGuard.IsRegExp(left) ? (0, index_4.String)() : left;
    const R = index_10.TypeGuard.IsRegExp(right) ? (0, index_4.String)() : right;
    return Visit(L, R);
  }
  function FromStringRight(left, right) {
    return index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsString(left.const) ? ExtendsResult.True : index_10.TypeGuard.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromString(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromSymbol(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromTemplateLiteral(left, right) {
    return index_10.TypeGuard.IsTemplateLiteral(left) ? Visit((0, index_6.TemplateLiteralToUnion)(left), right) : index_10.TypeGuard.IsTemplateLiteral(right) ? Visit(left, (0, index_6.TemplateLiteralToUnion)(right)) : Throw("Invalid fallthrough for TemplateLiteral");
  }
  function IsArrayOfTuple(left, right) {
    return index_10.TypeGuard.IsArray(right) && left.items !== void 0 && left.items.every((schema2) => Visit(schema2, right.items) === ExtendsResult.True);
  }
  function FromTupleRight(left, right) {
    return index_10.TypeGuard.IsNever(left) ? ExtendsResult.True : index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
  }
  function FromTuple(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : index_10.TypeGuard.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !index_10.TypeGuard.IsTuple(right) ? ExtendsResult.False : index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items) || !index_10.ValueGuard.IsUndefined(left.items) && index_10.ValueGuard.IsUndefined(right.items) ? ExtendsResult.False : index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema2, index2) => Visit(schema2, right.items[index2]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUint8Array(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUndefined(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsVoid(right) ? FromVoidRight(left) : index_10.TypeGuard.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUnionRight(left, right) {
    return right.anyOf.some((schema2) => Visit(left, schema2) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUnion(left, right) {
    return left.anyOf.every((schema2) => Visit(schema2, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUnknownRight(left, right) {
    return ExtendsResult.True;
  }
  function FromUnknown(left, right) {
    return index_10.TypeGuard.IsNever(right) ? FromNeverRight() : index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight() : index_10.TypeGuard.IsString(right) ? FromStringRight(left) : index_10.TypeGuard.IsNumber(right) ? FromNumberRight(left) : index_10.TypeGuard.IsInteger(right) ? FromIntegerRight(left) : index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight(left) : index_10.TypeGuard.IsArray(right) ? FromArrayRight(left) : index_10.TypeGuard.IsTuple(right) ? FromTupleRight(left) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromVoidRight(left, right) {
    return index_10.TypeGuard.IsUndefined(left) ? ExtendsResult.True : index_10.TypeGuard.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromVoid(left, right) {
    return index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight() : index_10.TypeGuard.IsAny(right) ? FromAnyRight() : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function Visit(left, right) {
    return (
      // resolvable
      index_10.TypeGuard.IsTemplateLiteral(left) || index_10.TypeGuard.IsTemplateLiteral(right) ? FromTemplateLiteral(left, right) : index_10.TypeGuard.IsRegExp(left) || index_10.TypeGuard.IsRegExp(right) ? FromRegExp(left, right) : index_10.TypeGuard.IsNot(left) || index_10.TypeGuard.IsNot(right) ? FromNot(left, right) : (
        // standard
        index_10.TypeGuard.IsAny(left) ? FromAny(left, right) : index_10.TypeGuard.IsArray(left) ? FromArray(left, right) : index_10.TypeGuard.IsBigInt(left) ? FromBigInt(left, right) : index_10.TypeGuard.IsBoolean(left) ? FromBoolean(left, right) : index_10.TypeGuard.IsAsyncIterator(left) ? FromAsyncIterator(left, right) : index_10.TypeGuard.IsConstructor(left) ? FromConstructor(left, right) : index_10.TypeGuard.IsDate(left) ? FromDate(left, right) : index_10.TypeGuard.IsFunction(left) ? FromFunction(left, right) : index_10.TypeGuard.IsInteger(left) ? FromInteger(left, right) : index_10.TypeGuard.IsIntersect(left) ? FromIntersect(left, right) : index_10.TypeGuard.IsIterator(left) ? FromIterator(left, right) : index_10.TypeGuard.IsLiteral(left) ? FromLiteral(left, right) : index_10.TypeGuard.IsNever(left) ? FromNever() : index_10.TypeGuard.IsNull(left) ? FromNull(left, right) : index_10.TypeGuard.IsNumber(left) ? FromNumber(left, right) : index_10.TypeGuard.IsObject(left) ? FromObject(left, right) : index_10.TypeGuard.IsRecord(left) ? FromRecord(left, right) : index_10.TypeGuard.IsString(left) ? FromString(left, right) : index_10.TypeGuard.IsSymbol(left) ? FromSymbol(left, right) : index_10.TypeGuard.IsTuple(left) ? FromTuple(left, right) : index_10.TypeGuard.IsPromise(left) ? FromPromise(left, right) : index_10.TypeGuard.IsUint8Array(left) ? FromUint8Array(left, right) : index_10.TypeGuard.IsUndefined(left) ? FromUndefined(left, right) : index_10.TypeGuard.IsUnion(left) ? FromUnion(left, right) : index_10.TypeGuard.IsUnknown(left) ? FromUnknown(left, right) : index_10.TypeGuard.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[index_8.Kind]}'`)
      )
    );
  }
  function ExtendsCheck(left, right) {
    return Visit(left, right);
  }
  return extendsCheck;
}
var extendsFromMappedKey = {};
var _extends = {};
var extendsFromMappedResult = {};
var hasRequiredExtendsFromMappedResult;
function requireExtendsFromMappedResult() {
  if (hasRequiredExtendsFromMappedResult) return extendsFromMappedResult;
  hasRequiredExtendsFromMappedResult = 1;
  Object.defineProperty(extendsFromMappedResult, "__esModule", { value: true });
  extendsFromMappedResult.ExtendsFromMappedResult = ExtendsFromMappedResult;
  const index_1 = requireMapped();
  const extends_1 = require_extends$1();
  const value_1 = requireValue();
  function FromProperties(P, Right, True, False, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, extends_1.Extends)(P[K2], Right, True, False, (0, value_1.Clone)(options));
    return Acc;
  }
  function FromMappedResult(Left, Right, True, False, options) {
    return FromProperties(Left.properties, Right, True, False, options);
  }
  function ExtendsFromMappedResult(Left, Right, True, False, options) {
    const P = FromMappedResult(Left, Right, True, False, options);
    return (0, index_1.MappedResult)(P);
  }
  return extendsFromMappedResult;
}
var hasRequired_extends$1;
function require_extends$1() {
  if (hasRequired_extends$1) return _extends;
  hasRequired_extends$1 = 1;
  Object.defineProperty(_extends, "__esModule", { value: true });
  _extends.Extends = Extends;
  const type_1 = requireType$5();
  const index_1 = requireUnion$1();
  const extends_check_1 = requireExtendsCheck();
  const extends_from_mapped_key_1 = requireExtendsFromMappedKey();
  const extends_from_mapped_result_1 = requireExtendsFromMappedResult();
  const kind_1 = requireKind();
  function ExtendsResolve(left, right, trueType, falseType) {
    const R = (0, extends_check_1.ExtendsCheck)(left, right);
    return R === extends_check_1.ExtendsResult.Union ? (0, index_1.Union)([trueType, falseType]) : R === extends_check_1.ExtendsResult.True ? trueType : falseType;
  }
  function Extends(L, R, T, F, options) {
    return (0, kind_1.IsMappedResult)(L) ? (0, extends_from_mapped_result_1.ExtendsFromMappedResult)(L, R, T, F, options) : (0, kind_1.IsMappedKey)(L) ? (0, type_1.CreateType)((0, extends_from_mapped_key_1.ExtendsFromMappedKey)(L, R, T, F, options)) : (0, type_1.CreateType)(ExtendsResolve(L, R, T, F), options);
  }
  return _extends;
}
var hasRequiredExtendsFromMappedKey;
function requireExtendsFromMappedKey() {
  if (hasRequiredExtendsFromMappedKey) return extendsFromMappedKey;
  hasRequiredExtendsFromMappedKey = 1;
  Object.defineProperty(extendsFromMappedKey, "__esModule", { value: true });
  extendsFromMappedKey.ExtendsFromMappedKey = ExtendsFromMappedKey;
  const index_1 = requireMapped();
  const index_2 = requireLiteral();
  const extends_1 = require_extends$1();
  const value_1 = requireValue();
  function FromPropertyKey(K, U, L, R, options) {
    return {
      [K]: (0, extends_1.Extends)((0, index_2.Literal)(K), U, L, R, (0, value_1.Clone)(options))
    };
  }
  function FromPropertyKeys(K, U, L, R, options) {
    return K.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
    }, {});
  }
  function FromMappedKey(K, U, L, R, options) {
    return FromPropertyKeys(K.keys, U, L, R, options);
  }
  function ExtendsFromMappedKey(T, U, L, R, options) {
    const P = FromMappedKey(T, U, L, R, options);
    return (0, index_1.MappedResult)(P);
  }
  return extendsFromMappedKey;
}
var extendsUndefined = {};
var hasRequiredExtendsUndefined;
function requireExtendsUndefined() {
  if (hasRequiredExtendsUndefined) return extendsUndefined;
  hasRequiredExtendsUndefined = 1;
  Object.defineProperty(extendsUndefined, "__esModule", { value: true });
  extendsUndefined.ExtendsUndefinedCheck = ExtendsUndefinedCheck;
  const index_1 = requireSymbols();
  function Intersect(schema2) {
    return schema2.allOf.every((schema3) => ExtendsUndefinedCheck(schema3));
  }
  function Union(schema2) {
    return schema2.anyOf.some((schema3) => ExtendsUndefinedCheck(schema3));
  }
  function Not(schema2) {
    return !ExtendsUndefinedCheck(schema2.not);
  }
  function ExtendsUndefinedCheck(schema2) {
    return schema2[index_1.Kind] === "Intersect" ? Intersect(schema2) : schema2[index_1.Kind] === "Union" ? Union(schema2) : schema2[index_1.Kind] === "Not" ? Not(schema2) : schema2[index_1.Kind] === "Undefined" ? true : false;
  }
  return extendsUndefined;
}
var hasRequired_extends;
function require_extends() {
  if (hasRequired_extends) return _extends$1;
  hasRequired_extends = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireExtendsCheck(), exports$12);
    __exportStar(requireExtendsFromMappedKey(), exports$12);
    __exportStar(requireExtendsFromMappedResult(), exports$12);
    __exportStar(requireExtendsUndefined(), exports$12);
    __exportStar(require_extends$1(), exports$12);
  })(_extends$1);
  return _extends$1;
}
var excludeFromTemplateLiteral = {};
var hasRequiredExcludeFromTemplateLiteral;
function requireExcludeFromTemplateLiteral() {
  if (hasRequiredExcludeFromTemplateLiteral) return excludeFromTemplateLiteral;
  hasRequiredExcludeFromTemplateLiteral = 1;
  Object.defineProperty(excludeFromTemplateLiteral, "__esModule", { value: true });
  excludeFromTemplateLiteral.ExcludeFromTemplateLiteral = ExcludeFromTemplateLiteral;
  const exclude_1 = requireExclude$1();
  const index_1 = requireTemplateLiteral();
  function ExcludeFromTemplateLiteral(L, R) {
    return (0, exclude_1.Exclude)((0, index_1.TemplateLiteralToUnion)(L), R);
  }
  return excludeFromTemplateLiteral;
}
var hasRequiredExclude$1;
function requireExclude$1() {
  if (hasRequiredExclude$1) return exclude;
  hasRequiredExclude$1 = 1;
  Object.defineProperty(exclude, "__esModule", { value: true });
  exclude.Exclude = Exclude;
  const type_1 = requireType$5();
  const index_1 = requireUnion$1();
  const index_2 = requireNever();
  const index_3 = require_extends();
  const exclude_from_mapped_result_1 = requireExcludeFromMappedResult();
  const exclude_from_template_literal_1 = requireExcludeFromTemplateLiteral();
  const kind_1 = requireKind();
  function ExcludeRest(L, R) {
    const excluded = L.filter((inner) => (0, index_3.ExtendsCheck)(inner, R) === index_3.ExtendsResult.False);
    return excluded.length === 1 ? excluded[0] : (0, index_1.Union)(excluded);
  }
  function Exclude(L, R, options = {}) {
    if ((0, kind_1.IsTemplateLiteral)(L))
      return (0, type_1.CreateType)((0, exclude_from_template_literal_1.ExcludeFromTemplateLiteral)(L, R), options);
    if ((0, kind_1.IsMappedResult)(L))
      return (0, type_1.CreateType)((0, exclude_from_mapped_result_1.ExcludeFromMappedResult)(L, R), options);
    return (0, type_1.CreateType)((0, kind_1.IsUnion)(L) ? ExcludeRest(L.anyOf, R) : (0, index_3.ExtendsCheck)(L, R) !== index_3.ExtendsResult.False ? (0, index_2.Never)() : L, options);
  }
  return exclude;
}
var hasRequiredExcludeFromMappedResult;
function requireExcludeFromMappedResult() {
  if (hasRequiredExcludeFromMappedResult) return excludeFromMappedResult;
  hasRequiredExcludeFromMappedResult = 1;
  Object.defineProperty(excludeFromMappedResult, "__esModule", { value: true });
  excludeFromMappedResult.ExcludeFromMappedResult = ExcludeFromMappedResult;
  const index_1 = requireMapped();
  const exclude_1 = requireExclude$1();
  function FromProperties(P, U) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, exclude_1.Exclude)(P[K2], U);
    return Acc;
  }
  function FromMappedResult(R, T) {
    return FromProperties(R.properties, T);
  }
  function ExcludeFromMappedResult(R, T) {
    const P = FromMappedResult(R, T);
    return (0, index_1.MappedResult)(P);
  }
  return excludeFromMappedResult;
}
var hasRequiredExclude;
function requireExclude() {
  if (hasRequiredExclude) return exclude$1;
  hasRequiredExclude = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireExcludeFromMappedResult(), exports$12);
    __exportStar(requireExcludeFromTemplateLiteral(), exports$12);
    __exportStar(requireExclude$1(), exports$12);
  })(exclude$1);
  return exclude$1;
}
var extract$1 = {};
var extractFromMappedResult = {};
var extract = {};
var extractFromTemplateLiteral = {};
var hasRequiredExtractFromTemplateLiteral;
function requireExtractFromTemplateLiteral() {
  if (hasRequiredExtractFromTemplateLiteral) return extractFromTemplateLiteral;
  hasRequiredExtractFromTemplateLiteral = 1;
  Object.defineProperty(extractFromTemplateLiteral, "__esModule", { value: true });
  extractFromTemplateLiteral.ExtractFromTemplateLiteral = ExtractFromTemplateLiteral;
  const extract_1 = requireExtract$1();
  const index_1 = requireTemplateLiteral();
  function ExtractFromTemplateLiteral(L, R) {
    return (0, extract_1.Extract)((0, index_1.TemplateLiteralToUnion)(L), R);
  }
  return extractFromTemplateLiteral;
}
var hasRequiredExtract$1;
function requireExtract$1() {
  if (hasRequiredExtract$1) return extract;
  hasRequiredExtract$1 = 1;
  Object.defineProperty(extract, "__esModule", { value: true });
  extract.Extract = Extract;
  const type_1 = requireType$5();
  const index_1 = requireUnion$1();
  const index_2 = requireNever();
  const index_3 = require_extends();
  const extract_from_mapped_result_1 = requireExtractFromMappedResult();
  const extract_from_template_literal_1 = requireExtractFromTemplateLiteral();
  const kind_1 = requireKind();
  function ExtractRest(L, R) {
    const extracted = L.filter((inner) => (0, index_3.ExtendsCheck)(inner, R) !== index_3.ExtendsResult.False);
    return extracted.length === 1 ? extracted[0] : (0, index_1.Union)(extracted);
  }
  function Extract(L, R, options) {
    if ((0, kind_1.IsTemplateLiteral)(L))
      return (0, type_1.CreateType)((0, extract_from_template_literal_1.ExtractFromTemplateLiteral)(L, R), options);
    if ((0, kind_1.IsMappedResult)(L))
      return (0, type_1.CreateType)((0, extract_from_mapped_result_1.ExtractFromMappedResult)(L, R), options);
    return (0, type_1.CreateType)((0, kind_1.IsUnion)(L) ? ExtractRest(L.anyOf, R) : (0, index_3.ExtendsCheck)(L, R) !== index_3.ExtendsResult.False ? L : (0, index_2.Never)(), options);
  }
  return extract;
}
var hasRequiredExtractFromMappedResult;
function requireExtractFromMappedResult() {
  if (hasRequiredExtractFromMappedResult) return extractFromMappedResult;
  hasRequiredExtractFromMappedResult = 1;
  Object.defineProperty(extractFromMappedResult, "__esModule", { value: true });
  extractFromMappedResult.ExtractFromMappedResult = ExtractFromMappedResult;
  const index_1 = requireMapped();
  const extract_1 = requireExtract$1();
  function FromProperties(P, T) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, extract_1.Extract)(P[K2], T);
    return Acc;
  }
  function FromMappedResult(R, T) {
    return FromProperties(R.properties, T);
  }
  function ExtractFromMappedResult(R, T) {
    const P = FromMappedResult(R, T);
    return (0, index_1.MappedResult)(P);
  }
  return extractFromMappedResult;
}
var hasRequiredExtract;
function requireExtract() {
  if (hasRequiredExtract) return extract$1;
  hasRequiredExtract = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireExtractFromMappedResult(), exports$12);
    __exportStar(requireExtractFromTemplateLiteral(), exports$12);
    __exportStar(requireExtract$1(), exports$12);
  })(extract$1);
  return extract$1;
}
var instanceType$1 = {};
var instanceType = {};
var hasRequiredInstanceType$1;
function requireInstanceType$1() {
  if (hasRequiredInstanceType$1) return instanceType;
  hasRequiredInstanceType$1 = 1;
  Object.defineProperty(instanceType, "__esModule", { value: true });
  instanceType.InstanceType = InstanceType;
  const type_1 = requireType$5();
  function InstanceType(schema2, options) {
    return (0, type_1.CreateType)(schema2.returns, options);
  }
  return instanceType;
}
var hasRequiredInstanceType;
function requireInstanceType() {
  if (hasRequiredInstanceType) return instanceType$1;
  hasRequiredInstanceType = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireInstanceType$1(), exports$12);
  })(instanceType$1);
  return instanceType$1;
}
var integer$1 = {};
var integer = {};
var hasRequiredInteger$1;
function requireInteger$1() {
  if (hasRequiredInteger$1) return integer;
  hasRequiredInteger$1 = 1;
  Object.defineProperty(integer, "__esModule", { value: true });
  integer.Integer = Integer;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Integer(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Integer", type: "integer" }, options);
  }
  return integer;
}
var hasRequiredInteger;
function requireInteger() {
  if (hasRequiredInteger) return integer$1;
  hasRequiredInteger = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireInteger$1(), exports$12);
  })(integer$1);
  return integer$1;
}
var intrinsic$1 = {};
var capitalize = {};
var intrinsic = {};
var intrinsicFromMappedKey = {};
var hasRequiredIntrinsicFromMappedKey;
function requireIntrinsicFromMappedKey() {
  if (hasRequiredIntrinsicFromMappedKey) return intrinsicFromMappedKey;
  hasRequiredIntrinsicFromMappedKey = 1;
  Object.defineProperty(intrinsicFromMappedKey, "__esModule", { value: true });
  intrinsicFromMappedKey.IntrinsicFromMappedKey = IntrinsicFromMappedKey;
  const index_1 = requireMapped();
  const intrinsic_1 = requireIntrinsic$1();
  const index_2 = requireLiteral();
  const value_1 = requireValue();
  function MappedIntrinsicPropertyKey(K, M, options) {
    return {
      [K]: (0, intrinsic_1.Intrinsic)((0, index_2.Literal)(K), M, (0, value_1.Clone)(options))
    };
  }
  function MappedIntrinsicPropertyKeys(K, M, options) {
    const result = K.reduce((Acc, L) => {
      return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
    }, {});
    return result;
  }
  function MappedIntrinsicProperties(T, M, options) {
    return MappedIntrinsicPropertyKeys(T["keys"], M, options);
  }
  function IntrinsicFromMappedKey(T, M, options) {
    const P = MappedIntrinsicProperties(T, M, options);
    return (0, index_1.MappedResult)(P);
  }
  return intrinsicFromMappedKey;
}
var hasRequiredIntrinsic$1;
function requireIntrinsic$1() {
  if (hasRequiredIntrinsic$1) return intrinsic;
  hasRequiredIntrinsic$1 = 1;
  Object.defineProperty(intrinsic, "__esModule", { value: true });
  intrinsic.Intrinsic = Intrinsic;
  const type_1 = requireType$5();
  const index_1 = requireTemplateLiteral();
  const intrinsic_from_mapped_key_1 = requireIntrinsicFromMappedKey();
  const index_2 = requireLiteral();
  const index_3 = requireUnion$1();
  const kind_1 = requireKind();
  function ApplyUncapitalize(value2) {
    const [first, rest2] = [value2.slice(0, 1), value2.slice(1)];
    return [first.toLowerCase(), rest2].join("");
  }
  function ApplyCapitalize(value2) {
    const [first, rest2] = [value2.slice(0, 1), value2.slice(1)];
    return [first.toUpperCase(), rest2].join("");
  }
  function ApplyUppercase(value2) {
    return value2.toUpperCase();
  }
  function ApplyLowercase(value2) {
    return value2.toLowerCase();
  }
  function FromTemplateLiteral(schema2, mode, options) {
    const expression = (0, index_1.TemplateLiteralParseExact)(schema2.pattern);
    const finite2 = (0, index_1.IsTemplateLiteralExpressionFinite)(expression);
    if (!finite2)
      return { ...schema2, pattern: FromLiteralValue(schema2.pattern, mode) };
    const strings = [...(0, index_1.TemplateLiteralExpressionGenerate)(expression)];
    const literals = strings.map((value2) => (0, index_2.Literal)(value2));
    const mapped2 = FromRest(literals, mode);
    const union2 = (0, index_3.Union)(mapped2);
    return (0, index_1.TemplateLiteral)([union2], options);
  }
  function FromLiteralValue(value2, mode) {
    return typeof value2 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value2) : mode === "Capitalize" ? ApplyCapitalize(value2) : mode === "Uppercase" ? ApplyUppercase(value2) : mode === "Lowercase" ? ApplyLowercase(value2) : value2 : value2.toString();
  }
  function FromRest(T, M) {
    return T.map((L) => Intrinsic(L, M));
  }
  function Intrinsic(schema2, mode, options = {}) {
    return (
      // Intrinsic-Mapped-Inference
      (0, kind_1.IsMappedKey)(schema2) ? (0, intrinsic_from_mapped_key_1.IntrinsicFromMappedKey)(schema2, mode, options) : (
        // Standard-Inference
        (0, kind_1.IsTemplateLiteral)(schema2) ? FromTemplateLiteral(schema2, mode, options) : (0, kind_1.IsUnion)(schema2) ? (0, index_3.Union)(FromRest(schema2.anyOf, mode), options) : (0, kind_1.IsLiteral)(schema2) ? (0, index_2.Literal)(FromLiteralValue(schema2.const, mode), options) : (
          // Default Type
          (0, type_1.CreateType)(schema2, options)
        )
      )
    );
  }
  return intrinsic;
}
var hasRequiredCapitalize;
function requireCapitalize() {
  if (hasRequiredCapitalize) return capitalize;
  hasRequiredCapitalize = 1;
  Object.defineProperty(capitalize, "__esModule", { value: true });
  capitalize.Capitalize = Capitalize;
  const intrinsic_1 = requireIntrinsic$1();
  function Capitalize(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Capitalize", options);
  }
  return capitalize;
}
var lowercase = {};
var hasRequiredLowercase;
function requireLowercase() {
  if (hasRequiredLowercase) return lowercase;
  hasRequiredLowercase = 1;
  Object.defineProperty(lowercase, "__esModule", { value: true });
  lowercase.Lowercase = Lowercase;
  const intrinsic_1 = requireIntrinsic$1();
  function Lowercase(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Lowercase", options);
  }
  return lowercase;
}
var uncapitalize = {};
var hasRequiredUncapitalize;
function requireUncapitalize() {
  if (hasRequiredUncapitalize) return uncapitalize;
  hasRequiredUncapitalize = 1;
  Object.defineProperty(uncapitalize, "__esModule", { value: true });
  uncapitalize.Uncapitalize = Uncapitalize;
  const intrinsic_1 = requireIntrinsic$1();
  function Uncapitalize(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Uncapitalize", options);
  }
  return uncapitalize;
}
var uppercase = {};
var hasRequiredUppercase;
function requireUppercase() {
  if (hasRequiredUppercase) return uppercase;
  hasRequiredUppercase = 1;
  Object.defineProperty(uppercase, "__esModule", { value: true });
  uppercase.Uppercase = Uppercase;
  const intrinsic_1 = requireIntrinsic$1();
  function Uppercase(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Uppercase", options);
  }
  return uppercase;
}
var hasRequiredIntrinsic;
function requireIntrinsic() {
  if (hasRequiredIntrinsic) return intrinsic$1;
  hasRequiredIntrinsic = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireCapitalize(), exports$12);
    __exportStar(requireIntrinsicFromMappedKey(), exports$12);
    __exportStar(requireIntrinsic$1(), exports$12);
    __exportStar(requireLowercase(), exports$12);
    __exportStar(requireUncapitalize(), exports$12);
    __exportStar(requireUppercase(), exports$12);
  })(intrinsic$1);
  return intrinsic$1;
}
var not$1 = {};
var not = {};
var hasRequiredNot$1;
function requireNot$1() {
  if (hasRequiredNot$1) return not;
  hasRequiredNot$1 = 1;
  Object.defineProperty(not, "__esModule", { value: true });
  not.Not = Not;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Not(not2, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Not", not: not2 }, options);
  }
  return not;
}
var hasRequiredNot;
function requireNot() {
  if (hasRequiredNot) return not$1;
  hasRequiredNot = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireNot$1(), exports$12);
  })(not$1);
  return not$1;
}
var omit$1 = {};
var omitFromMappedKey = {};
var omit = {};
var omitFromMappedResult = {};
var hasRequiredOmitFromMappedResult;
function requireOmitFromMappedResult() {
  if (hasRequiredOmitFromMappedResult) return omitFromMappedResult;
  hasRequiredOmitFromMappedResult = 1;
  Object.defineProperty(omitFromMappedResult, "__esModule", { value: true });
  omitFromMappedResult.OmitFromMappedResult = OmitFromMappedResult;
  const index_1 = requireMapped();
  const omit_1 = requireOmit$1();
  const value_1 = requireValue();
  function FromProperties(P, K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, omit_1.Omit)(P[K2], K, (0, value_1.Clone)(options));
    return Acc;
  }
  function FromMappedResult(R, K, options) {
    return FromProperties(R.properties, K, options);
  }
  function OmitFromMappedResult(R, K, options) {
    const P = FromMappedResult(R, K, options);
    return (0, index_1.MappedResult)(P);
  }
  return omitFromMappedResult;
}
var hasRequiredOmit$1;
function requireOmit$1() {
  if (hasRequiredOmit$1) return omit;
  hasRequiredOmit$1 = 1;
  Object.defineProperty(omit, "__esModule", { value: true });
  omit.Omit = Omit;
  const type_1 = requireType$5();
  const discard_1 = requireDiscard$1();
  const index_1 = requireIntersect();
  const index_2 = requireUnion$1();
  const index_3 = requireObject$1();
  const index_4 = requireIndexed();
  const omit_from_mapped_key_1 = requireOmitFromMappedKey();
  const omit_from_mapped_result_1 = requireOmitFromMappedResult();
  const symbols_1 = requireSymbols$1();
  const kind_1 = requireKind();
  function FromIntersect(T, K) {
    return T.map((T2) => OmitResolve(T2, K));
  }
  function FromUnion(T, K) {
    return T.map((T2) => OmitResolve(T2, K));
  }
  function FromProperty(T, K) {
    const { [K]: _, ...R } = T;
    return R;
  }
  function FromProperties(T, K) {
    return K.reduce((T2, K2) => FromProperty(T2, K2), T);
  }
  function FromObject(T, K) {
    const options = (0, discard_1.Discard)(T, [symbols_1.TransformKind, "$id", "required", "properties"]);
    const properties = FromProperties(T["properties"], K);
    return (0, index_3.Object)(properties, options);
  }
  function OmitResolve(T, K) {
    return (0, kind_1.IsIntersect)(T) ? (0, index_1.Intersect)(FromIntersect(T.allOf, K)) : (0, kind_1.IsUnion)(T) ? (0, index_2.Union)(FromUnion(T.anyOf, K)) : (0, kind_1.IsObject)(T) ? FromObject(T, K) : (0, index_3.Object)({});
  }
  function Omit(T, K, options) {
    if ((0, kind_1.IsMappedKey)(K))
      return (0, omit_from_mapped_key_1.OmitFromMappedKey)(T, K, options);
    if ((0, kind_1.IsMappedResult)(T))
      return (0, omit_from_mapped_result_1.OmitFromMappedResult)(T, K, options);
    const I = (0, kind_1.IsSchema)(K) ? (0, index_4.IndexPropertyKeys)(K) : K;
    return (0, type_1.CreateType)({ ...OmitResolve(T, I), ...options });
  }
  return omit;
}
var hasRequiredOmitFromMappedKey;
function requireOmitFromMappedKey() {
  if (hasRequiredOmitFromMappedKey) return omitFromMappedKey;
  hasRequiredOmitFromMappedKey = 1;
  Object.defineProperty(omitFromMappedKey, "__esModule", { value: true });
  omitFromMappedKey.OmitFromMappedKey = OmitFromMappedKey;
  const index_1 = requireMapped();
  const omit_1 = requireOmit$1();
  const value_1 = requireValue();
  function FromPropertyKey(T, K, options) {
    return {
      [K]: (0, omit_1.Omit)(T, [K], (0, value_1.Clone)(options))
    };
  }
  function FromPropertyKeys(T, K, options) {
    return K.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey(T, LK, options) };
    }, {});
  }
  function FromMappedKey(T, K, options) {
    return FromPropertyKeys(T, K.keys, options);
  }
  function OmitFromMappedKey(T, K, options) {
    const P = FromMappedKey(T, K, options);
    return (0, index_1.MappedResult)(P);
  }
  return omitFromMappedKey;
}
var hasRequiredOmit;
function requireOmit() {
  if (hasRequiredOmit) return omit$1;
  hasRequiredOmit = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireOmitFromMappedKey(), exports$12);
    __exportStar(requireOmitFromMappedResult(), exports$12);
    __exportStar(requireOmit$1(), exports$12);
  })(omit$1);
  return omit$1;
}
var parameters$1 = {};
var parameters = {};
var hasRequiredParameters$1;
function requireParameters$1() {
  if (hasRequiredParameters$1) return parameters;
  hasRequiredParameters$1 = 1;
  Object.defineProperty(parameters, "__esModule", { value: true });
  parameters.Parameters = Parameters;
  const index_1 = requireTuple();
  function Parameters(schema2, options) {
    return (0, index_1.Tuple)(schema2.parameters, options);
  }
  return parameters;
}
var hasRequiredParameters;
function requireParameters() {
  if (hasRequiredParameters) return parameters$1;
  hasRequiredParameters = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireParameters$1(), exports$12);
  })(parameters$1);
  return parameters$1;
}
var partial$1 = {};
var partialFromMappedResult = {};
var partial = {};
var hasRequiredPartial$1;
function requirePartial$1() {
  if (hasRequiredPartial$1) return partial;
  hasRequiredPartial$1 = 1;
  Object.defineProperty(partial, "__esModule", { value: true });
  partial.Partial = Partial;
  const type_1 = requireType$5();
  const index_1 = requireOptional();
  const index_2 = requireObject$1();
  const index_3 = requireIntersect();
  const index_4 = requireUnion$1();
  const index_5 = requireDiscard();
  const index_6 = requireSymbols();
  const partial_from_mapped_result_1 = requirePartialFromMappedResult();
  const kind_1 = requireKind();
  function FromRest(T) {
    return T.map((L) => PartialResolve(L));
  }
  function FromProperties(T) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(T))
      Acc[K] = (0, index_1.Optional)(T[K]);
    return Acc;
  }
  function FromObject(T) {
    const options = (0, index_5.Discard)(T, [index_6.TransformKind, "$id", "required", "properties"]);
    const properties = FromProperties(T["properties"]);
    return (0, index_2.Object)(properties, options);
  }
  function PartialResolve(T) {
    return (0, kind_1.IsIntersect)(T) ? (0, index_3.Intersect)(FromRest(T.allOf)) : (0, kind_1.IsUnion)(T) ? (0, index_4.Union)(FromRest(T.anyOf)) : (0, kind_1.IsObject)(T) ? FromObject(T) : (0, index_2.Object)({});
  }
  function Partial(T, options) {
    if ((0, kind_1.IsMappedResult)(T)) {
      return (0, partial_from_mapped_result_1.PartialFromMappedResult)(T, options);
    } else {
      return (0, type_1.CreateType)({ ...PartialResolve(T), ...options });
    }
  }
  return partial;
}
var hasRequiredPartialFromMappedResult;
function requirePartialFromMappedResult() {
  if (hasRequiredPartialFromMappedResult) return partialFromMappedResult;
  hasRequiredPartialFromMappedResult = 1;
  Object.defineProperty(partialFromMappedResult, "__esModule", { value: true });
  partialFromMappedResult.PartialFromMappedResult = PartialFromMappedResult;
  const index_1 = requireMapped();
  const partial_1 = requirePartial$1();
  const value_1 = requireValue();
  function FromProperties(K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
      Acc[K2] = (0, partial_1.Partial)(K[K2], (0, value_1.Clone)(options));
    return Acc;
  }
  function FromMappedResult(R, options) {
    return FromProperties(R.properties, options);
  }
  function PartialFromMappedResult(R, options) {
    const P = FromMappedResult(R, options);
    return (0, index_1.MappedResult)(P);
  }
  return partialFromMappedResult;
}
var hasRequiredPartial;
function requirePartial() {
  if (hasRequiredPartial) return partial$1;
  hasRequiredPartial = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requirePartialFromMappedResult(), exports$12);
    __exportStar(requirePartial$1(), exports$12);
  })(partial$1);
  return partial$1;
}
var pick$1 = {};
var pickFromMappedKey = {};
var pick = {};
var pickFromMappedResult = {};
var hasRequiredPickFromMappedResult;
function requirePickFromMappedResult() {
  if (hasRequiredPickFromMappedResult) return pickFromMappedResult;
  hasRequiredPickFromMappedResult = 1;
  Object.defineProperty(pickFromMappedResult, "__esModule", { value: true });
  pickFromMappedResult.PickFromMappedResult = PickFromMappedResult;
  const index_1 = requireMapped();
  const pick_1 = requirePick$1();
  const value_1 = requireValue();
  function FromProperties(P, K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, pick_1.Pick)(P[K2], K, (0, value_1.Clone)(options));
    return Acc;
  }
  function FromMappedResult(R, K, options) {
    return FromProperties(R.properties, K, options);
  }
  function PickFromMappedResult(R, K, options) {
    const P = FromMappedResult(R, K, options);
    return (0, index_1.MappedResult)(P);
  }
  return pickFromMappedResult;
}
var hasRequiredPick$1;
function requirePick$1() {
  if (hasRequiredPick$1) return pick;
  hasRequiredPick$1 = 1;
  Object.defineProperty(pick, "__esModule", { value: true });
  pick.Pick = Pick;
  const type_1 = requireType$5();
  const discard_1 = requireDiscard$1();
  const index_1 = requireIntersect();
  const index_2 = requireUnion$1();
  const index_3 = requireObject$1();
  const index_4 = requireIndexed();
  const pick_from_mapped_key_1 = requirePickFromMappedKey();
  const pick_from_mapped_result_1 = requirePickFromMappedResult();
  const symbols_1 = requireSymbols$1();
  const kind_1 = requireKind();
  function FromIntersect(T, K) {
    return T.map((T2) => PickResolve(T2, K));
  }
  function FromUnion(T, K) {
    return T.map((T2) => PickResolve(T2, K));
  }
  function FromProperties(T, K) {
    const Acc = {};
    for (const K2 of K)
      if (K2 in T)
        Acc[K2] = T[K2];
    return Acc;
  }
  function FromObject(T, K) {
    const options = (0, discard_1.Discard)(T, [symbols_1.TransformKind, "$id", "required", "properties"]);
    const properties = FromProperties(T["properties"], K);
    return (0, index_3.Object)(properties, options);
  }
  function PickResolve(T, K) {
    return (0, kind_1.IsIntersect)(T) ? (0, index_1.Intersect)(FromIntersect(T.allOf, K)) : (0, kind_1.IsUnion)(T) ? (0, index_2.Union)(FromUnion(T.anyOf, K)) : (0, kind_1.IsObject)(T) ? FromObject(T, K) : (0, index_3.Object)({});
  }
  function Pick(T, K, options) {
    if ((0, kind_1.IsMappedKey)(K))
      return (0, pick_from_mapped_key_1.PickFromMappedKey)(T, K, options);
    if ((0, kind_1.IsMappedResult)(T))
      return (0, pick_from_mapped_result_1.PickFromMappedResult)(T, K, options);
    const I = (0, kind_1.IsSchema)(K) ? (0, index_4.IndexPropertyKeys)(K) : K;
    return (0, type_1.CreateType)({ ...PickResolve(T, I), ...options });
  }
  return pick;
}
var hasRequiredPickFromMappedKey;
function requirePickFromMappedKey() {
  if (hasRequiredPickFromMappedKey) return pickFromMappedKey;
  hasRequiredPickFromMappedKey = 1;
  Object.defineProperty(pickFromMappedKey, "__esModule", { value: true });
  pickFromMappedKey.PickFromMappedKey = PickFromMappedKey;
  const index_1 = requireMapped();
  const pick_1 = requirePick$1();
  const value_1 = requireValue();
  function FromPropertyKey(T, K, options) {
    return {
      [K]: (0, pick_1.Pick)(T, [K], (0, value_1.Clone)(options))
    };
  }
  function FromPropertyKeys(T, K, options) {
    return K.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey(T, LK, options) };
    }, {});
  }
  function FromMappedKey(T, K, options) {
    return FromPropertyKeys(T, K.keys, options);
  }
  function PickFromMappedKey(T, K, options) {
    const P = FromMappedKey(T, K, options);
    return (0, index_1.MappedResult)(P);
  }
  return pickFromMappedKey;
}
var hasRequiredPick;
function requirePick() {
  if (hasRequiredPick) return pick$1;
  hasRequiredPick = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requirePickFromMappedKey(), exports$12);
    __exportStar(requirePickFromMappedResult(), exports$12);
    __exportStar(requirePick$1(), exports$12);
  })(pick$1);
  return pick$1;
}
var readonlyOptional$1 = {};
var readonlyOptional = {};
var hasRequiredReadonlyOptional$1;
function requireReadonlyOptional$1() {
  if (hasRequiredReadonlyOptional$1) return readonlyOptional;
  hasRequiredReadonlyOptional$1 = 1;
  Object.defineProperty(readonlyOptional, "__esModule", { value: true });
  readonlyOptional.ReadonlyOptional = ReadonlyOptional;
  const index_1 = requireReadonly();
  const index_2 = requireOptional();
  function ReadonlyOptional(schema2) {
    return (0, index_1.Readonly)((0, index_2.Optional)(schema2));
  }
  return readonlyOptional;
}
var hasRequiredReadonlyOptional;
function requireReadonlyOptional() {
  if (hasRequiredReadonlyOptional) return readonlyOptional$1;
  hasRequiredReadonlyOptional = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireReadonlyOptional$1(), exports$12);
  })(readonlyOptional$1);
  return readonlyOptional$1;
}
var record$1 = {};
var record = {};
var hasRequiredRecord$1;
function requireRecord$1() {
  if (hasRequiredRecord$1) return record;
  hasRequiredRecord$1 = 1;
  Object.defineProperty(record, "__esModule", { value: true });
  record.Record = Record;
  const type_1 = requireType$5();
  const index_1 = requireObject$1();
  const index_2 = requireNever();
  const index_3 = requireUnion$1();
  const index_4 = requireTemplateLiteral();
  const index_5 = requirePatterns();
  const index_6 = requireIndexed();
  const index_7 = requireSymbols();
  const value_1 = requireValue$1();
  const kind_1 = requireKind();
  function RecordCreateFromPattern(pattern2, T, options) {
    return (0, type_1.CreateType)({
      [index_7.Kind]: "Record",
      type: "object",
      patternProperties: { [pattern2]: T }
    }, options);
  }
  function RecordCreateFromKeys(K, T, options) {
    const Acc = {};
    for (const K2 of K)
      Acc[K2] = T;
    return (0, index_1.Object)(Acc, { ...options, [index_7.Hint]: "Record" });
  }
  function FromTemplateLiteralKey(K, T, options) {
    return (0, index_4.IsTemplateLiteralFinite)(K) ? RecordCreateFromKeys((0, index_6.IndexPropertyKeys)(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
  }
  function FromUnionKey(K, T, options) {
    return RecordCreateFromKeys((0, index_6.IndexPropertyKeys)((0, index_3.Union)(K)), T, options);
  }
  function FromLiteralKey(K, T, options) {
    return RecordCreateFromKeys([K.toString()], T, options);
  }
  function FromRegExpKey(K, T, options) {
    return RecordCreateFromPattern(K.source, T, options);
  }
  function FromStringKey(K, T, options) {
    const pattern2 = (0, value_1.IsUndefined)(K.pattern) ? index_5.PatternStringExact : K.pattern;
    return RecordCreateFromPattern(pattern2, T, options);
  }
  function FromAnyKey(K, T, options) {
    return RecordCreateFromPattern(index_5.PatternStringExact, T, options);
  }
  function FromNeverKey(K, T, options) {
    return RecordCreateFromPattern(index_5.PatternNeverExact, T, options);
  }
  function FromIntegerKey(_, T, options) {
    return RecordCreateFromPattern(index_5.PatternNumberExact, T, options);
  }
  function FromNumberKey(_, T, options) {
    return RecordCreateFromPattern(index_5.PatternNumberExact, T, options);
  }
  function Record(K, T, options = {}) {
    return (0, kind_1.IsUnion)(K) ? FromUnionKey(K.anyOf, T, options) : (0, kind_1.IsTemplateLiteral)(K) ? FromTemplateLiteralKey(K, T, options) : (0, kind_1.IsLiteral)(K) ? FromLiteralKey(K.const, T, options) : (0, kind_1.IsInteger)(K) ? FromIntegerKey(K, T, options) : (0, kind_1.IsNumber)(K) ? FromNumberKey(K, T, options) : (0, kind_1.IsRegExp)(K) ? FromRegExpKey(K, T, options) : (0, kind_1.IsString)(K) ? FromStringKey(K, T, options) : (0, kind_1.IsAny)(K) ? FromAnyKey(K, T, options) : (0, kind_1.IsNever)(K) ? FromNeverKey(K, T, options) : (0, index_2.Never)(options);
  }
  return record;
}
var hasRequiredRecord;
function requireRecord() {
  if (hasRequiredRecord) return record$1;
  hasRequiredRecord = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireRecord$1(), exports$12);
  })(record$1);
  return record$1;
}
var recursive$1 = {};
var recursive = {};
var hasRequiredRecursive$1;
function requireRecursive$1() {
  if (hasRequiredRecursive$1) return recursive;
  hasRequiredRecursive$1 = 1;
  Object.defineProperty(recursive, "__esModule", { value: true });
  recursive.Recursive = Recursive;
  const type_1 = requireType$6();
  const type_2 = requireType$5();
  const value_1 = requireValue$1();
  const index_1 = requireSymbols();
  let Ordinal = 0;
  function Recursive(callback, options = {}) {
    if ((0, value_1.IsUndefined)(options.$id))
      options.$id = `T${Ordinal++}`;
    const thisType = (0, type_1.CloneType)(callback({ [index_1.Kind]: "This", $ref: `${options.$id}` }));
    thisType.$id = options.$id;
    return (0, type_2.CreateType)({ [index_1.Hint]: "Recursive", ...thisType }, options);
  }
  return recursive;
}
var hasRequiredRecursive;
function requireRecursive() {
  if (hasRequiredRecursive) return recursive$1;
  hasRequiredRecursive = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireRecursive$1(), exports$12);
  })(recursive$1);
  return recursive$1;
}
var ref$1 = {};
var ref = {};
var hasRequiredRef$1;
function requireRef$1() {
  if (hasRequiredRef$1) return ref;
  hasRequiredRef$1 = 1;
  Object.defineProperty(ref, "__esModule", { value: true });
  ref.Ref = Ref;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  const value_1 = requireValue$1();
  function Ref(unresolved, options) {
    if ((0, value_1.IsString)(unresolved))
      return (0, type_1.CreateType)({ [index_1.Kind]: "Ref", $ref: unresolved }, options);
    if ((0, value_1.IsUndefined)(unresolved.$id))
      throw new Error("Reference target type must specify an $id");
    return (0, type_1.CreateType)({ [index_1.Kind]: "Ref", $ref: unresolved.$id }, options);
  }
  return ref;
}
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref$1;
  hasRequiredRef = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireRef$1(), exports$12);
  })(ref$1);
  return ref$1;
}
var regexp$1 = {};
var regexp = {};
var hasRequiredRegexp$1;
function requireRegexp$1() {
  if (hasRequiredRegexp$1) return regexp;
  hasRequiredRegexp$1 = 1;
  Object.defineProperty(regexp, "__esModule", { value: true });
  regexp.RegExp = RegExp2;
  const type_1 = requireType$5();
  const value_1 = requireValue$1();
  const index_1 = requireSymbols();
  function RegExp2(unresolved, options) {
    const expr = (0, value_1.IsString)(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
    return (0, type_1.CreateType)({ [index_1.Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
  }
  return regexp;
}
var hasRequiredRegexp;
function requireRegexp() {
  if (hasRequiredRegexp) return regexp$1;
  hasRequiredRegexp = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireRegexp$1(), exports$12);
  })(regexp$1);
  return regexp$1;
}
var required$1 = {};
var requiredFromMappedResult = {};
var required = {};
var hasRequiredRequired$1;
function requireRequired$1() {
  if (hasRequiredRequired$1) return required;
  hasRequiredRequired$1 = 1;
  Object.defineProperty(required, "__esModule", { value: true });
  required.Required = Required;
  const type_1 = requireType$5();
  const index_1 = requireIntersect();
  const index_2 = requireUnion$1();
  const index_3 = requireObject$1();
  const index_4 = requireSymbols();
  const index_5 = requireDiscard();
  const required_from_mapped_result_1 = requireRequiredFromMappedResult();
  const kind_1 = requireKind();
  function FromRest(T) {
    return T.map((L) => RequiredResolve(L));
  }
  function FromProperties(T) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(T))
      Acc[K] = (0, index_5.Discard)(T[K], [index_4.OptionalKind]);
    return Acc;
  }
  function FromObject(T) {
    const options = (0, index_5.Discard)(T, [index_4.TransformKind, "$id", "required", "properties"]);
    const properties = FromProperties(T["properties"]);
    return (0, index_3.Object)(properties, options);
  }
  function RequiredResolve(T) {
    return (0, kind_1.IsIntersect)(T) ? (0, index_1.Intersect)(FromRest(T.allOf)) : (0, kind_1.IsUnion)(T) ? (0, index_2.Union)(FromRest(T.anyOf)) : (0, kind_1.IsObject)(T) ? FromObject(T) : (0, index_3.Object)({});
  }
  function Required(T, options) {
    if ((0, kind_1.IsMappedResult)(T)) {
      return (0, required_from_mapped_result_1.RequiredFromMappedResult)(T, options);
    } else {
      return (0, type_1.CreateType)({ ...RequiredResolve(T), ...options });
    }
  }
  return required;
}
var hasRequiredRequiredFromMappedResult;
function requireRequiredFromMappedResult() {
  if (hasRequiredRequiredFromMappedResult) return requiredFromMappedResult;
  hasRequiredRequiredFromMappedResult = 1;
  Object.defineProperty(requiredFromMappedResult, "__esModule", { value: true });
  requiredFromMappedResult.RequiredFromMappedResult = RequiredFromMappedResult;
  const index_1 = requireMapped();
  const required_1 = requireRequired$1();
  function FromProperties(P, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, required_1.Required)(P[K2], options);
    return Acc;
  }
  function FromMappedResult(R, options) {
    return FromProperties(R.properties, options);
  }
  function RequiredFromMappedResult(R, options) {
    const P = FromMappedResult(R, options);
    return (0, index_1.MappedResult)(P);
  }
  return requiredFromMappedResult;
}
var hasRequiredRequired;
function requireRequired() {
  if (hasRequiredRequired) return required$1;
  hasRequiredRequired = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireRequiredFromMappedResult(), exports$12);
    __exportStar(requireRequired$1(), exports$12);
  })(required$1);
  return required$1;
}
var rest$1 = {};
var rest = {};
var hasRequiredRest$1;
function requireRest$1() {
  if (hasRequiredRest$1) return rest;
  hasRequiredRest$1 = 1;
  Object.defineProperty(rest, "__esModule", { value: true });
  rest.Rest = Rest;
  const kind_1 = requireKind();
  function RestResolve(T) {
    return (0, kind_1.IsIntersect)(T) ? T.allOf : (0, kind_1.IsUnion)(T) ? T.anyOf : (0, kind_1.IsTuple)(T) ? T.items ?? [] : [];
  }
  function Rest(T) {
    return RestResolve(T);
  }
  return rest;
}
var hasRequiredRest;
function requireRest() {
  if (hasRequiredRest) return rest$1;
  hasRequiredRest = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireRest$1(), exports$12);
  })(rest$1);
  return rest$1;
}
var returnType$1 = {};
var returnType = {};
var hasRequiredReturnType$1;
function requireReturnType$1() {
  if (hasRequiredReturnType$1) return returnType;
  hasRequiredReturnType$1 = 1;
  Object.defineProperty(returnType, "__esModule", { value: true });
  returnType.ReturnType = ReturnType;
  const type_1 = requireType$5();
  function ReturnType(schema2, options) {
    return (0, type_1.CreateType)(schema2.returns, options);
  }
  return returnType;
}
var hasRequiredReturnType;
function requireReturnType() {
  if (hasRequiredReturnType) return returnType$1;
  hasRequiredReturnType = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireReturnType$1(), exports$12);
  })(returnType$1);
  return returnType$1;
}
var schema$1 = {};
var anyschema = {};
var hasRequiredAnyschema;
function requireAnyschema() {
  if (hasRequiredAnyschema) return anyschema;
  hasRequiredAnyschema = 1;
  Object.defineProperty(anyschema, "__esModule", { value: true });
  return anyschema;
}
var schema = {};
var hasRequiredSchema$1;
function requireSchema$1() {
  if (hasRequiredSchema$1) return schema;
  hasRequiredSchema$1 = 1;
  Object.defineProperty(schema, "__esModule", { value: true });
  requireSymbols();
  return schema;
}
var hasRequiredSchema;
function requireSchema() {
  if (hasRequiredSchema) return schema$1;
  hasRequiredSchema = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireAnyschema(), exports$12);
    __exportStar(requireSchema$1(), exports$12);
  })(schema$1);
  return schema$1;
}
var _static$1 = {};
var _static = {};
var hasRequired_static$1;
function require_static$1() {
  if (hasRequired_static$1) return _static;
  hasRequired_static$1 = 1;
  Object.defineProperty(_static, "__esModule", { value: true });
  return _static;
}
var hasRequired_static;
function require_static() {
  if (hasRequired_static) return _static$1;
  hasRequired_static = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(require_static$1(), exports$12);
  })(_static$1);
  return _static$1;
}
var strict$1 = {};
var strict = {};
var hasRequiredStrict$1;
function requireStrict$1() {
  if (hasRequiredStrict$1) return strict;
  hasRequiredStrict$1 = 1;
  Object.defineProperty(strict, "__esModule", { value: true });
  strict.Strict = Strict;
  function Strict(schema2) {
    return JSON.parse(JSON.stringify(schema2));
  }
  return strict;
}
var hasRequiredStrict;
function requireStrict() {
  if (hasRequiredStrict) return strict$1;
  hasRequiredStrict = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireStrict$1(), exports$12);
  })(strict$1);
  return strict$1;
}
var transform$1 = {};
var transform = {};
var hasRequiredTransform$1;
function requireTransform$1() {
  if (hasRequiredTransform$1) return transform;
  hasRequiredTransform$1 = 1;
  Object.defineProperty(transform, "__esModule", { value: true });
  transform.TransformEncodeBuilder = transform.TransformDecodeBuilder = void 0;
  transform.Transform = Transform;
  const index_1 = requireSymbols();
  const kind_1 = requireKind();
  class TransformDecodeBuilder {
    constructor(schema2) {
      this.schema = schema2;
    }
    Decode(decode2) {
      return new TransformEncodeBuilder(this.schema, decode2);
    }
  }
  transform.TransformDecodeBuilder = TransformDecodeBuilder;
  class TransformEncodeBuilder {
    constructor(schema2, decode2) {
      this.schema = schema2;
      this.decode = decode2;
    }
    EncodeTransform(encode2, schema2) {
      const Encode = (value2) => schema2[index_1.TransformKind].Encode(encode2(value2));
      const Decode = (value2) => this.decode(schema2[index_1.TransformKind].Decode(value2));
      const Codec = { Encode, Decode };
      return { ...schema2, [index_1.TransformKind]: Codec };
    }
    EncodeSchema(encode2, schema2) {
      const Codec = { Decode: this.decode, Encode: encode2 };
      return { ...schema2, [index_1.TransformKind]: Codec };
    }
    Encode(encode2) {
      return (0, kind_1.IsTransform)(this.schema) ? this.EncodeTransform(encode2, this.schema) : this.EncodeSchema(encode2, this.schema);
    }
  }
  transform.TransformEncodeBuilder = TransformEncodeBuilder;
  function Transform(schema2) {
    return new TransformDecodeBuilder(schema2);
  }
  return transform;
}
var hasRequiredTransform;
function requireTransform() {
  if (hasRequiredTransform) return transform$1;
  hasRequiredTransform = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireTransform$1(), exports$12);
  })(transform$1);
  return transform$1;
}
var unsafe$1 = {};
var unsafe = {};
var hasRequiredUnsafe$1;
function requireUnsafe$1() {
  if (hasRequiredUnsafe$1) return unsafe;
  hasRequiredUnsafe$1 = 1;
  Object.defineProperty(unsafe, "__esModule", { value: true });
  unsafe.Unsafe = Unsafe;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Unsafe(options = {}) {
    return (0, type_1.CreateType)({ [index_1.Kind]: options[index_1.Kind] ?? "Unsafe" }, options);
  }
  return unsafe;
}
var hasRequiredUnsafe;
function requireUnsafe() {
  if (hasRequiredUnsafe) return unsafe$1;
  hasRequiredUnsafe = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireUnsafe$1(), exports$12);
  })(unsafe$1);
  return unsafe$1;
}
var _void$1 = {};
var _void = {};
var hasRequired_void$1;
function require_void$1() {
  if (hasRequired_void$1) return _void;
  hasRequired_void$1 = 1;
  Object.defineProperty(_void, "__esModule", { value: true });
  _void.Void = Void;
  const type_1 = requireType$5();
  const index_1 = requireSymbols();
  function Void(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Void", type: "void" }, options);
  }
  return _void;
}
var hasRequired_void;
function require_void() {
  if (hasRequired_void) return _void$1;
  hasRequired_void = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(require_void$1(), exports$12);
  })(_void$1);
  return _void$1;
}
var type$2 = {};
var json = {};
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json;
  hasRequiredJson = 1;
  Object.defineProperty(json, "__esModule", { value: true });
  json.JsonTypeBuilder = void 0;
  const index_1 = requireAny();
  const index_2 = requireArray();
  const index_3 = requireBoolean();
  const index_4 = requireComposite();
  const index_5 = require_const();
  const index_6 = requireDeref$2();
  const index_7 = require_enum$1();
  const index_8 = requireExclude();
  const index_9 = require_extends();
  const index_10 = requireExtract();
  const index_11 = requireIndexed();
  const index_12 = requireInteger();
  const index_13 = requireIntersect();
  const index_14 = requireIntrinsic();
  const index_15 = requireKeyof();
  const index_16 = requireLiteral();
  const index_17 = requireMapped();
  const index_18 = requireNever();
  const index_19 = requireNot();
  const index_20 = require_null();
  const index_21 = requireNumber();
  const index_22 = requireObject$1();
  const index_23 = requireOmit();
  const index_24 = requireOptional();
  const index_25 = requirePartial();
  const index_26 = requirePick();
  const index_27 = requireReadonly();
  const index_28 = requireReadonlyOptional();
  const index_29 = requireRecord();
  const index_30 = requireRecursive();
  const index_31 = requireRef();
  const index_32 = requireRequired();
  const index_33 = requireRest();
  const index_34 = requireStrict();
  const index_35 = requireString();
  const index_36 = requireTemplateLiteral();
  const index_37 = requireTransform();
  const index_38 = requireTuple();
  const index_39 = requireUnion$1();
  const index_40 = requireUnknown();
  const index_41 = requireUnsafe();
  class JsonTypeBuilder {
    // ------------------------------------------------------------------------
    // Strict
    // ------------------------------------------------------------------------
    /**
     * @deprecated `[Json]` Omits compositing symbols from this schema. It is recommended
     * to use the JSON parse/stringify to remove compositing symbols if needed. This
     * is how Strict works internally.
     *
     * ```typescript
     * JSON.parse(JSON.stringify(Type.String()))
     * ```
     */
    Strict(schema2) {
      return (0, index_34.Strict)(schema2);
    }
    // ------------------------------------------------------------------------
    // Modifiers
    // ------------------------------------------------------------------------
    /** `[Json]` Creates a Readonly and Optional property */
    ReadonlyOptional(schema2) {
      return (0, index_28.ReadonlyOptional)(schema2);
    }
    /** `[Json]` Creates a Readonly property */
    Readonly(schema2, enable) {
      return (0, index_27.Readonly)(schema2, enable ?? true);
    }
    /** `[Json]` Creates a Optional property */
    Optional(schema2, enable) {
      return (0, index_24.Optional)(schema2, enable ?? true);
    }
    // ------------------------------------------------------------------------
    // Types
    // ------------------------------------------------------------------------
    /** `[Json]` Creates an Any type */
    Any(options) {
      return (0, index_1.Any)(options);
    }
    /** `[Json]` Creates an Array type */
    Array(schema2, options) {
      return (0, index_2.Array)(schema2, options);
    }
    /** `[Json]` Creates a Boolean type */
    Boolean(options) {
      return (0, index_3.Boolean)(options);
    }
    /** `[Json]` Intrinsic function to Capitalize LiteralString types */
    Capitalize(schema2, options) {
      return (0, index_14.Capitalize)(schema2, options);
    }
    /** `[Json]` Creates a Composite object type */
    Composite(schemas, options) {
      return (0, index_4.Composite)(schemas, options);
    }
    /** `[JavaScript]` Creates a readonly const type from the given value. */
    Const(value2, options) {
      return (0, index_5.Const)(value2, options);
    }
    /** `[Json]` Creates a dereferenced type */
    Deref(schema2, references) {
      return (0, index_6.Deref)(schema2, references);
    }
    /** `[Json]` Creates a Enum type */
    Enum(item, options) {
      return (0, index_7.Enum)(item, options);
    }
    /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
    Exclude(unionType2, excludedMembers, options) {
      return (0, index_8.Exclude)(unionType2, excludedMembers, options);
    }
    /** `[Json]` Creates a Conditional type */
    Extends(L, R, T, F, options) {
      return (0, index_9.Extends)(L, R, T, F, options);
    }
    /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
    Extract(type2, union2, options) {
      return (0, index_10.Extract)(type2, union2, options);
    }
    /** `[Json]` Returns an Indexed property type for the given keys */
    Index(schema2, unresolved, options) {
      return (0, index_11.Index)(schema2, unresolved, options);
    }
    /** `[Json]` Creates an Integer type */
    Integer(options) {
      return (0, index_12.Integer)(options);
    }
    /** `[Json]` Creates an Intersect type */
    Intersect(T, options) {
      return (0, index_13.Intersect)(T, options);
    }
    /** `[Json]` Creates a KeyOf type */
    KeyOf(schema2, options) {
      return (0, index_15.KeyOf)(schema2, options);
    }
    /** `[Json]` Creates a Literal type */
    Literal(value2, options) {
      return (0, index_16.Literal)(value2, options);
    }
    /** `[Json]` Intrinsic function to Lowercase LiteralString types */
    Lowercase(schema2, options) {
      return (0, index_14.Lowercase)(schema2, options);
    }
    /** `[Json]` Creates a Mapped object type */
    Mapped(key, map, options) {
      return (0, index_17.Mapped)(key, map, options);
    }
    /** `[Json]` Creates a Never type */
    Never(options) {
      return (0, index_18.Never)(options);
    }
    /** `[Json]` Creates a Not type */
    Not(schema2, options) {
      return (0, index_19.Not)(schema2, options);
    }
    /** `[Json]` Creates a Null type */
    Null(options) {
      return (0, index_20.Null)(options);
    }
    /** `[Json]` Creates a Number type */
    Number(options) {
      return (0, index_21.Number)(options);
    }
    /** `[Json]` Creates an Object type */
    Object(properties, options) {
      return (0, index_22.Object)(properties, options);
    }
    /** `[Json]` Constructs a type whose keys are omitted from the given type */
    Omit(schema2, unresolved, options) {
      return (0, index_23.Omit)(schema2, unresolved, options);
    }
    /** `[Json]` Constructs a type where all properties are optional */
    Partial(schema2, options) {
      return (0, index_25.Partial)(schema2, options);
    }
    /** `[Json]` Constructs a type whose keys are picked from the given type */
    Pick(schema2, unresolved, options) {
      return (0, index_26.Pick)(schema2, unresolved, options);
    }
    /** `[Json]` Creates a Record type */
    Record(key, schema2, options) {
      return (0, index_29.Record)(key, schema2, options);
    }
    /** `[Json]` Creates a Recursive type */
    Recursive(callback, options) {
      return (0, index_30.Recursive)(callback, options);
    }
    /** `[Json]` Creates a Ref type. */
    Ref(unresolved, options) {
      return (0, index_31.Ref)(unresolved, options);
    }
    /** `[Json]` Constructs a type where all properties are required */
    Required(schema2, options) {
      return (0, index_32.Required)(schema2, options);
    }
    /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
    Rest(schema2) {
      return (0, index_33.Rest)(schema2);
    }
    /** `[Json]` Creates a String type */
    String(options) {
      return (0, index_35.String)(options);
    }
    /** `[Json]` Creates a TemplateLiteral type */
    TemplateLiteral(unresolved, options) {
      return (0, index_36.TemplateLiteral)(unresolved, options);
    }
    /** `[Json]` Creates a Transform type */
    Transform(schema2) {
      return (0, index_37.Transform)(schema2);
    }
    /** `[Json]` Creates a Tuple type */
    Tuple(items, options) {
      return (0, index_38.Tuple)(items, options);
    }
    /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
    Uncapitalize(schema2, options) {
      return (0, index_14.Uncapitalize)(schema2, options);
    }
    /** `[Json]` Creates a Union type */
    Union(schemas, options) {
      return (0, index_39.Union)(schemas, options);
    }
    /** `[Json]` Creates an Unknown type */
    Unknown(options) {
      return (0, index_40.Unknown)(options);
    }
    /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
    Unsafe(options) {
      return (0, index_41.Unsafe)(options);
    }
    /** `[Json]` Intrinsic function to Uppercase LiteralString types */
    Uppercase(schema2, options) {
      return (0, index_14.Uppercase)(schema2, options);
    }
  }
  json.JsonTypeBuilder = JsonTypeBuilder;
  return json;
}
var type$1 = {};
var hasRequiredType$2;
function requireType$2() {
  if (hasRequiredType$2) return type$1;
  hasRequiredType$2 = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", { value: true });
    exports$12.String = exports$12.ReturnType = exports$12.Rest = exports$12.Required = exports$12.RegExp = exports$12.Ref = exports$12.Recursive = exports$12.Record = exports$12.ReadonlyOptional = exports$12.Readonly = exports$12.Promise = exports$12.Pick = exports$12.Partial = exports$12.Parameters = exports$12.Optional = exports$12.Omit = exports$12.Object = exports$12.Number = exports$12.Null = exports$12.Not = exports$12.Never = exports$12.Mapped = exports$12.Literal = exports$12.KeyOf = exports$12.Iterator = exports$12.Uppercase = exports$12.Lowercase = exports$12.Uncapitalize = exports$12.Capitalize = exports$12.Intersect = exports$12.Integer = exports$12.InstanceType = exports$12.Index = exports$12.Function = exports$12.Extract = exports$12.Extends = exports$12.Exclude = exports$12.Enum = exports$12.Deref = exports$12.Date = exports$12.ConstructorParameters = exports$12.Constructor = exports$12.Const = exports$12.Composite = exports$12.Boolean = exports$12.BigInt = exports$12.Awaited = exports$12.AsyncIterator = exports$12.Array = exports$12.Any = void 0;
    exports$12.Void = exports$12.Unsafe = exports$12.Unknown = exports$12.Union = exports$12.Undefined = exports$12.Uint8Array = exports$12.Tuple = exports$12.Transform = exports$12.TemplateLiteral = exports$12.Symbol = exports$12.Strict = void 0;
    var index_1 = requireAny();
    Object.defineProperty(exports$12, "Any", { enumerable: true, get: function() {
      return index_1.Any;
    } });
    var index_2 = requireArray();
    Object.defineProperty(exports$12, "Array", { enumerable: true, get: function() {
      return index_2.Array;
    } });
    var index_3 = requireAsyncIterator();
    Object.defineProperty(exports$12, "AsyncIterator", { enumerable: true, get: function() {
      return index_3.AsyncIterator;
    } });
    var index_4 = requireAwaited();
    Object.defineProperty(exports$12, "Awaited", { enumerable: true, get: function() {
      return index_4.Awaited;
    } });
    var index_5 = requireBigint();
    Object.defineProperty(exports$12, "BigInt", { enumerable: true, get: function() {
      return index_5.BigInt;
    } });
    var index_6 = requireBoolean();
    Object.defineProperty(exports$12, "Boolean", { enumerable: true, get: function() {
      return index_6.Boolean;
    } });
    var index_7 = requireComposite();
    Object.defineProperty(exports$12, "Composite", { enumerable: true, get: function() {
      return index_7.Composite;
    } });
    var index_8 = require_const();
    Object.defineProperty(exports$12, "Const", { enumerable: true, get: function() {
      return index_8.Const;
    } });
    var index_9 = requireConstructor();
    Object.defineProperty(exports$12, "Constructor", { enumerable: true, get: function() {
      return index_9.Constructor;
    } });
    var index_10 = requireConstructorParameters();
    Object.defineProperty(exports$12, "ConstructorParameters", { enumerable: true, get: function() {
      return index_10.ConstructorParameters;
    } });
    var index_11 = requireDate();
    Object.defineProperty(exports$12, "Date", { enumerable: true, get: function() {
      return index_11.Date;
    } });
    var index_12 = requireDeref$2();
    Object.defineProperty(exports$12, "Deref", { enumerable: true, get: function() {
      return index_12.Deref;
    } });
    var index_13 = require_enum$1();
    Object.defineProperty(exports$12, "Enum", { enumerable: true, get: function() {
      return index_13.Enum;
    } });
    var index_14 = requireExclude();
    Object.defineProperty(exports$12, "Exclude", { enumerable: true, get: function() {
      return index_14.Exclude;
    } });
    var index_15 = require_extends();
    Object.defineProperty(exports$12, "Extends", { enumerable: true, get: function() {
      return index_15.Extends;
    } });
    var index_16 = requireExtract();
    Object.defineProperty(exports$12, "Extract", { enumerable: true, get: function() {
      return index_16.Extract;
    } });
    var index_17 = require_function$1();
    Object.defineProperty(exports$12, "Function", { enumerable: true, get: function() {
      return index_17.Function;
    } });
    var index_18 = requireIndexed();
    Object.defineProperty(exports$12, "Index", { enumerable: true, get: function() {
      return index_18.Index;
    } });
    var index_19 = requireInstanceType();
    Object.defineProperty(exports$12, "InstanceType", { enumerable: true, get: function() {
      return index_19.InstanceType;
    } });
    var index_20 = requireInteger();
    Object.defineProperty(exports$12, "Integer", { enumerable: true, get: function() {
      return index_20.Integer;
    } });
    var index_21 = requireIntersect();
    Object.defineProperty(exports$12, "Intersect", { enumerable: true, get: function() {
      return index_21.Intersect;
    } });
    var index_22 = requireIntrinsic();
    Object.defineProperty(exports$12, "Capitalize", { enumerable: true, get: function() {
      return index_22.Capitalize;
    } });
    Object.defineProperty(exports$12, "Uncapitalize", { enumerable: true, get: function() {
      return index_22.Uncapitalize;
    } });
    Object.defineProperty(exports$12, "Lowercase", { enumerable: true, get: function() {
      return index_22.Lowercase;
    } });
    Object.defineProperty(exports$12, "Uppercase", { enumerable: true, get: function() {
      return index_22.Uppercase;
    } });
    var index_23 = requireIterator();
    Object.defineProperty(exports$12, "Iterator", { enumerable: true, get: function() {
      return index_23.Iterator;
    } });
    var index_24 = requireKeyof();
    Object.defineProperty(exports$12, "KeyOf", { enumerable: true, get: function() {
      return index_24.KeyOf;
    } });
    var index_25 = requireLiteral();
    Object.defineProperty(exports$12, "Literal", { enumerable: true, get: function() {
      return index_25.Literal;
    } });
    var index_26 = requireMapped();
    Object.defineProperty(exports$12, "Mapped", { enumerable: true, get: function() {
      return index_26.Mapped;
    } });
    var index_27 = requireNever();
    Object.defineProperty(exports$12, "Never", { enumerable: true, get: function() {
      return index_27.Never;
    } });
    var index_28 = requireNot();
    Object.defineProperty(exports$12, "Not", { enumerable: true, get: function() {
      return index_28.Not;
    } });
    var index_29 = require_null();
    Object.defineProperty(exports$12, "Null", { enumerable: true, get: function() {
      return index_29.Null;
    } });
    var index_30 = requireNumber();
    Object.defineProperty(exports$12, "Number", { enumerable: true, get: function() {
      return index_30.Number;
    } });
    var index_31 = requireObject$1();
    Object.defineProperty(exports$12, "Object", { enumerable: true, get: function() {
      return index_31.Object;
    } });
    var index_32 = requireOmit();
    Object.defineProperty(exports$12, "Omit", { enumerable: true, get: function() {
      return index_32.Omit;
    } });
    var index_33 = requireOptional();
    Object.defineProperty(exports$12, "Optional", { enumerable: true, get: function() {
      return index_33.Optional;
    } });
    var index_34 = requireParameters();
    Object.defineProperty(exports$12, "Parameters", { enumerable: true, get: function() {
      return index_34.Parameters;
    } });
    var index_35 = requirePartial();
    Object.defineProperty(exports$12, "Partial", { enumerable: true, get: function() {
      return index_35.Partial;
    } });
    var index_36 = requirePick();
    Object.defineProperty(exports$12, "Pick", { enumerable: true, get: function() {
      return index_36.Pick;
    } });
    var index_37 = requirePromise();
    Object.defineProperty(exports$12, "Promise", { enumerable: true, get: function() {
      return index_37.Promise;
    } });
    var index_38 = requireReadonly();
    Object.defineProperty(exports$12, "Readonly", { enumerable: true, get: function() {
      return index_38.Readonly;
    } });
    var index_39 = requireReadonlyOptional();
    Object.defineProperty(exports$12, "ReadonlyOptional", { enumerable: true, get: function() {
      return index_39.ReadonlyOptional;
    } });
    var index_40 = requireRecord();
    Object.defineProperty(exports$12, "Record", { enumerable: true, get: function() {
      return index_40.Record;
    } });
    var index_41 = requireRecursive();
    Object.defineProperty(exports$12, "Recursive", { enumerable: true, get: function() {
      return index_41.Recursive;
    } });
    var index_42 = requireRef();
    Object.defineProperty(exports$12, "Ref", { enumerable: true, get: function() {
      return index_42.Ref;
    } });
    var index_43 = requireRegexp();
    Object.defineProperty(exports$12, "RegExp", { enumerable: true, get: function() {
      return index_43.RegExp;
    } });
    var index_44 = requireRequired();
    Object.defineProperty(exports$12, "Required", { enumerable: true, get: function() {
      return index_44.Required;
    } });
    var index_45 = requireRest();
    Object.defineProperty(exports$12, "Rest", { enumerable: true, get: function() {
      return index_45.Rest;
    } });
    var index_46 = requireReturnType();
    Object.defineProperty(exports$12, "ReturnType", { enumerable: true, get: function() {
      return index_46.ReturnType;
    } });
    var index_47 = requireString();
    Object.defineProperty(exports$12, "String", { enumerable: true, get: function() {
      return index_47.String;
    } });
    var index_48 = requireStrict();
    Object.defineProperty(exports$12, "Strict", { enumerable: true, get: function() {
      return index_48.Strict;
    } });
    var index_49 = requireSymbol();
    Object.defineProperty(exports$12, "Symbol", { enumerable: true, get: function() {
      return index_49.Symbol;
    } });
    var index_50 = requireTemplateLiteral();
    Object.defineProperty(exports$12, "TemplateLiteral", { enumerable: true, get: function() {
      return index_50.TemplateLiteral;
    } });
    var index_51 = requireTransform();
    Object.defineProperty(exports$12, "Transform", { enumerable: true, get: function() {
      return index_51.Transform;
    } });
    var index_52 = requireTuple();
    Object.defineProperty(exports$12, "Tuple", { enumerable: true, get: function() {
      return index_52.Tuple;
    } });
    var index_53 = requireUint8array();
    Object.defineProperty(exports$12, "Uint8Array", { enumerable: true, get: function() {
      return index_53.Uint8Array;
    } });
    var index_54 = require_undefined();
    Object.defineProperty(exports$12, "Undefined", { enumerable: true, get: function() {
      return index_54.Undefined;
    } });
    var index_55 = requireUnion$1();
    Object.defineProperty(exports$12, "Union", { enumerable: true, get: function() {
      return index_55.Union;
    } });
    var index_56 = requireUnknown();
    Object.defineProperty(exports$12, "Unknown", { enumerable: true, get: function() {
      return index_56.Unknown;
    } });
    var index_57 = requireUnsafe();
    Object.defineProperty(exports$12, "Unsafe", { enumerable: true, get: function() {
      return index_57.Unsafe;
    } });
    var index_58 = require_void();
    Object.defineProperty(exports$12, "Void", { enumerable: true, get: function() {
      return index_58.Void;
    } });
  })(type$1);
  return type$1;
}
var javascript = {};
var hasRequiredJavascript;
function requireJavascript() {
  if (hasRequiredJavascript) return javascript;
  hasRequiredJavascript = 1;
  Object.defineProperty(javascript, "__esModule", { value: true });
  javascript.JavaScriptTypeBuilder = void 0;
  const json_1 = requireJson();
  const index_1 = requireAsyncIterator();
  const index_2 = requireAwaited();
  const index_3 = requireBigint();
  const index_4 = requireConstructor();
  const index_5 = requireConstructorParameters();
  const index_6 = requireDate();
  const index_7 = require_function$1();
  const index_8 = requireInstanceType();
  const index_9 = requireIterator();
  const index_10 = requireParameters();
  const index_11 = requirePromise();
  const index_12 = requireRegexp();
  const index_13 = requireReturnType();
  const index_14 = requireSymbol();
  const index_15 = requireUint8array();
  const index_16 = require_undefined();
  const index_17 = require_void();
  class JavaScriptTypeBuilder extends json_1.JsonTypeBuilder {
    /** `[JavaScript]` Creates a AsyncIterator type */
    AsyncIterator(items, options) {
      return (0, index_1.AsyncIterator)(items, options);
    }
    /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
    Awaited(schema2, options) {
      return (0, index_2.Awaited)(schema2, options);
    }
    /** `[JavaScript]` Creates a BigInt type */
    BigInt(options) {
      return (0, index_3.BigInt)(options);
    }
    /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
    ConstructorParameters(schema2, options) {
      return (0, index_5.ConstructorParameters)(schema2, options);
    }
    /** `[JavaScript]` Creates a Constructor type */
    Constructor(parameters2, returns, options) {
      return (0, index_4.Constructor)(parameters2, returns, options);
    }
    /** `[JavaScript]` Creates a Date type */
    Date(options = {}) {
      return (0, index_6.Date)(options);
    }
    /** `[JavaScript]` Creates a Function type */
    Function(parameters2, returns, options) {
      return (0, index_7.Function)(parameters2, returns, options);
    }
    /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
    InstanceType(schema2, options) {
      return (0, index_8.InstanceType)(schema2, options);
    }
    /** `[JavaScript]` Creates an Iterator type */
    Iterator(items, options) {
      return (0, index_9.Iterator)(items, options);
    }
    /** `[JavaScript]` Extracts the Parameters from the given Function type */
    Parameters(schema2, options) {
      return (0, index_10.Parameters)(schema2, options);
    }
    /** `[JavaScript]` Creates a Promise type */
    Promise(item, options) {
      return (0, index_11.Promise)(item, options);
    }
    /** `[JavaScript]` Creates a RegExp type */
    RegExp(unresolved, options) {
      return (0, index_12.RegExp)(unresolved, options);
    }
    /** `[JavaScript]` Extracts the ReturnType from the given Function type */
    ReturnType(schema2, options) {
      return (0, index_13.ReturnType)(schema2, options);
    }
    /** `[JavaScript]` Creates a Symbol type */
    Symbol(options) {
      return (0, index_14.Symbol)(options);
    }
    /** `[JavaScript]` Creates a Undefined type */
    Undefined(options) {
      return (0, index_16.Undefined)(options);
    }
    /** `[JavaScript]` Creates a Uint8Array type */
    Uint8Array(options) {
      return (0, index_15.Uint8Array)(options);
    }
    /** `[JavaScript]` Creates a Void type */
    Void(options) {
      return (0, index_17.Void)(options);
    }
  }
  javascript.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
  return javascript;
}
var hasRequiredType$1;
function requireType$1() {
  if (hasRequiredType$1) return type$2;
  hasRequiredType$1 = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", { value: true });
    exports$12.Type = exports$12.JavaScriptTypeBuilder = exports$12.JsonTypeBuilder = void 0;
    var json_1 = requireJson();
    Object.defineProperty(exports$12, "JsonTypeBuilder", { enumerable: true, get: function() {
      return json_1.JsonTypeBuilder;
    } });
    const TypeBuilder = requireType$2();
    const javascript_1 = requireJavascript();
    Object.defineProperty(exports$12, "JavaScriptTypeBuilder", { enumerable: true, get: function() {
      return javascript_1.JavaScriptTypeBuilder;
    } });
    const Type = TypeBuilder;
    exports$12.Type = Type;
  })(type$2);
  return type$2;
}
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireClone(), exports$12);
    __exportStar(requireCreate(), exports$12);
    __exportStar(requireError(), exports$12);
    __exportStar(requireGuard(), exports$12);
    __exportStar(requireHelpers(), exports$12);
    __exportStar(requirePatterns(), exports$12);
    __exportStar(requireRegistry(), exports$12);
    __exportStar(requireSets(), exports$12);
    __exportStar(requireSymbols(), exports$12);
    __exportStar(requireAny(), exports$12);
    __exportStar(requireArray(), exports$12);
    __exportStar(requireAsyncIterator(), exports$12);
    __exportStar(requireAwaited(), exports$12);
    __exportStar(requireBigint(), exports$12);
    __exportStar(requireBoolean(), exports$12);
    __exportStar(requireComposite(), exports$12);
    __exportStar(require_const(), exports$12);
    __exportStar(requireConstructor(), exports$12);
    __exportStar(requireConstructorParameters(), exports$12);
    __exportStar(requireDate(), exports$12);
    __exportStar(requireDeref$2(), exports$12);
    __exportStar(require_enum$1(), exports$12);
    __exportStar(requireExclude(), exports$12);
    __exportStar(require_extends(), exports$12);
    __exportStar(requireExtract(), exports$12);
    __exportStar(require_function$1(), exports$12);
    __exportStar(requireIndexed(), exports$12);
    __exportStar(requireInstanceType(), exports$12);
    __exportStar(requireInteger(), exports$12);
    __exportStar(requireIntersect(), exports$12);
    __exportStar(requireIterator(), exports$12);
    __exportStar(requireIntrinsic(), exports$12);
    __exportStar(requireKeyof(), exports$12);
    __exportStar(requireLiteral(), exports$12);
    __exportStar(requireMapped(), exports$12);
    __exportStar(requireNever(), exports$12);
    __exportStar(requireNot(), exports$12);
    __exportStar(require_null(), exports$12);
    __exportStar(requireNumber(), exports$12);
    __exportStar(requireObject$1(), exports$12);
    __exportStar(requireOmit(), exports$12);
    __exportStar(requireOptional(), exports$12);
    __exportStar(requireParameters(), exports$12);
    __exportStar(requirePartial(), exports$12);
    __exportStar(requirePick(), exports$12);
    __exportStar(requirePromise(), exports$12);
    __exportStar(requireReadonly(), exports$12);
    __exportStar(requireReadonlyOptional(), exports$12);
    __exportStar(requireRecord(), exports$12);
    __exportStar(requireRecursive(), exports$12);
    __exportStar(requireRef(), exports$12);
    __exportStar(requireRegexp(), exports$12);
    __exportStar(requireRequired(), exports$12);
    __exportStar(requireRest(), exports$12);
    __exportStar(requireReturnType(), exports$12);
    __exportStar(requireSchema(), exports$12);
    __exportStar(require_static(), exports$12);
    __exportStar(requireStrict(), exports$12);
    __exportStar(requireString(), exports$12);
    __exportStar(requireSymbol(), exports$12);
    __exportStar(requireTemplateLiteral(), exports$12);
    __exportStar(requireTransform(), exports$12);
    __exportStar(requireTuple(), exports$12);
    __exportStar(requireUint8array(), exports$12);
    __exportStar(require_undefined(), exports$12);
    __exportStar(requireUnion$1(), exports$12);
    __exportStar(requireUnknown(), exports$12);
    __exportStar(requireUnsafe(), exports$12);
    __exportStar(require_void(), exports$12);
    __exportStar(requireType$1(), exports$12);
  })(cjs);
  return cjs;
}
var errors$2 = {};
var errors$1 = {};
var system$1 = {};
var system = {};
var hasRequiredSystem$1;
function requireSystem$1() {
  if (hasRequiredSystem$1) return system;
  hasRequiredSystem$1 = 1;
  Object.defineProperty(system, "__esModule", { value: true });
  system.TypeSystem = system.TypeSystemDuplicateFormat = system.TypeSystemDuplicateTypeKind = void 0;
  const index_1 = requireRegistry();
  const index_2 = requireUnsafe();
  const index_3 = requireSymbols();
  const index_4 = requireError();
  class TypeSystemDuplicateTypeKind extends index_4.TypeBoxError {
    constructor(kind2) {
      super(`Duplicate type kind '${kind2}' detected`);
    }
  }
  system.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;
  class TypeSystemDuplicateFormat extends index_4.TypeBoxError {
    constructor(kind2) {
      super(`Duplicate string format '${kind2}' detected`);
    }
  }
  system.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
  var TypeSystem;
  (function(TypeSystem2) {
    function Type(kind2, check2) {
      if (index_1.TypeRegistry.Has(kind2))
        throw new TypeSystemDuplicateTypeKind(kind2);
      index_1.TypeRegistry.Set(kind2, check2);
      return (options = {}) => (0, index_2.Unsafe)({ ...options, [index_3.Kind]: kind2 });
    }
    TypeSystem2.Type = Type;
    function Format(format2, check2) {
      if (index_1.FormatRegistry.Has(format2))
        throw new TypeSystemDuplicateFormat(format2);
      index_1.FormatRegistry.Set(format2, check2);
      return format2;
    }
    TypeSystem2.Format = Format;
  })(TypeSystem || (system.TypeSystem = TypeSystem = {}));
  return system;
}
var hasRequiredSystem;
function requireSystem() {
  if (hasRequiredSystem) return system$1;
  hasRequiredSystem = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requirePolicy(), exports$12);
    __exportStar(requireSystem$1(), exports$12);
  })(system$1);
  return system$1;
}
var _function = {};
var hasRequired_function;
function require_function() {
  if (hasRequired_function) return _function;
  hasRequired_function = 1;
  Object.defineProperty(_function, "__esModule", { value: true });
  _function.DefaultErrorFunction = DefaultErrorFunction;
  _function.SetErrorFunction = SetErrorFunction;
  _function.GetErrorFunction = GetErrorFunction;
  const index_1 = requireSymbols();
  const errors_1 = requireErrors$2();
  function DefaultErrorFunction(error2) {
    switch (error2.errorType) {
      case errors_1.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case errors_1.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${error2.schema.maxContains} matching values`;
      case errors_1.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${error2.schema.minContains} matching values`;
      case errors_1.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${error2.schema.maxItems}`;
      case errors_1.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${error2.schema.minItems}`;
      case errors_1.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case errors_1.ValueErrorType.Array:
        return "Expected array";
      case errors_1.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case errors_1.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${error2.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${error2.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${error2.schema.maximum}`;
      case errors_1.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${error2.schema.minimum}`;
      case errors_1.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${error2.schema.multipleOf}`;
      case errors_1.ValueErrorType.BigInt:
        return "Expected bigint";
      case errors_1.ValueErrorType.Boolean:
        return "Expected boolean";
      case errors_1.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${error2.schema.exclusiveMinimumTimestamp}`;
      case errors_1.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${error2.schema.exclusiveMaximumTimestamp}`;
      case errors_1.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${error2.schema.minimumTimestamp}`;
      case errors_1.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${error2.schema.maximumTimestamp}`;
      case errors_1.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${error2.schema.multipleOfTimestamp}`;
      case errors_1.ValueErrorType.Date:
        return "Expected Date";
      case errors_1.ValueErrorType.Function:
        return "Expected function";
      case errors_1.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${error2.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${error2.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${error2.schema.maximum}`;
      case errors_1.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${error2.schema.minimum}`;
      case errors_1.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${error2.schema.multipleOf}`;
      case errors_1.ValueErrorType.Integer:
        return "Expected integer";
      case errors_1.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case errors_1.ValueErrorType.Intersect:
        return "Expected all values to match";
      case errors_1.ValueErrorType.Iterator:
        return "Expected Iterator";
      case errors_1.ValueErrorType.Literal:
        return `Expected ${typeof error2.schema.const === "string" ? `'${error2.schema.const}'` : error2.schema.const}`;
      case errors_1.ValueErrorType.Never:
        return "Never";
      case errors_1.ValueErrorType.Not:
        return "Value should not match";
      case errors_1.ValueErrorType.Null:
        return "Expected null";
      case errors_1.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${error2.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${error2.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${error2.schema.maximum}`;
      case errors_1.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${error2.schema.minimum}`;
      case errors_1.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${error2.schema.multipleOf}`;
      case errors_1.ValueErrorType.Number:
        return "Expected number";
      case errors_1.ValueErrorType.Object:
        return "Expected object";
      case errors_1.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case errors_1.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${error2.schema.maxProperties} properties`;
      case errors_1.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${error2.schema.minProperties} properties`;
      case errors_1.ValueErrorType.ObjectRequiredProperty:
        return "Expected required property";
      case errors_1.ValueErrorType.Promise:
        return "Expected Promise";
      case errors_1.ValueErrorType.RegExp:
        return "Expected string to match regular expression";
      case errors_1.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${error2.schema.format}'`;
      case errors_1.ValueErrorType.StringFormat:
        return `Expected string to match '${error2.schema.format}' format`;
      case errors_1.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${error2.schema.maxLength}`;
      case errors_1.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${error2.schema.minLength}`;
      case errors_1.ValueErrorType.StringPattern:
        return `Expected string to match '${error2.schema.pattern}'`;
      case errors_1.ValueErrorType.String:
        return "Expected string";
      case errors_1.ValueErrorType.Symbol:
        return "Expected symbol";
      case errors_1.ValueErrorType.TupleLength:
        return `Expected tuple to have ${error2.schema.maxItems || 0} elements`;
      case errors_1.ValueErrorType.Tuple:
        return "Expected tuple";
      case errors_1.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${error2.schema.maxByteLength}`;
      case errors_1.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${error2.schema.minByteLength}`;
      case errors_1.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case errors_1.ValueErrorType.Undefined:
        return "Expected undefined";
      case errors_1.ValueErrorType.Union:
        return "Expected union value";
      case errors_1.ValueErrorType.Void:
        return "Expected void";
      case errors_1.ValueErrorType.Kind:
        return `Expected kind '${error2.schema[index_1.Kind]}'`;
      default:
        return "Unknown error type";
    }
  }
  let errorFunction = DefaultErrorFunction;
  function SetErrorFunction(callback) {
    errorFunction = callback;
  }
  function GetErrorFunction() {
    return errorFunction;
  }
  return _function;
}
var deref$1 = {};
var deref = {};
var hasRequiredDeref$1;
function requireDeref$1() {
  if (hasRequiredDeref$1) return deref;
  hasRequiredDeref$1 = 1;
  Object.defineProperty(deref, "__esModule", { value: true });
  deref.TypeDereferenceError = void 0;
  deref.Pushref = Pushref;
  deref.Deref = Deref;
  const index_1 = requireError();
  const index_2 = requireSymbols();
  const guard_1 = requireGuard$2();
  class TypeDereferenceError extends index_1.TypeBoxError {
    constructor(schema2) {
      super(`Unable to dereference schema with $id '${schema2.$ref}'`);
      this.schema = schema2;
    }
  }
  deref.TypeDereferenceError = TypeDereferenceError;
  function Resolve(schema2, references) {
    const target = references.find((target2) => target2.$id === schema2.$ref);
    if (target === void 0)
      throw new TypeDereferenceError(schema2);
    return Deref(target, references);
  }
  function Pushref(schema2, references) {
    if (!(0, guard_1.IsString)(schema2.$id) || references.some((target) => target.$id === schema2.$id))
      return references;
    references.push(schema2);
    return references;
  }
  function Deref(schema2, references) {
    return schema2[index_2.Kind] === "This" || schema2[index_2.Kind] === "Ref" ? Resolve(schema2, references) : schema2;
  }
  return deref;
}
var hasRequiredDeref;
function requireDeref() {
  if (hasRequiredDeref) return deref$1;
  hasRequiredDeref = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireDeref$1(), exports$12);
  })(deref$1);
  return deref$1;
}
var hash$1 = {};
var hash = {};
var hasRequiredHash$1;
function requireHash$1() {
  if (hasRequiredHash$1) return hash;
  hasRequiredHash$1 = 1;
  Object.defineProperty(hash, "__esModule", { value: true });
  hash.ValueHashError = void 0;
  hash.Hash = Hash;
  const index_1 = requireGuard$1();
  const index_2 = requireError();
  class ValueHashError extends index_2.TypeBoxError {
    constructor(value2) {
      super(`Unable to hash value`);
      this.value = value2;
    }
  }
  hash.ValueHashError = ValueHashError;
  var ByteMarker;
  (function(ByteMarker2) {
    ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
    ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
    ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
    ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
    ByteMarker2[ByteMarker2["String"] = 4] = "String";
    ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
    ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
    ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
    ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
    ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
    ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
  })(ByteMarker || (ByteMarker = {}));
  let Accumulator = BigInt("14695981039346656037");
  const [Prime, Size] = [BigInt("1099511628211"), BigInt(
    "18446744073709551616"
    /* 2 ^ 64 */
  )];
  const Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
  const F64 = new Float64Array(1);
  const F64In = new DataView(F64.buffer);
  const F64Out = new Uint8Array(F64.buffer);
  function* NumberToBytes(value2) {
    const byteCount = value2 === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value2) + 1) / 8);
    for (let i = 0; i < byteCount; i++) {
      yield value2 >> 8 * (byteCount - 1 - i) & 255;
    }
  }
  function ArrayType(value2) {
    FNV1A64(ByteMarker.Array);
    for (const item of value2) {
      Visit(item);
    }
  }
  function BooleanType(value2) {
    FNV1A64(ByteMarker.Boolean);
    FNV1A64(value2 ? 1 : 0);
  }
  function BigIntType(value2) {
    FNV1A64(ByteMarker.BigInt);
    F64In.setBigInt64(0, value2);
    for (const byte of F64Out) {
      FNV1A64(byte);
    }
  }
  function DateType(value2) {
    FNV1A64(ByteMarker.Date);
    Visit(value2.getTime());
  }
  function NullType(value2) {
    FNV1A64(ByteMarker.Null);
  }
  function NumberType(value2) {
    FNV1A64(ByteMarker.Number);
    F64In.setFloat64(0, value2);
    for (const byte of F64Out) {
      FNV1A64(byte);
    }
  }
  function ObjectType(value2) {
    FNV1A64(ByteMarker.Object);
    for (const key of globalThis.Object.getOwnPropertyNames(value2).sort()) {
      Visit(key);
      Visit(value2[key]);
    }
  }
  function StringType(value2) {
    FNV1A64(ByteMarker.String);
    for (let i = 0; i < value2.length; i++) {
      for (const byte of NumberToBytes(value2.charCodeAt(i))) {
        FNV1A64(byte);
      }
    }
  }
  function SymbolType(value2) {
    FNV1A64(ByteMarker.Symbol);
    Visit(value2.description);
  }
  function Uint8ArrayType(value2) {
    FNV1A64(ByteMarker.Uint8Array);
    for (let i = 0; i < value2.length; i++) {
      FNV1A64(value2[i]);
    }
  }
  function UndefinedType(value2) {
    return FNV1A64(ByteMarker.Undefined);
  }
  function Visit(value2) {
    if ((0, index_1.IsArray)(value2))
      return ArrayType(value2);
    if ((0, index_1.IsBoolean)(value2))
      return BooleanType(value2);
    if ((0, index_1.IsBigInt)(value2))
      return BigIntType(value2);
    if ((0, index_1.IsDate)(value2))
      return DateType(value2);
    if ((0, index_1.IsNull)(value2))
      return NullType();
    if ((0, index_1.IsNumber)(value2))
      return NumberType(value2);
    if ((0, index_1.IsObject)(value2))
      return ObjectType(value2);
    if ((0, index_1.IsString)(value2))
      return StringType(value2);
    if ((0, index_1.IsSymbol)(value2))
      return SymbolType(value2);
    if ((0, index_1.IsUint8Array)(value2))
      return Uint8ArrayType(value2);
    if ((0, index_1.IsUndefined)(value2))
      return UndefinedType();
    throw new ValueHashError(value2);
  }
  function FNV1A64(byte) {
    Accumulator = Accumulator ^ Bytes[byte];
    Accumulator = Accumulator * Prime % Size;
  }
  function Hash(value2) {
    Accumulator = BigInt("14695981039346656037");
    Visit(value2);
    return Accumulator;
  }
  return hash;
}
var hasRequiredHash;
function requireHash() {
  if (hasRequiredHash) return hash$1;
  hasRequiredHash = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireHash$1(), exports$12);
  })(hash$1);
  return hash$1;
}
var check$1 = {};
var check = {};
var hasRequiredCheck$1;
function requireCheck$1() {
  if (hasRequiredCheck$1) return check;
  hasRequiredCheck$1 = 1;
  Object.defineProperty(check, "__esModule", { value: true });
  check.ValueCheckUnknownTypeError = void 0;
  check.Check = Check;
  const index_1 = requireSystem();
  const index_2 = requireDeref();
  const index_3 = requireHash();
  const index_4 = requireSymbols();
  const index_5 = requireKeyof();
  const index_6 = require_extends();
  const index_7 = requireRegistry();
  const index_8 = requireError();
  const index_9 = requireNever();
  const index_10 = requireGuard$1();
  const type_1 = requireType$4();
  class ValueCheckUnknownTypeError extends index_8.TypeBoxError {
    constructor(schema2) {
      super(`Unknown type`);
      this.schema = schema2;
    }
  }
  check.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;
  function IsAnyOrUnknown(schema2) {
    return schema2[index_4.Kind] === "Any" || schema2[index_4.Kind] === "Unknown";
  }
  function IsDefined(value2) {
    return value2 !== void 0;
  }
  function FromAny(schema2, references, value2) {
    return true;
  }
  function FromArray(schema2, references, value2) {
    if (!(0, index_10.IsArray)(value2))
      return false;
    if (IsDefined(schema2.minItems) && !(value2.length >= schema2.minItems)) {
      return false;
    }
    if (IsDefined(schema2.maxItems) && !(value2.length <= schema2.maxItems)) {
      return false;
    }
    if (!value2.every((value3) => Visit(schema2.items, references, value3))) {
      return false;
    }
    if (schema2.uniqueItems === true && !function() {
      const set2 = /* @__PURE__ */ new Set();
      for (const element of value2) {
        const hashed = (0, index_3.Hash)(element);
        if (set2.has(hashed)) {
          return false;
        } else {
          set2.add(hashed);
        }
      }
      return true;
    }()) {
      return false;
    }
    if (!(IsDefined(schema2.contains) || (0, index_10.IsNumber)(schema2.minContains) || (0, index_10.IsNumber)(schema2.maxContains))) {
      return true;
    }
    const containsSchema = IsDefined(schema2.contains) ? schema2.contains : (0, index_9.Never)();
    const containsCount = value2.reduce((acc, value3) => Visit(containsSchema, references, value3) ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      return false;
    }
    if ((0, index_10.IsNumber)(schema2.minContains) && containsCount < schema2.minContains) {
      return false;
    }
    if ((0, index_10.IsNumber)(schema2.maxContains) && containsCount > schema2.maxContains) {
      return false;
    }
    return true;
  }
  function FromAsyncIterator(schema2, references, value2) {
    return (0, index_10.IsAsyncIterator)(value2);
  }
  function FromBigInt(schema2, references, value2) {
    if (!(0, index_10.IsBigInt)(value2))
      return false;
    if (IsDefined(schema2.exclusiveMaximum) && !(value2 < schema2.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema2.exclusiveMinimum) && !(value2 > schema2.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema2.maximum) && !(value2 <= schema2.maximum)) {
      return false;
    }
    if (IsDefined(schema2.minimum) && !(value2 >= schema2.minimum)) {
      return false;
    }
    if (IsDefined(schema2.multipleOf) && !(value2 % schema2.multipleOf === BigInt(0))) {
      return false;
    }
    return true;
  }
  function FromBoolean(schema2, references, value2) {
    return (0, index_10.IsBoolean)(value2);
  }
  function FromConstructor(schema2, references, value2) {
    return Visit(schema2.returns, references, value2.prototype);
  }
  function FromDate(schema2, references, value2) {
    if (!(0, index_10.IsDate)(value2))
      return false;
    if (IsDefined(schema2.exclusiveMaximumTimestamp) && !(value2.getTime() < schema2.exclusiveMaximumTimestamp)) {
      return false;
    }
    if (IsDefined(schema2.exclusiveMinimumTimestamp) && !(value2.getTime() > schema2.exclusiveMinimumTimestamp)) {
      return false;
    }
    if (IsDefined(schema2.maximumTimestamp) && !(value2.getTime() <= schema2.maximumTimestamp)) {
      return false;
    }
    if (IsDefined(schema2.minimumTimestamp) && !(value2.getTime() >= schema2.minimumTimestamp)) {
      return false;
    }
    if (IsDefined(schema2.multipleOfTimestamp) && !(value2.getTime() % schema2.multipleOfTimestamp === 0)) {
      return false;
    }
    return true;
  }
  function FromFunction(schema2, references, value2) {
    return (0, index_10.IsFunction)(value2);
  }
  function FromInteger(schema2, references, value2) {
    if (!(0, index_10.IsInteger)(value2)) {
      return false;
    }
    if (IsDefined(schema2.exclusiveMaximum) && !(value2 < schema2.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema2.exclusiveMinimum) && !(value2 > schema2.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema2.maximum) && !(value2 <= schema2.maximum)) {
      return false;
    }
    if (IsDefined(schema2.minimum) && !(value2 >= schema2.minimum)) {
      return false;
    }
    if (IsDefined(schema2.multipleOf) && !(value2 % schema2.multipleOf === 0)) {
      return false;
    }
    return true;
  }
  function FromIntersect(schema2, references, value2) {
    const check1 = schema2.allOf.every((schema3) => Visit(schema3, references, value2));
    if (schema2.unevaluatedProperties === false) {
      const keyPattern = new RegExp((0, index_5.KeyOfPattern)(schema2));
      const check2 = Object.getOwnPropertyNames(value2).every((key) => keyPattern.test(key));
      return check1 && check2;
    } else if ((0, type_1.IsSchema)(schema2.unevaluatedProperties)) {
      const keyCheck = new RegExp((0, index_5.KeyOfPattern)(schema2));
      const check2 = Object.getOwnPropertyNames(value2).every((key) => keyCheck.test(key) || Visit(schema2.unevaluatedProperties, references, value2[key]));
      return check1 && check2;
    } else {
      return check1;
    }
  }
  function FromIterator(schema2, references, value2) {
    return (0, index_10.IsIterator)(value2);
  }
  function FromLiteral(schema2, references, value2) {
    return value2 === schema2.const;
  }
  function FromNever(schema2, references, value2) {
    return false;
  }
  function FromNot(schema2, references, value2) {
    return !Visit(schema2.not, references, value2);
  }
  function FromNull(schema2, references, value2) {
    return (0, index_10.IsNull)(value2);
  }
  function FromNumber(schema2, references, value2) {
    if (!index_1.TypeSystemPolicy.IsNumberLike(value2))
      return false;
    if (IsDefined(schema2.exclusiveMaximum) && !(value2 < schema2.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema2.exclusiveMinimum) && !(value2 > schema2.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema2.minimum) && !(value2 >= schema2.minimum)) {
      return false;
    }
    if (IsDefined(schema2.maximum) && !(value2 <= schema2.maximum)) {
      return false;
    }
    if (IsDefined(schema2.multipleOf) && !(value2 % schema2.multipleOf === 0)) {
      return false;
    }
    return true;
  }
  function FromObject(schema2, references, value2) {
    if (!index_1.TypeSystemPolicy.IsObjectLike(value2))
      return false;
    if (IsDefined(schema2.minProperties) && !(Object.getOwnPropertyNames(value2).length >= schema2.minProperties)) {
      return false;
    }
    if (IsDefined(schema2.maxProperties) && !(Object.getOwnPropertyNames(value2).length <= schema2.maxProperties)) {
      return false;
    }
    const knownKeys = Object.getOwnPropertyNames(schema2.properties);
    for (const knownKey of knownKeys) {
      const property = schema2.properties[knownKey];
      if (schema2.required && schema2.required.includes(knownKey)) {
        if (!Visit(property, references, value2[knownKey])) {
          return false;
        }
        if (((0, index_6.ExtendsUndefinedCheck)(property) || IsAnyOrUnknown(property)) && !(knownKey in value2)) {
          return false;
        }
      } else {
        if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value2, knownKey) && !Visit(property, references, value2[knownKey])) {
          return false;
        }
      }
    }
    if (schema2.additionalProperties === false) {
      const valueKeys = Object.getOwnPropertyNames(value2);
      if (schema2.required && schema2.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
        return true;
      } else {
        return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
      }
    } else if (typeof schema2.additionalProperties === "object") {
      const valueKeys = Object.getOwnPropertyNames(value2);
      return valueKeys.every((key) => knownKeys.includes(key) || Visit(schema2.additionalProperties, references, value2[key]));
    } else {
      return true;
    }
  }
  function FromPromise(schema2, references, value2) {
    return (0, index_10.IsPromise)(value2);
  }
  function FromRecord(schema2, references, value2) {
    if (!index_1.TypeSystemPolicy.IsRecordLike(value2)) {
      return false;
    }
    if (IsDefined(schema2.minProperties) && !(Object.getOwnPropertyNames(value2).length >= schema2.minProperties)) {
      return false;
    }
    if (IsDefined(schema2.maxProperties) && !(Object.getOwnPropertyNames(value2).length <= schema2.maxProperties)) {
      return false;
    }
    const [patternKey, patternSchema] = Object.entries(schema2.patternProperties)[0];
    const regex = new RegExp(patternKey);
    const check1 = Object.entries(value2).every(([key, value3]) => {
      return regex.test(key) ? Visit(patternSchema, references, value3) : true;
    });
    const check2 = typeof schema2.additionalProperties === "object" ? Object.entries(value2).every(([key, value3]) => {
      return !regex.test(key) ? Visit(schema2.additionalProperties, references, value3) : true;
    }) : true;
    const check3 = schema2.additionalProperties === false ? Object.getOwnPropertyNames(value2).every((key) => {
      return regex.test(key);
    }) : true;
    return check1 && check2 && check3;
  }
  function FromRef(schema2, references, value2) {
    return Visit((0, index_2.Deref)(schema2, references), references, value2);
  }
  function FromRegExp(schema2, references, value2) {
    const regex = new RegExp(schema2.source, schema2.flags);
    if (IsDefined(schema2.minLength)) {
      if (!(value2.length >= schema2.minLength))
        return false;
    }
    if (IsDefined(schema2.maxLength)) {
      if (!(value2.length <= schema2.maxLength))
        return false;
    }
    return regex.test(value2);
  }
  function FromString(schema2, references, value2) {
    if (!(0, index_10.IsString)(value2)) {
      return false;
    }
    if (IsDefined(schema2.minLength)) {
      if (!(value2.length >= schema2.minLength))
        return false;
    }
    if (IsDefined(schema2.maxLength)) {
      if (!(value2.length <= schema2.maxLength))
        return false;
    }
    if (IsDefined(schema2.pattern)) {
      const regex = new RegExp(schema2.pattern);
      if (!regex.test(value2))
        return false;
    }
    if (IsDefined(schema2.format)) {
      if (!index_7.FormatRegistry.Has(schema2.format))
        return false;
      const func = index_7.FormatRegistry.Get(schema2.format);
      return func(value2);
    }
    return true;
  }
  function FromSymbol(schema2, references, value2) {
    return (0, index_10.IsSymbol)(value2);
  }
  function FromTemplateLiteral(schema2, references, value2) {
    return (0, index_10.IsString)(value2) && new RegExp(schema2.pattern).test(value2);
  }
  function FromThis(schema2, references, value2) {
    return Visit((0, index_2.Deref)(schema2, references), references, value2);
  }
  function FromTuple(schema2, references, value2) {
    if (!(0, index_10.IsArray)(value2)) {
      return false;
    }
    if (schema2.items === void 0 && !(value2.length === 0)) {
      return false;
    }
    if (!(value2.length === schema2.maxItems)) {
      return false;
    }
    if (!schema2.items) {
      return true;
    }
    for (let i = 0; i < schema2.items.length; i++) {
      if (!Visit(schema2.items[i], references, value2[i]))
        return false;
    }
    return true;
  }
  function FromUndefined(schema2, references, value2) {
    return (0, index_10.IsUndefined)(value2);
  }
  function FromUnion(schema2, references, value2) {
    return schema2.anyOf.some((inner) => Visit(inner, references, value2));
  }
  function FromUint8Array(schema2, references, value2) {
    if (!(0, index_10.IsUint8Array)(value2)) {
      return false;
    }
    if (IsDefined(schema2.maxByteLength) && !(value2.length <= schema2.maxByteLength)) {
      return false;
    }
    if (IsDefined(schema2.minByteLength) && !(value2.length >= schema2.minByteLength)) {
      return false;
    }
    return true;
  }
  function FromUnknown(schema2, references, value2) {
    return true;
  }
  function FromVoid(schema2, references, value2) {
    return index_1.TypeSystemPolicy.IsVoidLike(value2);
  }
  function FromKind(schema2, references, value2) {
    if (!index_7.TypeRegistry.Has(schema2[index_4.Kind]))
      return false;
    const func = index_7.TypeRegistry.Get(schema2[index_4.Kind]);
    return func(schema2, value2);
  }
  function Visit(schema2, references, value2) {
    const references_ = IsDefined(schema2.$id) ? [...references, schema2] : references;
    const schema_ = schema2;
    switch (schema_[index_4.Kind]) {
      case "Any":
        return FromAny();
      case "Array":
        return FromArray(schema_, references_, value2);
      case "AsyncIterator":
        return FromAsyncIterator(schema_, references_, value2);
      case "BigInt":
        return FromBigInt(schema_, references_, value2);
      case "Boolean":
        return FromBoolean(schema_, references_, value2);
      case "Constructor":
        return FromConstructor(schema_, references_, value2);
      case "Date":
        return FromDate(schema_, references_, value2);
      case "Function":
        return FromFunction(schema_, references_, value2);
      case "Integer":
        return FromInteger(schema_, references_, value2);
      case "Intersect":
        return FromIntersect(schema_, references_, value2);
      case "Iterator":
        return FromIterator(schema_, references_, value2);
      case "Literal":
        return FromLiteral(schema_, references_, value2);
      case "Never":
        return FromNever();
      case "Not":
        return FromNot(schema_, references_, value2);
      case "Null":
        return FromNull(schema_, references_, value2);
      case "Number":
        return FromNumber(schema_, references_, value2);
      case "Object":
        return FromObject(schema_, references_, value2);
      case "Promise":
        return FromPromise(schema_, references_, value2);
      case "Record":
        return FromRecord(schema_, references_, value2);
      case "Ref":
        return FromRef(schema_, references_, value2);
      case "RegExp":
        return FromRegExp(schema_, references_, value2);
      case "String":
        return FromString(schema_, references_, value2);
      case "Symbol":
        return FromSymbol(schema_, references_, value2);
      case "TemplateLiteral":
        return FromTemplateLiteral(schema_, references_, value2);
      case "This":
        return FromThis(schema_, references_, value2);
      case "Tuple":
        return FromTuple(schema_, references_, value2);
      case "Undefined":
        return FromUndefined(schema_, references_, value2);
      case "Union":
        return FromUnion(schema_, references_, value2);
      case "Uint8Array":
        return FromUint8Array(schema_, references_, value2);
      case "Unknown":
        return FromUnknown();
      case "Void":
        return FromVoid(schema_, references_, value2);
      default:
        if (!index_7.TypeRegistry.Has(schema_[index_4.Kind]))
          throw new ValueCheckUnknownTypeError(schema_);
        return FromKind(schema_, references_, value2);
    }
  }
  function Check(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
  return check;
}
var hasRequiredCheck;
function requireCheck() {
  if (hasRequiredCheck) return check$1;
  hasRequiredCheck = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireCheck$1(), exports$12);
  })(check$1);
  return check$1;
}
var hasRequiredErrors$2;
function requireErrors$2() {
  if (hasRequiredErrors$2) return errors$1;
  hasRequiredErrors$2 = 1;
  Object.defineProperty(errors$1, "__esModule", { value: true });
  errors$1.ValueErrorIterator = errors$1.ValueErrorsUnknownTypeError = errors$1.ValueErrorType = void 0;
  errors$1.Errors = Errors;
  const index_1 = requireSystem();
  const index_2 = requireKeyof();
  const index_3 = requireRegistry();
  const extends_undefined_1 = requireExtendsUndefined();
  const function_1 = require_function();
  const index_4 = requireError();
  const index_5 = requireDeref();
  const index_6 = requireHash();
  const index_7 = requireCheck();
  const index_8 = requireSymbols();
  const index_9 = requireNever();
  const index_10 = requireGuard$1();
  var ValueErrorType;
  (function(ValueErrorType2) {
    ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
    ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
    ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
    ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
    ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
    ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
    ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
    ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
    ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
    ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
    ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
    ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
    ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
    ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
    ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
    ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
    ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
    ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
    ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
    ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
    ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
    ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
    ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
    ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
    ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
    ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
    ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
    ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
    ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
    ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
    ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
    ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
    ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
    ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
    ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
    ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
    ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
    ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
    ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
    ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
    ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
    ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
    ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
    ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
    ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
  })(ValueErrorType || (errors$1.ValueErrorType = ValueErrorType = {}));
  class ValueErrorsUnknownTypeError extends index_4.TypeBoxError {
    constructor(schema2) {
      super("Unknown type");
      this.schema = schema2;
    }
  }
  errors$1.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;
  function EscapeKey(key) {
    return key.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function IsDefined(value2) {
    return value2 !== void 0;
  }
  class ValueErrorIterator {
    constructor(iterator2) {
      this.iterator = iterator2;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    /** Returns the first value error or undefined if no errors */
    First() {
      const next = this.iterator.next();
      return next.done ? void 0 : next.value;
    }
  }
  errors$1.ValueErrorIterator = ValueErrorIterator;
  function Create(errorType, schema2, path2, value2, errors2 = []) {
    return {
      type: errorType,
      schema: schema2,
      path: path2,
      value: value2,
      message: (0, function_1.GetErrorFunction)()({ errorType, path: path2, schema: schema2, value: value2, errors: errors2 }),
      errors: errors2
    };
  }
  function* FromAny(schema2, references, path2, value2) {
  }
  function* FromArray(schema2, references, path2, value2) {
    if (!(0, index_10.IsArray)(value2)) {
      return yield Create(ValueErrorType.Array, schema2, path2, value2);
    }
    if (IsDefined(schema2.minItems) && !(value2.length >= schema2.minItems)) {
      yield Create(ValueErrorType.ArrayMinItems, schema2, path2, value2);
    }
    if (IsDefined(schema2.maxItems) && !(value2.length <= schema2.maxItems)) {
      yield Create(ValueErrorType.ArrayMaxItems, schema2, path2, value2);
    }
    for (let i = 0; i < value2.length; i++) {
      yield* Visit(schema2.items, references, `${path2}/${i}`, value2[i]);
    }
    if (schema2.uniqueItems === true && !function() {
      const set2 = /* @__PURE__ */ new Set();
      for (const element of value2) {
        const hashed = (0, index_6.Hash)(element);
        if (set2.has(hashed)) {
          return false;
        } else {
          set2.add(hashed);
        }
      }
      return true;
    }()) {
      yield Create(ValueErrorType.ArrayUniqueItems, schema2, path2, value2);
    }
    if (!(IsDefined(schema2.contains) || IsDefined(schema2.minContains) || IsDefined(schema2.maxContains))) {
      return;
    }
    const containsSchema = IsDefined(schema2.contains) ? schema2.contains : (0, index_9.Never)();
    const containsCount = value2.reduce((acc, value3, index2) => Visit(containsSchema, references, `${path2}${index2}`, value3).next().done === true ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      yield Create(ValueErrorType.ArrayContains, schema2, path2, value2);
    }
    if ((0, index_10.IsNumber)(schema2.minContains) && containsCount < schema2.minContains) {
      yield Create(ValueErrorType.ArrayMinContains, schema2, path2, value2);
    }
    if ((0, index_10.IsNumber)(schema2.maxContains) && containsCount > schema2.maxContains) {
      yield Create(ValueErrorType.ArrayMaxContains, schema2, path2, value2);
    }
  }
  function* FromAsyncIterator(schema2, references, path2, value2) {
    if (!(0, index_10.IsAsyncIterator)(value2))
      yield Create(ValueErrorType.AsyncIterator, schema2, path2, value2);
  }
  function* FromBigInt(schema2, references, path2, value2) {
    if (!(0, index_10.IsBigInt)(value2))
      return yield Create(ValueErrorType.BigInt, schema2, path2, value2);
    if (IsDefined(schema2.exclusiveMaximum) && !(value2 < schema2.exclusiveMaximum)) {
      yield Create(ValueErrorType.BigIntExclusiveMaximum, schema2, path2, value2);
    }
    if (IsDefined(schema2.exclusiveMinimum) && !(value2 > schema2.exclusiveMinimum)) {
      yield Create(ValueErrorType.BigIntExclusiveMinimum, schema2, path2, value2);
    }
    if (IsDefined(schema2.maximum) && !(value2 <= schema2.maximum)) {
      yield Create(ValueErrorType.BigIntMaximum, schema2, path2, value2);
    }
    if (IsDefined(schema2.minimum) && !(value2 >= schema2.minimum)) {
      yield Create(ValueErrorType.BigIntMinimum, schema2, path2, value2);
    }
    if (IsDefined(schema2.multipleOf) && !(value2 % schema2.multipleOf === BigInt(0))) {
      yield Create(ValueErrorType.BigIntMultipleOf, schema2, path2, value2);
    }
  }
  function* FromBoolean(schema2, references, path2, value2) {
    if (!(0, index_10.IsBoolean)(value2))
      yield Create(ValueErrorType.Boolean, schema2, path2, value2);
  }
  function* FromConstructor(schema2, references, path2, value2) {
    yield* Visit(schema2.returns, references, path2, value2.prototype);
  }
  function* FromDate(schema2, references, path2, value2) {
    if (!(0, index_10.IsDate)(value2))
      return yield Create(ValueErrorType.Date, schema2, path2, value2);
    if (IsDefined(schema2.exclusiveMaximumTimestamp) && !(value2.getTime() < schema2.exclusiveMaximumTimestamp)) {
      yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema2, path2, value2);
    }
    if (IsDefined(schema2.exclusiveMinimumTimestamp) && !(value2.getTime() > schema2.exclusiveMinimumTimestamp)) {
      yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema2, path2, value2);
    }
    if (IsDefined(schema2.maximumTimestamp) && !(value2.getTime() <= schema2.maximumTimestamp)) {
      yield Create(ValueErrorType.DateMaximumTimestamp, schema2, path2, value2);
    }
    if (IsDefined(schema2.minimumTimestamp) && !(value2.getTime() >= schema2.minimumTimestamp)) {
      yield Create(ValueErrorType.DateMinimumTimestamp, schema2, path2, value2);
    }
    if (IsDefined(schema2.multipleOfTimestamp) && !(value2.getTime() % schema2.multipleOfTimestamp === 0)) {
      yield Create(ValueErrorType.DateMultipleOfTimestamp, schema2, path2, value2);
    }
  }
  function* FromFunction(schema2, references, path2, value2) {
    if (!(0, index_10.IsFunction)(value2))
      yield Create(ValueErrorType.Function, schema2, path2, value2);
  }
  function* FromInteger(schema2, references, path2, value2) {
    if (!(0, index_10.IsInteger)(value2))
      return yield Create(ValueErrorType.Integer, schema2, path2, value2);
    if (IsDefined(schema2.exclusiveMaximum) && !(value2 < schema2.exclusiveMaximum)) {
      yield Create(ValueErrorType.IntegerExclusiveMaximum, schema2, path2, value2);
    }
    if (IsDefined(schema2.exclusiveMinimum) && !(value2 > schema2.exclusiveMinimum)) {
      yield Create(ValueErrorType.IntegerExclusiveMinimum, schema2, path2, value2);
    }
    if (IsDefined(schema2.maximum) && !(value2 <= schema2.maximum)) {
      yield Create(ValueErrorType.IntegerMaximum, schema2, path2, value2);
    }
    if (IsDefined(schema2.minimum) && !(value2 >= schema2.minimum)) {
      yield Create(ValueErrorType.IntegerMinimum, schema2, path2, value2);
    }
    if (IsDefined(schema2.multipleOf) && !(value2 % schema2.multipleOf === 0)) {
      yield Create(ValueErrorType.IntegerMultipleOf, schema2, path2, value2);
    }
  }
  function* FromIntersect(schema2, references, path2, value2) {
    let hasError = false;
    for (const inner of schema2.allOf) {
      for (const error2 of Visit(inner, references, path2, value2)) {
        hasError = true;
        yield error2;
      }
    }
    if (hasError) {
      return yield Create(ValueErrorType.Intersect, schema2, path2, value2);
    }
    if (schema2.unevaluatedProperties === false) {
      const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema2));
      for (const valueKey of Object.getOwnPropertyNames(value2)) {
        if (!keyCheck.test(valueKey)) {
          yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema2, `${path2}/${valueKey}`, value2);
        }
      }
    }
    if (typeof schema2.unevaluatedProperties === "object") {
      const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema2));
      for (const valueKey of Object.getOwnPropertyNames(value2)) {
        if (!keyCheck.test(valueKey)) {
          const next = Visit(schema2.unevaluatedProperties, references, `${path2}/${valueKey}`, value2[valueKey]).next();
          if (!next.done)
            yield next.value;
        }
      }
    }
  }
  function* FromIterator(schema2, references, path2, value2) {
    if (!(0, index_10.IsIterator)(value2))
      yield Create(ValueErrorType.Iterator, schema2, path2, value2);
  }
  function* FromLiteral(schema2, references, path2, value2) {
    if (!(value2 === schema2.const))
      yield Create(ValueErrorType.Literal, schema2, path2, value2);
  }
  function* FromNever(schema2, references, path2, value2) {
    yield Create(ValueErrorType.Never, schema2, path2, value2);
  }
  function* FromNot(schema2, references, path2, value2) {
    if (Visit(schema2.not, references, path2, value2).next().done === true)
      yield Create(ValueErrorType.Not, schema2, path2, value2);
  }
  function* FromNull(schema2, references, path2, value2) {
    if (!(0, index_10.IsNull)(value2))
      yield Create(ValueErrorType.Null, schema2, path2, value2);
  }
  function* FromNumber(schema2, references, path2, value2) {
    if (!index_1.TypeSystemPolicy.IsNumberLike(value2))
      return yield Create(ValueErrorType.Number, schema2, path2, value2);
    if (IsDefined(schema2.exclusiveMaximum) && !(value2 < schema2.exclusiveMaximum)) {
      yield Create(ValueErrorType.NumberExclusiveMaximum, schema2, path2, value2);
    }
    if (IsDefined(schema2.exclusiveMinimum) && !(value2 > schema2.exclusiveMinimum)) {
      yield Create(ValueErrorType.NumberExclusiveMinimum, schema2, path2, value2);
    }
    if (IsDefined(schema2.maximum) && !(value2 <= schema2.maximum)) {
      yield Create(ValueErrorType.NumberMaximum, schema2, path2, value2);
    }
    if (IsDefined(schema2.minimum) && !(value2 >= schema2.minimum)) {
      yield Create(ValueErrorType.NumberMinimum, schema2, path2, value2);
    }
    if (IsDefined(schema2.multipleOf) && !(value2 % schema2.multipleOf === 0)) {
      yield Create(ValueErrorType.NumberMultipleOf, schema2, path2, value2);
    }
  }
  function* FromObject(schema2, references, path2, value2) {
    if (!index_1.TypeSystemPolicy.IsObjectLike(value2))
      return yield Create(ValueErrorType.Object, schema2, path2, value2);
    if (IsDefined(schema2.minProperties) && !(Object.getOwnPropertyNames(value2).length >= schema2.minProperties)) {
      yield Create(ValueErrorType.ObjectMinProperties, schema2, path2, value2);
    }
    if (IsDefined(schema2.maxProperties) && !(Object.getOwnPropertyNames(value2).length <= schema2.maxProperties)) {
      yield Create(ValueErrorType.ObjectMaxProperties, schema2, path2, value2);
    }
    const requiredKeys = Array.isArray(schema2.required) ? schema2.required : [];
    const knownKeys = Object.getOwnPropertyNames(schema2.properties);
    const unknownKeys = Object.getOwnPropertyNames(value2);
    for (const requiredKey of requiredKeys) {
      if (unknownKeys.includes(requiredKey))
        continue;
      yield Create(ValueErrorType.ObjectRequiredProperty, schema2.properties[requiredKey], `${path2}/${EscapeKey(requiredKey)}`, void 0);
    }
    if (schema2.additionalProperties === false) {
      for (const valueKey of unknownKeys) {
        if (!knownKeys.includes(valueKey)) {
          yield Create(ValueErrorType.ObjectAdditionalProperties, schema2, `${path2}/${EscapeKey(valueKey)}`, value2[valueKey]);
        }
      }
    }
    if (typeof schema2.additionalProperties === "object") {
      for (const valueKey of unknownKeys) {
        if (knownKeys.includes(valueKey))
          continue;
        yield* Visit(schema2.additionalProperties, references, `${path2}/${EscapeKey(valueKey)}`, value2[valueKey]);
      }
    }
    for (const knownKey of knownKeys) {
      const property = schema2.properties[knownKey];
      if (schema2.required && schema2.required.includes(knownKey)) {
        yield* Visit(property, references, `${path2}/${EscapeKey(knownKey)}`, value2[knownKey]);
        if ((0, extends_undefined_1.ExtendsUndefinedCheck)(schema2) && !(knownKey in value2)) {
          yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path2}/${EscapeKey(knownKey)}`, void 0);
        }
      } else {
        if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value2, knownKey)) {
          yield* Visit(property, references, `${path2}/${EscapeKey(knownKey)}`, value2[knownKey]);
        }
      }
    }
  }
  function* FromPromise(schema2, references, path2, value2) {
    if (!(0, index_10.IsPromise)(value2))
      yield Create(ValueErrorType.Promise, schema2, path2, value2);
  }
  function* FromRecord(schema2, references, path2, value2) {
    if (!index_1.TypeSystemPolicy.IsRecordLike(value2))
      return yield Create(ValueErrorType.Object, schema2, path2, value2);
    if (IsDefined(schema2.minProperties) && !(Object.getOwnPropertyNames(value2).length >= schema2.minProperties)) {
      yield Create(ValueErrorType.ObjectMinProperties, schema2, path2, value2);
    }
    if (IsDefined(schema2.maxProperties) && !(Object.getOwnPropertyNames(value2).length <= schema2.maxProperties)) {
      yield Create(ValueErrorType.ObjectMaxProperties, schema2, path2, value2);
    }
    const [patternKey, patternSchema] = Object.entries(schema2.patternProperties)[0];
    const regex = new RegExp(patternKey);
    for (const [propertyKey, propertyValue] of Object.entries(value2)) {
      if (regex.test(propertyKey))
        yield* Visit(patternSchema, references, `${path2}/${EscapeKey(propertyKey)}`, propertyValue);
    }
    if (typeof schema2.additionalProperties === "object") {
      for (const [propertyKey, propertyValue] of Object.entries(value2)) {
        if (!regex.test(propertyKey))
          yield* Visit(schema2.additionalProperties, references, `${path2}/${EscapeKey(propertyKey)}`, propertyValue);
      }
    }
    if (schema2.additionalProperties === false) {
      for (const [propertyKey, propertyValue] of Object.entries(value2)) {
        if (regex.test(propertyKey))
          continue;
        return yield Create(ValueErrorType.ObjectAdditionalProperties, schema2, `${path2}/${EscapeKey(propertyKey)}`, propertyValue);
      }
    }
  }
  function* FromRef(schema2, references, path2, value2) {
    yield* Visit((0, index_5.Deref)(schema2, references), references, path2, value2);
  }
  function* FromRegExp(schema2, references, path2, value2) {
    if (!(0, index_10.IsString)(value2))
      return yield Create(ValueErrorType.String, schema2, path2, value2);
    if (IsDefined(schema2.minLength) && !(value2.length >= schema2.minLength)) {
      yield Create(ValueErrorType.StringMinLength, schema2, path2, value2);
    }
    if (IsDefined(schema2.maxLength) && !(value2.length <= schema2.maxLength)) {
      yield Create(ValueErrorType.StringMaxLength, schema2, path2, value2);
    }
    const regex = new RegExp(schema2.source, schema2.flags);
    if (!regex.test(value2)) {
      return yield Create(ValueErrorType.RegExp, schema2, path2, value2);
    }
  }
  function* FromString(schema2, references, path2, value2) {
    if (!(0, index_10.IsString)(value2))
      return yield Create(ValueErrorType.String, schema2, path2, value2);
    if (IsDefined(schema2.minLength) && !(value2.length >= schema2.minLength)) {
      yield Create(ValueErrorType.StringMinLength, schema2, path2, value2);
    }
    if (IsDefined(schema2.maxLength) && !(value2.length <= schema2.maxLength)) {
      yield Create(ValueErrorType.StringMaxLength, schema2, path2, value2);
    }
    if ((0, index_10.IsString)(schema2.pattern)) {
      const regex = new RegExp(schema2.pattern);
      if (!regex.test(value2)) {
        yield Create(ValueErrorType.StringPattern, schema2, path2, value2);
      }
    }
    if ((0, index_10.IsString)(schema2.format)) {
      if (!index_3.FormatRegistry.Has(schema2.format)) {
        yield Create(ValueErrorType.StringFormatUnknown, schema2, path2, value2);
      } else {
        const format2 = index_3.FormatRegistry.Get(schema2.format);
        if (!format2(value2)) {
          yield Create(ValueErrorType.StringFormat, schema2, path2, value2);
        }
      }
    }
  }
  function* FromSymbol(schema2, references, path2, value2) {
    if (!(0, index_10.IsSymbol)(value2))
      yield Create(ValueErrorType.Symbol, schema2, path2, value2);
  }
  function* FromTemplateLiteral(schema2, references, path2, value2) {
    if (!(0, index_10.IsString)(value2))
      return yield Create(ValueErrorType.String, schema2, path2, value2);
    const regex = new RegExp(schema2.pattern);
    if (!regex.test(value2)) {
      yield Create(ValueErrorType.StringPattern, schema2, path2, value2);
    }
  }
  function* FromThis(schema2, references, path2, value2) {
    yield* Visit((0, index_5.Deref)(schema2, references), references, path2, value2);
  }
  function* FromTuple(schema2, references, path2, value2) {
    if (!(0, index_10.IsArray)(value2))
      return yield Create(ValueErrorType.Tuple, schema2, path2, value2);
    if (schema2.items === void 0 && !(value2.length === 0)) {
      return yield Create(ValueErrorType.TupleLength, schema2, path2, value2);
    }
    if (!(value2.length === schema2.maxItems)) {
      return yield Create(ValueErrorType.TupleLength, schema2, path2, value2);
    }
    if (!schema2.items) {
      return;
    }
    for (let i = 0; i < schema2.items.length; i++) {
      yield* Visit(schema2.items[i], references, `${path2}/${i}`, value2[i]);
    }
  }
  function* FromUndefined(schema2, references, path2, value2) {
    if (!(0, index_10.IsUndefined)(value2))
      yield Create(ValueErrorType.Undefined, schema2, path2, value2);
  }
  function* FromUnion(schema2, references, path2, value2) {
    if ((0, index_7.Check)(schema2, references, value2))
      return;
    const errors2 = schema2.anyOf.map((variant) => new ValueErrorIterator(Visit(variant, references, path2, value2)));
    yield Create(ValueErrorType.Union, schema2, path2, value2, errors2);
  }
  function* FromUint8Array(schema2, references, path2, value2) {
    if (!(0, index_10.IsUint8Array)(value2))
      return yield Create(ValueErrorType.Uint8Array, schema2, path2, value2);
    if (IsDefined(schema2.maxByteLength) && !(value2.length <= schema2.maxByteLength)) {
      yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema2, path2, value2);
    }
    if (IsDefined(schema2.minByteLength) && !(value2.length >= schema2.minByteLength)) {
      yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema2, path2, value2);
    }
  }
  function* FromUnknown(schema2, references, path2, value2) {
  }
  function* FromVoid(schema2, references, path2, value2) {
    if (!index_1.TypeSystemPolicy.IsVoidLike(value2))
      yield Create(ValueErrorType.Void, schema2, path2, value2);
  }
  function* FromKind(schema2, references, path2, value2) {
    const check2 = index_3.TypeRegistry.Get(schema2[index_8.Kind]);
    if (!check2(schema2, value2))
      yield Create(ValueErrorType.Kind, schema2, path2, value2);
  }
  function* Visit(schema2, references, path2, value2) {
    const references_ = IsDefined(schema2.$id) ? [...references, schema2] : references;
    const schema_ = schema2;
    switch (schema_[index_8.Kind]) {
      case "Any":
        return yield* FromAny();
      case "Array":
        return yield* FromArray(schema_, references_, path2, value2);
      case "AsyncIterator":
        return yield* FromAsyncIterator(schema_, references_, path2, value2);
      case "BigInt":
        return yield* FromBigInt(schema_, references_, path2, value2);
      case "Boolean":
        return yield* FromBoolean(schema_, references_, path2, value2);
      case "Constructor":
        return yield* FromConstructor(schema_, references_, path2, value2);
      case "Date":
        return yield* FromDate(schema_, references_, path2, value2);
      case "Function":
        return yield* FromFunction(schema_, references_, path2, value2);
      case "Integer":
        return yield* FromInteger(schema_, references_, path2, value2);
      case "Intersect":
        return yield* FromIntersect(schema_, references_, path2, value2);
      case "Iterator":
        return yield* FromIterator(schema_, references_, path2, value2);
      case "Literal":
        return yield* FromLiteral(schema_, references_, path2, value2);
      case "Never":
        return yield* FromNever(schema_, references_, path2, value2);
      case "Not":
        return yield* FromNot(schema_, references_, path2, value2);
      case "Null":
        return yield* FromNull(schema_, references_, path2, value2);
      case "Number":
        return yield* FromNumber(schema_, references_, path2, value2);
      case "Object":
        return yield* FromObject(schema_, references_, path2, value2);
      case "Promise":
        return yield* FromPromise(schema_, references_, path2, value2);
      case "Record":
        return yield* FromRecord(schema_, references_, path2, value2);
      case "Ref":
        return yield* FromRef(schema_, references_, path2, value2);
      case "RegExp":
        return yield* FromRegExp(schema_, references_, path2, value2);
      case "String":
        return yield* FromString(schema_, references_, path2, value2);
      case "Symbol":
        return yield* FromSymbol(schema_, references_, path2, value2);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral(schema_, references_, path2, value2);
      case "This":
        return yield* FromThis(schema_, references_, path2, value2);
      case "Tuple":
        return yield* FromTuple(schema_, references_, path2, value2);
      case "Undefined":
        return yield* FromUndefined(schema_, references_, path2, value2);
      case "Union":
        return yield* FromUnion(schema_, references_, path2, value2);
      case "Uint8Array":
        return yield* FromUint8Array(schema_, references_, path2, value2);
      case "Unknown":
        return yield* FromUnknown();
      case "Void":
        return yield* FromVoid(schema_, references_, path2, value2);
      default:
        if (!index_3.TypeRegistry.Has(schema_[index_8.Kind]))
          throw new ValueErrorsUnknownTypeError(schema2);
        return yield* FromKind(schema_, references_, path2, value2);
    }
  }
  function Errors(...args) {
    const iterator2 = args.length === 3 ? Visit(args[0], args[1], "", args[2]) : Visit(args[0], [], "", args[1]);
    return new ValueErrorIterator(iterator2);
  }
  return errors$1;
}
var hasRequiredErrors$1;
function requireErrors$1() {
  if (hasRequiredErrors$1) return errors$2;
  hasRequiredErrors$1 = 1;
  (function(exports$12) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports$13) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$13, p)) __createBinding(exports$13, m, p);
    };
    Object.defineProperty(exports$12, "__esModule", { value: true });
    __exportStar(requireErrors$2(), exports$12);
    __exportStar(require_function(), exports$12);
  })(errors$2);
  return errors$2;
}
const copyProps = (dest, src, exclude2 = []) => {
  const props = Object.getOwnPropertyDescriptors(src);
  for (let prop of exclude2)
    delete props[prop];
  Object.defineProperties(dest, props);
};
const protoChain = (obj, currentChain = [obj]) => {
  const proto = Object.getPrototypeOf(obj);
  if (proto === null)
    return currentChain;
  return protoChain(proto, [...currentChain, proto]);
};
const nearestCommonProto = (...objs) => {
  if (objs.length === 0)
    return void 0;
  let commonProto = void 0;
  const protoChains = objs.map((obj) => protoChain(obj));
  while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
    const protos = protoChains.map((protoChain2) => protoChain2.pop());
    const potentialCommonProto = protos[0];
    if (protos.every((proto) => proto === potentialCommonProto))
      commonProto = potentialCommonProto;
    else
      break;
  }
  return commonProto;
};
const hardMixProtos = (ingredients, constructor2, exclude2 = []) => {
  var _a;
  const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;
  const mixedProto = Object.create(base);
  const visitedProtos = protoChain(base);
  for (let prototype of ingredients) {
    let protos = protoChain(prototype);
    for (let i = protos.length - 1; i >= 0; i--) {
      let newProto = protos[i];
      if (visitedProtos.indexOf(newProto) === -1) {
        copyProps(mixedProto, newProto, ["constructor", ...exclude2]);
        visitedProtos.push(newProto);
      }
    }
  }
  mixedProto.constructor = constructor2;
  return mixedProto;
};
const unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);
const getIngredientWithProp = (prop, ingredients) => {
  const protoChains = ingredients.map((ingredient) => protoChain(ingredient));
  let protoDepth = 0;
  let protosAreLeftToSearch = true;
  while (protosAreLeftToSearch) {
    protosAreLeftToSearch = false;
    for (let i = ingredients.length - 1; i >= 0; i--) {
      const searchTarget = protoChains[i][protoDepth];
      if (searchTarget !== void 0 && searchTarget !== null) {
        protosAreLeftToSearch = true;
        if (Object.getOwnPropertyDescriptor(searchTarget, prop) != void 0) {
          return protoChains[i][0];
        }
      }
    }
    protoDepth++;
  }
  return void 0;
};
const proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
  getPrototypeOf() {
    return prototype;
  },
  setPrototypeOf() {
    throw Error("Cannot set prototype of Proxies created by ts-mixer");
  },
  getOwnPropertyDescriptor(_, prop) {
    return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);
  },
  defineProperty() {
    throw new Error("Cannot define new properties on Proxies created by ts-mixer");
  },
  has(_, prop) {
    return getIngredientWithProp(prop, ingredients) !== void 0 || prototype[prop] !== void 0;
  },
  get(_, prop) {
    return (getIngredientWithProp(prop, ingredients) || prototype)[prop];
  },
  set(_, prop, val) {
    const ingredientWithProp = getIngredientWithProp(prop, ingredients);
    if (ingredientWithProp === void 0)
      throw new Error("Cannot set new properties on Proxies created by ts-mixer");
    ingredientWithProp[prop] = val;
    return true;
  },
  deleteProperty() {
    throw new Error("Cannot delete properties on Proxies created by ts-mixer");
  },
  ownKeys() {
    return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)));
  }
});
const softMixProtos = (ingredients, constructor2) => proxyMix([...ingredients, { constructor: constructor2 }]);
const settings$1 = {
  initFunction: null,
  staticsStrategy: "copy",
  prototypeStrategy: "copy",
  decoratorInheritance: "deep"
};
const mixins = /* @__PURE__ */ new WeakMap();
const getMixinsForClass = (clazz) => mixins.get(clazz);
const registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
const hasMixin = (instance, mixin) => {
  if (instance instanceof mixin)
    return true;
  const constructor2 = instance.constructor;
  const visited = /* @__PURE__ */ new Set();
  let frontier = /* @__PURE__ */ new Set();
  frontier.add(constructor2);
  while (frontier.size > 0) {
    if (frontier.has(mixin))
      return true;
    frontier.forEach((item) => visited.add(item));
    const newFrontier = /* @__PURE__ */ new Set();
    frontier.forEach((item) => {
      var _a;
      const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype).map((proto) => proto.constructor).filter((item2) => item2 !== null);
      if (itemConstituents)
        itemConstituents.forEach((constituent) => {
          if (!visited.has(constituent) && !frontier.has(constituent))
            newFrontier.add(constituent);
        });
    });
    frontier = newFrontier;
  }
  return false;
};
const mergeObjectsOfDecorators = (o1, o2) => {
  var _a, _b;
  const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
  const mergedObject = {};
  for (let key of allKeys)
    mergedObject[key] = unique([...(_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : [], ...(_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : []]);
  return mergedObject;
};
const mergePropertyAndMethodDecorators = (d1, d2) => {
  var _a, _b, _c, _d;
  return {
    property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),
    method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})
  };
};
const mergeDecorators = (d1, d2) => {
  var _a, _b, _c, _d, _e, _f;
  return {
    class: unique([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),
    static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),
    instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})
  };
};
const decorators = /* @__PURE__ */ new Map();
const findAllConstituentClasses = (...classes) => {
  var _a;
  const allClasses = /* @__PURE__ */ new Set();
  const frontier = /* @__PURE__ */ new Set([...classes]);
  while (frontier.size > 0) {
    for (let clazz of frontier) {
      const protoChainClasses = protoChain(clazz.prototype).map((proto) => proto.constructor);
      const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];
      const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
      const newClasses = potentiallyNewClasses.filter((c) => !allClasses.has(c));
      for (let newClass of newClasses)
        frontier.add(newClass);
      allClasses.add(clazz);
      frontier.delete(clazz);
    }
  }
  return [...allClasses];
};
const deepDecoratorSearch = (...classes) => {
  const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
  if (decoratorsForClassChain.length == 0)
    return {};
  if (decoratorsForClassChain.length == 1)
    return decoratorsForClassChain[0];
  return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
};
const directDecoratorSearch = (...classes) => {
  const classDecorators = classes.map((clazz) => getDecoratorsForClass(clazz));
  if (classDecorators.length === 0)
    return {};
  if (classDecorators.length === 1)
    return classDecorators[0];
  return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
};
const getDecoratorsForClass = (clazz) => {
  let decoratorsForClass = decorators.get(clazz);
  if (!decoratorsForClass) {
    decoratorsForClass = {};
    decorators.set(clazz, decoratorsForClass);
  }
  return decoratorsForClass;
};
const decorateClass = (decorator) => (clazz) => {
  const decoratorsForClass = getDecoratorsForClass(clazz);
  let classDecorators = decoratorsForClass.class;
  if (!classDecorators) {
    classDecorators = [];
    decoratorsForClass.class = classDecorators;
  }
  classDecorators.push(decorator);
  return decorator(clazz);
};
const decorateMember = (decorator) => (object2, key, ...otherArgs) => {
  var _a, _b, _c;
  const decoratorTargetType = typeof object2 === "function" ? "static" : "instance";
  const decoratorType = typeof object2[key] === "function" ? "method" : "property";
  const clazz = decoratorTargetType === "static" ? object2 : object2.constructor;
  const decoratorsForClass = getDecoratorsForClass(clazz);
  const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};
  decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
  let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};
  decoratorsForTargetType[decoratorType] = decoratorsForType;
  let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];
  decoratorsForType[key] = decoratorsForKey;
  decoratorsForKey.push(decorator);
  return decorator(object2, key, ...otherArgs);
};
const decorate = (decorator) => (...args) => {
  if (args.length === 1)
    return decorateClass(decorator)(args[0]);
  return decorateMember(decorator)(...args);
};
function Mixin(...constructors) {
  var _a, _b, _c;
  const prototypes = constructors.map((constructor2) => constructor2.prototype);
  const initFunctionName = settings$1.initFunction;
  if (initFunctionName !== null) {
    const initFunctions = prototypes.map((proto) => proto[initFunctionName]).filter((func) => typeof func === "function");
    const combinedInitFunction = function(...args) {
      for (let initFunction of initFunctions)
        initFunction.apply(this, args);
    };
    const extraProto = { [initFunctionName]: combinedInitFunction };
    prototypes.push(extraProto);
  }
  function MixedClass(...args) {
    for (const constructor2 of constructors)
      copyProps(this, new constructor2(...args));
    if (initFunctionName !== null && typeof this[initFunctionName] === "function")
      this[initFunctionName].apply(this, args);
  }
  MixedClass.prototype = settings$1.prototypeStrategy === "copy" ? hardMixProtos(prototypes, MixedClass) : softMixProtos(prototypes, MixedClass);
  Object.setPrototypeOf(MixedClass, settings$1.staticsStrategy === "copy" ? hardMixProtos(constructors, null, ["prototype"]) : proxyMix(constructors, Function.prototype));
  let DecoratedMixedClass = MixedClass;
  if (settings$1.decoratorInheritance !== "none") {
    const classDecorators = settings$1.decoratorInheritance === "deep" ? deepDecoratorSearch(...constructors) : directDecoratorSearch(...constructors);
    for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {
      const result = decorator(DecoratedMixedClass);
      if (result) {
        DecoratedMixedClass = result;
      }
    }
    applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);
    applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);
  }
  registerMixins(DecoratedMixedClass, constructors);
  return DecoratedMixedClass;
}
const applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
  const propDecorators = propAndMethodDecorators.property;
  const methodDecorators = propAndMethodDecorators.method;
  if (propDecorators)
    for (let key in propDecorators)
      for (let decorator of propDecorators[key])
        decorator(target, key);
  if (methodDecorators)
    for (let key in methodDecorators)
      for (let decorator of methodDecorators[key])
        decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
};
const mix = (...ingredients) => (decoratedClass) => {
  const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
  Object.defineProperty(mixedClass, "name", {
    value: decoratedClass.name,
    writable: false
  });
  return mixedClass;
};
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Mixin,
  decorate,
  hasMixin,
  mix,
  settings: settings$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(esm);
var customTypes = {};
var arrayBuffer = {};
var hasRequiredArrayBuffer;
function requireArrayBuffer() {
  if (hasRequiredArrayBuffer) return arrayBuffer;
  hasRequiredArrayBuffer = 1;
  Object.defineProperty(arrayBuffer, "__esModule", {
    value: true
  });
  arrayBuffer.ArrayBufferBuilder = void 0;
  const typebox_1 = requireCjs();
  typebox_1.TypeRegistry.Set("ArrayBuffer", (_, value2) => value2 instanceof ArrayBuffer);
  class ArrayBufferBuilder extends typebox_1.JavaScriptTypeBuilder {
    ArrayBuffer(options) {
      return (0, typebox_1.CreateType)({
        [typebox_1.Kind]: "ArrayBuffer",
        type: "ArrayBuffer"
      }, options);
    }
  }
  arrayBuffer.ArrayBufferBuilder = ArrayBufferBuilder;
  return arrayBuffer;
}
var buffer = {};
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  Object.defineProperty(buffer, "__esModule", {
    value: true
  });
  buffer.BufferBuilder = void 0;
  const typebox_1 = requireCjs();
  typebox_1.TypeRegistry.Set("Buffer", (_, value2) => value2 instanceof Buffer);
  class BufferBuilder extends typebox_1.JavaScriptTypeBuilder {
    Buffer(options) {
      return (0, typebox_1.CreateType)({
        [typebox_1.Kind]: "Buffer",
        type: "Buffer"
      }, options);
    }
  }
  buffer.BufferBuilder = BufferBuilder;
  return buffer;
}
var keyofEnum = {};
var hasRequiredKeyofEnum;
function requireKeyofEnum() {
  if (hasRequiredKeyofEnum) return keyofEnum;
  hasRequiredKeyofEnum = 1;
  Object.defineProperty(keyofEnum, "__esModule", {
    value: true
  });
  keyofEnum.KeyofEnumBuilder = void 0;
  const typebox_1 = requireCjs();
  class KeyofEnumBuilder extends typebox_1.JavaScriptTypeBuilder {
    KeyOfEnum(schema2, options) {
      const keys = Object.keys(schema2).map((key) => this.Literal(key));
      return this.Union(keys, {
        ...options,
        [typebox_1.Hint]: "KeyOfEnum"
      });
    }
    Enum(schema2, options) {
      const anyOf = Object.entries(schema2).filter(([key, _value]) => typeof key === "string" || !isNaN(key)).map(([key, value2]) => this.Literal(value2, {
        $id: key
      }));
      return this.Union(anyOf, {
        ...options,
        [typebox_1.Hint]: "Enum"
      });
    }
  }
  keyofEnum.KeyofEnumBuilder = KeyofEnumBuilder;
  return keyofEnum;
}
var uint = {};
var hasRequiredUint;
function requireUint() {
  if (hasRequiredUint) return uint;
  hasRequiredUint = 1;
  Object.defineProperty(uint, "__esModule", {
    value: true
  });
  uint.UintBuilder = void 0;
  const typebox_1 = requireCjs();
  typebox_1.TypeRegistry.Set("Uint", (schema2, value2) => {
    if (typeof value2 !== "string" && typeof value2 !== "number") {
      return false;
    }
    if (typeof value2 === "number" && !Number.isSafeInteger(value2) || !/^(?:[1-9]\d*|\d)$/.test(value2.toString().replace(/^-/, schema2.allowNegative ? "" : "-"))) {
      return false;
    }
    return true;
  });
  class UintBuilder extends typebox_1.JavaScriptTypeBuilder {
    Uint(options) {
      return (0, typebox_1.CreateType)({
        [typebox_1.Kind]: "Uint",
        type: "Uint"
      }, options);
    }
  }
  uint.UintBuilder = UintBuilder;
  return uint;
}
var hasRequiredCustomTypes;
function requireCustomTypes() {
  if (hasRequiredCustomTypes) return customTypes;
  hasRequiredCustomTypes = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.UintBuilder = exports$12.KeyofEnumBuilder = exports$12.BufferBuilder = exports$12.ArrayBufferBuilder = void 0;
    var array_buffer_1 = requireArrayBuffer();
    Object.defineProperty(exports$12, "ArrayBufferBuilder", {
      enumerable: true,
      get: function() {
        return array_buffer_1.ArrayBufferBuilder;
      }
    });
    var buffer_1 = requireBuffer();
    Object.defineProperty(exports$12, "BufferBuilder", {
      enumerable: true,
      get: function() {
        return buffer_1.BufferBuilder;
      }
    });
    var keyof_enum_1 = requireKeyofEnum();
    Object.defineProperty(exports$12, "KeyofEnumBuilder", {
      enumerable: true,
      get: function() {
        return keyof_enum_1.KeyofEnumBuilder;
      }
    });
    var uint_1 = requireUint();
    Object.defineProperty(exports$12, "UintBuilder", {
      enumerable: true,
      get: function() {
        return uint_1.UintBuilder;
      }
    });
  })(customTypes);
  return customTypes;
}
var errors = {};
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  Object.defineProperty(errors, "__esModule", {
    value: true
  });
  errors.InvalidParameter = void 0;
  class InvalidParameter extends Error {
    constructor(reason, field2, type2, value2) {
      let message2 = `Invalid parameter`;
      message2 += ` "${field2.substring(1)}"`;
      message2 += ` (= ${JSON.stringify(value2)})`;
      message2 += `: ${reason.replace(/'/g, '"')}`;
      super(message2);
      __publicField(this, "field");
      __publicField(this, "type");
      this.name = "InvalidParameter";
      this.field = field2;
      this.type = type2;
    }
  }
  errors.InvalidParameter = InvalidParameter;
  return errors;
}
var utils$1 = {};
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  Object.defineProperty(utils$1, "__esModule", {
    value: true
  });
  utils$1.setDeepValue = setDeepValue;
  utils$1.getDeepValue = getDeepValue;
  function setDeepValue(obj, [prop, ...path2], value2) {
    if (!path2.length) {
      obj[prop] = value2;
    } else {
      if (!(prop in obj)) obj[prop] = {};
      setDeepValue(obj[prop], path2, value2);
    }
  }
  function getDeepValue(obj, [prop, ...path2]) {
    if (!path2.length) {
      return obj[prop];
    } else {
      if (!(prop in obj)) return void 0;
      return getDeepValue(obj[prop], path2);
    }
  }
  return utils$1;
}
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$3;
  hasRequiredLib$3 = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.CloneType = exports$12.Optional = exports$12.Type = void 0;
    exports$12.Validate = Validate;
    exports$12.Assert = Assert;
    exports$12.AssertWeak = AssertWeak;
    const typebox_1 = requireCjs();
    Object.defineProperty(exports$12, "CloneType", {
      enumerable: true,
      get: function() {
        return typebox_1.CloneType;
      }
    });
    Object.defineProperty(exports$12, "Optional", {
      enumerable: true,
      get: function() {
        return typebox_1.Optional;
      }
    });
    const errors_1 = requireErrors$1();
    const ts_mixer_1 = require$$2;
    const custom_types_1 = requireCustomTypes();
    const errors_2 = requireErrors();
    const utils_12 = requireUtils$1();
    class CustomTypeBuilder extends (0, ts_mixer_1.Mixin)(typebox_1.JavaScriptTypeBuilder, custom_types_1.ArrayBufferBuilder, custom_types_1.BufferBuilder, custom_types_1.KeyofEnumBuilder, custom_types_1.UintBuilder) {
    }
    function Validate(schema2, value2) {
      try {
        Assert(schema2, value2);
        return true;
      } catch {
        return false;
      }
    }
    function FindErrorInUnion(error2) {
      const currentValue = error2.value;
      const unionMembers = error2.schema.anyOf;
      const hasValidMember = unionMembers.find((unionSchema) => Validate(unionSchema, currentValue));
      if (!hasValidMember) {
        const possibleMatchesByLiterals = unionMembers.filter((unionSchema) => {
          if (unionSchema[typebox_1.Kind] !== "Object") return false;
          return !Object.entries(unionSchema.properties).find(([property, propertySchema]) => propertySchema.const && propertySchema.const !== currentValue[property]);
        });
        if (possibleMatchesByLiterals.length === 1) {
          Assert(possibleMatchesByLiterals[0], currentValue);
        } else if (possibleMatchesByLiterals.length > 1) {
          const errorsOfPossibleMatches = possibleMatchesByLiterals.map((matchSchema) => ({
            schema: matchSchema,
            errors: [...(0, errors_1.Errors)(matchSchema, currentValue)]
          }));
          const sortedErrors = errorsOfPossibleMatches.sort((a, b) => a.errors.length - b.errors.length);
          const [bestMatch] = sortedErrors;
          Assert(bestMatch.schema, currentValue);
        }
        throw new errors_2.InvalidParameter(error2.message, error2.path, error2.type, error2.value);
      }
    }
    function Assert(schema2, value2) {
      const errors2 = [...(0, errors_1.Errors)(schema2, value2)];
      let [error2] = errors2;
      while (error2) {
        if (error2.path === "/" && errors2.length > 1) ;
        else if (error2.value == null && error2.schema[typebox_1.OptionalKind] === "Optional") ;
        else if (error2.type === errors_1.ValueErrorType.Union) {
          FindErrorInUnion(error2);
        } else if (error2.type === errors_1.ValueErrorType.Number && typeof error2.value === "string") {
          const currentValue = error2.value;
          const parsedNumber = Number(currentValue);
          if (!Number.isNaN(parsedNumber) && currentValue === parsedNumber.toString()) {
            const pathParts = error2.path.slice(1).split("/");
            (0, utils_12.setDeepValue)(value2, pathParts, parsedNumber);
          } else {
            throw new errors_2.InvalidParameter(error2.message, error2.path, error2.type, error2.value);
          }
        } else {
          throw new errors_2.InvalidParameter(error2.message, error2.path, error2.type, error2.value);
        }
        errors2.shift();
        [error2] = errors2;
      }
    }
    function AssertWeak(schema2, value2) {
      try {
        Assert(schema2, value2);
      } catch (e) {
        if (e instanceof errors_2.InvalidParameter) {
          if (e.type === errors_1.ValueErrorType.ObjectRequiredProperty) {
            throw e;
          }
          console.warn("Method params validation failed", e);
        } else {
          throw e;
        }
      }
    }
    exports$12.Type = new CustomTypeBuilder();
  })(lib$3);
  return lib$3;
}
var hasRequiredNem;
function requireNem() {
  if (hasRequiredNem) return nem;
  hasRequiredNem = 1;
  Object.defineProperty(nem, "__esModule", {
    value: true
  });
  nem.EnumTxVersion = nem.TxVersion = nem.EnumTxType = nem.TxType = nem.EnumNetworks = nem.Networks = void 0;
  const schema_utils_1 = requireLib$3();
  var Networks;
  (function(Networks2) {
    Networks2[Networks2["mainnet"] = 104] = "mainnet";
    Networks2[Networks2["testnet"] = 152] = "testnet";
    Networks2[Networks2["mijin"] = 96] = "mijin";
  })(Networks || (nem.Networks = Networks = {}));
  nem.EnumNetworks = schema_utils_1.Type.Enum(Networks);
  var TxType;
  (function(TxType2) {
    TxType2[TxType2["TRANSFER"] = 257] = "TRANSFER";
    TxType2[TxType2["COSIGNING"] = 258] = "COSIGNING";
    TxType2[TxType2["IMPORTANCE_TRANSFER"] = 2049] = "IMPORTANCE_TRANSFER";
    TxType2[TxType2["AGGREGATE_MODIFICATION"] = 4097] = "AGGREGATE_MODIFICATION";
    TxType2[TxType2["MULTISIG_SIGNATURE"] = 4098] = "MULTISIG_SIGNATURE";
    TxType2[TxType2["MULTISIG"] = 4100] = "MULTISIG";
    TxType2[TxType2["PROVISION_NAMESPACE"] = 8193] = "PROVISION_NAMESPACE";
    TxType2[TxType2["MOSAIC_CREATION"] = 16385] = "MOSAIC_CREATION";
    TxType2[TxType2["SUPPLY_CHANGE"] = 16386] = "SUPPLY_CHANGE";
  })(TxType || (nem.TxType = TxType = {}));
  nem.EnumTxType = schema_utils_1.Type.Enum(TxType);
  var TxVersion;
  (function(TxVersion2) {
    TxVersion2[TxVersion2["mainnet"] = 1744830464] = "mainnet";
    TxVersion2[TxVersion2["testnet"] = -1744830464] = "testnet";
    TxVersion2[TxVersion2["mijin"] = 1610612736] = "mijin";
  })(TxVersion || (nem.TxVersion = TxVersion = {}));
  nem.EnumTxVersion = schema_utils_1.Type.Enum(TxVersion);
  return nem;
}
var firmware$1 = {};
var hasRequiredFirmware$1;
function requireFirmware$1() {
  if (hasRequiredFirmware$1) return firmware$1;
  hasRequiredFirmware$1 = 1;
  Object.defineProperty(firmware$1, "__esModule", {
    value: true
  });
  firmware$1.REVISION_CHECK_RETRIABLE_ERRORS = firmware$1.HASH_CHECK_RETRIABLE_ERRORS = firmware$1.HASH_CHECK_MAX_ATTEMPTS = void 0;
  firmware$1.HASH_CHECK_MAX_ATTEMPTS = 3;
  firmware$1.HASH_CHECK_RETRIABLE_ERRORS = ["other-error"];
  firmware$1.REVISION_CHECK_RETRIABLE_ERRORS = ["cannot-perform-check-offline", "other-error"];
  return firmware$1;
}
var utxo = {};
var hasRequiredUtxo;
function requireUtxo() {
  if (hasRequiredUtxo) return utxo;
  hasRequiredUtxo = 1;
  Object.defineProperty(utxo, "__esModule", {
    value: true
  });
  utxo.DEFAULT_SORTING_STRATEGY = void 0;
  utxo.DEFAULT_SORTING_STRATEGY = "random";
  return utxo;
}
var lib$2 = {};
var umd = { exports: {} };
var hasRequiredUmd;
function requireUmd() {
  if (hasRequiredUmd) return umd.exports;
  hasRequiredUmd = 1;
  (function(module, exports$12) {
    var Long = function(exports$13) {
      Object.defineProperty(exports$13, "__esModule", {
        value: true
      });
      exports$13.default = void 0;
      /**
       * @license
       * Copyright 2009 The Closure Library Authors
       * Copyright 2020 Daniel Wirtz / The long.js Authors.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       *
       * SPDX-License-Identifier: Apache-2.0
       */
      var wasm = null;
      try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
      } catch (e) {
      }
      function Long2(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long2.prototype.__isLong__;
      Object.defineProperty(Long2.prototype, "__isLong__", {
        value: true
      });
      function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      function ctz32(value2) {
        var c = Math.clz32(value2 & -value2);
        return value2 ? 31 - c : c;
      }
      Long2.isLong = isLong;
      var INT_CACHE = {};
      var UINT_CACHE = {};
      function fromInt(value2, unsigned) {
        var obj, cachedObj, cache2;
        if (unsigned) {
          value2 >>>= 0;
          if (cache2 = 0 <= value2 && value2 < 256) {
            cachedObj = UINT_CACHE[value2];
            if (cachedObj) return cachedObj;
          }
          obj = fromBits(value2, 0, true);
          if (cache2) UINT_CACHE[value2] = obj;
          return obj;
        } else {
          value2 |= 0;
          if (cache2 = -128 <= value2 && value2 < 128) {
            cachedObj = INT_CACHE[value2];
            if (cachedObj) return cachedObj;
          }
          obj = fromBits(value2, value2 < 0 ? -1 : 0, false);
          if (cache2) INT_CACHE[value2] = obj;
          return obj;
        }
      }
      Long2.fromInt = fromInt;
      function fromNumber(value2, unsigned) {
        if (isNaN(value2)) return unsigned ? UZERO : ZERO;
        if (unsigned) {
          if (value2 < 0) return UZERO;
          if (value2 >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
        } else {
          if (value2 <= -TWO_PWR_63_DBL) return MIN_VALUE;
          if (value2 + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
        }
        if (value2 < 0) return fromNumber(-value2, unsigned).neg();
        return fromBits(value2 % TWO_PWR_32_DBL | 0, value2 / TWO_PWR_32_DBL | 0, unsigned);
      }
      Long2.fromNumber = fromNumber;
      function fromBits(lowBits, highBits, unsigned) {
        return new Long2(lowBits, highBits, unsigned);
      }
      Long2.fromBits = fromBits;
      var pow_dbl = Math.pow;
      function fromString(str, unsigned, radix) {
        if (str.length === 0) throw Error("empty string");
        if (typeof unsigned === "number") {
          radix = unsigned;
          unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError("radix");
        var p;
        if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
        else if (p === 0) {
          return fromString(str.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
          var size = Math.min(8, str.length - i), value2 = parseInt(str.substring(i, i + size), radix);
          if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value2));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value2));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      Long2.fromString = fromString;
      function fromValue(val, unsigned) {
        if (typeof val === "number") return fromNumber(val, unsigned);
        if (typeof val === "string") return fromString(val, unsigned);
        return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
      }
      Long2.fromValue = fromValue;
      var TWO_PWR_16_DBL = 1 << 16;
      var TWO_PWR_24_DBL = 1 << 24;
      var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      var ZERO = fromInt(0);
      Long2.ZERO = ZERO;
      var UZERO = fromInt(0, true);
      Long2.UZERO = UZERO;
      var ONE = fromInt(1);
      Long2.ONE = ONE;
      var UONE = fromInt(1, true);
      Long2.UONE = UONE;
      var NEG_ONE = fromInt(-1);
      Long2.NEG_ONE = NEG_ONE;
      var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long2.MAX_VALUE = MAX_VALUE;
      var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long2.MIN_VALUE = MIN_VALUE;
      var LongPrototype = Long2.prototype;
      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype.toNumber = function toNumber() {
        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError("radix");
        if (this.isZero()) return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero()) return digits + result;
          else {
            while (digits.length < 6) digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype.eqz = LongPrototype.isZero;
      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
      };
      LongPrototype.equals = function equals(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(
          /* validates */
          other
        );
      };
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.ne = LongPrototype.notEquals;
      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      };
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      };
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.le = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      };
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      };
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.ge = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = function compare(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.eq(other)) return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) return -1;
        if (!thisNeg && otherNeg) return 1;
        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
        return this.not().add(ONE);
      };
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = function add(addend) {
        if (!isLong(addend)) addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero()) return this;
        if (!isLong(multiplier)) multiplier = fromValue(multiplier);
        if (wasm) {
          var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
          else return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        if (divisor.isZero()) throw Error("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (this.isZero()) return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE)) return ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO)) {
                return divisor.isNegative() ? ONE : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative()) return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
          res = ZERO;
        } else {
          if (!divisor.unsigned) divisor = divisor.toUnsigned();
          if (divisor.gt(this)) return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero()) approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        if (wasm) {
          var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.rem = LongPrototype.modulo;
      LongPrototype.not = function not2() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype.countLeadingZeros = function countLeadingZeros() {
        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
      };
      LongPrototype.clz = LongPrototype.countLeadingZeros;
      LongPrototype.countTrailingZeros = function countTrailingZeros() {
        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
      };
      LongPrototype.ctz = LongPrototype.countTrailingZeros;
      LongPrototype.and = function and(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype.or = function or(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype.xor = function xor(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
        if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
      };
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
      LongPrototype.rotateLeft = function rotateLeft(numBits) {
        var b;
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
      };
      LongPrototype.rotl = LongPrototype.rotateLeft;
      LongPrototype.rotateRight = function rotateRight(numBits) {
        var b;
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
      };
      LongPrototype.rotr = LongPrototype.rotateRight;
      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned) return this;
        return fromBits(this.low, this.high, false);
      };
      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned) return this;
        return fromBits(this.low, this.high, true);
      };
      LongPrototype.toBytes = function toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype.toBytesLE = function toBytesLE() {
        var hi = this.high, lo = this.low;
        return [lo & 255, lo >>> 8 & 255, lo >>> 16 & 255, lo >>> 24, hi & 255, hi >>> 8 & 255, hi >>> 16 & 255, hi >>> 24];
      };
      LongPrototype.toBytesBE = function toBytesBE() {
        var hi = this.high, lo = this.low;
        return [hi >>> 24, hi >>> 16 & 255, hi >>> 8 & 255, hi & 255, lo >>> 24, lo >>> 16 & 255, lo >>> 8 & 255, lo & 255];
      };
      Long2.fromBytes = function fromBytes(bytes, unsigned, le) {
        return le ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
      };
      Long2.fromBytesLE = function fromBytesLE(bytes, unsigned) {
        return new Long2(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
      };
      Long2.fromBytesBE = function fromBytesBE(bytes, unsigned) {
        return new Long2(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
      };
      var _default = Long2;
      exports$13.default = _default;
      return "default" in exports$13 ? exports$13.default : exports$13;
    }({});
    module.exports = Long;
  })(umd);
  return umd.exports;
}
var indexLight = { exports: {} };
var indexMinimal = {};
var minimal = {};
var aspromise;
var hasRequiredAspromise;
function requireAspromise() {
  if (hasRequiredAspromise) return aspromise;
  hasRequiredAspromise = 1;
  aspromise = asPromise;
  function asPromise(fn, ctx) {
    var params2 = new Array(arguments.length - 1), offset = 0, index2 = 2, pending = true;
    while (index2 < arguments.length)
      params2[offset++] = arguments[index2++];
    return new Promise(function executor(resolve, reject) {
      params2[offset] = function callback(err) {
        if (pending) {
          pending = false;
          if (err)
            reject(err);
          else {
            var params3 = new Array(arguments.length - 1), offset2 = 0;
            while (offset2 < params3.length)
              params3[offset2++] = arguments[offset2];
            resolve.apply(null, params3);
          }
        }
      };
      try {
        fn.apply(ctx || null, params2);
      } catch (err) {
        if (pending) {
          pending = false;
          reject(err);
        }
      }
    });
  }
  return aspromise;
}
var base64 = {};
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  (function(exports$12) {
    var base642 = exports$12;
    base642.length = function length(string2) {
      var p = string2.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string2.charAt(p) === "=")
        ++n;
      return Math.ceil(string2.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (var i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    base642.encode = function encode2(buffer2, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer2[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base642.decode = function decode2(string2, buffer2, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string2.length; ) {
        var c = string2.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base642.test = function test(string2) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
    };
  })(base64);
  return base64;
}
var eventemitter;
var hasRequiredEventemitter;
function requireEventemitter() {
  if (hasRequiredEventemitter) return eventemitter;
  hasRequiredEventemitter = 1;
  eventemitter = EventEmitter;
  function EventEmitter() {
    this._listeners = {};
  }
  EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
      fn,
      ctx: ctx || this
    });
    return this;
  };
  EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === void 0)
      this._listeners = {};
    else {
      if (fn === void 0)
        this._listeners[evt] = [];
      else {
        var listeners = this._listeners[evt];
        for (var i = 0; i < listeners.length; )
          if (listeners[i].fn === fn)
            listeners.splice(i, 1);
          else
            ++i;
      }
    }
    return this;
  };
  EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
      var args = [], i = 1;
      for (; i < arguments.length; )
        args.push(arguments[i++]);
      for (i = 0; i < listeners.length; )
        listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
  };
  return eventemitter;
}
var float;
var hasRequiredFloat;
function requireFloat() {
  if (hasRequiredFloat) return float;
  hasRequiredFloat = 1;
  float = factory2(factory2);
  function factory2(exports$12) {
    if (typeof Float32Array !== "undefined") (function() {
      var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
      function writeFloat_f32_cpy(val, buf, pos) {
        f32[0] = val;
        buf[pos] = f8b[0];
        buf[pos + 1] = f8b[1];
        buf[pos + 2] = f8b[2];
        buf[pos + 3] = f8b[3];
      }
      function writeFloat_f32_rev(val, buf, pos) {
        f32[0] = val;
        buf[pos] = f8b[3];
        buf[pos + 1] = f8b[2];
        buf[pos + 2] = f8b[1];
        buf[pos + 3] = f8b[0];
      }
      exports$12.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
      exports$12.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
      function readFloat_f32_cpy(buf, pos) {
        f8b[0] = buf[pos];
        f8b[1] = buf[pos + 1];
        f8b[2] = buf[pos + 2];
        f8b[3] = buf[pos + 3];
        return f32[0];
      }
      function readFloat_f32_rev(buf, pos) {
        f8b[3] = buf[pos];
        f8b[2] = buf[pos + 1];
        f8b[1] = buf[pos + 2];
        f8b[0] = buf[pos + 3];
        return f32[0];
      }
      exports$12.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
      exports$12.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
    })();
    else (function() {
      function writeFloat_ieee754(writeUint, val, buf, pos) {
        var sign = val < 0 ? 1 : 0;
        if (sign)
          val = -val;
        if (val === 0)
          writeUint(1 / val > 0 ? (
            /* positive */
            0
          ) : (
            /* negative 0 */
            2147483648
          ), buf, pos);
        else if (isNaN(val))
          writeUint(2143289344, buf, pos);
        else if (val > 34028234663852886e22)
          writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
        else if (val < 11754943508222875e-54)
          writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
        else {
          var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
          writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
        }
      }
      exports$12.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
      exports$12.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
      function readFloat_ieee754(readUint, buf, pos) {
        var uint2 = readUint(buf, pos), sign = (uint2 >> 31) * 2 + 1, exponent = uint2 >>> 23 & 255, mantissa = uint2 & 8388607;
        return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
      }
      exports$12.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
      exports$12.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
    })();
    if (typeof Float64Array !== "undefined") (function() {
      var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
      function writeDouble_f64_cpy(val, buf, pos) {
        f64[0] = val;
        buf[pos] = f8b[0];
        buf[pos + 1] = f8b[1];
        buf[pos + 2] = f8b[2];
        buf[pos + 3] = f8b[3];
        buf[pos + 4] = f8b[4];
        buf[pos + 5] = f8b[5];
        buf[pos + 6] = f8b[6];
        buf[pos + 7] = f8b[7];
      }
      function writeDouble_f64_rev(val, buf, pos) {
        f64[0] = val;
        buf[pos] = f8b[7];
        buf[pos + 1] = f8b[6];
        buf[pos + 2] = f8b[5];
        buf[pos + 3] = f8b[4];
        buf[pos + 4] = f8b[3];
        buf[pos + 5] = f8b[2];
        buf[pos + 6] = f8b[1];
        buf[pos + 7] = f8b[0];
      }
      exports$12.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
      exports$12.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
      function readDouble_f64_cpy(buf, pos) {
        f8b[0] = buf[pos];
        f8b[1] = buf[pos + 1];
        f8b[2] = buf[pos + 2];
        f8b[3] = buf[pos + 3];
        f8b[4] = buf[pos + 4];
        f8b[5] = buf[pos + 5];
        f8b[6] = buf[pos + 6];
        f8b[7] = buf[pos + 7];
        return f64[0];
      }
      function readDouble_f64_rev(buf, pos) {
        f8b[7] = buf[pos];
        f8b[6] = buf[pos + 1];
        f8b[5] = buf[pos + 2];
        f8b[4] = buf[pos + 3];
        f8b[3] = buf[pos + 4];
        f8b[2] = buf[pos + 5];
        f8b[1] = buf[pos + 6];
        f8b[0] = buf[pos + 7];
        return f64[0];
      }
      exports$12.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
      exports$12.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
    })();
    else (function() {
      function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
        var sign = val < 0 ? 1 : 0;
        if (sign)
          val = -val;
        if (val === 0) {
          writeUint(0, buf, pos + off0);
          writeUint(1 / val > 0 ? (
            /* positive */
            0
          ) : (
            /* negative 0 */
            2147483648
          ), buf, pos + off1);
        } else if (isNaN(val)) {
          writeUint(0, buf, pos + off0);
          writeUint(2146959360, buf, pos + off1);
        } else if (val > 17976931348623157e292) {
          writeUint(0, buf, pos + off0);
          writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
        } else {
          var mantissa;
          if (val < 22250738585072014e-324) {
            mantissa = val / 5e-324;
            writeUint(mantissa >>> 0, buf, pos + off0);
            writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
          } else {
            var exponent = Math.floor(Math.log(val) / Math.LN2);
            if (exponent === 1024)
              exponent = 1023;
            mantissa = val * Math.pow(2, -exponent);
            writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
            writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
          }
        }
      }
      exports$12.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
      exports$12.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
      function readDouble_ieee754(readUint, off0, off1, buf, pos) {
        var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
        var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
        return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
      }
      exports$12.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
      exports$12.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
    })();
    return exports$12;
  }
  function writeUintLE(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  function writeUintBE(val, buf, pos) {
    buf[pos] = val >>> 24;
    buf[pos + 1] = val >>> 16 & 255;
    buf[pos + 2] = val >>> 8 & 255;
    buf[pos + 3] = val & 255;
  }
  function readUintLE(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
  }
  function readUintBE(buf, pos) {
    return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
  }
  return float;
}
var inquire_1;
var hasRequiredInquire;
function requireInquire() {
  if (hasRequiredInquire) return inquire_1;
  hasRequiredInquire = 1;
  inquire_1 = inquire;
  function inquire(moduleName) {
    try {
      var mod = null;
      if (mod && (mod.length || Object.keys(mod).length))
        return mod;
    } catch (e) {
    }
    return null;
  }
  return inquire_1;
}
var utf8 = {};
var hasRequiredUtf8;
function requireUtf8() {
  if (hasRequiredUtf8) return utf8;
  hasRequiredUtf8 = 1;
  (function(exports$12) {
    var utf82 = exports$12;
    utf82.length = function utf8_length(string2) {
      var len = 0, c = 0;
      for (var i = 0; i < string2.length; ++i) {
        c = string2.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string2.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf82.read = function utf8_read(buffer2, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer2[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer2[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf82.write = function utf8_write(string2, buffer2, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string2.length; ++i) {
        c1 = string2.charCodeAt(i);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  })(utf8);
  return utf8;
}
var pool_1;
var hasRequiredPool;
function requirePool() {
  if (hasRequiredPool) return pool_1;
  hasRequiredPool = 1;
  pool_1 = pool;
  function pool(alloc, slice, size) {
    var SIZE = size || 8192;
    var MAX = SIZE >>> 1;
    var slab = null;
    var offset = SIZE;
    return function pool_alloc(size2) {
      if (size2 < 1 || size2 > MAX)
        return alloc(size2);
      if (offset + size2 > SIZE) {
        slab = alloc(SIZE);
        offset = 0;
      }
      var buf = slice.call(slab, offset, offset += size2);
      if (offset & 7)
        offset = (offset | 7) + 1;
      return buf;
    };
  }
  return pool_1;
}
var longbits;
var hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits) return longbits;
  hasRequiredLongbits = 1;
  longbits = LongBits;
  var util2 = requireMinimal();
  function LongBits(lo, hi) {
    this.lo = lo >>> 0;
    this.hi = hi >>> 0;
  }
  var zero = LongBits.zero = new LongBits(0, 0);
  zero.toNumber = function() {
    return 0;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
  LongBits.fromNumber = function fromNumber(value2) {
    if (value2 === 0)
      return zero;
    var sign = value2 < 0;
    if (sign)
      value2 = -value2;
    var lo = value2 >>> 0, hi = (value2 - lo) / 4294967296 >>> 0;
    if (sign) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295)
          hi = 0;
      }
    }
    return new LongBits(lo, hi);
  };
  LongBits.from = function from(value2) {
    if (typeof value2 === "number")
      return LongBits.fromNumber(value2);
    if (util2.isString(value2)) {
      if (util2.Long)
        value2 = util2.Long.fromString(value2);
      else
        return LongBits.fromNumber(parseInt(value2, 10));
    }
    return value2.low || value2.high ? new LongBits(value2.low >>> 0, value2.high >>> 0) : zero;
  };
  LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
      var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
      if (!lo)
        hi = hi + 1 >>> 0;
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits.prototype.toLong = function toLong(unsigned) {
    return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
  };
  var charCodeAt = String.prototype.charCodeAt;
  LongBits.fromHash = function fromHash(hash2) {
    if (hash2 === zeroHash)
      return zero;
    return new LongBits(
      (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
      (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
    );
  };
  LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  };
  LongBits.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.length = function length() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
  return longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  if (hasRequiredMinimal) return minimal;
  hasRequiredMinimal = 1;
  (function(exports$12) {
    var util2 = exports$12;
    util2.asPromise = requireAspromise();
    util2.base64 = requireBase64();
    util2.EventEmitter = requireEventemitter();
    util2.float = requireFloat();
    util2.inquire = requireInquire();
    util2.utf8 = requireUtf8();
    util2.pool = requirePool();
    util2.LongBits = requireLongbits();
    util2.isNode = Boolean(typeof globalThis !== "undefined" && globalThis && globalThis.process && globalThis.process.versions && globalThis.process.versions.node);
    util2.global = util2.isNode && globalThis || typeof window !== "undefined" && window || typeof self !== "undefined" && self || commonjsGlobal;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util2.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util2.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value2) {
      return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2;
    };
    util2.isString = function isString(value2) {
      return typeof value2 === "string" || value2 instanceof String;
    };
    util2.isObject = function isObject(value2) {
      return value2 && typeof value2 === "object";
    };
    util2.isset = /**
    * Checks if a property on a message is considered to be present.
    * @param {Object} obj Plain object or message instance
    * @param {string} prop Property name
    * @returns {boolean} `true` if considered to be present, otherwise `false`
    */
    util2.isSet = function isSet(obj, prop) {
      var value2 = obj[prop];
      if (value2 != null && obj.hasOwnProperty(prop))
        return typeof value2 !== "object" || (Array.isArray(value2) ? value2.length : Object.keys(value2).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer2 = util2.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = /* istanbul ignore next */
    util2.global.dcodeIO && /* istanbul ignore next */
    util2.global.dcodeIO.Long || /* istanbul ignore next */
    util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value2) {
      return value2 ? util2.LongBits.from(value2).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util2.LongBits.fromHash(hash2);
      if (util2.Long)
        return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util2.merge = merge;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message2, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message2, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message2;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value2() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer2 = util2.Buffer;
      if (!Buffer2) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value2, encoding) {
        return new Buffer2(value2, encoding);
      };
      util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  })(minimal);
  return minimal;
}
var writer;
var hasRequiredWriter;
function requireWriter() {
  if (hasRequiredWriter) return writer;
  hasRequiredWriter = 1;
  writer = Writer;
  var util2 = requireMinimal();
  var BufferWriter;
  var LongBits = util2.LongBits, base642 = util2.base64, utf82 = util2.utf8;
  function Op(fn, len, val) {
    this.fn = fn;
    this.len = len;
    this.next = void 0;
    this.val = val;
  }
  function noop() {
  }
  function State(writer2) {
    this.head = writer2.head;
    this.tail = writer2.tail;
    this.len = writer2.len;
    this.next = writer2.states;
  }
  function Writer() {
    this.len = 0;
    this.head = new Op(noop, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  var create2 = function create3() {
    return util2.Buffer ? function create_buffer_setup() {
      return (Writer.create = function create_buffer() {
        return new BufferWriter();
      })();
    } : function create_array() {
      return new Writer();
    };
  };
  Writer.create = create2();
  Writer.alloc = function alloc(size) {
    return new util2.Array(size);
  };
  if (util2.Array !== Array)
    Writer.alloc = util2.pool(Writer.alloc, util2.Array.prototype.subarray);
  Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
  };
  function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
  }
  function writeVarint32(val, buf, pos) {
    while (val > 127) {
      buf[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf[pos] = val;
  }
  function VarintOp(len, val) {
    this.len = len;
    this.next = void 0;
    this.val = val;
  }
  VarintOp.prototype = Object.create(Op.prototype);
  VarintOp.prototype.fn = writeVarint32;
  Writer.prototype.uint32 = function write_uint32(value2) {
    this.len += (this.tail = this.tail.next = new VarintOp(
      (value2 = value2 >>> 0) < 128 ? 1 : value2 < 16384 ? 2 : value2 < 2097152 ? 3 : value2 < 268435456 ? 4 : 5,
      value2
    )).len;
    return this;
  };
  Writer.prototype.int32 = function write_int32(value2) {
    return value2 < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value2)) : this.uint32(value2);
  };
  Writer.prototype.sint32 = function write_sint32(value2) {
    return this.uint32((value2 << 1 ^ value2 >> 31) >>> 0);
  };
  function writeVarint64(val, buf, pos) {
    while (val.hi) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
  }
  Writer.prototype.uint64 = function write_uint64(value2) {
    var bits = LongBits.from(value2);
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.int64 = Writer.prototype.uint64;
  Writer.prototype.sint64 = function write_sint64(value2) {
    var bits = LongBits.from(value2).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.bool = function write_bool(value2) {
    return this._push(writeByte, 1, value2 ? 1 : 0);
  };
  function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  Writer.prototype.fixed32 = function write_fixed32(value2) {
    return this._push(writeFixed32, 4, value2 >>> 0);
  };
  Writer.prototype.sfixed32 = Writer.prototype.fixed32;
  Writer.prototype.fixed64 = function write_fixed64(value2) {
    var bits = LongBits.from(value2);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  };
  Writer.prototype.sfixed64 = Writer.prototype.fixed64;
  Writer.prototype.float = function write_float(value2) {
    return this._push(util2.float.writeFloatLE, 4, value2);
  };
  Writer.prototype.double = function write_double(value2) {
    return this._push(util2.float.writeDoubleLE, 8, value2);
  };
  var writeBytes = util2.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytes_for(val, buf, pos) {
    for (var i = 0; i < val.length; ++i)
      buf[pos + i] = val[i];
  };
  Writer.prototype.bytes = function write_bytes(value2) {
    var len = value2.length >>> 0;
    if (!len)
      return this._push(writeByte, 1, 0);
    if (util2.isString(value2)) {
      var buf = Writer.alloc(len = base642.length(value2));
      base642.decode(value2, buf, 0);
      value2 = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value2);
  };
  Writer.prototype.string = function write_string(value2) {
    var len = utf82.length(value2);
    return len ? this.uint32(len)._push(utf82.write, len, value2) : this._push(writeByte, 1, 0);
  };
  Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
  };
  Writer.prototype.reset = function reset() {
    if (this.states) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
    }
    return this;
  };
  Writer.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len = this.len;
    this.reset().uint32(len);
    if (len) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len;
    }
    return this;
  };
  Writer.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
    while (head) {
      head.fn(head.val, buf, pos);
      pos += head.len;
      head = head.next;
    }
    return buf;
  };
  Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create2();
    BufferWriter._configure();
  };
  return writer;
}
var writer_buffer;
var hasRequiredWriter_buffer;
function requireWriter_buffer() {
  if (hasRequiredWriter_buffer) return writer_buffer;
  hasRequiredWriter_buffer = 1;
  writer_buffer = BufferWriter;
  var Writer = requireWriter();
  (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
  var util2 = requireMinimal();
  function BufferWriter() {
    Writer.call(this);
  }
  BufferWriter._configure = function() {
    BufferWriter.alloc = util2._Buffer_allocUnsafe;
    BufferWriter.writeBytesBuffer = util2.Buffer && util2.Buffer.prototype instanceof Uint8Array && util2.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytesBuffer_copy(val, buf, pos) {
      if (val.copy)
        val.copy(buf, pos, 0, val.length);
      else for (var i = 0; i < val.length; )
        buf[pos++] = val[i++];
    };
  };
  BufferWriter.prototype.bytes = function write_bytes_buffer(value2) {
    if (util2.isString(value2))
      value2 = util2._Buffer_from(value2, "base64");
    var len = value2.length >>> 0;
    this.uint32(len);
    if (len)
      this._push(BufferWriter.writeBytesBuffer, len, value2);
    return this;
  };
  function writeStringBuffer(val, buf, pos) {
    if (val.length < 40)
      util2.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
      buf.utf8Write(val, pos);
    else
      buf.write(val, pos);
  }
  BufferWriter.prototype.string = function write_string_buffer(value2) {
    var len = util2.Buffer.byteLength(value2);
    this.uint32(len);
    if (len)
      this._push(writeStringBuffer, len, value2);
    return this;
  };
  BufferWriter._configure();
  return writer_buffer;
}
var reader;
var hasRequiredReader;
function requireReader() {
  if (hasRequiredReader) return reader;
  hasRequiredReader = 1;
  reader = Reader;
  var util2 = requireMinimal();
  var BufferReader;
  var LongBits = util2.LongBits, utf82 = util2.utf8;
  function indexOutOfRange(reader2, writeLength) {
    return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
  }
  function Reader(buffer2) {
    this.buf = buffer2;
    this.pos = 0;
    this.len = buffer2.length;
  }
  var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
    if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
      return new Reader(buffer2);
    throw Error("illegal buffer");
  } : function create_array2(buffer2) {
    if (Array.isArray(buffer2))
      return new Reader(buffer2);
    throw Error("illegal buffer");
  };
  var create2 = function create3() {
    return util2.Buffer ? function create_buffer_setup(buffer2) {
      return (Reader.create = function create_buffer(buffer3) {
        return util2.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
      })(buffer2);
    } : create_array;
  };
  Reader.create = create2();
  Reader.prototype._slice = util2.Array.prototype.subarray || /* istanbul ignore next */
  util2.Array.prototype.slice;
  Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
    var value2 = 4294967295;
    return function read_uint32() {
      value2 = (this.buf[this.pos] & 127) >>> 0;
      if (this.buf[this.pos++] < 128) return value2;
      value2 = (value2 | (this.buf[this.pos] & 127) << 7) >>> 0;
      if (this.buf[this.pos++] < 128) return value2;
      value2 = (value2 | (this.buf[this.pos] & 127) << 14) >>> 0;
      if (this.buf[this.pos++] < 128) return value2;
      value2 = (value2 | (this.buf[this.pos] & 127) << 21) >>> 0;
      if (this.buf[this.pos++] < 128) return value2;
      value2 = (value2 | (this.buf[this.pos] & 15) << 28) >>> 0;
      if (this.buf[this.pos++] < 128) return value2;
      if ((this.pos += 5) > this.len) {
        this.pos = this.len;
        throw indexOutOfRange(this, 10);
      }
      return value2;
    };
  }();
  Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
  };
  Reader.prototype.sint32 = function read_sint32() {
    var value2 = this.uint32();
    return value2 >>> 1 ^ -(value2 & 1) | 0;
  };
  function readLongVarint() {
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) {
      for (; i < 4; ++i) {
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
      i = 0;
    } else {
      for (; i < 3; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
      return bits;
    }
    if (this.len - this.pos > 4) {
      for (; i < 5; ++i) {
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    } else {
      for (; i < 5; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    }
    throw Error("invalid varint encoding");
  }
  Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
  };
  function readFixed32_end(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
  }
  Reader.prototype.fixed32 = function read_fixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
  };
  Reader.prototype.sfixed32 = function read_sfixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
  };
  function readFixed64() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
  }
  Reader.prototype.float = function read_float() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    var value2 = util2.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value2;
  };
  Reader.prototype.double = function read_double() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 4);
    var value2 = util2.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value2;
  };
  Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(), start = this.pos, end = this.pos + length;
    if (end > this.len)
      throw indexOutOfRange(this, length);
    this.pos += length;
    if (Array.isArray(this.buf))
      return this.buf.slice(start, end);
    if (start === end) {
      var nativeBuffer = util2.Buffer;
      return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
    }
    return this._slice.call(this.buf, start, end);
  };
  Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf82.read(bytes, 0, bytes.length);
  };
  Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
      if (this.pos + length > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
    } else {
      do {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
      } while (this.buf[this.pos++] & 128);
    }
    return this;
  };
  Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      default:
        throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
  };
  Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create2();
    BufferReader._configure();
    var fn = util2.Long ? "toLong" : (
      /* istanbul ignore next */
      "toNumber"
    );
    util2.merge(Reader.prototype, {
      int64: function read_int64() {
        return readLongVarint.call(this)[fn](false);
      },
      uint64: function read_uint64() {
        return readLongVarint.call(this)[fn](true);
      },
      sint64: function read_sint64() {
        return readLongVarint.call(this).zzDecode()[fn](false);
      },
      fixed64: function read_fixed64() {
        return readFixed64.call(this)[fn](true);
      },
      sfixed64: function read_sfixed64() {
        return readFixed64.call(this)[fn](false);
      }
    });
  };
  return reader;
}
var reader_buffer;
var hasRequiredReader_buffer;
function requireReader_buffer() {
  if (hasRequiredReader_buffer) return reader_buffer;
  hasRequiredReader_buffer = 1;
  reader_buffer = BufferReader;
  var Reader = requireReader();
  (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
  var util2 = requireMinimal();
  function BufferReader(buffer2) {
    Reader.call(this, buffer2);
  }
  BufferReader._configure = function() {
    if (util2.Buffer)
      BufferReader.prototype._slice = util2.Buffer.prototype.slice;
  };
  BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32();
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
  };
  BufferReader._configure();
  return reader_buffer;
}
var rpc = {};
var service$1;
var hasRequiredService$1;
function requireService$1() {
  if (hasRequiredService$1) return service$1;
  hasRequiredService$1 = 1;
  service$1 = Service;
  var util2 = requireMinimal();
  (Service.prototype = Object.create(util2.EventEmitter.prototype)).constructor = Service;
  function Service(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function")
      throw TypeError("rpcImpl must be a function");
    util2.EventEmitter.call(this);
    this.rpcImpl = rpcImpl;
    this.requestDelimited = Boolean(requestDelimited);
    this.responseDelimited = Boolean(responseDelimited);
  }
  Service.prototype.rpcCall = function rpcCall(method2, requestCtor, responseCtor, request, callback) {
    if (!request)
      throw TypeError("request must be specified");
    var self2 = this;
    if (!callback)
      return util2.asPromise(rpcCall, self2, method2, requestCtor, responseCtor, request);
    if (!self2.rpcImpl) {
      setTimeout(function() {
        callback(Error("already ended"));
      }, 0);
      return void 0;
    }
    try {
      return self2.rpcImpl(
        method2,
        requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
        function rpcCallback(err, response) {
          if (err) {
            self2.emit("error", err, method2);
            return callback(err);
          }
          if (response === null) {
            self2.end(
              /* endedByRPC */
              true
            );
            return void 0;
          }
          if (!(response instanceof responseCtor)) {
            try {
              response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
            } catch (err2) {
              self2.emit("error", err2, method2);
              return callback(err2);
            }
          }
          self2.emit("data", response, method2);
          return callback(null, response);
        }
      );
    } catch (err) {
      self2.emit("error", err, method2);
      setTimeout(function() {
        callback(err);
      }, 0);
      return void 0;
    }
  };
  Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
      if (!endedByRPC)
        this.rpcImpl(null, null, null);
      this.rpcImpl = null;
      this.emit("end").off();
    }
    return this;
  };
  return service$1;
}
var hasRequiredRpc;
function requireRpc() {
  if (hasRequiredRpc) return rpc;
  hasRequiredRpc = 1;
  (function(exports$12) {
    var rpc2 = exports$12;
    rpc2.Service = requireService$1();
  })(rpc);
  return rpc;
}
var roots;
var hasRequiredRoots;
function requireRoots() {
  if (hasRequiredRoots) return roots;
  hasRequiredRoots = 1;
  roots = {};
  return roots;
}
var hasRequiredIndexMinimal;
function requireIndexMinimal() {
  if (hasRequiredIndexMinimal) return indexMinimal;
  hasRequiredIndexMinimal = 1;
  (function(exports$12) {
    var protobuf = exports$12;
    protobuf.build = "minimal";
    protobuf.Writer = requireWriter();
    protobuf.BufferWriter = requireWriter_buffer();
    protobuf.Reader = requireReader();
    protobuf.BufferReader = requireReader_buffer();
    protobuf.util = requireMinimal();
    protobuf.rpc = requireRpc();
    protobuf.roots = requireRoots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  })(indexMinimal);
  return indexMinimal;
}
var util = { exports: {} };
var codegen_1;
var hasRequiredCodegen;
function requireCodegen() {
  if (hasRequiredCodegen) return codegen_1;
  hasRequiredCodegen = 1;
  codegen_1 = codegen;
  function codegen(functionParams, functionName) {
    if (typeof functionParams === "string") {
      functionName = functionParams;
      functionParams = void 0;
    }
    var body = [];
    function Codegen(formatStringOrScope) {
      if (typeof formatStringOrScope !== "string") {
        var source = toString();
        if (codegen.verbose)
          console.log("codegen: " + source);
        source = "return " + source;
        if (formatStringOrScope) {
          var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
          while (scopeOffset < scopeKeys.length) {
            scopeParams[scopeOffset] = scopeKeys[scopeOffset];
            scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
          }
          scopeParams[scopeOffset] = source;
          return Function.apply(null, scopeParams).apply(null, scopeValues);
        }
        return Function(source)();
      }
      var formatParams = new Array(arguments.length - 1), formatOffset = 0;
      while (formatOffset < formatParams.length)
        formatParams[formatOffset] = arguments[++formatOffset];
      formatOffset = 0;
      formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
        var value2 = formatParams[formatOffset++];
        switch ($1) {
          case "d":
          case "f":
            return String(Number(value2));
          case "i":
            return String(Math.floor(value2));
          case "j":
            return JSON.stringify(value2);
          case "s":
            return String(value2);
        }
        return "%";
      });
      if (formatOffset !== formatParams.length)
        throw Error("parameter count mismatch");
      body.push(formatStringOrScope);
      return Codegen;
    }
    function toString(functionNameOverride) {
      return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
    }
    Codegen.toString = toString;
    return Codegen;
  }
  codegen.verbose = false;
  return codegen_1;
}
var fetch_1;
var hasRequiredFetch;
function requireFetch() {
  if (hasRequiredFetch) return fetch_1;
  hasRequiredFetch = 1;
  fetch_1 = fetch;
  var asPromise = requireAspromise(), inquire = requireInquire();
  var fs = inquire("fs");
  function fetch(filename, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if (!options)
      options = {};
    if (!callback)
      return asPromise(fetch, this, filename, options);
    if (!options.xhr && fs && fs.readFile)
      return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
        return err && typeof XMLHttpRequest !== "undefined" ? fetch.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
      });
    return fetch.xhr(filename, options, callback);
  }
  fetch.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function fetchOnReadyStateChange() {
      if (xhr.readyState !== 4)
        return void 0;
      if (xhr.status !== 0 && xhr.status !== 200)
        return callback(Error("status " + xhr.status));
      if (options.binary) {
        var buffer2 = xhr.response;
        if (!buffer2) {
          buffer2 = [];
          for (var i = 0; i < xhr.responseText.length; ++i)
            buffer2.push(xhr.responseText.charCodeAt(i) & 255);
        }
        return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer2) : buffer2);
      }
      return callback(null, xhr.responseText);
    };
    if (options.binary) {
      if ("overrideMimeType" in xhr)
        xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.responseType = "arraybuffer";
    }
    xhr.open("GET", filename);
    xhr.send();
  };
  return fetch_1;
}
var path = {};
var hasRequiredPath;
function requirePath() {
  if (hasRequiredPath) return path;
  hasRequiredPath = 1;
  (function(exports$12) {
    var path2 = exports$12;
    var isAbsolute = (
      /**
       * Tests if the specified path is absolute.
       * @param {string} path Path to test
       * @returns {boolean} `true` if path is absolute
       */
      path2.isAbsolute = function isAbsolute2(path3) {
        return /^(?:\/|\w+:)/.test(path3);
      }
    );
    var normalize = (
      /**
       * Normalizes the specified path.
       * @param {string} path Path to normalize
       * @returns {string} Normalized path
       */
      path2.normalize = function normalize2(path3) {
        path3 = path3.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
        var parts = path3.split("/"), absolute = isAbsolute(path3), prefix = "";
        if (absolute)
          prefix = parts.shift() + "/";
        for (var i = 0; i < parts.length; ) {
          if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
              parts.splice(--i, 2);
            else if (absolute)
              parts.splice(i, 1);
            else
              ++i;
          } else if (parts[i] === ".")
            parts.splice(i, 1);
          else
            ++i;
        }
        return prefix + parts.join("/");
      }
    );
    path2.resolve = function resolve(originPath, includePath, alreadyNormalized) {
      if (!alreadyNormalized)
        includePath = normalize(includePath);
      if (isAbsolute(includePath))
        return includePath;
      if (!alreadyNormalized)
        originPath = normalize(originPath);
      return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
    };
  })(path);
  return path;
}
var types$2 = {};
var hasRequiredTypes$2;
function requireTypes$2() {
  if (hasRequiredTypes$2) return types$2;
  hasRequiredTypes$2 = 1;
  (function(exports$12) {
    var types2 = exports$12;
    var util2 = requireUtil();
    var s = [
      "double",
      // 0
      "float",
      // 1
      "int32",
      // 2
      "uint32",
      // 3
      "sint32",
      // 4
      "fixed32",
      // 5
      "sfixed32",
      // 6
      "int64",
      // 7
      "uint64",
      // 8
      "sint64",
      // 9
      "fixed64",
      // 10
      "sfixed64",
      // 11
      "bool",
      // 12
      "string",
      // 13
      "bytes"
      // 14
    ];
    function bake(values, offset) {
      var i = 0, o = {};
      offset |= 0;
      while (i < values.length) o[s[i + offset]] = values[i++];
      return o;
    }
    types2.basic = bake([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2,
      /* bytes    */
      2
    ]);
    types2.defaults = bake([
      /* double   */
      0,
      /* float    */
      0,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      0,
      /* sfixed32 */
      0,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      0,
      /* sfixed64 */
      0,
      /* bool     */
      false,
      /* string   */
      "",
      /* bytes    */
      util2.emptyArray,
      /* message  */
      null
    ]);
    types2.long = bake([
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1
    ], 7);
    types2.mapKey = bake([
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2
    ], 2);
    types2.packed = bake([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0
    ]);
  })(types$2);
  return types$2;
}
var field;
var hasRequiredField;
function requireField() {
  if (hasRequiredField) return field;
  hasRequiredField = 1;
  field = Field;
  var ReflectionObject = requireObject();
  ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";
  var Enum = require_enum(), types2 = requireTypes$2(), util2 = requireUtil();
  var Type;
  var ruleRe = /^required|optional|repeated$/;
  Field.fromJSON = function fromJSON(name, json2) {
    return new Field(name, json2.id, json2.type, json2.rule, json2.extend, json2.options, json2.comment);
  };
  function Field(name, id, type2, rule, extend, options, comment) {
    if (util2.isObject(rule)) {
      comment = extend;
      options = rule;
      rule = extend = void 0;
    } else if (util2.isObject(extend)) {
      comment = options;
      options = extend;
      extend = void 0;
    }
    ReflectionObject.call(this, name, options);
    if (!util2.isInteger(id) || id < 0)
      throw TypeError("id must be a non-negative integer");
    if (!util2.isString(type2))
      throw TypeError("type must be a string");
    if (rule !== void 0 && !ruleRe.test(rule = rule.toString().toLowerCase()))
      throw TypeError("rule must be a string rule");
    if (extend !== void 0 && !util2.isString(extend))
      throw TypeError("extend must be a string");
    if (rule === "proto3_optional") {
      rule = "optional";
    }
    this.rule = rule && rule !== "optional" ? rule : void 0;
    this.type = type2;
    this.id = id;
    this.extend = extend || void 0;
    this.required = rule === "required";
    this.optional = !this.required;
    this.repeated = rule === "repeated";
    this.map = false;
    this.message = null;
    this.partOf = null;
    this.typeDefault = null;
    this.defaultValue = null;
    this.long = util2.Long ? types2.long[type2] !== void 0 : (
      /* istanbul ignore next */
      false
    );
    this.bytes = type2 === "bytes";
    this.resolvedType = null;
    this.extensionField = null;
    this.declaringField = null;
    this._packed = null;
    this.comment = comment;
  }
  Object.defineProperty(Field.prototype, "packed", {
    get: function() {
      if (this._packed === null)
        this._packed = this.getOption("packed") !== false;
      return this._packed;
    }
  });
  Field.prototype.setOption = function setOption(name, value2, ifNotSet) {
    if (name === "packed")
      this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value2, ifNotSet);
  };
  Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util2.toObject([
      "rule",
      this.rule !== "optional" && this.rule || void 0,
      "type",
      this.type,
      "id",
      this.id,
      "extend",
      this.extend,
      "options",
      this.options,
      "comment",
      keepComments ? this.comment : void 0
    ]);
  };
  Field.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    if ((this.typeDefault = types2.defaults[this.type]) === void 0) {
      this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
      if (this.resolvedType instanceof Type)
        this.typeDefault = null;
      else
        this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
    } else if (this.options && this.options.proto3_optional) {
      this.typeDefault = null;
    }
    if (this.options && this.options["default"] != null) {
      this.typeDefault = this.options["default"];
      if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
        this.typeDefault = this.resolvedType.values[this.typeDefault];
    }
    if (this.options) {
      if (this.options.packed === true || this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof Enum))
        delete this.options.packed;
      if (!Object.keys(this.options).length)
        this.options = void 0;
    }
    if (this.long) {
      this.typeDefault = util2.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
      if (Object.freeze)
        Object.freeze(this.typeDefault);
    } else if (this.bytes && typeof this.typeDefault === "string") {
      var buf;
      if (util2.base64.test(this.typeDefault))
        util2.base64.decode(this.typeDefault, buf = util2.newBuffer(util2.base64.length(this.typeDefault)), 0);
      else
        util2.utf8.write(this.typeDefault, buf = util2.newBuffer(util2.utf8.length(this.typeDefault)), 0);
      this.typeDefault = buf;
    }
    if (this.map)
      this.defaultValue = util2.emptyObject;
    else if (this.repeated)
      this.defaultValue = util2.emptyArray;
    else
      this.defaultValue = this.typeDefault;
    if (this.parent instanceof Type)
      this.parent.ctor.prototype[this.name] = this.defaultValue;
    return ReflectionObject.prototype.resolve.call(this);
  };
  Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
    if (typeof fieldType === "function")
      fieldType = util2.decorateType(fieldType).name;
    else if (fieldType && typeof fieldType === "object")
      fieldType = util2.decorateEnum(fieldType).name;
    return function fieldDecorator(prototype, fieldName) {
      util2.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
  };
  Field._configure = function configure(Type_) {
    Type = Type_;
  };
  return field;
}
var oneof;
var hasRequiredOneof;
function requireOneof() {
  if (hasRequiredOneof) return oneof;
  hasRequiredOneof = 1;
  oneof = OneOf;
  var ReflectionObject = requireObject();
  ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
  var Field = requireField(), util2 = requireUtil();
  function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
      options = fieldNames;
      fieldNames = void 0;
    }
    ReflectionObject.call(this, name, options);
    if (!(fieldNames === void 0 || Array.isArray(fieldNames)))
      throw TypeError("fieldNames must be an Array");
    this.oneof = fieldNames || [];
    this.fieldsArray = [];
    this.comment = comment;
  }
  OneOf.fromJSON = function fromJSON(name, json2) {
    return new OneOf(name, json2.oneof, json2.options, json2.comment);
  };
  OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util2.toObject([
      "options",
      this.options,
      "oneof",
      this.oneof,
      "comment",
      keepComments ? this.comment : void 0
    ]);
  };
  function addFieldsToParent(oneof2) {
    if (oneof2.parent) {
      for (var i = 0; i < oneof2.fieldsArray.length; ++i)
        if (!oneof2.fieldsArray[i].parent)
          oneof2.parent.add(oneof2.fieldsArray[i]);
    }
  }
  OneOf.prototype.add = function add(field2) {
    if (!(field2 instanceof Field))
      throw TypeError("field must be a Field");
    if (field2.parent && field2.parent !== this.parent)
      field2.parent.remove(field2);
    this.oneof.push(field2.name);
    this.fieldsArray.push(field2);
    field2.partOf = this;
    addFieldsToParent(this);
    return this;
  };
  OneOf.prototype.remove = function remove(field2) {
    if (!(field2 instanceof Field))
      throw TypeError("field must be a Field");
    var index2 = this.fieldsArray.indexOf(field2);
    if (index2 < 0)
      throw Error(field2 + " is not a member of " + this);
    this.fieldsArray.splice(index2, 1);
    index2 = this.oneof.indexOf(field2.name);
    if (index2 > -1)
      this.oneof.splice(index2, 1);
    field2.partOf = null;
    return this;
  };
  OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self2 = this;
    for (var i = 0; i < this.oneof.length; ++i) {
      var field2 = parent.get(this.oneof[i]);
      if (field2 && !field2.partOf) {
        field2.partOf = self2;
        self2.fieldsArray.push(field2);
      }
    }
    addFieldsToParent(this);
  };
  OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field2; i < this.fieldsArray.length; ++i)
      if ((field2 = this.fieldsArray[i]).parent)
        field2.parent.remove(field2);
    ReflectionObject.prototype.onRemove.call(this, parent);
  };
  OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length), index2 = 0;
    while (index2 < arguments.length)
      fieldNames[index2] = arguments[index2++];
    return function oneOfDecorator(prototype, oneofName) {
      util2.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
      Object.defineProperty(prototype, oneofName, {
        get: util2.oneOfGetter(fieldNames),
        set: util2.oneOfSetter(fieldNames)
      });
    };
  };
  return oneof;
}
var namespace;
var hasRequiredNamespace;
function requireNamespace() {
  if (hasRequiredNamespace) return namespace;
  hasRequiredNamespace = 1;
  namespace = Namespace;
  var ReflectionObject = requireObject();
  ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";
  var Field = requireField(), util2 = requireUtil(), OneOf = requireOneof();
  var Type, Service, Enum;
  Namespace.fromJSON = function fromJSON(name, json2) {
    return new Namespace(name, json2.options).addJSON(json2.nested);
  };
  function arrayToJSON(array2, toJSONOptions) {
    if (!(array2 && array2.length))
      return void 0;
    var obj = {};
    for (var i = 0; i < array2.length; ++i)
      obj[array2[i].name] = array2[i].toJSON(toJSONOptions);
    return obj;
  }
  Namespace.arrayToJSON = arrayToJSON;
  Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved) {
      for (var i = 0; i < reserved.length; ++i)
        if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
          return true;
    }
    return false;
  };
  Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved) {
      for (var i = 0; i < reserved.length; ++i)
        if (reserved[i] === name)
          return true;
    }
    return false;
  };
  function Namespace(name, options) {
    ReflectionObject.call(this, name, options);
    this.nested = void 0;
    this._nestedArray = null;
  }
  function clearCache(namespace2) {
    namespace2._nestedArray = null;
    return namespace2;
  }
  Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
      return this._nestedArray || (this._nestedArray = util2.toArray(this.nested));
    }
  });
  Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util2.toObject([
      "options",
      this.options,
      "nested",
      arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
  };
  Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    if (nestedJson) {
      for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
        nested = nestedJson[names[i]];
        ns.add(
          // most to least likely
          (nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : nested.id !== void 0 ? Field.fromJSON : Namespace.fromJSON)(names[i], nested)
        );
      }
    }
    return this;
  };
  Namespace.prototype.get = function get(name) {
    return this.nested && this.nested[name] || null;
  };
  Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
      return this.nested[name].values;
    throw Error("no such enum: " + name);
  };
  Namespace.prototype.add = function add(object2) {
    if (!(object2 instanceof Field && object2.extend !== void 0 || object2 instanceof Type || object2 instanceof OneOf || object2 instanceof Enum || object2 instanceof Service || object2 instanceof Namespace))
      throw TypeError("object must be a valid nested object");
    if (!this.nested)
      this.nested = {};
    else {
      var prev = this.get(object2.name);
      if (prev) {
        if (prev instanceof Namespace && object2 instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
          var nested = prev.nestedArray;
          for (var i = 0; i < nested.length; ++i)
            object2.add(nested[i]);
          this.remove(prev);
          if (!this.nested)
            this.nested = {};
          object2.setOptions(prev.options, true);
        } else
          throw Error("duplicate name '" + object2.name + "' in " + this);
      }
    }
    this.nested[object2.name] = object2;
    object2.onAdd(this);
    return clearCache(this);
  };
  Namespace.prototype.remove = function remove(object2) {
    if (!(object2 instanceof ReflectionObject))
      throw TypeError("object must be a ReflectionObject");
    if (object2.parent !== this)
      throw Error(object2 + " is not a member of " + this);
    delete this.nested[object2.name];
    if (!Object.keys(this.nested).length)
      this.nested = void 0;
    object2.onRemove(this);
    return clearCache(this);
  };
  Namespace.prototype.define = function define(path2, json2) {
    if (util2.isString(path2))
      path2 = path2.split(".");
    else if (!Array.isArray(path2))
      throw TypeError("illegal path");
    if (path2 && path2.length && path2[0] === "")
      throw Error("path must be relative");
    var ptr = this;
    while (path2.length > 0) {
      var part = path2.shift();
      if (ptr.nested && ptr.nested[part]) {
        ptr = ptr.nested[part];
        if (!(ptr instanceof Namespace))
          throw Error("path conflicts with non-namespace objects");
      } else
        ptr.add(ptr = new Namespace(part));
    }
    if (json2)
      ptr.addJSON(json2);
    return ptr;
  };
  Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
      if (nested[i] instanceof Namespace)
        nested[i++].resolveAll();
      else
        nested[i++].resolve();
    return this.resolve();
  };
  Namespace.prototype.lookup = function lookup(path2, filterTypes, parentAlreadyChecked) {
    if (typeof filterTypes === "boolean") {
      parentAlreadyChecked = filterTypes;
      filterTypes = void 0;
    } else if (filterTypes && !Array.isArray(filterTypes))
      filterTypes = [filterTypes];
    if (util2.isString(path2) && path2.length) {
      if (path2 === ".")
        return this.root;
      path2 = path2.split(".");
    } else if (!path2.length)
      return this;
    if (path2[0] === "")
      return this.root.lookup(path2.slice(1), filterTypes);
    var found = this.get(path2[0]);
    if (found) {
      if (path2.length === 1) {
        if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
          return found;
      } else if (found instanceof Namespace && (found = found.lookup(path2.slice(1), filterTypes, true)))
        return found;
    } else
      for (var i = 0; i < this.nestedArray.length; ++i)
        if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path2, filterTypes, true)))
          return found;
    if (this.parent === null || parentAlreadyChecked)
      return null;
    return this.parent.lookup(path2, filterTypes);
  };
  Namespace.prototype.lookupType = function lookupType(path2) {
    var found = this.lookup(path2, [Type]);
    if (!found)
      throw Error("no such type: " + path2);
    return found;
  };
  Namespace.prototype.lookupEnum = function lookupEnum(path2) {
    var found = this.lookup(path2, [Enum]);
    if (!found)
      throw Error("no such Enum '" + path2 + "' in " + this);
    return found;
  };
  Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path2) {
    var found = this.lookup(path2, [Type, Enum]);
    if (!found)
      throw Error("no such Type or Enum '" + path2 + "' in " + this);
    return found;
  };
  Namespace.prototype.lookupService = function lookupService(path2) {
    var found = this.lookup(path2, [Service]);
    if (!found)
      throw Error("no such Service '" + path2 + "' in " + this);
    return found;
  };
  Namespace._configure = function(Type_, Service_, Enum_) {
    Type = Type_;
    Service = Service_;
    Enum = Enum_;
  };
  return namespace;
}
var mapfield;
var hasRequiredMapfield;
function requireMapfield() {
  if (hasRequiredMapfield) return mapfield;
  hasRequiredMapfield = 1;
  mapfield = MapField;
  var Field = requireField();
  ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";
  var types2 = requireTypes$2(), util2 = requireUtil();
  function MapField(name, id, keyType, type2, options, comment) {
    Field.call(this, name, id, type2, void 0, void 0, options, comment);
    if (!util2.isString(keyType))
      throw TypeError("keyType must be a string");
    this.keyType = keyType;
    this.resolvedKeyType = null;
    this.map = true;
  }
  MapField.fromJSON = function fromJSON(name, json2) {
    return new MapField(name, json2.id, json2.keyType, json2.type, json2.options, json2.comment);
  };
  MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util2.toObject([
      "keyType",
      this.keyType,
      "type",
      this.type,
      "id",
      this.id,
      "extend",
      this.extend,
      "options",
      this.options,
      "comment",
      keepComments ? this.comment : void 0
    ]);
  };
  MapField.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    if (types2.mapKey[this.keyType] === void 0)
      throw Error("invalid key type: " + this.keyType);
    return Field.prototype.resolve.call(this);
  };
  MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
    if (typeof fieldValueType === "function")
      fieldValueType = util2.decorateType(fieldValueType).name;
    else if (fieldValueType && typeof fieldValueType === "object")
      fieldValueType = util2.decorateEnum(fieldValueType).name;
    return function mapFieldDecorator(prototype, fieldName) {
      util2.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
  };
  return mapfield;
}
var method;
var hasRequiredMethod;
function requireMethod() {
  if (hasRequiredMethod) return method;
  hasRequiredMethod = 1;
  method = Method;
  var ReflectionObject = requireObject();
  ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
  var util2 = requireUtil();
  function Method(name, type2, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {
    if (util2.isObject(requestStream)) {
      options = requestStream;
      requestStream = responseStream = void 0;
    } else if (util2.isObject(responseStream)) {
      options = responseStream;
      responseStream = void 0;
    }
    if (!(type2 === void 0 || util2.isString(type2)))
      throw TypeError("type must be a string");
    if (!util2.isString(requestType))
      throw TypeError("requestType must be a string");
    if (!util2.isString(responseType))
      throw TypeError("responseType must be a string");
    ReflectionObject.call(this, name, options);
    this.type = type2 || "rpc";
    this.requestType = requestType;
    this.requestStream = requestStream ? true : void 0;
    this.responseType = responseType;
    this.responseStream = responseStream ? true : void 0;
    this.resolvedRequestType = null;
    this.resolvedResponseType = null;
    this.comment = comment;
    this.parsedOptions = parsedOptions;
  }
  Method.fromJSON = function fromJSON(name, json2) {
    return new Method(name, json2.type, json2.requestType, json2.responseType, json2.requestStream, json2.responseStream, json2.options, json2.comment, json2.parsedOptions);
  };
  Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util2.toObject([
      "type",
      this.type !== "rpc" && /* istanbul ignore next */
      this.type || void 0,
      "requestType",
      this.requestType,
      "requestStream",
      this.requestStream,
      "responseType",
      this.responseType,
      "responseStream",
      this.responseStream,
      "options",
      this.options,
      "comment",
      keepComments ? this.comment : void 0,
      "parsedOptions",
      this.parsedOptions
    ]);
  };
  Method.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);
    return ReflectionObject.prototype.resolve.call(this);
  };
  return method;
}
var service;
var hasRequiredService;
function requireService() {
  if (hasRequiredService) return service;
  hasRequiredService = 1;
  service = Service;
  var Namespace = requireNamespace();
  ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";
  var Method = requireMethod(), util2 = requireUtil(), rpc2 = requireRpc();
  function Service(name, options) {
    Namespace.call(this, name, options);
    this.methods = {};
    this._methodsArray = null;
  }
  Service.fromJSON = function fromJSON(name, json2) {
    var service2 = new Service(name, json2.options);
    if (json2.methods)
      for (var names = Object.keys(json2.methods), i = 0; i < names.length; ++i)
        service2.add(Method.fromJSON(names[i], json2.methods[names[i]]));
    if (json2.nested)
      service2.addJSON(json2.nested);
    service2.comment = json2.comment;
    return service2;
  };
  Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util2.toObject([
      "options",
      inherited && inherited.options || void 0,
      "methods",
      Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */
      {},
      "nested",
      inherited && inherited.nested || void 0,
      "comment",
      keepComments ? this.comment : void 0
    ]);
  };
  Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
      return this._methodsArray || (this._methodsArray = util2.toArray(this.methods));
    }
  });
  function clearCache(service2) {
    service2._methodsArray = null;
    return service2;
  }
  Service.prototype.get = function get(name) {
    return this.methods[name] || Namespace.prototype.get.call(this, name);
  };
  Service.prototype.resolveAll = function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i < methods.length; ++i)
      methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
  };
  Service.prototype.add = function add(object2) {
    if (this.get(object2.name))
      throw Error("duplicate name '" + object2.name + "' in " + this);
    if (object2 instanceof Method) {
      this.methods[object2.name] = object2;
      object2.parent = this;
      return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object2);
  };
  Service.prototype.remove = function remove(object2) {
    if (object2 instanceof Method) {
      if (this.methods[object2.name] !== object2)
        throw Error(object2 + " is not a member of " + this);
      delete this.methods[object2.name];
      object2.parent = null;
      return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object2);
  };
  Service.prototype.create = function create2(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc2.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method2; i < /* initializes */
    this.methodsArray.length; ++i) {
      var methodName = util2.lcFirst((method2 = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
      rpcService[methodName] = util2.codegen(["r", "c"], util2.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
        m: method2,
        q: method2.resolvedRequestType.ctor,
        s: method2.resolvedResponseType.ctor
      });
    }
    return rpcService;
  };
  return service;
}
var message;
var hasRequiredMessage;
function requireMessage() {
  if (hasRequiredMessage) return message;
  hasRequiredMessage = 1;
  message = Message;
  var util2 = requireMinimal();
  function Message(properties) {
    if (properties)
      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
        this[keys[i]] = properties[keys[i]];
  }
  Message.create = function create2(properties) {
    return this.$type.create(properties);
  };
  Message.encode = function encode2(message2, writer2) {
    return this.$type.encode(message2, writer2);
  };
  Message.encodeDelimited = function encodeDelimited(message2, writer2) {
    return this.$type.encodeDelimited(message2, writer2);
  };
  Message.decode = function decode2(reader2) {
    return this.$type.decode(reader2);
  };
  Message.decodeDelimited = function decodeDelimited(reader2) {
    return this.$type.decodeDelimited(reader2);
  };
  Message.verify = function verify(message2) {
    return this.$type.verify(message2);
  };
  Message.fromObject = function fromObject(object2) {
    return this.$type.fromObject(object2);
  };
  Message.toObject = function toObject(message2, options) {
    return this.$type.toObject(message2, options);
  };
  Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util2.toJSONOptions);
  };
  return message;
}
var decoder_1;
var hasRequiredDecoder;
function requireDecoder() {
  if (hasRequiredDecoder) return decoder_1;
  hasRequiredDecoder = 1;
  decoder_1 = decoder;
  var Enum = require_enum(), types2 = requireTypes$2(), util2 = requireUtil();
  function missing(field2) {
    return "missing required '" + field2.name + "'";
  }
  function decoder(mtype) {
    var gen = util2.codegen(["r", "l"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field3) {
      return field3.map;
    }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
    if (mtype.group) gen("if((t&7)===4)")("break");
    gen("switch(t>>>3){");
    var i = 0;
    for (; i < /* initializes */
    mtype.fieldsArray.length; ++i) {
      var field2 = mtype._fieldsArray[i].resolve(), type2 = field2.resolvedType instanceof Enum ? "int32" : field2.type, ref2 = "m" + util2.safeProp(field2.name);
      gen("case %i: {", field2.id);
      if (field2.map) {
        gen("if(%s===util.emptyObject)", ref2)("%s={}", ref2)("var c2 = r.uint32()+r.pos");
        if (types2.defaults[field2.keyType] !== void 0) gen("k=%j", types2.defaults[field2.keyType]);
        else gen("k=null");
        if (types2.defaults[type2] !== void 0) gen("value=%j", types2.defaults[type2]);
        else gen("value=null");
        gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field2.keyType)("case 2:");
        if (types2.basic[type2] === void 0) gen("value=types[%i].decode(r,r.uint32())", i);
        else gen("value=r.%s()", type2);
        gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
        if (types2.long[field2.keyType] !== void 0) gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref2);
        else gen("%s[k]=value", ref2);
      } else if (field2.repeated) {
        gen("if(!(%s&&%s.length))", ref2, ref2)("%s=[]", ref2);
        if (types2.packed[type2] !== void 0) gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref2, type2)("}else");
        if (types2.basic[type2] === void 0) gen(field2.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref2, i);
        else gen("%s.push(r.%s())", ref2, type2);
      } else if (types2.basic[type2] === void 0) gen(field2.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref2, i);
      else gen("%s=r.%s()", ref2, type2);
      gen("break")("}");
    }
    gen("default:")("r.skipType(t&7)")("break")("}")("}");
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
      var rfield = mtype._fieldsArray[i];
      if (rfield.required) gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }
    return gen("return m");
  }
  return decoder_1;
}
var verifier_1;
var hasRequiredVerifier;
function requireVerifier() {
  if (hasRequiredVerifier) return verifier_1;
  hasRequiredVerifier = 1;
  verifier_1 = verifier;
  var Enum = require_enum(), util2 = requireUtil();
  function invalid(field2, expected) {
    return field2.name + ": " + expected + (field2.repeated && expected !== "array" ? "[]" : field2.map && expected !== "object" ? "{k:" + field2.keyType + "}" : "") + " expected";
  }
  function genVerifyValue(gen, field2, fieldIndex, ref2) {
    if (field2.resolvedType) {
      if (field2.resolvedType instanceof Enum) {
        gen("switch(%s){", ref2)("default:")("return%j", invalid(field2, "enum value"));
        for (var keys = Object.keys(field2.resolvedType.values), j = 0; j < keys.length; ++j) gen("case %i:", field2.resolvedType.values[keys[j]]);
        gen("break")("}");
      } else {
        gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref2)("if(e)")("return%j+e", field2.name + ".")("}");
      }
    } else {
      switch (field2.type) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          gen("if(!util.isInteger(%s))", ref2)("return%j", invalid(field2, "integer"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref2, ref2, ref2, ref2)("return%j", invalid(field2, "integer|Long"));
          break;
        case "float":
        case "double":
          gen('if(typeof %s!=="number")', ref2)("return%j", invalid(field2, "number"));
          break;
        case "bool":
          gen('if(typeof %s!=="boolean")', ref2)("return%j", invalid(field2, "boolean"));
          break;
        case "string":
          gen("if(!util.isString(%s))", ref2)("return%j", invalid(field2, "string"));
          break;
        case "bytes":
          gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref2, ref2, ref2)("return%j", invalid(field2, "buffer"));
          break;
      }
    }
    return gen;
  }
  function genVerifyKey(gen, field2, ref2) {
    switch (field2.keyType) {
      case "int32":
      case "uint32":
      case "sint32":
      case "fixed32":
      case "sfixed32":
        gen("if(!util.key32Re.test(%s))", ref2)("return%j", invalid(field2, "integer key"));
        break;
      case "int64":
      case "uint64":
      case "sint64":
      case "fixed64":
      case "sfixed64":
        gen("if(!util.key64Re.test(%s))", ref2)("return%j", invalid(field2, "integer|Long key"));
        break;
      case "bool":
        gen("if(!util.key2Re.test(%s))", ref2)("return%j", invalid(field2, "boolean key"));
        break;
    }
    return gen;
  }
  function verifier(mtype) {
    var gen = util2.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
    var oneofs = mtype.oneofsArray, seenFirstField = {};
    if (oneofs.length) gen("var p={}");
    for (var i = 0; i < /* initializes */
    mtype.fieldsArray.length; ++i) {
      var field2 = mtype._fieldsArray[i].resolve(), ref2 = "m" + util2.safeProp(field2.name);
      if (field2.optional) gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref2, field2.name);
      if (field2.map) {
        gen("if(!util.isObject(%s))", ref2)("return%j", invalid(field2, "object"))("var k=Object.keys(%s)", ref2)("for(var i=0;i<k.length;++i){");
        genVerifyKey(gen, field2, "k[i]");
        genVerifyValue(gen, field2, i, ref2 + "[k[i]]")("}");
      } else if (field2.repeated) {
        gen("if(!Array.isArray(%s))", ref2)("return%j", invalid(field2, "array"))("for(var i=0;i<%s.length;++i){", ref2);
        genVerifyValue(gen, field2, i, ref2 + "[i]")("}");
      } else {
        if (field2.partOf) {
          var oneofProp = util2.safeProp(field2.partOf.name);
          if (seenFirstField[field2.partOf.name] === 1) gen("if(p%s===1)", oneofProp)("return%j", field2.partOf.name + ": multiple values");
          seenFirstField[field2.partOf.name] = 1;
          gen("p%s=1", oneofProp);
        }
        genVerifyValue(gen, field2, i, ref2);
      }
      if (field2.optional) gen("}");
    }
    return gen("return null");
  }
  return verifier_1;
}
var converter = {};
var hasRequiredConverter;
function requireConverter() {
  if (hasRequiredConverter) return converter;
  hasRequiredConverter = 1;
  (function(exports$12) {
    var converter2 = exports$12;
    var Enum = require_enum(), util2 = requireUtil();
    function genValuePartial_fromObject(gen, field2, fieldIndex, prop) {
      var defaultAlreadyEmitted = false;
      if (field2.resolvedType) {
        if (field2.resolvedType instanceof Enum) {
          gen("switch(d%s){", prop);
          for (var values = field2.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
            if (values[keys[i]] === field2.typeDefault && !defaultAlreadyEmitted) {
              gen("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}', prop, prop, prop);
              if (!field2.repeated) gen("break");
              defaultAlreadyEmitted = true;
            }
            gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
          }
          gen("}");
        } else gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field2.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field2.type) {
          case "double":
          case "float":
            gen("m%s=Number(d%s)", prop, prop);
            break;
          case "uint32":
          case "fixed32":
            gen("m%s=d%s>>>0", prop, prop);
            break;
          case "int32":
          case "sint32":
          case "sfixed32":
            gen("m%s=d%s|0", prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
            break;
          case "bytes":
            gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length >= 0)", prop)("m%s=d%s", prop, prop);
            break;
          case "string":
            gen("m%s=String(d%s)", prop, prop);
            break;
          case "bool":
            gen("m%s=Boolean(d%s)", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter2.fromObject = function fromObject(mtype) {
      var fields = mtype.fieldsArray;
      var gen = util2.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
      if (!fields.length) return gen("return new this.ctor");
      gen("var m=new this.ctor");
      for (var i = 0; i < fields.length; ++i) {
        var field2 = fields[i].resolve(), prop = util2.safeProp(field2.name);
        if (field2.map) {
          gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field2.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
          genValuePartial_fromObject(
            gen,
            field2,
            /* not sorted */
            i,
            prop + "[ks[i]]"
          )("}")("}");
        } else if (field2.repeated) {
          gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field2.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
          genValuePartial_fromObject(
            gen,
            field2,
            /* not sorted */
            i,
            prop + "[i]"
          )("}")("}");
        } else {
          if (!(field2.resolvedType instanceof Enum)) gen("if(d%s!=null){", prop);
          genValuePartial_fromObject(
            gen,
            field2,
            /* not sorted */
            i,
            prop
          );
          if (!(field2.resolvedType instanceof Enum)) gen("}");
        }
      }
      return gen("return m");
    };
    function genValuePartial_toObject(gen, field2, fieldIndex, prop) {
      if (field2.resolvedType) {
        if (field2.resolvedType instanceof Enum) gen("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
        else gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field2.type) {
          case "double":
          case "float":
            gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
            break;
          case "bytes":
            gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
            break;
          default:
            gen("d%s=m%s", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter2.toObject = function toObject(mtype) {
      var fields = mtype.fieldsArray.slice().sort(util2.compareFieldsById);
      if (!fields.length)
        return util2.codegen()("return {}");
      var gen = util2.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
      var repeatedFields = [], mapFields = [], normalFields = [], i = 0;
      for (; i < fields.length; ++i)
        if (!fields[i].partOf)
          (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
      if (repeatedFields.length) {
        gen("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen("d%s=[]", util2.safeProp(repeatedFields[i].name));
        gen("}");
      }
      if (mapFields.length) {
        gen("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen("d%s={}", util2.safeProp(mapFields[i].name));
        gen("}");
      }
      if (normalFields.length) {
        gen("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
          var field2 = normalFields[i], prop = util2.safeProp(field2.name);
          if (field2.resolvedType instanceof Enum) gen("d%s=o.enums===String?%j:%j", prop, field2.resolvedType.valuesById[field2.typeDefault], field2.typeDefault);
          else if (field2.long) gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field2.typeDefault.low, field2.typeDefault.high, field2.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field2.typeDefault.toString(), field2.typeDefault.toNumber());
          else if (field2.bytes) {
            var arrayDefault = "[" + Array.prototype.slice.call(field2.typeDefault).join(",") + "]";
            gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field2.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
          } else gen("d%s=%j", prop, field2.typeDefault);
        }
        gen("}");
      }
      var hasKs2 = false;
      for (i = 0; i < fields.length; ++i) {
        var field2 = fields[i], index2 = mtype._fieldsArray.indexOf(field2), prop = util2.safeProp(field2.name);
        if (field2.map) {
          if (!hasKs2) {
            hasKs2 = true;
            gen("var ks2");
          }
          gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
          genValuePartial_toObject(
            gen,
            field2,
            /* sorted */
            index2,
            prop + "[ks2[j]]"
          )("}");
        } else if (field2.repeated) {
          gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
          genValuePartial_toObject(
            gen,
            field2,
            /* sorted */
            index2,
            prop + "[j]"
          )("}");
        } else {
          gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field2.name);
          genValuePartial_toObject(
            gen,
            field2,
            /* sorted */
            index2,
            prop
          );
          if (field2.partOf) gen("if(o.oneofs)")("d%s=%j", util2.safeProp(field2.partOf.name), field2.name);
        }
        gen("}");
      }
      return gen("return d");
    };
  })(converter);
  return converter;
}
var wrappers = {};
var hasRequiredWrappers;
function requireWrappers() {
  if (hasRequiredWrappers) return wrappers;
  hasRequiredWrappers = 1;
  (function(exports$12) {
    var wrappers2 = exports$12;
    var Message = requireMessage();
    wrappers2[".google.protobuf.Any"] = {
      fromObject: function(object2) {
        if (object2 && object2["@type"]) {
          var name = object2["@type"].substring(object2["@type"].lastIndexOf("/") + 1);
          var type2 = this.lookup(name);
          if (type2) {
            var type_url = object2["@type"].charAt(0) === "." ? object2["@type"].slice(1) : object2["@type"];
            if (type_url.indexOf("/") === -1) {
              type_url = "/" + type_url;
            }
            return this.create({
              type_url,
              value: type2.encode(type2.fromObject(object2)).finish()
            });
          }
        }
        return this.fromObject(object2);
      },
      toObject: function(message2, options) {
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";
        if (options && options.json && message2.type_url && message2.value) {
          name = message2.type_url.substring(message2.type_url.lastIndexOf("/") + 1);
          prefix = message2.type_url.substring(0, message2.type_url.lastIndexOf("/") + 1);
          var type2 = this.lookup(name);
          if (type2)
            message2 = type2.decode(message2.value);
        }
        if (!(message2 instanceof this.ctor) && message2 instanceof Message) {
          var object2 = message2.$type.toObject(message2, options);
          var messageName = message2.$type.fullName[0] === "." ? message2.$type.fullName.slice(1) : message2.$type.fullName;
          if (prefix === "") {
            prefix = googleApi;
          }
          name = prefix + messageName;
          object2["@type"] = name;
          return object2;
        }
        return this.toObject(message2, options);
      }
    };
  })(wrappers);
  return wrappers;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = Type;
  var Namespace = requireNamespace();
  ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";
  var Enum = require_enum(), OneOf = requireOneof(), Field = requireField(), MapField = requireMapfield(), Service = requireService(), Message = requireMessage(), Reader = requireReader(), Writer = requireWriter(), util2 = requireUtil(), encoder = requireEncoder(), decoder = requireDecoder(), verifier = requireVerifier(), converter2 = requireConverter(), wrappers2 = requireWrappers();
  function Type(name, options) {
    Namespace.call(this, name, options);
    this.fields = {};
    this.oneofs = void 0;
    this.extensions = void 0;
    this.reserved = void 0;
    this.group = void 0;
    this._fieldsById = null;
    this._fieldsArray = null;
    this._oneofsArray = null;
    this._ctor = null;
  }
  Object.defineProperties(Type.prototype, {
    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
      get: function() {
        if (this._fieldsById)
          return this._fieldsById;
        this._fieldsById = {};
        for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
          var field2 = this.fields[names[i]], id = field2.id;
          if (this._fieldsById[id])
            throw Error("duplicate id " + id + " in " + this);
          this._fieldsById[id] = field2;
        }
        return this._fieldsById;
      }
    },
    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
      get: function() {
        return this._fieldsArray || (this._fieldsArray = util2.toArray(this.fields));
      }
    },
    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
      get: function() {
        return this._oneofsArray || (this._oneofsArray = util2.toArray(this.oneofs));
      }
    },
    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
      get: function() {
        return this._ctor || (this.ctor = Type.generateConstructor(this)());
      },
      set: function(ctor) {
        var prototype = ctor.prototype;
        if (!(prototype instanceof Message)) {
          (ctor.prototype = new Message()).constructor = ctor;
          util2.merge(ctor.prototype, prototype);
        }
        ctor.$type = ctor.prototype.$type = this;
        util2.merge(ctor, Message, true);
        this._ctor = ctor;
        var i = 0;
        for (; i < /* initializes */
        this.fieldsArray.length; ++i)
          this._fieldsArray[i].resolve();
        var ctorProperties = {};
        for (i = 0; i < /* initializes */
        this.oneofsArray.length; ++i)
          ctorProperties[this._oneofsArray[i].resolve().name] = {
            get: util2.oneOfGetter(this._oneofsArray[i].oneof),
            set: util2.oneOfSetter(this._oneofsArray[i].oneof)
          };
        if (i)
          Object.defineProperties(ctor.prototype, ctorProperties);
      }
    }
  });
  Type.generateConstructor = function generateConstructor(mtype) {
    var gen = util2.codegen(["p"], mtype.name);
    for (var i = 0, field2; i < mtype.fieldsArray.length; ++i)
      if ((field2 = mtype._fieldsArray[i]).map) gen("this%s={}", util2.safeProp(field2.name));
      else if (field2.repeated) gen("this%s=[]", util2.safeProp(field2.name));
    return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
  };
  function clearCache(type2) {
    type2._fieldsById = type2._fieldsArray = type2._oneofsArray = null;
    delete type2.encode;
    delete type2.decode;
    delete type2.verify;
    return type2;
  }
  Type.fromJSON = function fromJSON(name, json2) {
    var type2 = new Type(name, json2.options);
    type2.extensions = json2.extensions;
    type2.reserved = json2.reserved;
    var names = Object.keys(json2.fields), i = 0;
    for (; i < names.length; ++i)
      type2.add(
        (typeof json2.fields[names[i]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i], json2.fields[names[i]])
      );
    if (json2.oneofs)
      for (names = Object.keys(json2.oneofs), i = 0; i < names.length; ++i)
        type2.add(OneOf.fromJSON(names[i], json2.oneofs[names[i]]));
    if (json2.nested)
      for (names = Object.keys(json2.nested), i = 0; i < names.length; ++i) {
        var nested = json2.nested[names[i]];
        type2.add(
          // most to least likely
          (nested.id !== void 0 ? Field.fromJSON : nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : Namespace.fromJSON)(names[i], nested)
        );
      }
    if (json2.extensions && json2.extensions.length)
      type2.extensions = json2.extensions;
    if (json2.reserved && json2.reserved.length)
      type2.reserved = json2.reserved;
    if (json2.group)
      type2.group = true;
    if (json2.comment)
      type2.comment = json2.comment;
    return type2;
  };
  Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util2.toObject([
      "options",
      inherited && inherited.options || void 0,
      "oneofs",
      Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
      "fields",
      Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {
        return !obj.declaringField;
      }), toJSONOptions) || {},
      "extensions",
      this.extensions && this.extensions.length ? this.extensions : void 0,
      "reserved",
      this.reserved && this.reserved.length ? this.reserved : void 0,
      "group",
      this.group || void 0,
      "nested",
      inherited && inherited.nested || void 0,
      "comment",
      keepComments ? this.comment : void 0
    ]);
  };
  Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
      fields[i++].resolve();
    var oneofs = this.oneofsArray;
    i = 0;
    while (i < oneofs.length)
      oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
  };
  Type.prototype.get = function get(name) {
    return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;
  };
  Type.prototype.add = function add(object2) {
    if (this.get(object2.name))
      throw Error("duplicate name '" + object2.name + "' in " + this);
    if (object2 instanceof Field && object2.extend === void 0) {
      if (this._fieldsById ? (
        /* istanbul ignore next */
        this._fieldsById[object2.id]
      ) : this.fieldsById[object2.id])
        throw Error("duplicate id " + object2.id + " in " + this);
      if (this.isReservedId(object2.id))
        throw Error("id " + object2.id + " is reserved in " + this);
      if (this.isReservedName(object2.name))
        throw Error("name '" + object2.name + "' is reserved in " + this);
      if (object2.parent)
        object2.parent.remove(object2);
      this.fields[object2.name] = object2;
      object2.message = this;
      object2.onAdd(this);
      return clearCache(this);
    }
    if (object2 instanceof OneOf) {
      if (!this.oneofs)
        this.oneofs = {};
      this.oneofs[object2.name] = object2;
      object2.onAdd(this);
      return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object2);
  };
  Type.prototype.remove = function remove(object2) {
    if (object2 instanceof Field && object2.extend === void 0) {
      if (!this.fields || this.fields[object2.name] !== object2)
        throw Error(object2 + " is not a member of " + this);
      delete this.fields[object2.name];
      object2.parent = null;
      object2.onRemove(this);
      return clearCache(this);
    }
    if (object2 instanceof OneOf) {
      if (!this.oneofs || this.oneofs[object2.name] !== object2)
        throw Error(object2 + " is not a member of " + this);
      delete this.oneofs[object2.name];
      object2.parent = null;
      object2.onRemove(this);
      return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object2);
  };
  Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
  };
  Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
  };
  Type.prototype.create = function create2(properties) {
    return new this.ctor(properties);
  };
  Type.prototype.setup = function setup() {
    var fullName = this.fullName, types2 = [];
    for (var i = 0; i < /* initializes */
    this.fieldsArray.length; ++i)
      types2.push(this._fieldsArray[i].resolve().resolvedType);
    this.encode = encoder(this)({
      Writer,
      types: types2,
      util: util2
    });
    this.decode = decoder(this)({
      Reader,
      types: types2,
      util: util2
    });
    this.verify = verifier(this)({
      types: types2,
      util: util2
    });
    this.fromObject = converter2.fromObject(this)({
      types: types2,
      util: util2
    });
    this.toObject = converter2.toObject(this)({
      types: types2,
      util: util2
    });
    var wrapper = wrappers2[fullName];
    if (wrapper) {
      var originalThis = Object.create(this);
      originalThis.fromObject = this.fromObject;
      this.fromObject = wrapper.fromObject.bind(originalThis);
      originalThis.toObject = this.toObject;
      this.toObject = wrapper.toObject.bind(originalThis);
    }
    return this;
  };
  Type.prototype.encode = function encode_setup(message2, writer2) {
    return this.setup().encode(message2, writer2);
  };
  Type.prototype.encodeDelimited = function encodeDelimited(message2, writer2) {
    return this.encode(message2, writer2 && writer2.len ? writer2.fork() : writer2).ldelim();
  };
  Type.prototype.decode = function decode_setup(reader2, length) {
    return this.setup().decode(reader2, length);
  };
  Type.prototype.decodeDelimited = function decodeDelimited(reader2) {
    if (!(reader2 instanceof Reader))
      reader2 = Reader.create(reader2);
    return this.decode(reader2, reader2.uint32());
  };
  Type.prototype.verify = function verify_setup(message2) {
    return this.setup().verify(message2);
  };
  Type.prototype.fromObject = function fromObject(object2) {
    return this.setup().fromObject(object2);
  };
  Type.prototype.toObject = function toObject(message2, options) {
    return this.setup().toObject(message2, options);
  };
  Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
      util2.decorateType(target, typeName);
    };
  };
  return type;
}
var root;
var hasRequiredRoot;
function requireRoot() {
  if (hasRequiredRoot) return root;
  hasRequiredRoot = 1;
  root = Root;
  var Namespace = requireNamespace();
  ((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";
  var Field = requireField(), Enum = require_enum(), OneOf = requireOneof(), util2 = requireUtil();
  var Type, parse2, common;
  function Root(options) {
    Namespace.call(this, "", options);
    this.deferred = [];
    this.files = [];
  }
  Root.fromJSON = function fromJSON(json2, root2) {
    if (!root2)
      root2 = new Root();
    if (json2.options)
      root2.setOptions(json2.options);
    return root2.addJSON(json2.nested);
  };
  Root.prototype.resolvePath = util2.path.resolve;
  Root.prototype.fetch = util2.fetch;
  function SYNC() {
  }
  Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = void 0;
    }
    var self2 = this;
    if (!callback)
      return util2.asPromise(load, self2, filename, options);
    var sync = callback === SYNC;
    function finish(err, root2) {
      if (!callback)
        return;
      if (sync)
        throw err;
      var cb = callback;
      callback = null;
      cb(err, root2);
    }
    function getBundledFileName(filename2) {
      var idx = filename2.lastIndexOf("google/protobuf/");
      if (idx > -1) {
        var altname = filename2.substring(idx);
        if (altname in common) return altname;
      }
      return null;
    }
    function process(filename2, source) {
      try {
        if (util2.isString(source) && source.charAt(0) === "{")
          source = JSON.parse(source);
        if (!util2.isString(source))
          self2.setOptions(source.options).addJSON(source.nested);
        else {
          parse2.filename = filename2;
          var parsed = parse2(source, self2, options), resolved2, i2 = 0;
          if (parsed.imports) {
            for (; i2 < parsed.imports.length; ++i2)
              if (resolved2 = getBundledFileName(parsed.imports[i2]) || self2.resolvePath(filename2, parsed.imports[i2]))
                fetch(resolved2);
          }
          if (parsed.weakImports) {
            for (i2 = 0; i2 < parsed.weakImports.length; ++i2)
              if (resolved2 = getBundledFileName(parsed.weakImports[i2]) || self2.resolvePath(filename2, parsed.weakImports[i2]))
                fetch(resolved2, true);
          }
        }
      } catch (err) {
        finish(err);
      }
      if (!sync && !queued)
        finish(null, self2);
    }
    function fetch(filename2, weak) {
      filename2 = getBundledFileName(filename2) || filename2;
      if (self2.files.indexOf(filename2) > -1)
        return;
      self2.files.push(filename2);
      if (filename2 in common) {
        if (sync)
          process(filename2, common[filename2]);
        else {
          ++queued;
          setTimeout(function() {
            --queued;
            process(filename2, common[filename2]);
          });
        }
        return;
      }
      if (sync) {
        var source;
        try {
          source = util2.fs.readFileSync(filename2).toString("utf8");
        } catch (err) {
          if (!weak)
            finish(err);
          return;
        }
        process(filename2, source);
      } else {
        ++queued;
        self2.fetch(filename2, function(err, source2) {
          --queued;
          if (!callback)
            return;
          if (err) {
            if (!weak)
              finish(err);
            else if (!queued)
              finish(null, self2);
            return;
          }
          process(filename2, source2);
        });
      }
    }
    var queued = 0;
    if (util2.isString(filename))
      filename = [filename];
    for (var i = 0, resolved; i < filename.length; ++i)
      if (resolved = self2.resolvePath("", filename[i]))
        fetch(resolved);
    if (sync)
      return self2;
    if (!queued)
      finish(null, self2);
    return void 0;
  };
  Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util2.isNode)
      throw Error("not supported");
    return this.load(filename, options, SYNC);
  };
  Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
      throw Error("unresolvable extensions: " + this.deferred.map(function(field2) {
        return "'extend " + field2.extend + "' in " + field2.parent.fullName;
      }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
  };
  var exposeRe = /^[A-Z]/;
  function tryHandleExtension(root2, field2) {
    var extendedType = field2.parent.lookup(field2.extend);
    if (extendedType) {
      var sisterField = new Field(field2.fullName, field2.id, field2.type, field2.rule, void 0, field2.options);
      if (extendedType.get(sisterField.name)) {
        return true;
      }
      sisterField.declaringField = field2;
      field2.extensionField = sisterField;
      extendedType.add(sisterField);
      return true;
    }
    return false;
  }
  Root.prototype._handleAdd = function _handleAdd(object2) {
    if (object2 instanceof Field) {
      if (
        /* an extension field (implies not part of a oneof) */
        object2.extend !== void 0 && /* not already handled */
        !object2.extensionField
      ) {
        if (!tryHandleExtension(this, object2))
          this.deferred.push(object2);
      }
    } else if (object2 instanceof Enum) {
      if (exposeRe.test(object2.name))
        object2.parent[object2.name] = object2.values;
    } else if (!(object2 instanceof OneOf)) {
      if (object2 instanceof Type)
        for (var i = 0; i < this.deferred.length; )
          if (tryHandleExtension(this, this.deferred[i]))
            this.deferred.splice(i, 1);
          else
            ++i;
      for (var j = 0; j < /* initializes */
      object2.nestedArray.length; ++j)
        this._handleAdd(object2._nestedArray[j]);
      if (exposeRe.test(object2.name))
        object2.parent[object2.name] = object2;
    }
  };
  Root.prototype._handleRemove = function _handleRemove(object2) {
    if (object2 instanceof Field) {
      if (
        /* an extension field */
        object2.extend !== void 0
      ) {
        if (
          /* already handled */
          object2.extensionField
        ) {
          object2.extensionField.parent.remove(object2.extensionField);
          object2.extensionField = null;
        } else {
          var index2 = this.deferred.indexOf(object2);
          if (index2 > -1)
            this.deferred.splice(index2, 1);
        }
      }
    } else if (object2 instanceof Enum) {
      if (exposeRe.test(object2.name))
        delete object2.parent[object2.name];
    } else if (object2 instanceof Namespace) {
      for (var i = 0; i < /* initializes */
      object2.nestedArray.length; ++i)
        this._handleRemove(object2._nestedArray[i]);
      if (exposeRe.test(object2.name))
        delete object2.parent[object2.name];
    }
  };
  Root._configure = function(Type_, parse_, common_) {
    Type = Type_;
    parse2 = parse_;
    common = common_;
  };
  return root;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util.exports;
  hasRequiredUtil = 1;
  var util$1 = util.exports = requireMinimal();
  var roots2 = requireRoots();
  var Type, Enum;
  util$1.codegen = requireCodegen();
  util$1.fetch = requireFetch();
  util$1.path = requirePath();
  util$1.fs = util$1.inquire("fs");
  util$1.toArray = function toArray(object2) {
    if (object2) {
      var keys = Object.keys(object2), array2 = new Array(keys.length), index2 = 0;
      while (index2 < keys.length)
        array2[index2] = object2[keys[index2++]];
      return array2;
    }
    return [];
  };
  util$1.toObject = function toObject(array2) {
    var object2 = {}, index2 = 0;
    while (index2 < array2.length) {
      var key = array2[index2++], val = array2[index2++];
      if (val !== void 0)
        object2[key] = val;
    }
    return object2;
  };
  var safePropBackslashRe = /\\/g, safePropQuoteRe = /"/g;
  util$1.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
  };
  util$1.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util$1.isReserved(prop))
      return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, '\\"') + '"]';
    return "." + prop;
  };
  util$1.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
  };
  var camelCaseRe = /_([a-z])/g;
  util$1.camelCase = function camelCase(str) {
    return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
      return $1.toUpperCase();
    });
  };
  util$1.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
  };
  util$1.decorateType = function decorateType(ctor, typeName) {
    if (ctor.$type) {
      if (typeName && ctor.$type.name !== typeName) {
        util$1.decorateRoot.remove(ctor.$type);
        ctor.$type.name = typeName;
        util$1.decorateRoot.add(ctor.$type);
      }
      return ctor.$type;
    }
    if (!Type)
      Type = requireType();
    var type2 = new Type(typeName || ctor.name);
    util$1.decorateRoot.add(type2);
    type2.ctor = ctor;
    Object.defineProperty(ctor, "$type", { value: type2, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type2, enumerable: false });
    return type2;
  };
  var decorateEnumIndex = 0;
  util$1.decorateEnum = function decorateEnum(object2) {
    if (object2.$type)
      return object2.$type;
    if (!Enum)
      Enum = require_enum();
    var enm = new Enum("Enum" + decorateEnumIndex++, object2);
    util$1.decorateRoot.add(enm);
    Object.defineProperty(object2, "$type", { value: enm, enumerable: false });
    return enm;
  };
  util$1.setProperty = function setProperty(dst, path2, value2) {
    function setProp(dst2, path3, value3) {
      var part = path3.shift();
      if (part === "__proto__" || part === "prototype") {
        return dst2;
      }
      if (path3.length > 0) {
        dst2[part] = setProp(dst2[part] || {}, path3, value3);
      } else {
        var prevValue = dst2[part];
        if (prevValue)
          value3 = [].concat(prevValue).concat(value3);
        dst2[part] = value3;
      }
      return dst2;
    }
    if (typeof dst !== "object")
      throw TypeError("dst must be an object");
    if (!path2)
      throw TypeError("path must be specified");
    path2 = path2.split(".");
    return setProp(dst, path2, value2);
  };
  Object.defineProperty(util$1, "decorateRoot", {
    get: function() {
      return roots2["decorated"] || (roots2["decorated"] = new (requireRoot())());
    }
  });
  return util.exports;
}
var object;
var hasRequiredObject;
function requireObject() {
  if (hasRequiredObject) return object;
  hasRequiredObject = 1;
  object = ReflectionObject;
  ReflectionObject.className = "ReflectionObject";
  var util2 = requireUtil();
  var Root;
  function ReflectionObject(name, options) {
    if (!util2.isString(name))
      throw TypeError("name must be a string");
    if (options && !util2.isObject(options))
      throw TypeError("options must be an object");
    this.options = options;
    this.parsedOptions = null;
    this.name = name;
    this.parent = null;
    this.resolved = false;
    this.comment = null;
    this.filename = null;
  }
  Object.defineProperties(ReflectionObject.prototype, {
    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
      get: function() {
        var ptr = this;
        while (ptr.parent !== null)
          ptr = ptr.parent;
        return ptr;
      }
    },
    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
      get: function() {
        var path2 = [this.name], ptr = this.parent;
        while (ptr) {
          path2.unshift(ptr.name);
          ptr = ptr.parent;
        }
        return path2.join(".");
      }
    }
  });
  ReflectionObject.prototype.toJSON = /* istanbul ignore next */
  function toJSON() {
    throw Error();
  };
  ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
      this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root2 = parent.root;
    if (root2 instanceof Root)
      root2._handleAdd(this);
  };
  ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root2 = parent.root;
    if (root2 instanceof Root)
      root2._handleRemove(this);
    this.parent = null;
    this.resolved = false;
  };
  ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    if (this.root instanceof Root)
      this.resolved = true;
    return this;
  };
  ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
      return this.options[name];
    return void 0;
  };
  ReflectionObject.prototype.setOption = function setOption(name, value2, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === void 0)
      (this.options || (this.options = {}))[name] = value2;
    return this;
  };
  ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value2, propName) {
    if (!this.parsedOptions) {
      this.parsedOptions = [];
    }
    var parsedOptions = this.parsedOptions;
    if (propName) {
      var opt = parsedOptions.find(function(opt2) {
        return Object.prototype.hasOwnProperty.call(opt2, name);
      });
      if (opt) {
        var newValue = opt[name];
        util2.setProperty(newValue, propName, value2);
      } else {
        opt = {};
        opt[name] = util2.setProperty({}, propName, value2);
        parsedOptions.push(opt);
      }
    } else {
      var newOpt = {};
      newOpt[name] = value2;
      parsedOptions.push(newOpt);
    }
    return this;
  };
  ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
      for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
        this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
  };
  ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className, fullName = this.fullName;
    if (fullName.length)
      return className + " " + fullName;
    return className;
  };
  ReflectionObject._configure = function(Root_) {
    Root = Root_;
  };
  return object;
}
var _enum;
var hasRequired_enum;
function require_enum() {
  if (hasRequired_enum) return _enum;
  hasRequired_enum = 1;
  _enum = Enum;
  var ReflectionObject = requireObject();
  ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
  var Namespace = requireNamespace(), util2 = requireUtil();
  function Enum(name, values, options, comment, comments, valuesOptions) {
    ReflectionObject.call(this, name, options);
    if (values && typeof values !== "object")
      throw TypeError("values must be an object");
    this.valuesById = {};
    this.values = Object.create(this.valuesById);
    this.comment = comment;
    this.comments = comments || {};
    this.valuesOptions = valuesOptions;
    this.reserved = void 0;
    if (values) {
      for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
        if (typeof values[keys[i]] === "number")
          this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
    }
  }
  Enum.fromJSON = function fromJSON(name, json2) {
    var enm = new Enum(name, json2.values, json2.options, json2.comment, json2.comments);
    enm.reserved = json2.reserved;
    return enm;
  };
  Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util2.toObject([
      "options",
      this.options,
      "valuesOptions",
      this.valuesOptions,
      "values",
      this.values,
      "reserved",
      this.reserved && this.reserved.length ? this.reserved : void 0,
      "comment",
      keepComments ? this.comment : void 0,
      "comments",
      keepComments ? this.comments : void 0
    ]);
  };
  Enum.prototype.add = function add(name, id, comment, options) {
    if (!util2.isString(name))
      throw TypeError("name must be a string");
    if (!util2.isInteger(id))
      throw TypeError("id must be an integer");
    if (this.values[name] !== void 0)
      throw Error("duplicate name '" + name + "' in " + this);
    if (this.isReservedId(id))
      throw Error("id " + id + " is reserved in " + this);
    if (this.isReservedName(name))
      throw Error("name '" + name + "' is reserved in " + this);
    if (this.valuesById[id] !== void 0) {
      if (!(this.options && this.options.allow_alias))
        throw Error("duplicate id " + id + " in " + this);
      this.values[name] = id;
    } else
      this.valuesById[this.values[name] = id] = name;
    if (options) {
      if (this.valuesOptions === void 0)
        this.valuesOptions = {};
      this.valuesOptions[name] = options || null;
    }
    this.comments[name] = comment || null;
    return this;
  };
  Enum.prototype.remove = function remove(name) {
    if (!util2.isString(name))
      throw TypeError("name must be a string");
    var val = this.values[name];
    if (val == null)
      throw Error("name '" + name + "' does not exist in " + this);
    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];
    if (this.valuesOptions)
      delete this.valuesOptions[name];
    return this;
  };
  Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
  };
  Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
  };
  return _enum;
}
var encoder_1;
var hasRequiredEncoder;
function requireEncoder() {
  if (hasRequiredEncoder) return encoder_1;
  hasRequiredEncoder = 1;
  encoder_1 = encoder;
  var Enum = require_enum(), types2 = requireTypes$2(), util2 = requireUtil();
  function genTypePartial(gen, field2, fieldIndex, ref2) {
    return field2.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref2, (field2.id << 3 | 3) >>> 0, (field2.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref2, (field2.id << 3 | 2) >>> 0);
  }
  function encoder(mtype) {
    var gen = util2.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
    var i, ref2;
    var fields = (
      /* initializes */
      mtype.fieldsArray.slice().sort(util2.compareFieldsById)
    );
    for (var i = 0; i < fields.length; ++i) {
      var field2 = fields[i].resolve(), index2 = mtype._fieldsArray.indexOf(field2), type2 = field2.resolvedType instanceof Enum ? "int32" : field2.type, wireType = types2.basic[type2];
      ref2 = "m" + util2.safeProp(field2.name);
      if (field2.map) {
        gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref2, field2.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref2)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field2.id << 3 | 2) >>> 0, 8 | types2.mapKey[field2.keyType], field2.keyType);
        if (wireType === void 0) gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index2, ref2);
        else gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type2, ref2);
        gen("}")("}");
      } else if (field2.repeated) {
        gen("if(%s!=null&&%s.length){", ref2, ref2);
        if (field2.packed && types2.packed[type2] !== void 0) {
          gen("w.uint32(%i).fork()", (field2.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref2)("w.%s(%s[i])", type2, ref2)("w.ldelim()");
        } else {
          gen("for(var i=0;i<%s.length;++i)", ref2);
          if (wireType === void 0)
            genTypePartial(gen, field2, index2, ref2 + "[i]");
          else gen("w.uint32(%i).%s(%s[i])", (field2.id << 3 | wireType) >>> 0, type2, ref2);
        }
        gen("}");
      } else {
        if (field2.optional) gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref2, field2.name);
        if (wireType === void 0)
          genTypePartial(gen, field2, index2, ref2);
        else gen("w.uint32(%i).%s(%s)", (field2.id << 3 | wireType) >>> 0, type2, ref2);
      }
    }
    return gen("return w");
  }
  return encoder_1;
}
var hasRequiredIndexLight;
function requireIndexLight() {
  if (hasRequiredIndexLight) return indexLight.exports;
  hasRequiredIndexLight = 1;
  var protobuf = indexLight.exports = requireIndexMinimal();
  protobuf.build = "light";
  function load(filename, root2, callback) {
    if (typeof root2 === "function") {
      callback = root2;
      root2 = new protobuf.Root();
    } else if (!root2)
      root2 = new protobuf.Root();
    return root2.load(filename, callback);
  }
  protobuf.load = load;
  function loadSync(filename, root2) {
    if (!root2)
      root2 = new protobuf.Root();
    return root2.loadSync(filename);
  }
  protobuf.loadSync = loadSync;
  protobuf.encoder = requireEncoder();
  protobuf.decoder = requireDecoder();
  protobuf.verifier = requireVerifier();
  protobuf.converter = requireConverter();
  protobuf.ReflectionObject = requireObject();
  protobuf.Namespace = requireNamespace();
  protobuf.Root = requireRoot();
  protobuf.Enum = require_enum();
  protobuf.Type = requireType();
  protobuf.Field = requireField();
  protobuf.OneOf = requireOneof();
  protobuf.MapField = requireMapfield();
  protobuf.Service = requireService();
  protobuf.Method = requireMethod();
  protobuf.Message = requireMessage();
  protobuf.wrappers = requireWrappers();
  protobuf.types = requireTypes$2();
  protobuf.util = requireUtil();
  protobuf.ReflectionObject._configure(protobuf.Root);
  protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
  protobuf.Root._configure(protobuf.Type);
  protobuf.Field._configure(protobuf.Type);
  return indexLight.exports;
}
var light;
var hasRequiredLight;
function requireLight() {
  if (hasRequiredLight) return light;
  hasRequiredLight = 1;
  light = requireIndexLight();
  return light;
}
var decode = {};
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  Object.defineProperty(utils, "__esModule", {
    value: true
  });
  utils.createMessageFromType = utils.createMessageFromName = utils.isPrimitiveField = void 0;
  utils.parseConfigure = parseConfigure;
  const tslib_12 = require$$0$1;
  const protobuf = tslib_12.__importStar(requireLight());
  const primitiveTypes = ["bool", "string", "bytes", "int32", "int64", "uint32", "uint64", "sint32", "sint64", "fixed32", "fixed64", "sfixed32", "sfixed64", "double", "float"];
  const isPrimitiveField = (field2) => primitiveTypes.includes(field2);
  utils.isPrimitiveField = isPrimitiveField;
  function parseConfigure(data) {
    if (typeof data === "string") {
      return protobuf.Root.fromJSON(JSON.parse(data));
    }
    return protobuf.Root.fromJSON(data);
  }
  const createMessageFromName = (messages2, name) => {
    const Message = messages2.lookupType(name);
    const messageTypes2 = messages2.lookupEnum("MessageType");
    let messageTypeId = messageTypes2.values[name];
    if (typeof messageTypeId !== "number" && Message.options) {
      messageTypeId = Message.options["(wire_type)"];
    }
    return {
      Message,
      messageType: messageTypeId ?? name
    };
  };
  utils.createMessageFromName = createMessageFromName;
  const createMessageFromType = (messages2, messageType) => {
    if (typeof messageType === "string") {
      const Message2 = messages2.lookupType(messageType);
      return {
        Message: Message2,
        messageName: messageType
      };
    }
    const messageTypes2 = messages2.lookupEnum("MessageType");
    const messageName = messageTypes2.valuesById[messageType];
    const Message = messages2.lookupType(messageName);
    return {
      Message,
      messageName
    };
  };
  utils.createMessageFromType = createMessageFromType;
  return utils;
}
var hasRequiredDecode;
function requireDecode() {
  if (hasRequiredDecode) return decode;
  hasRequiredDecode = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.decodeMessage = exports$12.decode = void 0;
    const utils_12 = requireUtils();
    const transform2 = (field2, value2) => {
      if ((0, utils_12.isPrimitiveField)(field2.type)) {
        if (field2.optional && typeof value2 === "undefined") {
          return null;
        }
        if (field2.type === "bytes") {
          return Buffer.from(value2).toString("hex");
        }
        if (field2.long) {
          if (Number.isSafeInteger(value2.toNumber())) {
            return value2.toNumber();
          }
          return value2.toString();
        }
        return value2;
      }
      if ("valuesById" in field2.resolvedType) {
        return field2.resolvedType.valuesById[value2];
      }
      if (field2.resolvedType.fields) {
        return messageToJSON(value2, field2.resolvedType.fields);
      }
      throw new Error(`transport: decode: case not handled: ${field2}`);
    };
    function messageToJSON(MessageParam, fields) {
      if (!MessageParam) {
        return {};
      }
      const {
        ...message2
      } = MessageParam;
      const res = {};
      Object.keys(fields).forEach((key) => {
        const field2 = fields[key];
        const value2 = message2[key];
        if (field2.repeated) {
          res[key] = value2.map((v) => transform2(field2, v));
        } else {
          res[key] = transform2(field2, value2);
        }
      });
      return res;
    }
    const decode2 = (MessageParam, data) => {
      const decoded = MessageParam.decode(new Uint8Array(data));
      return messageToJSON(decoded, decoded.$type.fields);
    };
    exports$12.decode = decode2;
    const decodeMessage = (messages2, messageType, data) => {
      const {
        Message,
        messageName
      } = (0, utils_12.createMessageFromType)(messages2, messageType);
      const message2 = (0, exports$12.decode)(Message, data);
      return {
        type: messageName,
        message: message2
      };
    };
    exports$12.decodeMessage = decodeMessage;
  })(decode);
  return decode;
}
var encode = {};
var hasRequiredEncode;
function requireEncode() {
  if (hasRequiredEncode) return encode;
  hasRequiredEncode = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.encodeMessage = exports$12.encode = void 0;
    const light_1 = requireLight();
    const utils_12 = requireUtils();
    const transform2 = (fieldType, value2) => {
      if (fieldType === "bytes") {
        if (typeof value2 === "string" && !value2) return value2;
        return Buffer.from(value2, "hex");
      }
      if (typeof value2 === "number" && !Number.isSafeInteger(value2)) {
        throw new RangeError("field value is not within safe integer range");
      }
      if (fieldType === "string" && typeof value2 === "string") {
        value2 = value2.replace(/[ââ]/g, "'");
      }
      return value2;
    };
    function patch(Message, payload) {
      const patched = {};
      if (!Message.fields) {
        return patched;
      }
      Object.keys(Message.fields).forEach((key) => {
        const field2 = Message.fields[key];
        const value2 = payload[key];
        if (typeof value2 === "undefined") {
          return;
        }
        if ((0, utils_12.isPrimitiveField)(field2.type)) {
          if (field2.repeated) {
            patched[key] = value2.map((v) => transform2(field2.type, v));
          } else {
            patched[key] = transform2(field2.type, value2);
          }
          return;
        }
        if (field2.repeated) {
          const fieldType = Message.lookupTypeOrEnum(field2.type);
          if (fieldType instanceof light_1.Enum) {
            patched[key] = value2;
          } else {
            patched[key] = value2.map((v) => patch(fieldType, v));
          }
        } else if (typeof value2 === "object" && value2 !== null) {
          const RefMessage = Message.lookupType(field2.type);
          patched[key] = patch(RefMessage, value2);
        } else if (typeof value2 === "number") {
          const RefMessage = Message.lookupEnum(field2.type);
          patched[key] = RefMessage.values[value2];
        } else {
          patched[key] = value2;
        }
      });
      return patched;
    }
    const encode2 = (Message, data) => {
      const payload = patch(Message, data);
      const message2 = Message.fromObject(payload);
      const bytes = Message.encode(message2).finish();
      return Buffer.from(bytes);
    };
    exports$12.encode = encode2;
    const encodeMessage = (messages2, messageName, data) => {
      const {
        Message,
        messageType
      } = (0, utils_12.createMessageFromName)(messages2, messageName);
      const message2 = (0, exports$12.encode)(Message, data);
      return {
        messageType,
        message: message2
      };
    };
    exports$12.encodeMessage = encodeMessage;
  })(encode);
  return encode;
}
var messages$1 = {};
var hasRequiredMessages$1;
function requireMessages$1() {
  if (hasRequiredMessages$1) return messages$1;
  hasRequiredMessages$1 = 1;
  Object.defineProperty(messages$1, "__esModule", {
    value: true
  });
  messages$1.TezosBallotType = messages$1.TezosContractType = messages$1.StellarSignerType = messages$1.StellarMemoType = messages$1.StellarAssetType = messages$1.NEMImportanceTransferMode = messages$1.NEMModificationType = messages$1.NEMSupplyChangeType = messages$1.NEMMosaicLevy = messages$1.MoneroNetworkType = messages$1.BootCommand = messages$1.Enum_WordRequestType = messages$1.SdProtectOperationType = messages$1.Enum_RecoveryType = messages$1.RecoveryDeviceInputMethod = messages$1.Enum_Capability = messages$1.Enum_RecoveryStatus = messages$1.Enum_BackupAvailability = messages$1.Enum_HomescreenFormat = messages$1.Enum_DisplayRotation = messages$1.Enum_SafetyCheckLevel = messages$1.Enum_BackupType = messages$1.EthereumDataType = messages$1.DefinitionType = messages$1.DebugWaitType = messages$1.DebugTouchEventType = messages$1.DebugPhysicalButton = messages$1.DebugButton = messages$1.Enum_PinMatrixRequestType = messages$1.Enum_ButtonRequestType = messages$1.Enum_FailureType = messages$1.CardanoTxWitnessType = messages$1.CardanoTxSigningMode = messages$1.CardanoCVoteRegistrationFormat = messages$1.CardanoTxAuxiliaryDataSupplementType = messages$1.CardanoPoolRelayType = messages$1.CardanoDRepType = messages$1.CardanoCertificateType = messages$1.CardanoTxOutputSerializationFormat = messages$1.CardanoNativeScriptHashDisplayFormat = messages$1.CardanoNativeScriptType = messages$1.CardanoAddressType = messages$1.CardanoDerivationType = messages$1.Enum_RequestType = messages$1.MultisigPubkeysOrder = messages$1.AmountUnit = messages$1.DecredStakingSpendType = messages$1.Enum_OutputScriptType = messages$1.Enum_InputScriptType = messages$1.DeviceModelInternal = void 0;
  var DeviceModelInternal;
  (function(DeviceModelInternal2) {
    DeviceModelInternal2["T1B1"] = "T1B1";
    DeviceModelInternal2["T2T1"] = "T2T1";
    DeviceModelInternal2["T2B1"] = "T2B1";
    DeviceModelInternal2["T3B1"] = "T3B1";
    DeviceModelInternal2["T3T1"] = "T3T1";
    DeviceModelInternal2["T3W1"] = "T3W1";
    DeviceModelInternal2["UNKNOWN"] = "UNKNOWN";
  })(DeviceModelInternal || (messages$1.DeviceModelInternal = DeviceModelInternal = {}));
  var Enum_InputScriptType;
  (function(Enum_InputScriptType2) {
    Enum_InputScriptType2[Enum_InputScriptType2["SPENDADDRESS"] = 0] = "SPENDADDRESS";
    Enum_InputScriptType2[Enum_InputScriptType2["SPENDMULTISIG"] = 1] = "SPENDMULTISIG";
    Enum_InputScriptType2[Enum_InputScriptType2["EXTERNAL"] = 2] = "EXTERNAL";
    Enum_InputScriptType2[Enum_InputScriptType2["SPENDWITNESS"] = 3] = "SPENDWITNESS";
    Enum_InputScriptType2[Enum_InputScriptType2["SPENDP2SHWITNESS"] = 4] = "SPENDP2SHWITNESS";
    Enum_InputScriptType2[Enum_InputScriptType2["SPENDTAPROOT"] = 5] = "SPENDTAPROOT";
  })(Enum_InputScriptType || (messages$1.Enum_InputScriptType = Enum_InputScriptType = {}));
  var Enum_OutputScriptType;
  (function(Enum_OutputScriptType2) {
    Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOADDRESS"] = 0] = "PAYTOADDRESS";
    Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOSCRIPTHASH"] = 1] = "PAYTOSCRIPTHASH";
    Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOMULTISIG"] = 2] = "PAYTOMULTISIG";
    Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOOPRETURN"] = 3] = "PAYTOOPRETURN";
    Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOWITNESS"] = 4] = "PAYTOWITNESS";
    Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOP2SHWITNESS"] = 5] = "PAYTOP2SHWITNESS";
    Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOTAPROOT"] = 6] = "PAYTOTAPROOT";
  })(Enum_OutputScriptType || (messages$1.Enum_OutputScriptType = Enum_OutputScriptType = {}));
  var DecredStakingSpendType;
  (function(DecredStakingSpendType2) {
    DecredStakingSpendType2[DecredStakingSpendType2["SSGen"] = 0] = "SSGen";
    DecredStakingSpendType2[DecredStakingSpendType2["SSRTX"] = 1] = "SSRTX";
  })(DecredStakingSpendType || (messages$1.DecredStakingSpendType = DecredStakingSpendType = {}));
  var AmountUnit;
  (function(AmountUnit2) {
    AmountUnit2[AmountUnit2["BITCOIN"] = 0] = "BITCOIN";
    AmountUnit2[AmountUnit2["MILLIBITCOIN"] = 1] = "MILLIBITCOIN";
    AmountUnit2[AmountUnit2["MICROBITCOIN"] = 2] = "MICROBITCOIN";
    AmountUnit2[AmountUnit2["SATOSHI"] = 3] = "SATOSHI";
  })(AmountUnit || (messages$1.AmountUnit = AmountUnit = {}));
  var MultisigPubkeysOrder;
  (function(MultisigPubkeysOrder2) {
    MultisigPubkeysOrder2[MultisigPubkeysOrder2["PRESERVED"] = 0] = "PRESERVED";
    MultisigPubkeysOrder2[MultisigPubkeysOrder2["LEXICOGRAPHIC"] = 1] = "LEXICOGRAPHIC";
  })(MultisigPubkeysOrder || (messages$1.MultisigPubkeysOrder = MultisigPubkeysOrder = {}));
  var Enum_RequestType;
  (function(Enum_RequestType2) {
    Enum_RequestType2[Enum_RequestType2["TXINPUT"] = 0] = "TXINPUT";
    Enum_RequestType2[Enum_RequestType2["TXOUTPUT"] = 1] = "TXOUTPUT";
    Enum_RequestType2[Enum_RequestType2["TXMETA"] = 2] = "TXMETA";
    Enum_RequestType2[Enum_RequestType2["TXFINISHED"] = 3] = "TXFINISHED";
    Enum_RequestType2[Enum_RequestType2["TXEXTRADATA"] = 4] = "TXEXTRADATA";
    Enum_RequestType2[Enum_RequestType2["TXORIGINPUT"] = 5] = "TXORIGINPUT";
    Enum_RequestType2[Enum_RequestType2["TXORIGOUTPUT"] = 6] = "TXORIGOUTPUT";
    Enum_RequestType2[Enum_RequestType2["TXPAYMENTREQ"] = 7] = "TXPAYMENTREQ";
  })(Enum_RequestType || (messages$1.Enum_RequestType = Enum_RequestType = {}));
  var CardanoDerivationType;
  (function(CardanoDerivationType2) {
    CardanoDerivationType2[CardanoDerivationType2["LEDGER"] = 0] = "LEDGER";
    CardanoDerivationType2[CardanoDerivationType2["ICARUS"] = 1] = "ICARUS";
    CardanoDerivationType2[CardanoDerivationType2["ICARUS_TREZOR"] = 2] = "ICARUS_TREZOR";
  })(CardanoDerivationType || (messages$1.CardanoDerivationType = CardanoDerivationType = {}));
  var CardanoAddressType;
  (function(CardanoAddressType2) {
    CardanoAddressType2[CardanoAddressType2["BASE"] = 0] = "BASE";
    CardanoAddressType2[CardanoAddressType2["BASE_SCRIPT_KEY"] = 1] = "BASE_SCRIPT_KEY";
    CardanoAddressType2[CardanoAddressType2["BASE_KEY_SCRIPT"] = 2] = "BASE_KEY_SCRIPT";
    CardanoAddressType2[CardanoAddressType2["BASE_SCRIPT_SCRIPT"] = 3] = "BASE_SCRIPT_SCRIPT";
    CardanoAddressType2[CardanoAddressType2["POINTER"] = 4] = "POINTER";
    CardanoAddressType2[CardanoAddressType2["POINTER_SCRIPT"] = 5] = "POINTER_SCRIPT";
    CardanoAddressType2[CardanoAddressType2["ENTERPRISE"] = 6] = "ENTERPRISE";
    CardanoAddressType2[CardanoAddressType2["ENTERPRISE_SCRIPT"] = 7] = "ENTERPRISE_SCRIPT";
    CardanoAddressType2[CardanoAddressType2["BYRON"] = 8] = "BYRON";
    CardanoAddressType2[CardanoAddressType2["REWARD"] = 14] = "REWARD";
    CardanoAddressType2[CardanoAddressType2["REWARD_SCRIPT"] = 15] = "REWARD_SCRIPT";
  })(CardanoAddressType || (messages$1.CardanoAddressType = CardanoAddressType = {}));
  var CardanoNativeScriptType;
  (function(CardanoNativeScriptType2) {
    CardanoNativeScriptType2[CardanoNativeScriptType2["PUB_KEY"] = 0] = "PUB_KEY";
    CardanoNativeScriptType2[CardanoNativeScriptType2["ALL"] = 1] = "ALL";
    CardanoNativeScriptType2[CardanoNativeScriptType2["ANY"] = 2] = "ANY";
    CardanoNativeScriptType2[CardanoNativeScriptType2["N_OF_K"] = 3] = "N_OF_K";
    CardanoNativeScriptType2[CardanoNativeScriptType2["INVALID_BEFORE"] = 4] = "INVALID_BEFORE";
    CardanoNativeScriptType2[CardanoNativeScriptType2["INVALID_HEREAFTER"] = 5] = "INVALID_HEREAFTER";
  })(CardanoNativeScriptType || (messages$1.CardanoNativeScriptType = CardanoNativeScriptType = {}));
  var CardanoNativeScriptHashDisplayFormat;
  (function(CardanoNativeScriptHashDisplayFormat2) {
    CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["HIDE"] = 0] = "HIDE";
    CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["BECH32"] = 1] = "BECH32";
    CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["POLICY_ID"] = 2] = "POLICY_ID";
  })(CardanoNativeScriptHashDisplayFormat || (messages$1.CardanoNativeScriptHashDisplayFormat = CardanoNativeScriptHashDisplayFormat = {}));
  var CardanoTxOutputSerializationFormat;
  (function(CardanoTxOutputSerializationFormat2) {
    CardanoTxOutputSerializationFormat2[CardanoTxOutputSerializationFormat2["ARRAY_LEGACY"] = 0] = "ARRAY_LEGACY";
    CardanoTxOutputSerializationFormat2[CardanoTxOutputSerializationFormat2["MAP_BABBAGE"] = 1] = "MAP_BABBAGE";
  })(CardanoTxOutputSerializationFormat || (messages$1.CardanoTxOutputSerializationFormat = CardanoTxOutputSerializationFormat = {}));
  var CardanoCertificateType;
  (function(CardanoCertificateType2) {
    CardanoCertificateType2[CardanoCertificateType2["STAKE_REGISTRATION"] = 0] = "STAKE_REGISTRATION";
    CardanoCertificateType2[CardanoCertificateType2["STAKE_DEREGISTRATION"] = 1] = "STAKE_DEREGISTRATION";
    CardanoCertificateType2[CardanoCertificateType2["STAKE_DELEGATION"] = 2] = "STAKE_DELEGATION";
    CardanoCertificateType2[CardanoCertificateType2["STAKE_POOL_REGISTRATION"] = 3] = "STAKE_POOL_REGISTRATION";
    CardanoCertificateType2[CardanoCertificateType2["STAKE_REGISTRATION_CONWAY"] = 7] = "STAKE_REGISTRATION_CONWAY";
    CardanoCertificateType2[CardanoCertificateType2["STAKE_DEREGISTRATION_CONWAY"] = 8] = "STAKE_DEREGISTRATION_CONWAY";
    CardanoCertificateType2[CardanoCertificateType2["VOTE_DELEGATION"] = 9] = "VOTE_DELEGATION";
  })(CardanoCertificateType || (messages$1.CardanoCertificateType = CardanoCertificateType = {}));
  var CardanoDRepType;
  (function(CardanoDRepType2) {
    CardanoDRepType2[CardanoDRepType2["KEY_HASH"] = 0] = "KEY_HASH";
    CardanoDRepType2[CardanoDRepType2["SCRIPT_HASH"] = 1] = "SCRIPT_HASH";
    CardanoDRepType2[CardanoDRepType2["ABSTAIN"] = 2] = "ABSTAIN";
    CardanoDRepType2[CardanoDRepType2["NO_CONFIDENCE"] = 3] = "NO_CONFIDENCE";
  })(CardanoDRepType || (messages$1.CardanoDRepType = CardanoDRepType = {}));
  var CardanoPoolRelayType;
  (function(CardanoPoolRelayType2) {
    CardanoPoolRelayType2[CardanoPoolRelayType2["SINGLE_HOST_IP"] = 0] = "SINGLE_HOST_IP";
    CardanoPoolRelayType2[CardanoPoolRelayType2["SINGLE_HOST_NAME"] = 1] = "SINGLE_HOST_NAME";
    CardanoPoolRelayType2[CardanoPoolRelayType2["MULTIPLE_HOST_NAME"] = 2] = "MULTIPLE_HOST_NAME";
  })(CardanoPoolRelayType || (messages$1.CardanoPoolRelayType = CardanoPoolRelayType = {}));
  var CardanoTxAuxiliaryDataSupplementType;
  (function(CardanoTxAuxiliaryDataSupplementType2) {
    CardanoTxAuxiliaryDataSupplementType2[CardanoTxAuxiliaryDataSupplementType2["NONE"] = 0] = "NONE";
    CardanoTxAuxiliaryDataSupplementType2[CardanoTxAuxiliaryDataSupplementType2["CVOTE_REGISTRATION_SIGNATURE"] = 1] = "CVOTE_REGISTRATION_SIGNATURE";
  })(CardanoTxAuxiliaryDataSupplementType || (messages$1.CardanoTxAuxiliaryDataSupplementType = CardanoTxAuxiliaryDataSupplementType = {}));
  var CardanoCVoteRegistrationFormat;
  (function(CardanoCVoteRegistrationFormat2) {
    CardanoCVoteRegistrationFormat2[CardanoCVoteRegistrationFormat2["CIP15"] = 0] = "CIP15";
    CardanoCVoteRegistrationFormat2[CardanoCVoteRegistrationFormat2["CIP36"] = 1] = "CIP36";
  })(CardanoCVoteRegistrationFormat || (messages$1.CardanoCVoteRegistrationFormat = CardanoCVoteRegistrationFormat = {}));
  var CardanoTxSigningMode;
  (function(CardanoTxSigningMode2) {
    CardanoTxSigningMode2[CardanoTxSigningMode2["ORDINARY_TRANSACTION"] = 0] = "ORDINARY_TRANSACTION";
    CardanoTxSigningMode2[CardanoTxSigningMode2["POOL_REGISTRATION_AS_OWNER"] = 1] = "POOL_REGISTRATION_AS_OWNER";
    CardanoTxSigningMode2[CardanoTxSigningMode2["MULTISIG_TRANSACTION"] = 2] = "MULTISIG_TRANSACTION";
    CardanoTxSigningMode2[CardanoTxSigningMode2["PLUTUS_TRANSACTION"] = 3] = "PLUTUS_TRANSACTION";
  })(CardanoTxSigningMode || (messages$1.CardanoTxSigningMode = CardanoTxSigningMode = {}));
  var CardanoTxWitnessType;
  (function(CardanoTxWitnessType2) {
    CardanoTxWitnessType2[CardanoTxWitnessType2["BYRON_WITNESS"] = 0] = "BYRON_WITNESS";
    CardanoTxWitnessType2[CardanoTxWitnessType2["SHELLEY_WITNESS"] = 1] = "SHELLEY_WITNESS";
  })(CardanoTxWitnessType || (messages$1.CardanoTxWitnessType = CardanoTxWitnessType = {}));
  var Enum_FailureType;
  (function(Enum_FailureType2) {
    Enum_FailureType2[Enum_FailureType2["Failure_UnexpectedMessage"] = 1] = "Failure_UnexpectedMessage";
    Enum_FailureType2[Enum_FailureType2["Failure_ButtonExpected"] = 2] = "Failure_ButtonExpected";
    Enum_FailureType2[Enum_FailureType2["Failure_DataError"] = 3] = "Failure_DataError";
    Enum_FailureType2[Enum_FailureType2["Failure_ActionCancelled"] = 4] = "Failure_ActionCancelled";
    Enum_FailureType2[Enum_FailureType2["Failure_PinExpected"] = 5] = "Failure_PinExpected";
    Enum_FailureType2[Enum_FailureType2["Failure_PinCancelled"] = 6] = "Failure_PinCancelled";
    Enum_FailureType2[Enum_FailureType2["Failure_PinInvalid"] = 7] = "Failure_PinInvalid";
    Enum_FailureType2[Enum_FailureType2["Failure_InvalidSignature"] = 8] = "Failure_InvalidSignature";
    Enum_FailureType2[Enum_FailureType2["Failure_ProcessError"] = 9] = "Failure_ProcessError";
    Enum_FailureType2[Enum_FailureType2["Failure_NotEnoughFunds"] = 10] = "Failure_NotEnoughFunds";
    Enum_FailureType2[Enum_FailureType2["Failure_NotInitialized"] = 11] = "Failure_NotInitialized";
    Enum_FailureType2[Enum_FailureType2["Failure_PinMismatch"] = 12] = "Failure_PinMismatch";
    Enum_FailureType2[Enum_FailureType2["Failure_WipeCodeMismatch"] = 13] = "Failure_WipeCodeMismatch";
    Enum_FailureType2[Enum_FailureType2["Failure_InvalidSession"] = 14] = "Failure_InvalidSession";
    Enum_FailureType2[Enum_FailureType2["Failure_Busy"] = 15] = "Failure_Busy";
    Enum_FailureType2[Enum_FailureType2["Failure_ThpUnallocatedSession"] = 16] = "Failure_ThpUnallocatedSession";
    Enum_FailureType2[Enum_FailureType2["Failure_InvalidProtocol"] = 17] = "Failure_InvalidProtocol";
    Enum_FailureType2[Enum_FailureType2["Failure_BufferError"] = 18] = "Failure_BufferError";
    Enum_FailureType2[Enum_FailureType2["Failure_FirmwareError"] = 99] = "Failure_FirmwareError";
  })(Enum_FailureType || (messages$1.Enum_FailureType = Enum_FailureType = {}));
  var Enum_ButtonRequestType;
  (function(Enum_ButtonRequestType2) {
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Other"] = 1] = "ButtonRequest_Other";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_FeeOverThreshold"] = 2] = "ButtonRequest_FeeOverThreshold";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ConfirmOutput"] = 3] = "ButtonRequest_ConfirmOutput";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ResetDevice"] = 4] = "ButtonRequest_ResetDevice";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ConfirmWord"] = 5] = "ButtonRequest_ConfirmWord";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_WipeDevice"] = 6] = "ButtonRequest_WipeDevice";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ProtectCall"] = 7] = "ButtonRequest_ProtectCall";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_SignTx"] = 8] = "ButtonRequest_SignTx";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_FirmwareCheck"] = 9] = "ButtonRequest_FirmwareCheck";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Address"] = 10] = "ButtonRequest_Address";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PublicKey"] = 11] = "ButtonRequest_PublicKey";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_MnemonicWordCount"] = 12] = "ButtonRequest_MnemonicWordCount";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_MnemonicInput"] = 13] = "ButtonRequest_MnemonicInput";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["_Deprecated_ButtonRequest_PassphraseType"] = 14] = "_Deprecated_ButtonRequest_PassphraseType";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_UnknownDerivationPath"] = 15] = "ButtonRequest_UnknownDerivationPath";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_RecoveryHomepage"] = 16] = "ButtonRequest_RecoveryHomepage";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Success"] = 17] = "ButtonRequest_Success";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Warning"] = 18] = "ButtonRequest_Warning";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PassphraseEntry"] = 19] = "ButtonRequest_PassphraseEntry";
    Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PinEntry"] = 20] = "ButtonRequest_PinEntry";
  })(Enum_ButtonRequestType || (messages$1.Enum_ButtonRequestType = Enum_ButtonRequestType = {}));
  var Enum_PinMatrixRequestType;
  (function(Enum_PinMatrixRequestType2) {
    Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_Current"] = 1] = "PinMatrixRequestType_Current";
    Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_NewFirst"] = 2] = "PinMatrixRequestType_NewFirst";
    Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_NewSecond"] = 3] = "PinMatrixRequestType_NewSecond";
    Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_WipeCodeFirst"] = 4] = "PinMatrixRequestType_WipeCodeFirst";
    Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_WipeCodeSecond"] = 5] = "PinMatrixRequestType_WipeCodeSecond";
  })(Enum_PinMatrixRequestType || (messages$1.Enum_PinMatrixRequestType = Enum_PinMatrixRequestType = {}));
  var DebugButton;
  (function(DebugButton2) {
    DebugButton2[DebugButton2["NO"] = 0] = "NO";
    DebugButton2[DebugButton2["YES"] = 1] = "YES";
    DebugButton2[DebugButton2["INFO"] = 2] = "INFO";
  })(DebugButton || (messages$1.DebugButton = DebugButton = {}));
  var DebugPhysicalButton;
  (function(DebugPhysicalButton2) {
    DebugPhysicalButton2[DebugPhysicalButton2["LEFT_BTN"] = 0] = "LEFT_BTN";
    DebugPhysicalButton2[DebugPhysicalButton2["MIDDLE_BTN"] = 1] = "MIDDLE_BTN";
    DebugPhysicalButton2[DebugPhysicalButton2["RIGHT_BTN"] = 2] = "RIGHT_BTN";
  })(DebugPhysicalButton || (messages$1.DebugPhysicalButton = DebugPhysicalButton = {}));
  var DebugTouchEventType;
  (function(DebugTouchEventType2) {
    DebugTouchEventType2[DebugTouchEventType2["TOUCH_FULL_CLICK"] = 0] = "TOUCH_FULL_CLICK";
    DebugTouchEventType2[DebugTouchEventType2["TOUCH_START"] = 1] = "TOUCH_START";
    DebugTouchEventType2[DebugTouchEventType2["TOUCH_END"] = 2] = "TOUCH_END";
  })(DebugTouchEventType || (messages$1.DebugTouchEventType = DebugTouchEventType = {}));
  var DebugWaitType;
  (function(DebugWaitType2) {
    DebugWaitType2[DebugWaitType2["IMMEDIATE"] = 0] = "IMMEDIATE";
    DebugWaitType2[DebugWaitType2["NEXT_LAYOUT"] = 1] = "NEXT_LAYOUT";
    DebugWaitType2[DebugWaitType2["CURRENT_LAYOUT"] = 2] = "CURRENT_LAYOUT";
  })(DebugWaitType || (messages$1.DebugWaitType = DebugWaitType = {}));
  var DefinitionType;
  (function(DefinitionType2) {
    DefinitionType2[DefinitionType2["ETHEREUM_NETWORK"] = 0] = "ETHEREUM_NETWORK";
    DefinitionType2[DefinitionType2["ETHEREUM_TOKEN"] = 1] = "ETHEREUM_TOKEN";
    DefinitionType2[DefinitionType2["SOLANA_TOKEN"] = 2] = "SOLANA_TOKEN";
  })(DefinitionType || (messages$1.DefinitionType = DefinitionType = {}));
  var EthereumDataType;
  (function(EthereumDataType2) {
    EthereumDataType2[EthereumDataType2["UINT"] = 1] = "UINT";
    EthereumDataType2[EthereumDataType2["INT"] = 2] = "INT";
    EthereumDataType2[EthereumDataType2["BYTES"] = 3] = "BYTES";
    EthereumDataType2[EthereumDataType2["STRING"] = 4] = "STRING";
    EthereumDataType2[EthereumDataType2["BOOL"] = 5] = "BOOL";
    EthereumDataType2[EthereumDataType2["ADDRESS"] = 6] = "ADDRESS";
    EthereumDataType2[EthereumDataType2["ARRAY"] = 7] = "ARRAY";
    EthereumDataType2[EthereumDataType2["STRUCT"] = 8] = "STRUCT";
  })(EthereumDataType || (messages$1.EthereumDataType = EthereumDataType = {}));
  var Enum_BackupType;
  (function(Enum_BackupType2) {
    Enum_BackupType2[Enum_BackupType2["Bip39"] = 0] = "Bip39";
    Enum_BackupType2[Enum_BackupType2["Slip39_Basic"] = 1] = "Slip39_Basic";
    Enum_BackupType2[Enum_BackupType2["Slip39_Advanced"] = 2] = "Slip39_Advanced";
    Enum_BackupType2[Enum_BackupType2["Slip39_Single_Extendable"] = 3] = "Slip39_Single_Extendable";
    Enum_BackupType2[Enum_BackupType2["Slip39_Basic_Extendable"] = 4] = "Slip39_Basic_Extendable";
    Enum_BackupType2[Enum_BackupType2["Slip39_Advanced_Extendable"] = 5] = "Slip39_Advanced_Extendable";
  })(Enum_BackupType || (messages$1.Enum_BackupType = Enum_BackupType = {}));
  var Enum_SafetyCheckLevel;
  (function(Enum_SafetyCheckLevel2) {
    Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["Strict"] = 0] = "Strict";
    Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["PromptAlways"] = 1] = "PromptAlways";
    Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["PromptTemporarily"] = 2] = "PromptTemporarily";
  })(Enum_SafetyCheckLevel || (messages$1.Enum_SafetyCheckLevel = Enum_SafetyCheckLevel = {}));
  var Enum_DisplayRotation;
  (function(Enum_DisplayRotation2) {
    Enum_DisplayRotation2[Enum_DisplayRotation2["North"] = 0] = "North";
    Enum_DisplayRotation2[Enum_DisplayRotation2["East"] = 90] = "East";
    Enum_DisplayRotation2[Enum_DisplayRotation2["South"] = 180] = "South";
    Enum_DisplayRotation2[Enum_DisplayRotation2["West"] = 270] = "West";
  })(Enum_DisplayRotation || (messages$1.Enum_DisplayRotation = Enum_DisplayRotation = {}));
  var Enum_HomescreenFormat;
  (function(Enum_HomescreenFormat2) {
    Enum_HomescreenFormat2[Enum_HomescreenFormat2["Toif"] = 1] = "Toif";
    Enum_HomescreenFormat2[Enum_HomescreenFormat2["Jpeg"] = 2] = "Jpeg";
    Enum_HomescreenFormat2[Enum_HomescreenFormat2["ToiG"] = 3] = "ToiG";
  })(Enum_HomescreenFormat || (messages$1.Enum_HomescreenFormat = Enum_HomescreenFormat = {}));
  var Enum_BackupAvailability;
  (function(Enum_BackupAvailability2) {
    Enum_BackupAvailability2[Enum_BackupAvailability2["NotAvailable"] = 0] = "NotAvailable";
    Enum_BackupAvailability2[Enum_BackupAvailability2["Required"] = 1] = "Required";
    Enum_BackupAvailability2[Enum_BackupAvailability2["Available"] = 2] = "Available";
  })(Enum_BackupAvailability || (messages$1.Enum_BackupAvailability = Enum_BackupAvailability = {}));
  var Enum_RecoveryStatus;
  (function(Enum_RecoveryStatus2) {
    Enum_RecoveryStatus2[Enum_RecoveryStatus2["Nothing"] = 0] = "Nothing";
    Enum_RecoveryStatus2[Enum_RecoveryStatus2["Recovery"] = 1] = "Recovery";
    Enum_RecoveryStatus2[Enum_RecoveryStatus2["Backup"] = 2] = "Backup";
  })(Enum_RecoveryStatus || (messages$1.Enum_RecoveryStatus = Enum_RecoveryStatus = {}));
  var Enum_Capability;
  (function(Enum_Capability2) {
    Enum_Capability2[Enum_Capability2["Capability_Bitcoin"] = 1] = "Capability_Bitcoin";
    Enum_Capability2[Enum_Capability2["Capability_Bitcoin_like"] = 2] = "Capability_Bitcoin_like";
    Enum_Capability2[Enum_Capability2["Capability_Binance"] = 3] = "Capability_Binance";
    Enum_Capability2[Enum_Capability2["Capability_Cardano"] = 4] = "Capability_Cardano";
    Enum_Capability2[Enum_Capability2["Capability_Crypto"] = 5] = "Capability_Crypto";
    Enum_Capability2[Enum_Capability2["Capability_EOS"] = 6] = "Capability_EOS";
    Enum_Capability2[Enum_Capability2["Capability_Ethereum"] = 7] = "Capability_Ethereum";
    Enum_Capability2[Enum_Capability2["Capability_Lisk"] = 8] = "Capability_Lisk";
    Enum_Capability2[Enum_Capability2["Capability_Monero"] = 9] = "Capability_Monero";
    Enum_Capability2[Enum_Capability2["Capability_NEM"] = 10] = "Capability_NEM";
    Enum_Capability2[Enum_Capability2["Capability_Ripple"] = 11] = "Capability_Ripple";
    Enum_Capability2[Enum_Capability2["Capability_Stellar"] = 12] = "Capability_Stellar";
    Enum_Capability2[Enum_Capability2["Capability_Tezos"] = 13] = "Capability_Tezos";
    Enum_Capability2[Enum_Capability2["Capability_U2F"] = 14] = "Capability_U2F";
    Enum_Capability2[Enum_Capability2["Capability_Shamir"] = 15] = "Capability_Shamir";
    Enum_Capability2[Enum_Capability2["Capability_ShamirGroups"] = 16] = "Capability_ShamirGroups";
    Enum_Capability2[Enum_Capability2["Capability_PassphraseEntry"] = 17] = "Capability_PassphraseEntry";
    Enum_Capability2[Enum_Capability2["Capability_Solana"] = 18] = "Capability_Solana";
    Enum_Capability2[Enum_Capability2["Capability_Translations"] = 19] = "Capability_Translations";
    Enum_Capability2[Enum_Capability2["Capability_Brightness"] = 20] = "Capability_Brightness";
    Enum_Capability2[Enum_Capability2["Capability_Haptic"] = 21] = "Capability_Haptic";
    Enum_Capability2[Enum_Capability2["Capability_BLE"] = 22] = "Capability_BLE";
    Enum_Capability2[Enum_Capability2["Capability_NFC"] = 23] = "Capability_NFC";
  })(Enum_Capability || (messages$1.Enum_Capability = Enum_Capability = {}));
  var RecoveryDeviceInputMethod;
  (function(RecoveryDeviceInputMethod2) {
    RecoveryDeviceInputMethod2[RecoveryDeviceInputMethod2["ScrambledWords"] = 0] = "ScrambledWords";
    RecoveryDeviceInputMethod2[RecoveryDeviceInputMethod2["Matrix"] = 1] = "Matrix";
  })(RecoveryDeviceInputMethod || (messages$1.RecoveryDeviceInputMethod = RecoveryDeviceInputMethod = {}));
  var Enum_RecoveryType;
  (function(Enum_RecoveryType2) {
    Enum_RecoveryType2[Enum_RecoveryType2["NormalRecovery"] = 0] = "NormalRecovery";
    Enum_RecoveryType2[Enum_RecoveryType2["DryRun"] = 1] = "DryRun";
    Enum_RecoveryType2[Enum_RecoveryType2["UnlockRepeatedBackup"] = 2] = "UnlockRepeatedBackup";
  })(Enum_RecoveryType || (messages$1.Enum_RecoveryType = Enum_RecoveryType = {}));
  var SdProtectOperationType;
  (function(SdProtectOperationType2) {
    SdProtectOperationType2[SdProtectOperationType2["DISABLE"] = 0] = "DISABLE";
    SdProtectOperationType2[SdProtectOperationType2["ENABLE"] = 1] = "ENABLE";
    SdProtectOperationType2[SdProtectOperationType2["REFRESH"] = 2] = "REFRESH";
  })(SdProtectOperationType || (messages$1.SdProtectOperationType = SdProtectOperationType = {}));
  var Enum_WordRequestType;
  (function(Enum_WordRequestType2) {
    Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Plain"] = 0] = "WordRequestType_Plain";
    Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Matrix9"] = 1] = "WordRequestType_Matrix9";
    Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Matrix6"] = 2] = "WordRequestType_Matrix6";
  })(Enum_WordRequestType || (messages$1.Enum_WordRequestType = Enum_WordRequestType = {}));
  var BootCommand;
  (function(BootCommand2) {
    BootCommand2[BootCommand2["STOP_AND_WAIT"] = 0] = "STOP_AND_WAIT";
    BootCommand2[BootCommand2["INSTALL_UPGRADE"] = 1] = "INSTALL_UPGRADE";
  })(BootCommand || (messages$1.BootCommand = BootCommand = {}));
  var MoneroNetworkType;
  (function(MoneroNetworkType2) {
    MoneroNetworkType2[MoneroNetworkType2["MAINNET"] = 0] = "MAINNET";
    MoneroNetworkType2[MoneroNetworkType2["TESTNET"] = 1] = "TESTNET";
    MoneroNetworkType2[MoneroNetworkType2["STAGENET"] = 2] = "STAGENET";
    MoneroNetworkType2[MoneroNetworkType2["FAKECHAIN"] = 3] = "FAKECHAIN";
  })(MoneroNetworkType || (messages$1.MoneroNetworkType = MoneroNetworkType = {}));
  var NEMMosaicLevy;
  (function(NEMMosaicLevy2) {
    NEMMosaicLevy2[NEMMosaicLevy2["MosaicLevy_Absolute"] = 1] = "MosaicLevy_Absolute";
    NEMMosaicLevy2[NEMMosaicLevy2["MosaicLevy_Percentile"] = 2] = "MosaicLevy_Percentile";
  })(NEMMosaicLevy || (messages$1.NEMMosaicLevy = NEMMosaicLevy = {}));
  var NEMSupplyChangeType;
  (function(NEMSupplyChangeType2) {
    NEMSupplyChangeType2[NEMSupplyChangeType2["SupplyChange_Increase"] = 1] = "SupplyChange_Increase";
    NEMSupplyChangeType2[NEMSupplyChangeType2["SupplyChange_Decrease"] = 2] = "SupplyChange_Decrease";
  })(NEMSupplyChangeType || (messages$1.NEMSupplyChangeType = NEMSupplyChangeType = {}));
  var NEMModificationType;
  (function(NEMModificationType2) {
    NEMModificationType2[NEMModificationType2["CosignatoryModification_Add"] = 1] = "CosignatoryModification_Add";
    NEMModificationType2[NEMModificationType2["CosignatoryModification_Delete"] = 2] = "CosignatoryModification_Delete";
  })(NEMModificationType || (messages$1.NEMModificationType = NEMModificationType = {}));
  var NEMImportanceTransferMode;
  (function(NEMImportanceTransferMode2) {
    NEMImportanceTransferMode2[NEMImportanceTransferMode2["ImportanceTransfer_Activate"] = 1] = "ImportanceTransfer_Activate";
    NEMImportanceTransferMode2[NEMImportanceTransferMode2["ImportanceTransfer_Deactivate"] = 2] = "ImportanceTransfer_Deactivate";
  })(NEMImportanceTransferMode || (messages$1.NEMImportanceTransferMode = NEMImportanceTransferMode = {}));
  var StellarAssetType;
  (function(StellarAssetType2) {
    StellarAssetType2[StellarAssetType2["NATIVE"] = 0] = "NATIVE";
    StellarAssetType2[StellarAssetType2["ALPHANUM4"] = 1] = "ALPHANUM4";
    StellarAssetType2[StellarAssetType2["ALPHANUM12"] = 2] = "ALPHANUM12";
  })(StellarAssetType || (messages$1.StellarAssetType = StellarAssetType = {}));
  var StellarMemoType;
  (function(StellarMemoType2) {
    StellarMemoType2[StellarMemoType2["NONE"] = 0] = "NONE";
    StellarMemoType2[StellarMemoType2["TEXT"] = 1] = "TEXT";
    StellarMemoType2[StellarMemoType2["ID"] = 2] = "ID";
    StellarMemoType2[StellarMemoType2["HASH"] = 3] = "HASH";
    StellarMemoType2[StellarMemoType2["RETURN"] = 4] = "RETURN";
  })(StellarMemoType || (messages$1.StellarMemoType = StellarMemoType = {}));
  var StellarSignerType;
  (function(StellarSignerType2) {
    StellarSignerType2[StellarSignerType2["ACCOUNT"] = 0] = "ACCOUNT";
    StellarSignerType2[StellarSignerType2["PRE_AUTH"] = 1] = "PRE_AUTH";
    StellarSignerType2[StellarSignerType2["HASH"] = 2] = "HASH";
  })(StellarSignerType || (messages$1.StellarSignerType = StellarSignerType = {}));
  var TezosContractType;
  (function(TezosContractType2) {
    TezosContractType2[TezosContractType2["Implicit"] = 0] = "Implicit";
    TezosContractType2[TezosContractType2["Originated"] = 1] = "Originated";
  })(TezosContractType || (messages$1.TezosContractType = TezosContractType = {}));
  var TezosBallotType;
  (function(TezosBallotType2) {
    TezosBallotType2[TezosBallotType2["Yay"] = 0] = "Yay";
    TezosBallotType2[TezosBallotType2["Nay"] = 1] = "Nay";
    TezosBallotType2[TezosBallotType2["Pass"] = 2] = "Pass";
  })(TezosBallotType || (messages$1.TezosBallotType = TezosBallotType = {}));
  return messages$1;
}
var loadDefinitions = {};
var hasRequiredLoadDefinitions;
function requireLoadDefinitions() {
  if (hasRequiredLoadDefinitions) return loadDefinitions;
  hasRequiredLoadDefinitions = 1;
  Object.defineProperty(loadDefinitions, "__esModule", {
    value: true
  });
  loadDefinitions.loadDefinitions = void 0;
  const loadDefinitions$1 = async (messages2, packageName, packageLoader) => {
    try {
      const pkg2 = messages2.lookup(packageName);
      if (pkg2) {
        return;
      }
    } catch {
    }
    let enumType;
    try {
      enumType = messages2.lookupEnum("MessageType");
    } catch {
    }
    const packageMessages = await packageLoader();
    const pkg = messages2.define(packageName, packageMessages);
    let packageEnumType;
    try {
      packageEnumType = pkg.lookupEnum("MessageType");
    } catch {
    }
    if (enumType && packageEnumType) {
      try {
        Object.keys(packageEnumType.values).forEach((key) => {
          enumType.add(key, packageEnumType.values[key]);
        });
        pkg.remove(packageEnumType);
      } catch (e) {
        messages2.remove(pkg);
        throw e;
      }
    }
  };
  loadDefinitions.loadDefinitions = loadDefinitions$1;
  return loadDefinitions;
}
var messagesSchema = {};
var hasRequiredMessagesSchema;
function requireMessagesSchema() {
  if (hasRequiredMessagesSchema) return messagesSchema;
  hasRequiredMessagesSchema = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.PrevOutput = exports$12.PrevInput = exports$12.PrevTx = exports$12.TxOutput = exports$12.TxOutputType = exports$12.ChangeOutputScriptType = exports$12.TxOutputBinType = exports$12.TxInput = exports$12.TxInputType = exports$12.InternalInputScriptType = exports$12.TxRequest = exports$12.TxRequestSerializedType = exports$12.TxRequestDetailsType = exports$12.RequestType = exports$12.EnumEnum_RequestType = exports$12.Enum_RequestType = exports$12.SignTx = exports$12.CoinJoinRequest = exports$12.VerifyMessage = exports$12.MessageSignature = exports$12.SignMessage = exports$12.OwnershipId = exports$12.GetOwnershipId = exports$12.Address = exports$12.GetAddress = exports$12.PublicKey = exports$12.GetPublicKey = exports$12.MultisigRedeemScriptType = exports$12.HDNodePathType = exports$12.HDNodeType = exports$12.EnumMultisigPubkeysOrder = exports$12.MultisigPubkeysOrder = exports$12.EnumAmountUnit = exports$12.AmountUnit = exports$12.PaymentRequest = exports$12.PaymentRequestMemo = exports$12.TextDetailsMemo = exports$12.CoinPurchaseMemo = exports$12.RefundMemo = exports$12.TextMemo = exports$12.EnumDecredStakingSpendType = exports$12.DecredStakingSpendType = exports$12.OutputScriptType = exports$12.EnumEnum_OutputScriptType = exports$12.Enum_OutputScriptType = exports$12.InputScriptType = exports$12.EnumEnum_InputScriptType = exports$12.Enum_InputScriptType = exports$12.EnumDeviceModelInternal = exports$12.DeviceModelInternal = void 0;
    exports$12.CardanoAddressParametersType = exports$12.CardanoNativeScriptHash = exports$12.CardanoGetNativeScriptHash = exports$12.CardanoNativeScript = exports$12.CardanoBlockchainPointerType = exports$12.EnumCardanoTxWitnessType = exports$12.CardanoTxWitnessType = exports$12.EnumCardanoTxSigningMode = exports$12.CardanoTxSigningMode = exports$12.EnumCardanoCVoteRegistrationFormat = exports$12.CardanoCVoteRegistrationFormat = exports$12.EnumCardanoTxAuxiliaryDataSupplementType = exports$12.CardanoTxAuxiliaryDataSupplementType = exports$12.EnumCardanoPoolRelayType = exports$12.CardanoPoolRelayType = exports$12.EnumCardanoDRepType = exports$12.CardanoDRepType = exports$12.EnumCardanoCertificateType = exports$12.CardanoCertificateType = exports$12.EnumCardanoTxOutputSerializationFormat = exports$12.CardanoTxOutputSerializationFormat = exports$12.EnumCardanoNativeScriptHashDisplayFormat = exports$12.CardanoNativeScriptHashDisplayFormat = exports$12.EnumCardanoNativeScriptType = exports$12.CardanoNativeScriptType = exports$12.EnumCardanoAddressType = exports$12.CardanoAddressType = exports$12.EnumCardanoDerivationType = exports$12.CardanoDerivationType = exports$12.ProdTestT1 = exports$12.FirmwareUpload = exports$12.FirmwareRequest = exports$12.FirmwareErase = exports$12.BleUnpair = exports$12.AuthorizeCoinJoin = exports$12.OwnershipProof = exports$12.GetOwnershipProof = exports$12.TxAckPrevExtraData = exports$12.TxAckPrevExtraDataWrapper = exports$12.TxAckPrevOutput = exports$12.TxAckPrevOutputWrapper = exports$12.TxAckPrevInput = exports$12.TxAckPrevInputWrapper = exports$12.TxAckPrevMeta = exports$12.TxAckOutput = exports$12.TxAckOutputWrapper = exports$12.TxAckInput = exports$12.TxAckInputWrapper = exports$12.TxAck = exports$12.TxAckResponse = void 0;
    exports$12.PinMatrixRequest = exports$12.PinMatrixRequestType = exports$12.EnumEnum_PinMatrixRequestType = exports$12.Enum_PinMatrixRequestType = exports$12.ButtonAck = exports$12.ButtonRequest = exports$12.ButtonRequestType = exports$12.EnumEnum_ButtonRequestType = exports$12.Enum_ButtonRequestType = exports$12.Failure = exports$12.FailureType = exports$12.EnumEnum_FailureType = exports$12.Enum_FailureType = exports$12.Success = exports$12.CardanoMessageSignature = exports$12.CardanoMessageDataResponse = exports$12.CardanoMessageDataRequest = exports$12.CardanoSignMessageInit = exports$12.CardanoSignTxFinished = exports$12.CardanoTxBodyHash = exports$12.CardanoTxHostAck = exports$12.CardanoTxWitnessResponse = exports$12.CardanoTxWitnessRequest = exports$12.CardanoTxAuxiliaryDataSupplement = exports$12.CardanoTxItemAck = exports$12.CardanoTxReferenceInput = exports$12.CardanoTxRequiredSigner = exports$12.CardanoTxCollateralInput = exports$12.CardanoTxMint = exports$12.CardanoTxAuxiliaryData = exports$12.CardanoCVoteRegistrationParametersType = exports$12.CardanoCVoteRegistrationDelegation = exports$12.CardanoTxWithdrawal = exports$12.CardanoTxCertificate = exports$12.CardanoDRep = exports$12.CardanoPoolParametersType = exports$12.CardanoPoolMetadataType = exports$12.CardanoPoolRelayParameters = exports$12.CardanoPoolOwner = exports$12.CardanoTxReferenceScriptChunk = exports$12.CardanoTxInlineDatumChunk = exports$12.CardanoToken = exports$12.CardanoAssetGroup = exports$12.CardanoTxOutput = exports$12.CardanoTxInput = exports$12.CardanoSignTxInit = exports$12.CardanoPublicKey = exports$12.CardanoGetPublicKey = exports$12.CardanoAddress = exports$12.CardanoGetAddress = void 0;
    exports$12.EosActionBuyRam = exports$12.EosActionRefund = exports$12.EosActionUndelegate = exports$12.EosActionDelegate = exports$12.EosActionTransfer = exports$12.EosActionCommon = exports$12.EosAuthorization = exports$12.EosAuthorizationWait = exports$12.EosAuthorizationAccount = exports$12.EosAuthorizationKey = exports$12.EosPermissionLevel = exports$12.EosAsset = exports$12.EosTxActionRequest = exports$12.EosSignTx = exports$12.EosTxHeader = exports$12.EosPublicKey = exports$12.EosGetPublicKey = exports$12.SolanaTokenInfo = exports$12.EthereumTokenInfo = exports$12.EthereumNetworkInfo = exports$12.EnumDefinitionType = exports$12.DefinitionType = exports$12.DebugLinkGcInfo = exports$12.DebugLinkGcInfoItem = exports$12.DebugLinkGetGcInfo = exports$12.DebugLinkOptigaSetSecMax = exports$12.DebugLinkResetDebugEvents = exports$12.DebugLinkPairingInfo = exports$12.DebugLinkGetPairingInfo = exports$12.EnumDebugWaitType = exports$12.DebugWaitType = exports$12.EnumDebugTouchEventType = exports$12.DebugTouchEventType = exports$12.EnumDebugPhysicalButton = exports$12.DebugPhysicalButton = exports$12.EnumDebugButton = exports$12.DebugButton = exports$12.PaymentNotification = exports$12.ECDHSessionKey = exports$12.GetECDHSessionKey = exports$12.SignedIdentity = exports$12.SignIdentity = exports$12.IdentityType = exports$12.CipheredKeyValue = exports$12.CipherKeyValue = exports$12.Deprecated_PassphraseStateAck = exports$12.Deprecated_PassphraseStateRequest = exports$12.PassphraseAck = exports$12.PassphraseRequest = exports$12.PinMatrixAck = void 0;
    exports$12.DisplayRotation = exports$12.EnumEnum_DisplayRotation = exports$12.Enum_DisplayRotation = exports$12.SafetyCheckLevel = exports$12.EnumEnum_SafetyCheckLevel = exports$12.Enum_SafetyCheckLevel = exports$12.BackupType = exports$12.EnumEnum_BackupType = exports$12.Enum_BackupType = exports$12.EvoluDelegatedIdentityKey = exports$12.EvoluGetDelegatedIdentityKey = exports$12.EvoluRegistrationRequest = exports$12.EvoluSignRegistrationRequest = exports$12.EvoluNode = exports$12.EvoluGetNode = exports$12.EthereumTypedDataSignature = exports$12.EthereumSignTypedHash = exports$12.EthereumVerifyMessage = exports$12.EthereumMessageSignature = exports$12.EthereumSignMessage = exports$12.EthereumTxAck = exports$12.EthereumTxRequest = exports$12.EthereumSignTxEIP1559 = exports$12.EthereumAccessList = exports$12.EthereumSignTx = exports$12.EthereumAddress = exports$12.EthereumGetAddress = exports$12.EthereumPublicKey = exports$12.EthereumGetPublicKey = exports$12.EthereumTypedDataValueAck = exports$12.EthereumTypedDataValueRequest = exports$12.EthereumTypedDataStructAck = exports$12.EthereumStructMember = exports$12.EthereumFieldType = exports$12.EnumEthereumDataType = exports$12.EthereumDataType = exports$12.EthereumTypedDataStructRequest = exports$12.EthereumSignTypedData = exports$12.EthereumDefinitions = exports$12.EosSignedTx = exports$12.EosTxActionAck = exports$12.EosActionUnknown = exports$12.EosActionNewAccount = exports$12.EosActionUnlinkAuth = exports$12.EosActionLinkAuth = exports$12.EosActionDeleteAuth = exports$12.EosActionUpdateAuth = exports$12.EosActionVoteProducer = exports$12.EosActionSellRam = exports$12.EosActionBuyRamBytes = void 0;
    exports$12.EntropyCheckReady = exports$12.EntropyAck = exports$12.EntropyRequest = exports$12.BackupDevice = exports$12.Slip39Group = exports$12.ResetDevice = exports$12.LoadDevice = exports$12.WipeDevice = exports$12.AuthenticityProof = exports$12.AuthenticateDevice = exports$12.FirmwareHash = exports$12.GetFirmwareHash = exports$12.Entropy = exports$12.GetEntropy = exports$12.Cancel = exports$12.Ping = exports$12.SdProtect = exports$12.EnumSdProtectOperationType = exports$12.SdProtectOperationType = exports$12.ChangeWipeCode = exports$12.ChangePin = exports$12.ApplyFlags = exports$12.DataChunkAck = exports$12.DataChunkRequest = exports$12.ChangeLanguage = exports$12.ApplySettings = exports$12.EndSession = exports$12.SetBusy = exports$12.LockDevice = exports$12.Features = exports$12.RecoveryDevice = exports$12.RecoveryType = exports$12.EnumEnum_RecoveryType = exports$12.Enum_RecoveryType = exports$12.EnumRecoveryDeviceInputMethod = exports$12.RecoveryDeviceInputMethod = exports$12.Capability = exports$12.EnumEnum_Capability = exports$12.Enum_Capability = exports$12.RecoveryStatus = exports$12.EnumEnum_RecoveryStatus = exports$12.Enum_RecoveryStatus = exports$12.BackupAvailability = exports$12.EnumEnum_BackupAvailability = exports$12.Enum_BackupAvailability = exports$12.GetFeatures = exports$12.Initialize = exports$12.HomescreenFormat = exports$12.EnumEnum_HomescreenFormat = exports$12.Enum_HomescreenFormat = void 0;
    exports$12.MoneroRingCtSig = exports$12.MoneroTransactionAllOutSetRequest = exports$12.MoneroTransactionSetOutputAck = exports$12.MoneroTransactionSetOutputRequest = exports$12.MoneroTransactionAllInputsSetAck = exports$12.MoneroTransactionAllInputsSetRequest = exports$12.MoneroTransactionInputViniAck = exports$12.MoneroTransactionInputViniRequest = exports$12.MoneroTransactionSetInputAck = exports$12.MoneroTransactionSetInputRequest = exports$12.MoneroTransactionInitAck = exports$12.MoneroTransactionInitRequest = exports$12.MoneroTransactionData = exports$12.MoneroWatchKey = exports$12.MoneroGetWatchKey = exports$12.MoneroAddress = exports$12.MoneroGetAddress = exports$12.MoneroTransactionRsigData = exports$12.MoneroTransactionDestinationEntry = exports$12.MoneroAccountPublicAddress = exports$12.MoneroTransactionSourceEntry = exports$12.MoneroMultisigKLRki = exports$12.MoneroOutputEntry = exports$12.MoneroRctKeyPublic = exports$12.EnumMoneroNetworkType = exports$12.MoneroNetworkType = exports$12.SerialNumber = exports$12.GetSerialNumber = exports$12.SetBrightness = exports$12.UnlockBootloader = exports$12.ShowDeviceTutorial = exports$12.UnlockedPathRequest = exports$12.UnlockPath = exports$12.Nonce = exports$12.GetNonce = exports$12.RebootToBootloader = exports$12.EnumBootCommand = exports$12.BootCommand = exports$12.CancelAuthorization = exports$12.PreauthorizedRequest = exports$12.DoPreauthorized = exports$12.NextU2FCounter = exports$12.GetNextU2FCounter = exports$12.SetU2FCounter = exports$12.WordAck = exports$12.WordRequest = exports$12.WordRequestType = exports$12.EnumEnum_WordRequestType = exports$12.Enum_WordRequestType = exports$12.EntropyCheckContinue = void 0;
    exports$12.RippleAddress = exports$12.RippleGetAddress = exports$12.NEMDecryptedMessage = exports$12.NEMDecryptMessage = exports$12.NEMSignedTx = exports$12.NEMSignTx = exports$12.NEMImportanceTransfer = exports$12.EnumNEMImportanceTransferMode = exports$12.NEMImportanceTransferMode = exports$12.NEMAggregateModification = exports$12.NEMCosignatoryModification = exports$12.EnumNEMModificationType = exports$12.NEMModificationType = exports$12.NEMMosaicSupplyChange = exports$12.EnumNEMSupplyChangeType = exports$12.NEMSupplyChangeType = exports$12.NEMMosaicCreation = exports$12.NEMMosaicDefinition = exports$12.EnumNEMMosaicLevy = exports$12.NEMMosaicLevy = exports$12.NEMProvisionNamespace = exports$12.NEMTransfer = exports$12.NEMMosaic = exports$12.NEMTransactionCommon = exports$12.NEMAddress = exports$12.NEMGetAddress = exports$12.DebugMoneroDiagAck = exports$12.DebugMoneroDiagRequest = exports$12.MoneroLiveRefreshFinalAck = exports$12.MoneroLiveRefreshFinalRequest = exports$12.MoneroLiveRefreshStepAck = exports$12.MoneroLiveRefreshStepRequest = exports$12.MoneroLiveRefreshStartAck = exports$12.MoneroLiveRefreshStartRequest = exports$12.MoneroGetTxKeyAck = exports$12.MoneroGetTxKeyRequest = exports$12.MoneroKeyImageSyncFinalAck = exports$12.MoneroKeyImageSyncFinalRequest = exports$12.MoneroKeyImageSyncStepAck = exports$12.MoneroExportedKeyImage = exports$12.MoneroKeyImageSyncStepRequest = exports$12.MoneroTransferDetails = exports$12.MoneroKeyImageExportInitAck = exports$12.MoneroKeyImageExportInitRequest = exports$12.MoneroSubAddressIndicesList = exports$12.MoneroTransactionFinalAck = exports$12.MoneroTransactionFinalRequest = exports$12.MoneroTransactionSignInputAck = exports$12.MoneroTransactionSignInputRequest = exports$12.MoneroTransactionAllOutSetAck = void 0;
    exports$12.TezosDelegationOp = exports$12.TezosOriginationOp = exports$12.TezosTransactionOp = exports$12.TezosParametersManager = exports$12.TezosManagerTransfer = exports$12.TezosRevealOp = exports$12.TezosContractID = exports$12.EnumTezosContractType = exports$12.TezosContractType = exports$12.TezosPublicKey = exports$12.TezosGetPublicKey = exports$12.TezosAddress = exports$12.TezosGetAddress = exports$12.StellarSignedTx = exports$12.StellarClaimClaimableBalanceOp = exports$12.StellarBumpSequenceOp = exports$12.StellarManageDataOp = exports$12.StellarAccountMergeOp = exports$12.StellarAllowTrustOp = exports$12.StellarChangeTrustOp = exports$12.StellarSetOptionsOp = exports$12.EnumStellarSignerType = exports$12.StellarSignerType = exports$12.StellarCreatePassiveSellOfferOp = exports$12.StellarManageBuyOfferOp = exports$12.StellarManageSellOfferOp = exports$12.StellarPathPaymentStrictSendOp = exports$12.StellarPathPaymentStrictReceiveOp = exports$12.StellarCreateAccountOp = exports$12.StellarPaymentOp = exports$12.StellarTxOpRequest = exports$12.StellarSignTx = exports$12.EnumStellarMemoType = exports$12.StellarMemoType = exports$12.StellarAddress = exports$12.StellarGetAddress = exports$12.StellarAsset = exports$12.EnumStellarAssetType = exports$12.StellarAssetType = exports$12.SolanaTxSignature = exports$12.SolanaSignTx = exports$12.SolanaTxAdditionalInfo = exports$12.SolanaTxTokenAccountInfo = exports$12.SolanaAddress = exports$12.SolanaGetAddress = exports$12.SolanaPublicKey = exports$12.SolanaGetPublicKey = exports$12.RippleSignedTx = exports$12.RippleSignTx = exports$12.RipplePayment = void 0;
    exports$12.MessageType = exports$12.TronAddress = exports$12.TronGetAddress = exports$12.TezosSignedTx = exports$12.TezosSignTx = exports$12.TezosBallotOp = exports$12.EnumTezosBallotType = exports$12.TezosBallotType = exports$12.TezosProposalOp = void 0;
    const schema_utils_1 = requireLib$3();
    var DeviceModelInternal;
    (function(DeviceModelInternal2) {
      DeviceModelInternal2["T1B1"] = "T1B1";
      DeviceModelInternal2["T2T1"] = "T2T1";
      DeviceModelInternal2["T2B1"] = "T2B1";
      DeviceModelInternal2["T3B1"] = "T3B1";
      DeviceModelInternal2["T3T1"] = "T3T1";
      DeviceModelInternal2["T3W1"] = "T3W1";
      DeviceModelInternal2["UNKNOWN"] = "UNKNOWN";
    })(DeviceModelInternal || (exports$12.DeviceModelInternal = DeviceModelInternal = {}));
    exports$12.EnumDeviceModelInternal = schema_utils_1.Type.Enum(DeviceModelInternal);
    var Enum_InputScriptType;
    (function(Enum_InputScriptType2) {
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDADDRESS"] = 0] = "SPENDADDRESS";
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDMULTISIG"] = 1] = "SPENDMULTISIG";
      Enum_InputScriptType2[Enum_InputScriptType2["EXTERNAL"] = 2] = "EXTERNAL";
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDWITNESS"] = 3] = "SPENDWITNESS";
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDP2SHWITNESS"] = 4] = "SPENDP2SHWITNESS";
      Enum_InputScriptType2[Enum_InputScriptType2["SPENDTAPROOT"] = 5] = "SPENDTAPROOT";
    })(Enum_InputScriptType || (exports$12.Enum_InputScriptType = Enum_InputScriptType = {}));
    exports$12.EnumEnum_InputScriptType = schema_utils_1.Type.Enum(Enum_InputScriptType);
    exports$12.InputScriptType = schema_utils_1.Type.KeyOfEnum(Enum_InputScriptType, {
      $id: "InputScriptType"
    });
    var Enum_OutputScriptType;
    (function(Enum_OutputScriptType2) {
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOADDRESS"] = 0] = "PAYTOADDRESS";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOSCRIPTHASH"] = 1] = "PAYTOSCRIPTHASH";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOMULTISIG"] = 2] = "PAYTOMULTISIG";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOOPRETURN"] = 3] = "PAYTOOPRETURN";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOWITNESS"] = 4] = "PAYTOWITNESS";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOP2SHWITNESS"] = 5] = "PAYTOP2SHWITNESS";
      Enum_OutputScriptType2[Enum_OutputScriptType2["PAYTOTAPROOT"] = 6] = "PAYTOTAPROOT";
    })(Enum_OutputScriptType || (exports$12.Enum_OutputScriptType = Enum_OutputScriptType = {}));
    exports$12.EnumEnum_OutputScriptType = schema_utils_1.Type.Enum(Enum_OutputScriptType);
    exports$12.OutputScriptType = schema_utils_1.Type.KeyOfEnum(Enum_OutputScriptType, {
      $id: "OutputScriptType"
    });
    var DecredStakingSpendType;
    (function(DecredStakingSpendType2) {
      DecredStakingSpendType2[DecredStakingSpendType2["SSGen"] = 0] = "SSGen";
      DecredStakingSpendType2[DecredStakingSpendType2["SSRTX"] = 1] = "SSRTX";
    })(DecredStakingSpendType || (exports$12.DecredStakingSpendType = DecredStakingSpendType = {}));
    exports$12.EnumDecredStakingSpendType = schema_utils_1.Type.Enum(DecredStakingSpendType);
    exports$12.TextMemo = schema_utils_1.Type.Object({
      text: schema_utils_1.Type.String()
    }, {
      $id: "TextMemo"
    });
    exports$12.RefundMemo = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      mac: schema_utils_1.Type.String()
    }, {
      $id: "RefundMemo"
    });
    exports$12.CoinPurchaseMemo = schema_utils_1.Type.Object({
      coin_type: schema_utils_1.Type.Number(),
      amount: schema_utils_1.Type.String(),
      address: schema_utils_1.Type.String(),
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      mac: schema_utils_1.Type.String()
    }, {
      $id: "CoinPurchaseMemo"
    });
    exports$12.TextDetailsMemo = schema_utils_1.Type.Object({
      title: schema_utils_1.Type.String(),
      text: schema_utils_1.Type.String()
    }, {
      $id: "TextDetailsMemo"
    });
    exports$12.PaymentRequestMemo = schema_utils_1.Type.Object({
      text_memo: schema_utils_1.Type.Optional(exports$12.TextMemo),
      refund_memo: schema_utils_1.Type.Optional(exports$12.RefundMemo),
      coin_purchase_memo: schema_utils_1.Type.Optional(exports$12.CoinPurchaseMemo),
      text_details_memo: schema_utils_1.Type.Optional(exports$12.TextDetailsMemo)
    }, {
      $id: "PaymentRequestMemo"
    });
    exports$12.PaymentRequest = schema_utils_1.Type.Object({
      nonce: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      recipient_name: schema_utils_1.Type.String(),
      memos: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.PaymentRequestMemo)),
      amount: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      signature: schema_utils_1.Type.String()
    }, {
      $id: "PaymentRequest"
    });
    var AmountUnit;
    (function(AmountUnit2) {
      AmountUnit2[AmountUnit2["BITCOIN"] = 0] = "BITCOIN";
      AmountUnit2[AmountUnit2["MILLIBITCOIN"] = 1] = "MILLIBITCOIN";
      AmountUnit2[AmountUnit2["MICROBITCOIN"] = 2] = "MICROBITCOIN";
      AmountUnit2[AmountUnit2["SATOSHI"] = 3] = "SATOSHI";
    })(AmountUnit || (exports$12.AmountUnit = AmountUnit = {}));
    exports$12.EnumAmountUnit = schema_utils_1.Type.Enum(AmountUnit);
    var MultisigPubkeysOrder;
    (function(MultisigPubkeysOrder2) {
      MultisigPubkeysOrder2[MultisigPubkeysOrder2["PRESERVED"] = 0] = "PRESERVED";
      MultisigPubkeysOrder2[MultisigPubkeysOrder2["LEXICOGRAPHIC"] = 1] = "LEXICOGRAPHIC";
    })(MultisigPubkeysOrder || (exports$12.MultisigPubkeysOrder = MultisigPubkeysOrder = {}));
    exports$12.EnumMultisigPubkeysOrder = schema_utils_1.Type.Enum(MultisigPubkeysOrder);
    exports$12.HDNodeType = schema_utils_1.Type.Object({
      depth: schema_utils_1.Type.Number(),
      fingerprint: schema_utils_1.Type.Number(),
      child_num: schema_utils_1.Type.Number(),
      chain_code: schema_utils_1.Type.String(),
      private_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      public_key: schema_utils_1.Type.String()
    }, {
      $id: "HDNodeType"
    });
    exports$12.HDNodePathType = schema_utils_1.Type.Object({
      node: schema_utils_1.Type.Union([exports$12.HDNodeType, schema_utils_1.Type.String()]),
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number())
    }, {
      $id: "HDNodePathType"
    });
    exports$12.MultisigRedeemScriptType = schema_utils_1.Type.Object({
      pubkeys: schema_utils_1.Type.Array(exports$12.HDNodePathType),
      signatures: schema_utils_1.Type.Array(schema_utils_1.Type.String()),
      m: schema_utils_1.Type.Number(),
      nodes: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.HDNodeType)),
      address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      pubkeys_order: schema_utils_1.Type.Optional(exports$12.EnumMultisigPubkeysOrder)
    }, {
      $id: "MultisigRedeemScriptType"
    });
    exports$12.GetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      ecdsa_curve_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_type: schema_utils_1.Type.Optional(exports$12.InputScriptType),
      ignore_xpub_magic: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "GetPublicKey"
    });
    exports$12.PublicKey = schema_utils_1.Type.Object({
      node: exports$12.HDNodeType,
      xpub: schema_utils_1.Type.String(),
      root_fingerprint: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      descriptor: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "PublicKey"
    });
    exports$12.GetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      multisig: schema_utils_1.Type.Optional(exports$12.MultisigRedeemScriptType),
      script_type: schema_utils_1.Type.Optional(exports$12.InputScriptType),
      ignore_xpub_magic: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "GetAddress"
    });
    exports$12.Address = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "Address"
    });
    exports$12.GetOwnershipId = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      multisig: schema_utils_1.Type.Optional(exports$12.MultisigRedeemScriptType),
      script_type: schema_utils_1.Type.Optional(exports$12.InputScriptType)
    }, {
      $id: "GetOwnershipId"
    });
    exports$12.OwnershipId = schema_utils_1.Type.Object({
      ownership_id: schema_utils_1.Type.String()
    }, {
      $id: "OwnershipId"
    });
    exports$12.SignMessage = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      message: schema_utils_1.Type.String(),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_type: schema_utils_1.Type.Optional(exports$12.InputScriptType),
      no_script_type: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "SignMessage"
    });
    exports$12.MessageSignature = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    }, {
      $id: "MessageSignature"
    });
    exports$12.VerifyMessage = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String(),
      message: schema_utils_1.Type.String(),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "VerifyMessage"
    });
    exports$12.CoinJoinRequest = schema_utils_1.Type.Object({
      fee_rate: schema_utils_1.Type.Number(),
      no_fee_threshold: schema_utils_1.Type.Number(),
      min_registrable_amount: schema_utils_1.Type.Number(),
      mask_public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      signature: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "CoinJoinRequest"
    });
    exports$12.SignTx = schema_utils_1.Type.Object({
      outputs_count: schema_utils_1.Type.Number(),
      inputs_count: schema_utils_1.Type.Number(),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      version: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      lock_time: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      expiry: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      overwintered: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      version_group_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      timestamp: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      branch_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      amount_unit: schema_utils_1.Type.Optional(exports$12.EnumAmountUnit),
      decred_staking_ticket: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      serialize: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      coinjoin_request: schema_utils_1.Type.Optional(exports$12.CoinJoinRequest),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "SignTx"
    });
    var Enum_RequestType;
    (function(Enum_RequestType2) {
      Enum_RequestType2[Enum_RequestType2["TXINPUT"] = 0] = "TXINPUT";
      Enum_RequestType2[Enum_RequestType2["TXOUTPUT"] = 1] = "TXOUTPUT";
      Enum_RequestType2[Enum_RequestType2["TXMETA"] = 2] = "TXMETA";
      Enum_RequestType2[Enum_RequestType2["TXFINISHED"] = 3] = "TXFINISHED";
      Enum_RequestType2[Enum_RequestType2["TXEXTRADATA"] = 4] = "TXEXTRADATA";
      Enum_RequestType2[Enum_RequestType2["TXORIGINPUT"] = 5] = "TXORIGINPUT";
      Enum_RequestType2[Enum_RequestType2["TXORIGOUTPUT"] = 6] = "TXORIGOUTPUT";
      Enum_RequestType2[Enum_RequestType2["TXPAYMENTREQ"] = 7] = "TXPAYMENTREQ";
    })(Enum_RequestType || (exports$12.Enum_RequestType = Enum_RequestType = {}));
    exports$12.EnumEnum_RequestType = schema_utils_1.Type.Enum(Enum_RequestType);
    exports$12.RequestType = schema_utils_1.Type.KeyOfEnum(Enum_RequestType, {
      $id: "RequestType"
    });
    exports$12.TxRequestDetailsType = schema_utils_1.Type.Object({
      request_index: schema_utils_1.Type.Number(),
      tx_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      extra_data_len: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      extra_data_offset: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "TxRequestDetailsType"
    });
    exports$12.TxRequestSerializedType = schema_utils_1.Type.Object({
      signature_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      signature: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      serialized_tx: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "TxRequestSerializedType"
    });
    exports$12.TxRequest = schema_utils_1.Type.Object({
      request_type: exports$12.RequestType,
      details: exports$12.TxRequestDetailsType,
      serialized: schema_utils_1.Type.Optional(exports$12.TxRequestSerializedType)
    }, {
      $id: "TxRequest"
    });
    exports$12.InternalInputScriptType = schema_utils_1.Type.Exclude(exports$12.InputScriptType, schema_utils_1.Type.Literal("EXTERNAL"), {
      $id: "InternalInputScriptType"
    });
    const CommonTxInputType = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number(),
      amount: schema_utils_1.Type.Uint(),
      sequence: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      multisig: schema_utils_1.Type.Optional(exports$12.MultisigRedeemScriptType),
      decred_tree: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      orig_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      orig_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      decred_staking_spend: schema_utils_1.Type.Optional(exports$12.EnumDecredStakingSpendType),
      script_pubkey: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      coinjoin_flags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      script_sig: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      witness: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ownership_proof: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      commitment_data: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "CommonTxInputType"
    });
    exports$12.TxInputType = schema_utils_1.Type.Union([schema_utils_1.Type.Intersect([CommonTxInputType, schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      script_type: schema_utils_1.Type.Optional(exports$12.InternalInputScriptType)
    })]), schema_utils_1.Type.Intersect([CommonTxInputType, schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      script_type: schema_utils_1.Type.Literal("EXTERNAL"),
      script_pubkey: schema_utils_1.Type.String()
    })])], {
      $id: "TxInputType"
    });
    exports$12.TxInput = (0, schema_utils_1.CloneType)(exports$12.TxInputType, {
      $id: "TxInput"
    });
    exports$12.TxOutputBinType = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.Uint(),
      script_pubkey: schema_utils_1.Type.String(),
      decred_script_version: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "TxOutputBinType"
    });
    exports$12.ChangeOutputScriptType = schema_utils_1.Type.Exclude(exports$12.OutputScriptType, schema_utils_1.Type.Literal("PAYTOOPRETURN"), {
      $id: "ChangeOutputScriptType"
    });
    exports$12.TxOutputType = schema_utils_1.Type.Union([schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      script_type: schema_utils_1.Type.Literal("PAYTOADDRESS"),
      amount: schema_utils_1.Type.Uint(),
      multisig: schema_utils_1.Type.Optional(exports$12.MultisigRedeemScriptType),
      orig_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      orig_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      payment_req_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }), schema_utils_1.Type.Object({
      address: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      script_type: schema_utils_1.Type.Optional(exports$12.ChangeOutputScriptType),
      amount: schema_utils_1.Type.Uint(),
      multisig: schema_utils_1.Type.Optional(exports$12.MultisigRedeemScriptType),
      orig_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      orig_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      payment_req_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }), schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      script_type: schema_utils_1.Type.Optional(exports$12.ChangeOutputScriptType),
      amount: schema_utils_1.Type.Uint(),
      multisig: schema_utils_1.Type.Optional(exports$12.MultisigRedeemScriptType),
      orig_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      orig_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      payment_req_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }), schema_utils_1.Type.Object({
      address: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      amount: schema_utils_1.Type.Union([schema_utils_1.Type.Literal("0"), schema_utils_1.Type.Literal(0)]),
      op_return_data: schema_utils_1.Type.String(),
      script_type: schema_utils_1.Type.Literal("PAYTOOPRETURN"),
      orig_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      orig_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      payment_req_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    })], {
      $id: "TxOutputType"
    });
    exports$12.TxOutput = (0, schema_utils_1.CloneType)(exports$12.TxOutputType, {
      $id: "TxOutput"
    });
    exports$12.PrevTx = schema_utils_1.Type.Object({
      version: schema_utils_1.Type.Number(),
      lock_time: schema_utils_1.Type.Number(),
      inputs_count: schema_utils_1.Type.Number(),
      outputs_count: schema_utils_1.Type.Number(),
      extra_data_len: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      expiry: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      version_group_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      timestamp: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      branch_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "PrevTx"
    });
    exports$12.PrevInput = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number(),
      script_sig: schema_utils_1.Type.String(),
      sequence: schema_utils_1.Type.Number(),
      decred_tree: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "PrevInput"
    });
    exports$12.PrevOutput = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.Uint(),
      script_pubkey: schema_utils_1.Type.String(),
      decred_script_version: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "PrevOutput"
    });
    exports$12.TxAckResponse = schema_utils_1.Type.Union([schema_utils_1.Type.Object({
      inputs: schema_utils_1.Type.Array(schema_utils_1.Type.Union([exports$12.TxInputType, exports$12.PrevInput]))
    }), schema_utils_1.Type.Object({
      bin_outputs: schema_utils_1.Type.Array(exports$12.TxOutputBinType)
    }), schema_utils_1.Type.Object({
      outputs: schema_utils_1.Type.Array(exports$12.TxOutputType)
    }), schema_utils_1.Type.Object({
      extra_data: schema_utils_1.Type.String()
    }), schema_utils_1.Type.Object({
      version: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      lock_time: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      inputs_cnt: schema_utils_1.Type.Number(),
      outputs_cnt: schema_utils_1.Type.Number(),
      extra_data: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      extra_data_len: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      timestamp: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      version_group_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      expiry: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      branch_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    })], {
      $id: "TxAckResponse"
    });
    exports$12.TxAck = schema_utils_1.Type.Object({
      tx: exports$12.TxAckResponse
    }, {
      $id: "TxAck"
    });
    exports$12.TxAckInputWrapper = schema_utils_1.Type.Object({
      input: exports$12.TxInput
    }, {
      $id: "TxAckInputWrapper"
    });
    exports$12.TxAckInput = schema_utils_1.Type.Object({
      tx: exports$12.TxAckInputWrapper
    }, {
      $id: "TxAckInput"
    });
    exports$12.TxAckOutputWrapper = schema_utils_1.Type.Object({
      output: exports$12.TxOutput
    }, {
      $id: "TxAckOutputWrapper"
    });
    exports$12.TxAckOutput = schema_utils_1.Type.Object({
      tx: exports$12.TxAckOutputWrapper
    }, {
      $id: "TxAckOutput"
    });
    exports$12.TxAckPrevMeta = schema_utils_1.Type.Object({
      tx: exports$12.PrevTx
    }, {
      $id: "TxAckPrevMeta"
    });
    exports$12.TxAckPrevInputWrapper = schema_utils_1.Type.Object({
      input: exports$12.PrevInput
    }, {
      $id: "TxAckPrevInputWrapper"
    });
    exports$12.TxAckPrevInput = schema_utils_1.Type.Object({
      tx: exports$12.TxAckPrevInputWrapper
    }, {
      $id: "TxAckPrevInput"
    });
    exports$12.TxAckPrevOutputWrapper = schema_utils_1.Type.Object({
      output: exports$12.PrevOutput
    }, {
      $id: "TxAckPrevOutputWrapper"
    });
    exports$12.TxAckPrevOutput = schema_utils_1.Type.Object({
      tx: exports$12.TxAckPrevOutputWrapper
    }, {
      $id: "TxAckPrevOutput"
    });
    exports$12.TxAckPrevExtraDataWrapper = schema_utils_1.Type.Object({
      extra_data_chunk: schema_utils_1.Type.String()
    }, {
      $id: "TxAckPrevExtraDataWrapper"
    });
    exports$12.TxAckPrevExtraData = schema_utils_1.Type.Object({
      tx: exports$12.TxAckPrevExtraDataWrapper
    }, {
      $id: "TxAckPrevExtraData"
    });
    exports$12.GetOwnershipProof = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_type: schema_utils_1.Type.Optional(exports$12.InputScriptType),
      multisig: schema_utils_1.Type.Optional(exports$12.MultisigRedeemScriptType),
      user_confirmation: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      ownership_ids: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.String())),
      commitment_data: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "GetOwnershipProof"
    });
    exports$12.OwnershipProof = schema_utils_1.Type.Object({
      ownership_proof: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    }, {
      $id: "OwnershipProof"
    });
    exports$12.AuthorizeCoinJoin = schema_utils_1.Type.Object({
      coordinator: schema_utils_1.Type.String(),
      max_rounds: schema_utils_1.Type.Number(),
      max_coordinator_fee_rate: schema_utils_1.Type.Number(),
      max_fee_per_kvbyte: schema_utils_1.Type.Number(),
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      coin_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_type: schema_utils_1.Type.Optional(exports$12.InputScriptType),
      amount_unit: schema_utils_1.Type.Optional(exports$12.EnumAmountUnit)
    }, {
      $id: "AuthorizeCoinJoin"
    });
    exports$12.BleUnpair = schema_utils_1.Type.Object({
      all: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      addr: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "BleUnpair"
    });
    exports$12.FirmwareErase = schema_utils_1.Type.Object({
      length: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "FirmwareErase"
    });
    exports$12.FirmwareRequest = schema_utils_1.Type.Object({
      offset: schema_utils_1.Type.Number(),
      length: schema_utils_1.Type.Number()
    }, {
      $id: "FirmwareRequest"
    });
    exports$12.FirmwareUpload = schema_utils_1.Type.Object({
      payload: schema_utils_1.Type.Union([schema_utils_1.Type.Buffer(), schema_utils_1.Type.ArrayBuffer()]),
      hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "FirmwareUpload"
    });
    exports$12.ProdTestT1 = schema_utils_1.Type.Object({
      payload: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "ProdTestT1"
    });
    var CardanoDerivationType;
    (function(CardanoDerivationType2) {
      CardanoDerivationType2[CardanoDerivationType2["LEDGER"] = 0] = "LEDGER";
      CardanoDerivationType2[CardanoDerivationType2["ICARUS"] = 1] = "ICARUS";
      CardanoDerivationType2[CardanoDerivationType2["ICARUS_TREZOR"] = 2] = "ICARUS_TREZOR";
    })(CardanoDerivationType || (exports$12.CardanoDerivationType = CardanoDerivationType = {}));
    exports$12.EnumCardanoDerivationType = schema_utils_1.Type.Enum(CardanoDerivationType);
    var CardanoAddressType;
    (function(CardanoAddressType2) {
      CardanoAddressType2[CardanoAddressType2["BASE"] = 0] = "BASE";
      CardanoAddressType2[CardanoAddressType2["BASE_SCRIPT_KEY"] = 1] = "BASE_SCRIPT_KEY";
      CardanoAddressType2[CardanoAddressType2["BASE_KEY_SCRIPT"] = 2] = "BASE_KEY_SCRIPT";
      CardanoAddressType2[CardanoAddressType2["BASE_SCRIPT_SCRIPT"] = 3] = "BASE_SCRIPT_SCRIPT";
      CardanoAddressType2[CardanoAddressType2["POINTER"] = 4] = "POINTER";
      CardanoAddressType2[CardanoAddressType2["POINTER_SCRIPT"] = 5] = "POINTER_SCRIPT";
      CardanoAddressType2[CardanoAddressType2["ENTERPRISE"] = 6] = "ENTERPRISE";
      CardanoAddressType2[CardanoAddressType2["ENTERPRISE_SCRIPT"] = 7] = "ENTERPRISE_SCRIPT";
      CardanoAddressType2[CardanoAddressType2["BYRON"] = 8] = "BYRON";
      CardanoAddressType2[CardanoAddressType2["REWARD"] = 14] = "REWARD";
      CardanoAddressType2[CardanoAddressType2["REWARD_SCRIPT"] = 15] = "REWARD_SCRIPT";
    })(CardanoAddressType || (exports$12.CardanoAddressType = CardanoAddressType = {}));
    exports$12.EnumCardanoAddressType = schema_utils_1.Type.Enum(CardanoAddressType);
    var CardanoNativeScriptType;
    (function(CardanoNativeScriptType2) {
      CardanoNativeScriptType2[CardanoNativeScriptType2["PUB_KEY"] = 0] = "PUB_KEY";
      CardanoNativeScriptType2[CardanoNativeScriptType2["ALL"] = 1] = "ALL";
      CardanoNativeScriptType2[CardanoNativeScriptType2["ANY"] = 2] = "ANY";
      CardanoNativeScriptType2[CardanoNativeScriptType2["N_OF_K"] = 3] = "N_OF_K";
      CardanoNativeScriptType2[CardanoNativeScriptType2["INVALID_BEFORE"] = 4] = "INVALID_BEFORE";
      CardanoNativeScriptType2[CardanoNativeScriptType2["INVALID_HEREAFTER"] = 5] = "INVALID_HEREAFTER";
    })(CardanoNativeScriptType || (exports$12.CardanoNativeScriptType = CardanoNativeScriptType = {}));
    exports$12.EnumCardanoNativeScriptType = schema_utils_1.Type.Enum(CardanoNativeScriptType);
    var CardanoNativeScriptHashDisplayFormat;
    (function(CardanoNativeScriptHashDisplayFormat2) {
      CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["HIDE"] = 0] = "HIDE";
      CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["BECH32"] = 1] = "BECH32";
      CardanoNativeScriptHashDisplayFormat2[CardanoNativeScriptHashDisplayFormat2["POLICY_ID"] = 2] = "POLICY_ID";
    })(CardanoNativeScriptHashDisplayFormat || (exports$12.CardanoNativeScriptHashDisplayFormat = CardanoNativeScriptHashDisplayFormat = {}));
    exports$12.EnumCardanoNativeScriptHashDisplayFormat = schema_utils_1.Type.Enum(CardanoNativeScriptHashDisplayFormat);
    var CardanoTxOutputSerializationFormat;
    (function(CardanoTxOutputSerializationFormat2) {
      CardanoTxOutputSerializationFormat2[CardanoTxOutputSerializationFormat2["ARRAY_LEGACY"] = 0] = "ARRAY_LEGACY";
      CardanoTxOutputSerializationFormat2[CardanoTxOutputSerializationFormat2["MAP_BABBAGE"] = 1] = "MAP_BABBAGE";
    })(CardanoTxOutputSerializationFormat || (exports$12.CardanoTxOutputSerializationFormat = CardanoTxOutputSerializationFormat = {}));
    exports$12.EnumCardanoTxOutputSerializationFormat = schema_utils_1.Type.Enum(CardanoTxOutputSerializationFormat);
    var CardanoCertificateType;
    (function(CardanoCertificateType2) {
      CardanoCertificateType2[CardanoCertificateType2["STAKE_REGISTRATION"] = 0] = "STAKE_REGISTRATION";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_DEREGISTRATION"] = 1] = "STAKE_DEREGISTRATION";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_DELEGATION"] = 2] = "STAKE_DELEGATION";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_POOL_REGISTRATION"] = 3] = "STAKE_POOL_REGISTRATION";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_REGISTRATION_CONWAY"] = 7] = "STAKE_REGISTRATION_CONWAY";
      CardanoCertificateType2[CardanoCertificateType2["STAKE_DEREGISTRATION_CONWAY"] = 8] = "STAKE_DEREGISTRATION_CONWAY";
      CardanoCertificateType2[CardanoCertificateType2["VOTE_DELEGATION"] = 9] = "VOTE_DELEGATION";
    })(CardanoCertificateType || (exports$12.CardanoCertificateType = CardanoCertificateType = {}));
    exports$12.EnumCardanoCertificateType = schema_utils_1.Type.Enum(CardanoCertificateType);
    var CardanoDRepType;
    (function(CardanoDRepType2) {
      CardanoDRepType2[CardanoDRepType2["KEY_HASH"] = 0] = "KEY_HASH";
      CardanoDRepType2[CardanoDRepType2["SCRIPT_HASH"] = 1] = "SCRIPT_HASH";
      CardanoDRepType2[CardanoDRepType2["ABSTAIN"] = 2] = "ABSTAIN";
      CardanoDRepType2[CardanoDRepType2["NO_CONFIDENCE"] = 3] = "NO_CONFIDENCE";
    })(CardanoDRepType || (exports$12.CardanoDRepType = CardanoDRepType = {}));
    exports$12.EnumCardanoDRepType = schema_utils_1.Type.Enum(CardanoDRepType);
    var CardanoPoolRelayType;
    (function(CardanoPoolRelayType2) {
      CardanoPoolRelayType2[CardanoPoolRelayType2["SINGLE_HOST_IP"] = 0] = "SINGLE_HOST_IP";
      CardanoPoolRelayType2[CardanoPoolRelayType2["SINGLE_HOST_NAME"] = 1] = "SINGLE_HOST_NAME";
      CardanoPoolRelayType2[CardanoPoolRelayType2["MULTIPLE_HOST_NAME"] = 2] = "MULTIPLE_HOST_NAME";
    })(CardanoPoolRelayType || (exports$12.CardanoPoolRelayType = CardanoPoolRelayType = {}));
    exports$12.EnumCardanoPoolRelayType = schema_utils_1.Type.Enum(CardanoPoolRelayType);
    var CardanoTxAuxiliaryDataSupplementType;
    (function(CardanoTxAuxiliaryDataSupplementType2) {
      CardanoTxAuxiliaryDataSupplementType2[CardanoTxAuxiliaryDataSupplementType2["NONE"] = 0] = "NONE";
      CardanoTxAuxiliaryDataSupplementType2[CardanoTxAuxiliaryDataSupplementType2["CVOTE_REGISTRATION_SIGNATURE"] = 1] = "CVOTE_REGISTRATION_SIGNATURE";
    })(CardanoTxAuxiliaryDataSupplementType || (exports$12.CardanoTxAuxiliaryDataSupplementType = CardanoTxAuxiliaryDataSupplementType = {}));
    exports$12.EnumCardanoTxAuxiliaryDataSupplementType = schema_utils_1.Type.Enum(CardanoTxAuxiliaryDataSupplementType);
    var CardanoCVoteRegistrationFormat;
    (function(CardanoCVoteRegistrationFormat2) {
      CardanoCVoteRegistrationFormat2[CardanoCVoteRegistrationFormat2["CIP15"] = 0] = "CIP15";
      CardanoCVoteRegistrationFormat2[CardanoCVoteRegistrationFormat2["CIP36"] = 1] = "CIP36";
    })(CardanoCVoteRegistrationFormat || (exports$12.CardanoCVoteRegistrationFormat = CardanoCVoteRegistrationFormat = {}));
    exports$12.EnumCardanoCVoteRegistrationFormat = schema_utils_1.Type.Enum(CardanoCVoteRegistrationFormat);
    var CardanoTxSigningMode;
    (function(CardanoTxSigningMode2) {
      CardanoTxSigningMode2[CardanoTxSigningMode2["ORDINARY_TRANSACTION"] = 0] = "ORDINARY_TRANSACTION";
      CardanoTxSigningMode2[CardanoTxSigningMode2["POOL_REGISTRATION_AS_OWNER"] = 1] = "POOL_REGISTRATION_AS_OWNER";
      CardanoTxSigningMode2[CardanoTxSigningMode2["MULTISIG_TRANSACTION"] = 2] = "MULTISIG_TRANSACTION";
      CardanoTxSigningMode2[CardanoTxSigningMode2["PLUTUS_TRANSACTION"] = 3] = "PLUTUS_TRANSACTION";
    })(CardanoTxSigningMode || (exports$12.CardanoTxSigningMode = CardanoTxSigningMode = {}));
    exports$12.EnumCardanoTxSigningMode = schema_utils_1.Type.Enum(CardanoTxSigningMode);
    var CardanoTxWitnessType;
    (function(CardanoTxWitnessType2) {
      CardanoTxWitnessType2[CardanoTxWitnessType2["BYRON_WITNESS"] = 0] = "BYRON_WITNESS";
      CardanoTxWitnessType2[CardanoTxWitnessType2["SHELLEY_WITNESS"] = 1] = "SHELLEY_WITNESS";
    })(CardanoTxWitnessType || (exports$12.CardanoTxWitnessType = CardanoTxWitnessType = {}));
    exports$12.EnumCardanoTxWitnessType = schema_utils_1.Type.Enum(CardanoTxWitnessType);
    exports$12.CardanoBlockchainPointerType = schema_utils_1.Type.Object({
      block_index: schema_utils_1.Type.Number(),
      tx_index: schema_utils_1.Type.Number(),
      certificate_index: schema_utils_1.Type.Number()
    }, {
      $id: "CardanoBlockchainPointerType"
    });
    exports$12.CardanoNativeScript = schema_utils_1.Type.Recursive((This) => schema_utils_1.Type.Object({
      type: exports$12.EnumCardanoNativeScriptType,
      scripts: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(This)),
      key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      key_path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      required_signatures_count: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      invalid_before: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      invalid_hereafter: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint())
    }), {
      $id: "CardanoNativeScript"
    });
    exports$12.CardanoGetNativeScriptHash = schema_utils_1.Type.Object({
      script: exports$12.CardanoNativeScript,
      display_format: exports$12.EnumCardanoNativeScriptHashDisplayFormat,
      derivation_type: exports$12.EnumCardanoDerivationType
    }, {
      $id: "CardanoGetNativeScriptHash"
    });
    exports$12.CardanoNativeScriptHash = schema_utils_1.Type.Object({
      script_hash: schema_utils_1.Type.String()
    }, {
      $id: "CardanoNativeScriptHash"
    });
    exports$12.CardanoAddressParametersType = schema_utils_1.Type.Object({
      address_type: exports$12.EnumCardanoAddressType,
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      address_n_staking: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      staking_key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      certificate_pointer: schema_utils_1.Type.Optional(exports$12.CardanoBlockchainPointerType),
      script_payment_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_staking_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "CardanoAddressParametersType"
    });
    exports$12.CardanoGetAddress = schema_utils_1.Type.Object({
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      protocol_magic: schema_utils_1.Type.Number(),
      network_id: schema_utils_1.Type.Number(),
      address_parameters: exports$12.CardanoAddressParametersType,
      derivation_type: exports$12.EnumCardanoDerivationType,
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "CardanoGetAddress"
    });
    exports$12.CardanoAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "CardanoAddress"
    });
    exports$12.CardanoGetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      derivation_type: exports$12.EnumCardanoDerivationType
    }, {
      $id: "CardanoGetPublicKey"
    });
    exports$12.CardanoPublicKey = schema_utils_1.Type.Object({
      xpub: schema_utils_1.Type.String(),
      node: exports$12.HDNodeType
    }, {
      $id: "CardanoPublicKey"
    });
    exports$12.CardanoSignTxInit = schema_utils_1.Type.Object({
      signing_mode: exports$12.EnumCardanoTxSigningMode,
      protocol_magic: schema_utils_1.Type.Number(),
      network_id: schema_utils_1.Type.Number(),
      inputs_count: schema_utils_1.Type.Number(),
      outputs_count: schema_utils_1.Type.Number(),
      fee: schema_utils_1.Type.Uint(),
      ttl: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      certificates_count: schema_utils_1.Type.Number(),
      withdrawals_count: schema_utils_1.Type.Number(),
      has_auxiliary_data: schema_utils_1.Type.Boolean(),
      validity_interval_start: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      witness_requests_count: schema_utils_1.Type.Number(),
      minting_asset_groups_count: schema_utils_1.Type.Number(),
      derivation_type: exports$12.EnumCardanoDerivationType,
      include_network_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      script_data_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      collateral_inputs_count: schema_utils_1.Type.Number(),
      required_signers_count: schema_utils_1.Type.Number(),
      has_collateral_return: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      total_collateral: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      reference_inputs_count: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      tag_cbor_sets: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      payment_req: schema_utils_1.Type.Optional(exports$12.PaymentRequest)
    }, {
      $id: "CardanoSignTxInit"
    });
    exports$12.CardanoTxInput = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    }, {
      $id: "CardanoTxInput"
    });
    exports$12.CardanoTxOutput = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      address_parameters: schema_utils_1.Type.Optional(exports$12.CardanoAddressParametersType),
      amount: schema_utils_1.Type.Uint(),
      asset_groups_count: schema_utils_1.Type.Number(),
      datum_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      format: schema_utils_1.Type.Optional(exports$12.EnumCardanoTxOutputSerializationFormat),
      inline_datum_size: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      reference_script_size: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "CardanoTxOutput"
    });
    exports$12.CardanoAssetGroup = schema_utils_1.Type.Object({
      policy_id: schema_utils_1.Type.String(),
      tokens_count: schema_utils_1.Type.Number()
    }, {
      $id: "CardanoAssetGroup"
    });
    exports$12.CardanoToken = schema_utils_1.Type.Object({
      asset_name_bytes: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      mint_amount: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint({
        allowNegative: true
      }))
    }, {
      $id: "CardanoToken"
    });
    exports$12.CardanoTxInlineDatumChunk = schema_utils_1.Type.Object({
      data: schema_utils_1.Type.String()
    }, {
      $id: "CardanoTxInlineDatumChunk"
    });
    exports$12.CardanoTxReferenceScriptChunk = schema_utils_1.Type.Object({
      data: schema_utils_1.Type.String()
    }, {
      $id: "CardanoTxReferenceScriptChunk"
    });
    exports$12.CardanoPoolOwner = schema_utils_1.Type.Object({
      staking_key_path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      staking_key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "CardanoPoolOwner"
    });
    exports$12.CardanoPoolRelayParameters = schema_utils_1.Type.Object({
      type: exports$12.EnumCardanoPoolRelayType,
      ipv4_address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ipv6_address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      host_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      port: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "CardanoPoolRelayParameters"
    });
    exports$12.CardanoPoolMetadataType = schema_utils_1.Type.Object({
      url: schema_utils_1.Type.String(),
      hash: schema_utils_1.Type.String()
    }, {
      $id: "CardanoPoolMetadataType"
    });
    exports$12.CardanoPoolParametersType = schema_utils_1.Type.Object({
      pool_id: schema_utils_1.Type.String(),
      vrf_key_hash: schema_utils_1.Type.String(),
      pledge: schema_utils_1.Type.Uint(),
      cost: schema_utils_1.Type.Uint(),
      margin_numerator: schema_utils_1.Type.Uint(),
      margin_denominator: schema_utils_1.Type.Uint(),
      reward_account: schema_utils_1.Type.String(),
      metadata: schema_utils_1.Type.Optional(exports$12.CardanoPoolMetadataType),
      owners_count: schema_utils_1.Type.Number(),
      relays_count: schema_utils_1.Type.Number()
    }, {
      $id: "CardanoPoolParametersType"
    });
    exports$12.CardanoDRep = schema_utils_1.Type.Object({
      type: exports$12.EnumCardanoDRepType,
      key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "CardanoDRep"
    });
    exports$12.CardanoTxCertificate = schema_utils_1.Type.Object({
      type: exports$12.EnumCardanoCertificateType,
      path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      pool: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      pool_parameters: schema_utils_1.Type.Optional(exports$12.CardanoPoolParametersType),
      script_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      deposit: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      drep: schema_utils_1.Type.Optional(exports$12.CardanoDRep)
    }, {
      $id: "CardanoTxCertificate"
    });
    exports$12.CardanoTxWithdrawal = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      amount: schema_utils_1.Type.Uint(),
      script_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "CardanoTxWithdrawal"
    });
    exports$12.CardanoCVoteRegistrationDelegation = schema_utils_1.Type.Object({
      vote_public_key: schema_utils_1.Type.String(),
      weight: schema_utils_1.Type.Uint()
    }, {
      $id: "CardanoCVoteRegistrationDelegation"
    });
    exports$12.CardanoCVoteRegistrationParametersType = schema_utils_1.Type.Object({
      vote_public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      staking_path: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      payment_address_parameters: schema_utils_1.Type.Optional(exports$12.CardanoAddressParametersType),
      nonce: schema_utils_1.Type.Uint(),
      format: schema_utils_1.Type.Optional(exports$12.EnumCardanoCVoteRegistrationFormat),
      delegations: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.CardanoCVoteRegistrationDelegation)),
      voting_purpose: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      payment_address: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "CardanoCVoteRegistrationParametersType"
    });
    exports$12.CardanoTxAuxiliaryData = schema_utils_1.Type.Object({
      cvote_registration_parameters: schema_utils_1.Type.Optional(exports$12.CardanoCVoteRegistrationParametersType),
      hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "CardanoTxAuxiliaryData"
    });
    exports$12.CardanoTxMint = schema_utils_1.Type.Object({
      asset_groups_count: schema_utils_1.Type.Number()
    }, {
      $id: "CardanoTxMint"
    });
    exports$12.CardanoTxCollateralInput = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    }, {
      $id: "CardanoTxCollateralInput"
    });
    exports$12.CardanoTxRequiredSigner = schema_utils_1.Type.Object({
      key_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      key_path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number()))
    }, {
      $id: "CardanoTxRequiredSigner"
    });
    exports$12.CardanoTxReferenceInput = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    }, {
      $id: "CardanoTxReferenceInput"
    });
    exports$12.CardanoTxItemAck = schema_utils_1.Type.Object({}, {
      $id: "CardanoTxItemAck"
    });
    exports$12.CardanoTxAuxiliaryDataSupplement = schema_utils_1.Type.Object({
      type: exports$12.EnumCardanoTxAuxiliaryDataSupplementType,
      auxiliary_data_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      cvote_registration_signature: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "CardanoTxAuxiliaryDataSupplement"
    });
    exports$12.CardanoTxWitnessRequest = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Array(schema_utils_1.Type.Number())
    }, {
      $id: "CardanoTxWitnessRequest"
    });
    exports$12.CardanoTxWitnessResponse = schema_utils_1.Type.Object({
      type: exports$12.EnumCardanoTxWitnessType,
      pub_key: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String(),
      chain_code: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "CardanoTxWitnessResponse"
    });
    exports$12.CardanoTxHostAck = schema_utils_1.Type.Object({}, {
      $id: "CardanoTxHostAck"
    });
    exports$12.CardanoTxBodyHash = schema_utils_1.Type.Object({
      tx_hash: schema_utils_1.Type.String()
    }, {
      $id: "CardanoTxBodyHash"
    });
    exports$12.CardanoSignTxFinished = schema_utils_1.Type.Object({}, {
      $id: "CardanoSignTxFinished"
    });
    exports$12.CardanoSignMessageInit = schema_utils_1.Type.Object({
      protocol_magic: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      network_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      signing_path: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      payload_size: schema_utils_1.Type.Number(),
      prefer_hex_display: schema_utils_1.Type.Boolean(),
      address_parameters: schema_utils_1.Type.Optional(exports$12.CardanoAddressParametersType),
      derivation_type: exports$12.EnumCardanoDerivationType
    }, {
      $id: "CardanoSignMessageInit"
    });
    exports$12.CardanoMessageDataRequest = schema_utils_1.Type.Object({
      length: schema_utils_1.Type.Number(),
      offset: schema_utils_1.Type.Number()
    }, {
      $id: "CardanoMessageDataRequest"
    });
    exports$12.CardanoMessageDataResponse = schema_utils_1.Type.Object({
      data: schema_utils_1.Type.String()
    }, {
      $id: "CardanoMessageDataResponse"
    });
    exports$12.CardanoMessageSignature = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      address: schema_utils_1.Type.String(),
      pub_key: schema_utils_1.Type.String()
    }, {
      $id: "CardanoMessageSignature"
    });
    exports$12.Success = schema_utils_1.Type.Object({
      message: schema_utils_1.Type.String()
    }, {
      $id: "Success"
    });
    var Enum_FailureType;
    (function(Enum_FailureType2) {
      Enum_FailureType2[Enum_FailureType2["Failure_UnexpectedMessage"] = 1] = "Failure_UnexpectedMessage";
      Enum_FailureType2[Enum_FailureType2["Failure_ButtonExpected"] = 2] = "Failure_ButtonExpected";
      Enum_FailureType2[Enum_FailureType2["Failure_DataError"] = 3] = "Failure_DataError";
      Enum_FailureType2[Enum_FailureType2["Failure_ActionCancelled"] = 4] = "Failure_ActionCancelled";
      Enum_FailureType2[Enum_FailureType2["Failure_PinExpected"] = 5] = "Failure_PinExpected";
      Enum_FailureType2[Enum_FailureType2["Failure_PinCancelled"] = 6] = "Failure_PinCancelled";
      Enum_FailureType2[Enum_FailureType2["Failure_PinInvalid"] = 7] = "Failure_PinInvalid";
      Enum_FailureType2[Enum_FailureType2["Failure_InvalidSignature"] = 8] = "Failure_InvalidSignature";
      Enum_FailureType2[Enum_FailureType2["Failure_ProcessError"] = 9] = "Failure_ProcessError";
      Enum_FailureType2[Enum_FailureType2["Failure_NotEnoughFunds"] = 10] = "Failure_NotEnoughFunds";
      Enum_FailureType2[Enum_FailureType2["Failure_NotInitialized"] = 11] = "Failure_NotInitialized";
      Enum_FailureType2[Enum_FailureType2["Failure_PinMismatch"] = 12] = "Failure_PinMismatch";
      Enum_FailureType2[Enum_FailureType2["Failure_WipeCodeMismatch"] = 13] = "Failure_WipeCodeMismatch";
      Enum_FailureType2[Enum_FailureType2["Failure_InvalidSession"] = 14] = "Failure_InvalidSession";
      Enum_FailureType2[Enum_FailureType2["Failure_Busy"] = 15] = "Failure_Busy";
      Enum_FailureType2[Enum_FailureType2["Failure_ThpUnallocatedSession"] = 16] = "Failure_ThpUnallocatedSession";
      Enum_FailureType2[Enum_FailureType2["Failure_InvalidProtocol"] = 17] = "Failure_InvalidProtocol";
      Enum_FailureType2[Enum_FailureType2["Failure_BufferError"] = 18] = "Failure_BufferError";
      Enum_FailureType2[Enum_FailureType2["Failure_FirmwareError"] = 99] = "Failure_FirmwareError";
    })(Enum_FailureType || (exports$12.Enum_FailureType = Enum_FailureType = {}));
    exports$12.EnumEnum_FailureType = schema_utils_1.Type.Enum(Enum_FailureType);
    exports$12.FailureType = schema_utils_1.Type.KeyOfEnum(Enum_FailureType, {
      $id: "FailureType"
    });
    exports$12.Failure = schema_utils_1.Type.Object({
      code: schema_utils_1.Type.Optional(exports$12.FailureType),
      message: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "Failure"
    });
    var Enum_ButtonRequestType;
    (function(Enum_ButtonRequestType2) {
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Other"] = 1] = "ButtonRequest_Other";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_FeeOverThreshold"] = 2] = "ButtonRequest_FeeOverThreshold";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ConfirmOutput"] = 3] = "ButtonRequest_ConfirmOutput";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ResetDevice"] = 4] = "ButtonRequest_ResetDevice";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ConfirmWord"] = 5] = "ButtonRequest_ConfirmWord";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_WipeDevice"] = 6] = "ButtonRequest_WipeDevice";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_ProtectCall"] = 7] = "ButtonRequest_ProtectCall";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_SignTx"] = 8] = "ButtonRequest_SignTx";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_FirmwareCheck"] = 9] = "ButtonRequest_FirmwareCheck";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Address"] = 10] = "ButtonRequest_Address";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PublicKey"] = 11] = "ButtonRequest_PublicKey";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_MnemonicWordCount"] = 12] = "ButtonRequest_MnemonicWordCount";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_MnemonicInput"] = 13] = "ButtonRequest_MnemonicInput";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["_Deprecated_ButtonRequest_PassphraseType"] = 14] = "_Deprecated_ButtonRequest_PassphraseType";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_UnknownDerivationPath"] = 15] = "ButtonRequest_UnknownDerivationPath";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_RecoveryHomepage"] = 16] = "ButtonRequest_RecoveryHomepage";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Success"] = 17] = "ButtonRequest_Success";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_Warning"] = 18] = "ButtonRequest_Warning";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PassphraseEntry"] = 19] = "ButtonRequest_PassphraseEntry";
      Enum_ButtonRequestType2[Enum_ButtonRequestType2["ButtonRequest_PinEntry"] = 20] = "ButtonRequest_PinEntry";
    })(Enum_ButtonRequestType || (exports$12.Enum_ButtonRequestType = Enum_ButtonRequestType = {}));
    exports$12.EnumEnum_ButtonRequestType = schema_utils_1.Type.Enum(Enum_ButtonRequestType);
    exports$12.ButtonRequestType = schema_utils_1.Type.KeyOfEnum(Enum_ButtonRequestType, {
      $id: "ButtonRequestType"
    });
    exports$12.ButtonRequest = schema_utils_1.Type.Object({
      code: schema_utils_1.Type.Optional(exports$12.ButtonRequestType),
      pages: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      name: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "ButtonRequest"
    });
    exports$12.ButtonAck = schema_utils_1.Type.Object({}, {
      $id: "ButtonAck"
    });
    var Enum_PinMatrixRequestType;
    (function(Enum_PinMatrixRequestType2) {
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_Current"] = 1] = "PinMatrixRequestType_Current";
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_NewFirst"] = 2] = "PinMatrixRequestType_NewFirst";
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_NewSecond"] = 3] = "PinMatrixRequestType_NewSecond";
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_WipeCodeFirst"] = 4] = "PinMatrixRequestType_WipeCodeFirst";
      Enum_PinMatrixRequestType2[Enum_PinMatrixRequestType2["PinMatrixRequestType_WipeCodeSecond"] = 5] = "PinMatrixRequestType_WipeCodeSecond";
    })(Enum_PinMatrixRequestType || (exports$12.Enum_PinMatrixRequestType = Enum_PinMatrixRequestType = {}));
    exports$12.EnumEnum_PinMatrixRequestType = schema_utils_1.Type.Enum(Enum_PinMatrixRequestType);
    exports$12.PinMatrixRequestType = schema_utils_1.Type.KeyOfEnum(Enum_PinMatrixRequestType, {
      $id: "PinMatrixRequestType"
    });
    exports$12.PinMatrixRequest = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Optional(exports$12.PinMatrixRequestType)
    }, {
      $id: "PinMatrixRequest"
    });
    exports$12.PinMatrixAck = schema_utils_1.Type.Object({
      pin: schema_utils_1.Type.String()
    }, {
      $id: "PinMatrixAck"
    });
    exports$12.PassphraseRequest = schema_utils_1.Type.Object({
      _on_device: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "PassphraseRequest"
    });
    exports$12.PassphraseAck = schema_utils_1.Type.Object({
      passphrase: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      _state: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      on_device: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "PassphraseAck"
    });
    exports$12.Deprecated_PassphraseStateRequest = schema_utils_1.Type.Object({
      state: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "Deprecated_PassphraseStateRequest"
    });
    exports$12.Deprecated_PassphraseStateAck = schema_utils_1.Type.Object({}, {
      $id: "Deprecated_PassphraseStateAck"
    });
    exports$12.CipherKeyValue = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      key: schema_utils_1.Type.String(),
      value: schema_utils_1.Type.String(),
      encrypt: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      ask_on_encrypt: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      ask_on_decrypt: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      iv: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "CipherKeyValue"
    });
    exports$12.CipheredKeyValue = schema_utils_1.Type.Object({
      value: schema_utils_1.Type.String()
    }, {
      $id: "CipheredKeyValue"
    });
    exports$12.IdentityType = schema_utils_1.Type.Object({
      proto: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      user: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      host: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      port: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      path: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "IdentityType"
    });
    exports$12.SignIdentity = schema_utils_1.Type.Object({
      identity: exports$12.IdentityType,
      challenge_hidden: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      challenge_visual: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ecdsa_curve_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "SignIdentity"
    });
    exports$12.SignedIdentity = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      public_key: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    }, {
      $id: "SignedIdentity"
    });
    exports$12.GetECDHSessionKey = schema_utils_1.Type.Object({
      identity: exports$12.IdentityType,
      peer_public_key: schema_utils_1.Type.String(),
      ecdsa_curve_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "GetECDHSessionKey"
    });
    exports$12.ECDHSessionKey = schema_utils_1.Type.Object({
      session_key: schema_utils_1.Type.String(),
      public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "ECDHSessionKey"
    });
    exports$12.PaymentNotification = schema_utils_1.Type.Object({
      payment_req: schema_utils_1.Type.Optional(exports$12.PaymentRequest)
    }, {
      $id: "PaymentNotification"
    });
    var DebugButton;
    (function(DebugButton2) {
      DebugButton2[DebugButton2["NO"] = 0] = "NO";
      DebugButton2[DebugButton2["YES"] = 1] = "YES";
      DebugButton2[DebugButton2["INFO"] = 2] = "INFO";
    })(DebugButton || (exports$12.DebugButton = DebugButton = {}));
    exports$12.EnumDebugButton = schema_utils_1.Type.Enum(DebugButton);
    var DebugPhysicalButton;
    (function(DebugPhysicalButton2) {
      DebugPhysicalButton2[DebugPhysicalButton2["LEFT_BTN"] = 0] = "LEFT_BTN";
      DebugPhysicalButton2[DebugPhysicalButton2["MIDDLE_BTN"] = 1] = "MIDDLE_BTN";
      DebugPhysicalButton2[DebugPhysicalButton2["RIGHT_BTN"] = 2] = "RIGHT_BTN";
    })(DebugPhysicalButton || (exports$12.DebugPhysicalButton = DebugPhysicalButton = {}));
    exports$12.EnumDebugPhysicalButton = schema_utils_1.Type.Enum(DebugPhysicalButton);
    var DebugTouchEventType;
    (function(DebugTouchEventType2) {
      DebugTouchEventType2[DebugTouchEventType2["TOUCH_FULL_CLICK"] = 0] = "TOUCH_FULL_CLICK";
      DebugTouchEventType2[DebugTouchEventType2["TOUCH_START"] = 1] = "TOUCH_START";
      DebugTouchEventType2[DebugTouchEventType2["TOUCH_END"] = 2] = "TOUCH_END";
    })(DebugTouchEventType || (exports$12.DebugTouchEventType = DebugTouchEventType = {}));
    exports$12.EnumDebugTouchEventType = schema_utils_1.Type.Enum(DebugTouchEventType);
    var DebugWaitType;
    (function(DebugWaitType2) {
      DebugWaitType2[DebugWaitType2["IMMEDIATE"] = 0] = "IMMEDIATE";
      DebugWaitType2[DebugWaitType2["NEXT_LAYOUT"] = 1] = "NEXT_LAYOUT";
      DebugWaitType2[DebugWaitType2["CURRENT_LAYOUT"] = 2] = "CURRENT_LAYOUT";
    })(DebugWaitType || (exports$12.DebugWaitType = DebugWaitType = {}));
    exports$12.EnumDebugWaitType = schema_utils_1.Type.Enum(DebugWaitType);
    exports$12.DebugLinkGetPairingInfo = schema_utils_1.Type.Object({
      channel_id: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      handshake_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      nfc_secret_host: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "DebugLinkGetPairingInfo"
    });
    exports$12.DebugLinkPairingInfo = schema_utils_1.Type.Object({
      channel_id: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      handshake_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      code_entry_code: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      code_qr_code: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      nfc_secret_trezor: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "DebugLinkPairingInfo"
    });
    exports$12.DebugLinkResetDebugEvents = schema_utils_1.Type.Object({}, {
      $id: "DebugLinkResetDebugEvents"
    });
    exports$12.DebugLinkOptigaSetSecMax = schema_utils_1.Type.Object({}, {
      $id: "DebugLinkOptigaSetSecMax"
    });
    exports$12.DebugLinkGetGcInfo = schema_utils_1.Type.Object({}, {
      $id: "DebugLinkGetGcInfo"
    });
    exports$12.DebugLinkGcInfoItem = schema_utils_1.Type.Object({
      name: schema_utils_1.Type.String(),
      value: schema_utils_1.Type.Number()
    }, {
      $id: "DebugLinkGcInfoItem"
    });
    exports$12.DebugLinkGcInfo = schema_utils_1.Type.Object({
      items: schema_utils_1.Type.Array(exports$12.DebugLinkGcInfoItem)
    }, {
      $id: "DebugLinkGcInfo"
    });
    var DefinitionType;
    (function(DefinitionType2) {
      DefinitionType2[DefinitionType2["ETHEREUM_NETWORK"] = 0] = "ETHEREUM_NETWORK";
      DefinitionType2[DefinitionType2["ETHEREUM_TOKEN"] = 1] = "ETHEREUM_TOKEN";
      DefinitionType2[DefinitionType2["SOLANA_TOKEN"] = 2] = "SOLANA_TOKEN";
    })(DefinitionType || (exports$12.DefinitionType = DefinitionType = {}));
    exports$12.EnumDefinitionType = schema_utils_1.Type.Enum(DefinitionType);
    exports$12.EthereumNetworkInfo = schema_utils_1.Type.Object({
      chain_id: schema_utils_1.Type.Number(),
      symbol: schema_utils_1.Type.String(),
      slip44: schema_utils_1.Type.Number(),
      name: schema_utils_1.Type.String()
    }, {
      $id: "EthereumNetworkInfo"
    });
    exports$12.EthereumTokenInfo = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      chain_id: schema_utils_1.Type.Number(),
      symbol: schema_utils_1.Type.String(),
      decimals: schema_utils_1.Type.Number(),
      name: schema_utils_1.Type.String()
    }, {
      $id: "EthereumTokenInfo"
    });
    exports$12.SolanaTokenInfo = schema_utils_1.Type.Object({
      mint: schema_utils_1.Type.String(),
      symbol: schema_utils_1.Type.String(),
      name: schema_utils_1.Type.String()
    }, {
      $id: "SolanaTokenInfo"
    });
    exports$12.EosGetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "EosGetPublicKey"
    });
    exports$12.EosPublicKey = schema_utils_1.Type.Object({
      wif_public_key: schema_utils_1.Type.String(),
      raw_public_key: schema_utils_1.Type.String()
    }, {
      $id: "EosPublicKey"
    });
    exports$12.EosTxHeader = schema_utils_1.Type.Object({
      expiration: schema_utils_1.Type.Number(),
      ref_block_num: schema_utils_1.Type.Number(),
      ref_block_prefix: schema_utils_1.Type.Number(),
      max_net_usage_words: schema_utils_1.Type.Number(),
      max_cpu_usage_ms: schema_utils_1.Type.Number(),
      delay_sec: schema_utils_1.Type.Number()
    }, {
      $id: "EosTxHeader"
    });
    exports$12.EosSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      chain_id: schema_utils_1.Type.String(),
      header: exports$12.EosTxHeader,
      num_actions: schema_utils_1.Type.Number(),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "EosSignTx"
    });
    exports$12.EosTxActionRequest = schema_utils_1.Type.Object({
      data_size: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "EosTxActionRequest"
    });
    exports$12.EosAsset = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.Uint(),
      symbol: schema_utils_1.Type.String()
    }, {
      $id: "EosAsset"
    });
    exports$12.EosPermissionLevel = schema_utils_1.Type.Object({
      actor: schema_utils_1.Type.String(),
      permission: schema_utils_1.Type.String()
    }, {
      $id: "EosPermissionLevel"
    });
    exports$12.EosAuthorizationKey = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      key: schema_utils_1.Type.String(),
      address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      weight: schema_utils_1.Type.Number()
    }, {
      $id: "EosAuthorizationKey"
    });
    exports$12.EosAuthorizationAccount = schema_utils_1.Type.Object({
      account: exports$12.EosPermissionLevel,
      weight: schema_utils_1.Type.Number()
    }, {
      $id: "EosAuthorizationAccount"
    });
    exports$12.EosAuthorizationWait = schema_utils_1.Type.Object({
      wait_sec: schema_utils_1.Type.Number(),
      weight: schema_utils_1.Type.Number()
    }, {
      $id: "EosAuthorizationWait"
    });
    exports$12.EosAuthorization = schema_utils_1.Type.Object({
      threshold: schema_utils_1.Type.Number(),
      keys: schema_utils_1.Type.Array(exports$12.EosAuthorizationKey),
      accounts: schema_utils_1.Type.Array(exports$12.EosAuthorizationAccount),
      waits: schema_utils_1.Type.Array(exports$12.EosAuthorizationWait)
    }, {
      $id: "EosAuthorization"
    });
    exports$12.EosActionCommon = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      name: schema_utils_1.Type.String(),
      authorization: schema_utils_1.Type.Array(exports$12.EosPermissionLevel)
    }, {
      $id: "EosActionCommon"
    });
    exports$12.EosActionTransfer = schema_utils_1.Type.Object({
      sender: schema_utils_1.Type.String(),
      receiver: schema_utils_1.Type.String(),
      quantity: exports$12.EosAsset,
      memo: schema_utils_1.Type.String()
    }, {
      $id: "EosActionTransfer"
    });
    exports$12.EosActionDelegate = schema_utils_1.Type.Object({
      sender: schema_utils_1.Type.String(),
      receiver: schema_utils_1.Type.String(),
      net_quantity: exports$12.EosAsset,
      cpu_quantity: exports$12.EosAsset,
      transfer: schema_utils_1.Type.Boolean()
    }, {
      $id: "EosActionDelegate"
    });
    exports$12.EosActionUndelegate = schema_utils_1.Type.Object({
      sender: schema_utils_1.Type.String(),
      receiver: schema_utils_1.Type.String(),
      net_quantity: exports$12.EosAsset,
      cpu_quantity: exports$12.EosAsset
    }, {
      $id: "EosActionUndelegate"
    });
    exports$12.EosActionRefund = schema_utils_1.Type.Object({
      owner: schema_utils_1.Type.String()
    }, {
      $id: "EosActionRefund"
    });
    exports$12.EosActionBuyRam = schema_utils_1.Type.Object({
      payer: schema_utils_1.Type.String(),
      receiver: schema_utils_1.Type.String(),
      quantity: exports$12.EosAsset
    }, {
      $id: "EosActionBuyRam"
    });
    exports$12.EosActionBuyRamBytes = schema_utils_1.Type.Object({
      payer: schema_utils_1.Type.String(),
      receiver: schema_utils_1.Type.String(),
      bytes: schema_utils_1.Type.Number()
    }, {
      $id: "EosActionBuyRamBytes"
    });
    exports$12.EosActionSellRam = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      bytes: schema_utils_1.Type.Number()
    }, {
      $id: "EosActionSellRam"
    });
    exports$12.EosActionVoteProducer = schema_utils_1.Type.Object({
      voter: schema_utils_1.Type.String(),
      proxy: schema_utils_1.Type.String(),
      producers: schema_utils_1.Type.Array(schema_utils_1.Type.String())
    }, {
      $id: "EosActionVoteProducer"
    });
    exports$12.EosActionUpdateAuth = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      permission: schema_utils_1.Type.String(),
      parent: schema_utils_1.Type.String(),
      auth: exports$12.EosAuthorization
    }, {
      $id: "EosActionUpdateAuth"
    });
    exports$12.EosActionDeleteAuth = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      permission: schema_utils_1.Type.String()
    }, {
      $id: "EosActionDeleteAuth"
    });
    exports$12.EosActionLinkAuth = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      code: schema_utils_1.Type.String(),
      type: schema_utils_1.Type.String(),
      requirement: schema_utils_1.Type.String()
    }, {
      $id: "EosActionLinkAuth"
    });
    exports$12.EosActionUnlinkAuth = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      code: schema_utils_1.Type.String(),
      type: schema_utils_1.Type.String()
    }, {
      $id: "EosActionUnlinkAuth"
    });
    exports$12.EosActionNewAccount = schema_utils_1.Type.Object({
      creator: schema_utils_1.Type.String(),
      name: schema_utils_1.Type.String(),
      owner: exports$12.EosAuthorization,
      active: exports$12.EosAuthorization
    }, {
      $id: "EosActionNewAccount"
    });
    exports$12.EosActionUnknown = schema_utils_1.Type.Object({
      data_size: schema_utils_1.Type.Number(),
      data_chunk: schema_utils_1.Type.String()
    }, {
      $id: "EosActionUnknown"
    });
    exports$12.EosTxActionAck = schema_utils_1.Type.Object({
      common: exports$12.EosActionCommon,
      transfer: schema_utils_1.Type.Optional(exports$12.EosActionTransfer),
      delegate: schema_utils_1.Type.Optional(exports$12.EosActionDelegate),
      undelegate: schema_utils_1.Type.Optional(exports$12.EosActionUndelegate),
      refund: schema_utils_1.Type.Optional(exports$12.EosActionRefund),
      buy_ram: schema_utils_1.Type.Optional(exports$12.EosActionBuyRam),
      buy_ram_bytes: schema_utils_1.Type.Optional(exports$12.EosActionBuyRamBytes),
      sell_ram: schema_utils_1.Type.Optional(exports$12.EosActionSellRam),
      vote_producer: schema_utils_1.Type.Optional(exports$12.EosActionVoteProducer),
      update_auth: schema_utils_1.Type.Optional(exports$12.EosActionUpdateAuth),
      delete_auth: schema_utils_1.Type.Optional(exports$12.EosActionDeleteAuth),
      link_auth: schema_utils_1.Type.Optional(exports$12.EosActionLinkAuth),
      unlink_auth: schema_utils_1.Type.Optional(exports$12.EosActionUnlinkAuth),
      new_account: schema_utils_1.Type.Optional(exports$12.EosActionNewAccount),
      unknown: schema_utils_1.Type.Optional(exports$12.EosActionUnknown)
    }, {
      $id: "EosTxActionAck"
    });
    exports$12.EosSignedTx = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String()
    }, {
      $id: "EosSignedTx"
    });
    exports$12.EthereumDefinitions = schema_utils_1.Type.Object({
      encoded_network: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer()),
      encoded_token: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer())
    }, {
      $id: "EthereumDefinitions"
    });
    exports$12.EthereumSignTypedData = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      primary_type: schema_utils_1.Type.String(),
      metamask_v4_compat: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      definitions: schema_utils_1.Type.Optional(exports$12.EthereumDefinitions),
      show_message_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "EthereumSignTypedData"
    });
    exports$12.EthereumTypedDataStructRequest = schema_utils_1.Type.Object({
      name: schema_utils_1.Type.String()
    }, {
      $id: "EthereumTypedDataStructRequest"
    });
    var EthereumDataType;
    (function(EthereumDataType2) {
      EthereumDataType2[EthereumDataType2["UINT"] = 1] = "UINT";
      EthereumDataType2[EthereumDataType2["INT"] = 2] = "INT";
      EthereumDataType2[EthereumDataType2["BYTES"] = 3] = "BYTES";
      EthereumDataType2[EthereumDataType2["STRING"] = 4] = "STRING";
      EthereumDataType2[EthereumDataType2["BOOL"] = 5] = "BOOL";
      EthereumDataType2[EthereumDataType2["ADDRESS"] = 6] = "ADDRESS";
      EthereumDataType2[EthereumDataType2["ARRAY"] = 7] = "ARRAY";
      EthereumDataType2[EthereumDataType2["STRUCT"] = 8] = "STRUCT";
    })(EthereumDataType || (exports$12.EthereumDataType = EthereumDataType = {}));
    exports$12.EnumEthereumDataType = schema_utils_1.Type.Enum(EthereumDataType);
    exports$12.EthereumFieldType = schema_utils_1.Type.Recursive((This) => schema_utils_1.Type.Object({
      data_type: exports$12.EnumEthereumDataType,
      size: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      entry_type: schema_utils_1.Type.Optional(This),
      struct_name: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }), {
      $id: "EthereumFieldType"
    });
    exports$12.EthereumStructMember = schema_utils_1.Type.Object({
      type: exports$12.EthereumFieldType,
      name: schema_utils_1.Type.String()
    }, {
      $id: "EthereumStructMember"
    });
    exports$12.EthereumTypedDataStructAck = schema_utils_1.Type.Object({
      members: schema_utils_1.Type.Array(exports$12.EthereumStructMember)
    }, {
      $id: "EthereumTypedDataStructAck"
    });
    exports$12.EthereumTypedDataValueRequest = schema_utils_1.Type.Object({
      member_path: schema_utils_1.Type.Array(schema_utils_1.Type.Number())
    }, {
      $id: "EthereumTypedDataValueRequest"
    });
    exports$12.EthereumTypedDataValueAck = schema_utils_1.Type.Object({
      value: schema_utils_1.Type.String()
    }, {
      $id: "EthereumTypedDataValueAck"
    });
    exports$12.EthereumGetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "EthereumGetPublicKey"
    });
    exports$12.EthereumPublicKey = schema_utils_1.Type.Object({
      node: exports$12.HDNodeType,
      xpub: schema_utils_1.Type.String()
    }, {
      $id: "EthereumPublicKey"
    });
    exports$12.EthereumGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      encoded_network: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "EthereumGetAddress"
    });
    exports$12.EthereumAddress = schema_utils_1.Type.Object({
      _old_address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "EthereumAddress"
    });
    exports$12.EthereumSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      nonce: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      gas_price: schema_utils_1.Type.String(),
      gas_limit: schema_utils_1.Type.String(),
      to: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      value: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      data_initial_chunk: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      data_length: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      chain_id: schema_utils_1.Type.Number(),
      tx_type: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      definitions: schema_utils_1.Type.Optional(exports$12.EthereumDefinitions),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      payment_req: schema_utils_1.Type.Optional(exports$12.PaymentRequest)
    }, {
      $id: "EthereumSignTx"
    });
    exports$12.EthereumAccessList = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      storage_keys: schema_utils_1.Type.Array(schema_utils_1.Type.String())
    }, {
      $id: "EthereumAccessList"
    });
    exports$12.EthereumSignTxEIP1559 = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      nonce: schema_utils_1.Type.String(),
      max_gas_fee: schema_utils_1.Type.String(),
      max_priority_fee: schema_utils_1.Type.String(),
      gas_limit: schema_utils_1.Type.String(),
      to: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      value: schema_utils_1.Type.String(),
      data_initial_chunk: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      data_length: schema_utils_1.Type.Number(),
      chain_id: schema_utils_1.Type.Number(),
      access_list: schema_utils_1.Type.Array(exports$12.EthereumAccessList),
      definitions: schema_utils_1.Type.Optional(exports$12.EthereumDefinitions),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      payment_req: schema_utils_1.Type.Optional(exports$12.PaymentRequest)
    }, {
      $id: "EthereumSignTxEIP1559"
    });
    exports$12.EthereumTxRequest = schema_utils_1.Type.Object({
      data_length: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      signature_v: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      signature_r: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      signature_s: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "EthereumTxRequest"
    });
    exports$12.EthereumTxAck = schema_utils_1.Type.Object({
      data_chunk: schema_utils_1.Type.String()
    }, {
      $id: "EthereumTxAck"
    });
    exports$12.EthereumSignMessage = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      message: schema_utils_1.Type.String(),
      encoded_network: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "EthereumSignMessage"
    });
    exports$12.EthereumMessageSignature = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      address: schema_utils_1.Type.String()
    }, {
      $id: "EthereumMessageSignature"
    });
    exports$12.EthereumVerifyMessage = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      message: schema_utils_1.Type.String(),
      address: schema_utils_1.Type.String(),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "EthereumVerifyMessage"
    });
    exports$12.EthereumSignTypedHash = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      domain_separator_hash: schema_utils_1.Type.String(),
      message_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      encoded_network: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer())
    }, {
      $id: "EthereumSignTypedHash"
    });
    exports$12.EthereumTypedDataSignature = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      address: schema_utils_1.Type.String()
    }, {
      $id: "EthereumTypedDataSignature"
    });
    exports$12.EvoluGetNode = schema_utils_1.Type.Object({
      proof_of_delegated_identity: schema_utils_1.Type.String()
    }, {
      $id: "EvoluGetNode"
    });
    exports$12.EvoluNode = schema_utils_1.Type.Object({
      data: schema_utils_1.Type.String()
    }, {
      $id: "EvoluNode"
    });
    exports$12.EvoluSignRegistrationRequest = schema_utils_1.Type.Object({
      challenge_from_server: schema_utils_1.Type.String(),
      size_to_acquire: schema_utils_1.Type.Number(),
      proof_of_delegated_identity: schema_utils_1.Type.String()
    }, {
      $id: "EvoluSignRegistrationRequest"
    });
    exports$12.EvoluRegistrationRequest = schema_utils_1.Type.Object({
      certificate_chain: schema_utils_1.Type.Array(schema_utils_1.Type.String()),
      signature: schema_utils_1.Type.String()
    }, {
      $id: "EvoluRegistrationRequest"
    });
    exports$12.EvoluGetDelegatedIdentityKey = schema_utils_1.Type.Object({
      thp_credential: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      host_static_public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "EvoluGetDelegatedIdentityKey"
    });
    exports$12.EvoluDelegatedIdentityKey = schema_utils_1.Type.Object({
      private_key: schema_utils_1.Type.String()
    }, {
      $id: "EvoluDelegatedIdentityKey"
    });
    var Enum_BackupType;
    (function(Enum_BackupType2) {
      Enum_BackupType2[Enum_BackupType2["Bip39"] = 0] = "Bip39";
      Enum_BackupType2[Enum_BackupType2["Slip39_Basic"] = 1] = "Slip39_Basic";
      Enum_BackupType2[Enum_BackupType2["Slip39_Advanced"] = 2] = "Slip39_Advanced";
      Enum_BackupType2[Enum_BackupType2["Slip39_Single_Extendable"] = 3] = "Slip39_Single_Extendable";
      Enum_BackupType2[Enum_BackupType2["Slip39_Basic_Extendable"] = 4] = "Slip39_Basic_Extendable";
      Enum_BackupType2[Enum_BackupType2["Slip39_Advanced_Extendable"] = 5] = "Slip39_Advanced_Extendable";
    })(Enum_BackupType || (exports$12.Enum_BackupType = Enum_BackupType = {}));
    exports$12.EnumEnum_BackupType = schema_utils_1.Type.Enum(Enum_BackupType);
    exports$12.BackupType = schema_utils_1.Type.KeyOfEnum(Enum_BackupType, {
      $id: "BackupType"
    });
    var Enum_SafetyCheckLevel;
    (function(Enum_SafetyCheckLevel2) {
      Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["Strict"] = 0] = "Strict";
      Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["PromptAlways"] = 1] = "PromptAlways";
      Enum_SafetyCheckLevel2[Enum_SafetyCheckLevel2["PromptTemporarily"] = 2] = "PromptTemporarily";
    })(Enum_SafetyCheckLevel || (exports$12.Enum_SafetyCheckLevel = Enum_SafetyCheckLevel = {}));
    exports$12.EnumEnum_SafetyCheckLevel = schema_utils_1.Type.Enum(Enum_SafetyCheckLevel);
    exports$12.SafetyCheckLevel = schema_utils_1.Type.KeyOfEnum(Enum_SafetyCheckLevel, {
      $id: "SafetyCheckLevel"
    });
    var Enum_DisplayRotation;
    (function(Enum_DisplayRotation2) {
      Enum_DisplayRotation2[Enum_DisplayRotation2["North"] = 0] = "North";
      Enum_DisplayRotation2[Enum_DisplayRotation2["East"] = 90] = "East";
      Enum_DisplayRotation2[Enum_DisplayRotation2["South"] = 180] = "South";
      Enum_DisplayRotation2[Enum_DisplayRotation2["West"] = 270] = "West";
    })(Enum_DisplayRotation || (exports$12.Enum_DisplayRotation = Enum_DisplayRotation = {}));
    exports$12.EnumEnum_DisplayRotation = schema_utils_1.Type.Enum(Enum_DisplayRotation);
    exports$12.DisplayRotation = schema_utils_1.Type.KeyOfEnum(Enum_DisplayRotation, {
      $id: "DisplayRotation"
    });
    var Enum_HomescreenFormat;
    (function(Enum_HomescreenFormat2) {
      Enum_HomescreenFormat2[Enum_HomescreenFormat2["Toif"] = 1] = "Toif";
      Enum_HomescreenFormat2[Enum_HomescreenFormat2["Jpeg"] = 2] = "Jpeg";
      Enum_HomescreenFormat2[Enum_HomescreenFormat2["ToiG"] = 3] = "ToiG";
    })(Enum_HomescreenFormat || (exports$12.Enum_HomescreenFormat = Enum_HomescreenFormat = {}));
    exports$12.EnumEnum_HomescreenFormat = schema_utils_1.Type.Enum(Enum_HomescreenFormat);
    exports$12.HomescreenFormat = schema_utils_1.Type.KeyOfEnum(Enum_HomescreenFormat, {
      $id: "HomescreenFormat"
    });
    exports$12.Initialize = schema_utils_1.Type.Object({
      session_id: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      _skip_passphrase: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      derive_cardano: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "Initialize"
    });
    exports$12.GetFeatures = schema_utils_1.Type.Object({}, {
      $id: "GetFeatures"
    });
    var Enum_BackupAvailability;
    (function(Enum_BackupAvailability2) {
      Enum_BackupAvailability2[Enum_BackupAvailability2["NotAvailable"] = 0] = "NotAvailable";
      Enum_BackupAvailability2[Enum_BackupAvailability2["Required"] = 1] = "Required";
      Enum_BackupAvailability2[Enum_BackupAvailability2["Available"] = 2] = "Available";
    })(Enum_BackupAvailability || (exports$12.Enum_BackupAvailability = Enum_BackupAvailability = {}));
    exports$12.EnumEnum_BackupAvailability = schema_utils_1.Type.Enum(Enum_BackupAvailability);
    exports$12.BackupAvailability = schema_utils_1.Type.KeyOfEnum(Enum_BackupAvailability, {
      $id: "BackupAvailability"
    });
    var Enum_RecoveryStatus;
    (function(Enum_RecoveryStatus2) {
      Enum_RecoveryStatus2[Enum_RecoveryStatus2["Nothing"] = 0] = "Nothing";
      Enum_RecoveryStatus2[Enum_RecoveryStatus2["Recovery"] = 1] = "Recovery";
      Enum_RecoveryStatus2[Enum_RecoveryStatus2["Backup"] = 2] = "Backup";
    })(Enum_RecoveryStatus || (exports$12.Enum_RecoveryStatus = Enum_RecoveryStatus = {}));
    exports$12.EnumEnum_RecoveryStatus = schema_utils_1.Type.Enum(Enum_RecoveryStatus);
    exports$12.RecoveryStatus = schema_utils_1.Type.KeyOfEnum(Enum_RecoveryStatus, {
      $id: "RecoveryStatus"
    });
    var Enum_Capability;
    (function(Enum_Capability2) {
      Enum_Capability2[Enum_Capability2["Capability_Bitcoin"] = 1] = "Capability_Bitcoin";
      Enum_Capability2[Enum_Capability2["Capability_Bitcoin_like"] = 2] = "Capability_Bitcoin_like";
      Enum_Capability2[Enum_Capability2["Capability_Binance"] = 3] = "Capability_Binance";
      Enum_Capability2[Enum_Capability2["Capability_Cardano"] = 4] = "Capability_Cardano";
      Enum_Capability2[Enum_Capability2["Capability_Crypto"] = 5] = "Capability_Crypto";
      Enum_Capability2[Enum_Capability2["Capability_EOS"] = 6] = "Capability_EOS";
      Enum_Capability2[Enum_Capability2["Capability_Ethereum"] = 7] = "Capability_Ethereum";
      Enum_Capability2[Enum_Capability2["Capability_Lisk"] = 8] = "Capability_Lisk";
      Enum_Capability2[Enum_Capability2["Capability_Monero"] = 9] = "Capability_Monero";
      Enum_Capability2[Enum_Capability2["Capability_NEM"] = 10] = "Capability_NEM";
      Enum_Capability2[Enum_Capability2["Capability_Ripple"] = 11] = "Capability_Ripple";
      Enum_Capability2[Enum_Capability2["Capability_Stellar"] = 12] = "Capability_Stellar";
      Enum_Capability2[Enum_Capability2["Capability_Tezos"] = 13] = "Capability_Tezos";
      Enum_Capability2[Enum_Capability2["Capability_U2F"] = 14] = "Capability_U2F";
      Enum_Capability2[Enum_Capability2["Capability_Shamir"] = 15] = "Capability_Shamir";
      Enum_Capability2[Enum_Capability2["Capability_ShamirGroups"] = 16] = "Capability_ShamirGroups";
      Enum_Capability2[Enum_Capability2["Capability_PassphraseEntry"] = 17] = "Capability_PassphraseEntry";
      Enum_Capability2[Enum_Capability2["Capability_Solana"] = 18] = "Capability_Solana";
      Enum_Capability2[Enum_Capability2["Capability_Translations"] = 19] = "Capability_Translations";
      Enum_Capability2[Enum_Capability2["Capability_Brightness"] = 20] = "Capability_Brightness";
      Enum_Capability2[Enum_Capability2["Capability_Haptic"] = 21] = "Capability_Haptic";
      Enum_Capability2[Enum_Capability2["Capability_BLE"] = 22] = "Capability_BLE";
      Enum_Capability2[Enum_Capability2["Capability_NFC"] = 23] = "Capability_NFC";
    })(Enum_Capability || (exports$12.Enum_Capability = Enum_Capability = {}));
    exports$12.EnumEnum_Capability = schema_utils_1.Type.Enum(Enum_Capability);
    exports$12.Capability = schema_utils_1.Type.KeyOfEnum(Enum_Capability, {
      $id: "Capability"
    });
    var RecoveryDeviceInputMethod;
    (function(RecoveryDeviceInputMethod2) {
      RecoveryDeviceInputMethod2[RecoveryDeviceInputMethod2["ScrambledWords"] = 0] = "ScrambledWords";
      RecoveryDeviceInputMethod2[RecoveryDeviceInputMethod2["Matrix"] = 1] = "Matrix";
    })(RecoveryDeviceInputMethod || (exports$12.RecoveryDeviceInputMethod = RecoveryDeviceInputMethod = {}));
    exports$12.EnumRecoveryDeviceInputMethod = schema_utils_1.Type.Enum(RecoveryDeviceInputMethod);
    var Enum_RecoveryType;
    (function(Enum_RecoveryType2) {
      Enum_RecoveryType2[Enum_RecoveryType2["NormalRecovery"] = 0] = "NormalRecovery";
      Enum_RecoveryType2[Enum_RecoveryType2["DryRun"] = 1] = "DryRun";
      Enum_RecoveryType2[Enum_RecoveryType2["UnlockRepeatedBackup"] = 2] = "UnlockRepeatedBackup";
    })(Enum_RecoveryType || (exports$12.Enum_RecoveryType = Enum_RecoveryType = {}));
    exports$12.EnumEnum_RecoveryType = schema_utils_1.Type.Enum(Enum_RecoveryType);
    exports$12.RecoveryType = schema_utils_1.Type.KeyOfEnum(Enum_RecoveryType, {
      $id: "RecoveryType"
    });
    exports$12.RecoveryDevice = schema_utils_1.Type.Object({
      word_count: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      passphrase_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      pin_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      language: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      label: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      enforce_wordlist: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      input_method: schema_utils_1.Type.Optional(exports$12.EnumRecoveryDeviceInputMethod),
      u2f_counter: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      type: schema_utils_1.Type.Optional(exports$12.RecoveryType)
    }, {
      $id: "RecoveryDevice"
    });
    exports$12.Features = schema_utils_1.Type.Object({
      vendor: schema_utils_1.Type.String(),
      major_version: schema_utils_1.Type.Number(),
      minor_version: schema_utils_1.Type.Number(),
      patch_version: schema_utils_1.Type.Number(),
      bootloader_mode: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      device_id: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      pin_protection: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      passphrase_protection: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      language: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      label: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      initialized: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      revision: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      bootloader_hash: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      imported: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      unlocked: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      _passphrase_cached: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      firmware_present: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      backup_availability: schema_utils_1.Type.Union([exports$12.BackupAvailability, schema_utils_1.Type.Null()]),
      flags: schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.Null()]),
      model: schema_utils_1.Type.String(),
      fw_major: schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.Null()]),
      fw_minor: schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.Null()]),
      fw_patch: schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.Null()]),
      fw_vendor: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      unfinished_backup: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      no_backup: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      recovery_status: schema_utils_1.Type.Union([exports$12.RecoveryStatus, schema_utils_1.Type.Null()]),
      capabilities: schema_utils_1.Type.Array(exports$12.Capability),
      backup_type: schema_utils_1.Type.Union([exports$12.BackupType, schema_utils_1.Type.Null()]),
      sd_card_present: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      sd_protection: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      wipe_code_protection: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      session_id: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      passphrase_always_on_device: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      safety_checks: schema_utils_1.Type.Union([exports$12.SafetyCheckLevel, schema_utils_1.Type.Null()]),
      auto_lock_delay_ms: schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.Null()]),
      display_rotation: schema_utils_1.Type.Union([exports$12.DisplayRotation, schema_utils_1.Type.Null()]),
      experimental_features: schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Null()]),
      busy: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      homescreen_format: schema_utils_1.Type.Optional(exports$12.HomescreenFormat),
      hide_passphrase_from_host: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      internal_model: exports$12.EnumDeviceModelInternal,
      unit_color: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      unit_btconly: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      homescreen_width: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      homescreen_height: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      bootloader_locked: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      language_version_matches: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      unit_packaging: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      haptic_feedback: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      recovery_type: schema_utils_1.Type.Optional(exports$12.RecoveryType),
      optiga_sec: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      soc: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      firmware_corrupted: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      auto_lock_delay_battery_ms: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      led: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      usb_connected: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      wireless_connected: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "Features"
    });
    exports$12.LockDevice = schema_utils_1.Type.Object({}, {
      $id: "LockDevice"
    });
    exports$12.SetBusy = schema_utils_1.Type.Object({
      expiry_ms: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "SetBusy"
    });
    exports$12.EndSession = schema_utils_1.Type.Object({}, {
      $id: "EndSession"
    });
    exports$12.ApplySettings = schema_utils_1.Type.Object({
      language: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      label: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      use_passphrase: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      homescreen: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      _passphrase_source: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      auto_lock_delay_ms: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      display_rotation: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([exports$12.DisplayRotation, exports$12.EnumEnum_DisplayRotation])),
      passphrase_always_on_device: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      safety_checks: schema_utils_1.Type.Optional(exports$12.SafetyCheckLevel),
      experimental_features: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      hide_passphrase_from_host: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      haptic_feedback: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      homescreen_length: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      auto_lock_delay_battery_ms: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "ApplySettings"
    });
    exports$12.ChangeLanguage = schema_utils_1.Type.Object({
      data_length: schema_utils_1.Type.Number(),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "ChangeLanguage"
    });
    exports$12.DataChunkRequest = schema_utils_1.Type.Object({
      data_length: schema_utils_1.Type.Number(),
      data_offset: schema_utils_1.Type.Number()
    }, {
      $id: "DataChunkRequest"
    });
    exports$12.DataChunkAck = schema_utils_1.Type.Object({
      data_chunk: schema_utils_1.Type.String()
    }, {
      $id: "DataChunkAck"
    });
    exports$12.ApplyFlags = schema_utils_1.Type.Object({
      flags: schema_utils_1.Type.Number()
    }, {
      $id: "ApplyFlags"
    });
    exports$12.ChangePin = schema_utils_1.Type.Object({
      remove: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "ChangePin"
    });
    exports$12.ChangeWipeCode = schema_utils_1.Type.Object({
      remove: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "ChangeWipeCode"
    });
    var SdProtectOperationType;
    (function(SdProtectOperationType2) {
      SdProtectOperationType2[SdProtectOperationType2["DISABLE"] = 0] = "DISABLE";
      SdProtectOperationType2[SdProtectOperationType2["ENABLE"] = 1] = "ENABLE";
      SdProtectOperationType2[SdProtectOperationType2["REFRESH"] = 2] = "REFRESH";
    })(SdProtectOperationType || (exports$12.SdProtectOperationType = SdProtectOperationType = {}));
    exports$12.EnumSdProtectOperationType = schema_utils_1.Type.Enum(SdProtectOperationType);
    exports$12.SdProtect = schema_utils_1.Type.Object({
      operation: exports$12.EnumSdProtectOperationType
    }, {
      $id: "SdProtect"
    });
    exports$12.Ping = schema_utils_1.Type.Object({
      message: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      button_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "Ping"
    });
    exports$12.Cancel = schema_utils_1.Type.Object({}, {
      $id: "Cancel"
    });
    exports$12.GetEntropy = schema_utils_1.Type.Object({
      size: schema_utils_1.Type.Number()
    }, {
      $id: "GetEntropy"
    });
    exports$12.Entropy = schema_utils_1.Type.Object({
      entropy: schema_utils_1.Type.String()
    }, {
      $id: "Entropy"
    });
    exports$12.GetFirmwareHash = schema_utils_1.Type.Object({
      challenge: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "GetFirmwareHash"
    });
    exports$12.FirmwareHash = schema_utils_1.Type.Object({
      hash: schema_utils_1.Type.String()
    }, {
      $id: "FirmwareHash"
    });
    exports$12.AuthenticateDevice = schema_utils_1.Type.Object({
      challenge: schema_utils_1.Type.String()
    }, {
      $id: "AuthenticateDevice"
    });
    exports$12.AuthenticityProof = schema_utils_1.Type.Object({
      optiga_certificates: schema_utils_1.Type.Array(schema_utils_1.Type.String()),
      optiga_signature: schema_utils_1.Type.String(),
      tropic_certificates: schema_utils_1.Type.Array(schema_utils_1.Type.String()),
      tropic_signature: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "AuthenticityProof"
    });
    exports$12.WipeDevice = schema_utils_1.Type.Object({}, {
      $id: "WipeDevice"
    });
    exports$12.LoadDevice = schema_utils_1.Type.Object({
      mnemonics: schema_utils_1.Type.Array(schema_utils_1.Type.String()),
      pin: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      passphrase_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      language: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      label: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      skip_checksum: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      u2f_counter: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      needs_backup: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      no_backup: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "LoadDevice"
    });
    exports$12.ResetDevice = schema_utils_1.Type.Object({
      strength: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      passphrase_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      pin_protection: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      language: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      label: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      u2f_counter: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      skip_backup: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      no_backup: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      backup_type: schema_utils_1.Type.Optional(exports$12.EnumEnum_BackupType),
      entropy_check: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "ResetDevice"
    });
    exports$12.Slip39Group = schema_utils_1.Type.Object({
      member_threshold: schema_utils_1.Type.Number(),
      member_count: schema_utils_1.Type.Number()
    }, {
      $id: "Slip39Group"
    });
    exports$12.BackupDevice = schema_utils_1.Type.Object({
      group_threshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      groups: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.Slip39Group))
    }, {
      $id: "BackupDevice"
    });
    exports$12.EntropyRequest = schema_utils_1.Type.Object({
      entropy_commitment: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      prev_entropy: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "EntropyRequest"
    });
    exports$12.EntropyAck = schema_utils_1.Type.Object({
      entropy: schema_utils_1.Type.String()
    }, {
      $id: "EntropyAck"
    });
    exports$12.EntropyCheckReady = schema_utils_1.Type.Object({}, {
      $id: "EntropyCheckReady"
    });
    exports$12.EntropyCheckContinue = schema_utils_1.Type.Object({
      finish: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "EntropyCheckContinue"
    });
    var Enum_WordRequestType;
    (function(Enum_WordRequestType2) {
      Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Plain"] = 0] = "WordRequestType_Plain";
      Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Matrix9"] = 1] = "WordRequestType_Matrix9";
      Enum_WordRequestType2[Enum_WordRequestType2["WordRequestType_Matrix6"] = 2] = "WordRequestType_Matrix6";
    })(Enum_WordRequestType || (exports$12.Enum_WordRequestType = Enum_WordRequestType = {}));
    exports$12.EnumEnum_WordRequestType = schema_utils_1.Type.Enum(Enum_WordRequestType);
    exports$12.WordRequestType = schema_utils_1.Type.KeyOfEnum(Enum_WordRequestType, {
      $id: "WordRequestType"
    });
    exports$12.WordRequest = schema_utils_1.Type.Object({
      type: exports$12.WordRequestType
    }, {
      $id: "WordRequest"
    });
    exports$12.WordAck = schema_utils_1.Type.Object({
      word: schema_utils_1.Type.String()
    }, {
      $id: "WordAck"
    });
    exports$12.SetU2FCounter = schema_utils_1.Type.Object({
      u2f_counter: schema_utils_1.Type.Number()
    }, {
      $id: "SetU2FCounter"
    });
    exports$12.GetNextU2FCounter = schema_utils_1.Type.Object({}, {
      $id: "GetNextU2FCounter"
    });
    exports$12.NextU2FCounter = schema_utils_1.Type.Object({
      u2f_counter: schema_utils_1.Type.Number()
    }, {
      $id: "NextU2FCounter"
    });
    exports$12.DoPreauthorized = schema_utils_1.Type.Object({}, {
      $id: "DoPreauthorized"
    });
    exports$12.PreauthorizedRequest = schema_utils_1.Type.Object({}, {
      $id: "PreauthorizedRequest"
    });
    exports$12.CancelAuthorization = schema_utils_1.Type.Object({}, {
      $id: "CancelAuthorization"
    });
    var BootCommand;
    (function(BootCommand2) {
      BootCommand2[BootCommand2["STOP_AND_WAIT"] = 0] = "STOP_AND_WAIT";
      BootCommand2[BootCommand2["INSTALL_UPGRADE"] = 1] = "INSTALL_UPGRADE";
    })(BootCommand || (exports$12.BootCommand = BootCommand = {}));
    exports$12.EnumBootCommand = schema_utils_1.Type.Enum(BootCommand);
    exports$12.RebootToBootloader = schema_utils_1.Type.Object({
      boot_command: schema_utils_1.Type.Optional(exports$12.EnumBootCommand),
      firmware_header: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      language_data_length: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "RebootToBootloader"
    });
    exports$12.GetNonce = schema_utils_1.Type.Object({}, {
      $id: "GetNonce"
    });
    exports$12.Nonce = schema_utils_1.Type.Object({
      nonce: schema_utils_1.Type.String()
    }, {
      $id: "Nonce"
    });
    exports$12.UnlockPath = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "UnlockPath"
    });
    exports$12.UnlockedPathRequest = schema_utils_1.Type.Object({
      mac: schema_utils_1.Type.String()
    }, {
      $id: "UnlockedPathRequest"
    });
    exports$12.ShowDeviceTutorial = schema_utils_1.Type.Object({}, {
      $id: "ShowDeviceTutorial"
    });
    exports$12.UnlockBootloader = schema_utils_1.Type.Object({}, {
      $id: "UnlockBootloader"
    });
    exports$12.SetBrightness = schema_utils_1.Type.Object({
      value: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "SetBrightness"
    });
    exports$12.GetSerialNumber = schema_utils_1.Type.Object({}, {
      $id: "GetSerialNumber"
    });
    exports$12.SerialNumber = schema_utils_1.Type.Object({
      serial_number: schema_utils_1.Type.String()
    }, {
      $id: "SerialNumber"
    });
    var MoneroNetworkType;
    (function(MoneroNetworkType2) {
      MoneroNetworkType2[MoneroNetworkType2["MAINNET"] = 0] = "MAINNET";
      MoneroNetworkType2[MoneroNetworkType2["TESTNET"] = 1] = "TESTNET";
      MoneroNetworkType2[MoneroNetworkType2["STAGENET"] = 2] = "STAGENET";
      MoneroNetworkType2[MoneroNetworkType2["FAKECHAIN"] = 3] = "FAKECHAIN";
    })(MoneroNetworkType || (exports$12.MoneroNetworkType = MoneroNetworkType = {}));
    exports$12.EnumMoneroNetworkType = schema_utils_1.Type.Enum(MoneroNetworkType);
    exports$12.MoneroRctKeyPublic = schema_utils_1.Type.Object({
      dest: schema_utils_1.Type.String(),
      commitment: schema_utils_1.Type.String()
    }, {
      $id: "MoneroRctKeyPublic"
    });
    exports$12.MoneroOutputEntry = schema_utils_1.Type.Object({
      idx: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      key: schema_utils_1.Type.Optional(exports$12.MoneroRctKeyPublic)
    }, {
      $id: "MoneroOutputEntry"
    });
    exports$12.MoneroMultisigKLRki = schema_utils_1.Type.Object({
      K: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      L: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      R: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ki: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "MoneroMultisigKLRki"
    });
    exports$12.MoneroTransactionSourceEntry = schema_utils_1.Type.Object({
      outputs: schema_utils_1.Type.Array(exports$12.MoneroOutputEntry),
      real_output: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      real_out_tx_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      real_out_additional_tx_keys: schema_utils_1.Type.Array(schema_utils_1.Type.String()),
      real_output_in_tx_index: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      amount: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      rct: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      mask: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      multisig_kLRki: schema_utils_1.Type.Optional(exports$12.MoneroMultisigKLRki),
      subaddr_minor: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "MoneroTransactionSourceEntry"
    });
    exports$12.MoneroAccountPublicAddress = schema_utils_1.Type.Object({
      spend_public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      view_public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "MoneroAccountPublicAddress"
    });
    exports$12.MoneroTransactionDestinationEntry = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      addr: schema_utils_1.Type.Optional(exports$12.MoneroAccountPublicAddress),
      is_subaddress: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      original: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      is_integrated: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "MoneroTransactionDestinationEntry"
    });
    exports$12.MoneroTransactionRsigData = schema_utils_1.Type.Object({
      rsig_type: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      offload_type: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      grouping: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      mask: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      rsig: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      rsig_parts: schema_utils_1.Type.Array(schema_utils_1.Type.String()),
      bp_version: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "MoneroTransactionRsigData"
    });
    exports$12.MoneroGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      network_type: schema_utils_1.Type.Optional(exports$12.EnumMoneroNetworkType),
      account: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      minor: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      payment_id: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "MoneroGetAddress"
    });
    exports$12.MoneroAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String()
    }, {
      $id: "MoneroAddress"
    });
    exports$12.MoneroGetWatchKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      network_type: schema_utils_1.Type.Optional(exports$12.EnumMoneroNetworkType)
    }, {
      $id: "MoneroGetWatchKey"
    });
    exports$12.MoneroWatchKey = schema_utils_1.Type.Object({
      watch_key: schema_utils_1.Type.String(),
      address: schema_utils_1.Type.String()
    }, {
      $id: "MoneroWatchKey"
    });
    exports$12.MoneroTransactionData = schema_utils_1.Type.Object({
      version: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      payment_id: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      unlock_time: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      outputs: schema_utils_1.Type.Array(exports$12.MoneroTransactionDestinationEntry),
      change_dts: schema_utils_1.Type.Optional(exports$12.MoneroTransactionDestinationEntry),
      num_inputs: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      mixin: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      fee: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      account: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      minor_indices: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      rsig_data: schema_utils_1.Type.Optional(exports$12.MoneroTransactionRsigData),
      integrated_indices: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      client_version: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      hard_fork: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      monero_version: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "MoneroTransactionData"
    });
    exports$12.MoneroTransactionInitRequest = schema_utils_1.Type.Object({
      version: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      network_type: schema_utils_1.Type.Optional(exports$12.EnumMoneroNetworkType),
      tsx_data: schema_utils_1.Type.Optional(exports$12.MoneroTransactionData)
    }, {
      $id: "MoneroTransactionInitRequest"
    });
    exports$12.MoneroTransactionInitAck = schema_utils_1.Type.Object({
      hmacs: schema_utils_1.Type.Array(schema_utils_1.Type.String()),
      rsig_data: schema_utils_1.Type.Optional(exports$12.MoneroTransactionRsigData)
    }, {
      $id: "MoneroTransactionInitAck"
    });
    exports$12.MoneroTransactionSetInputRequest = schema_utils_1.Type.Object({
      src_entr: schema_utils_1.Type.Optional(exports$12.MoneroTransactionSourceEntry)
    }, {
      $id: "MoneroTransactionSetInputRequest"
    });
    exports$12.MoneroTransactionSetInputAck = schema_utils_1.Type.Object({
      vini: schema_utils_1.Type.String(),
      vini_hmac: schema_utils_1.Type.String(),
      pseudo_out: schema_utils_1.Type.String(),
      pseudo_out_hmac: schema_utils_1.Type.String(),
      pseudo_out_alpha: schema_utils_1.Type.String(),
      spend_key: schema_utils_1.Type.String()
    }, {
      $id: "MoneroTransactionSetInputAck"
    });
    exports$12.MoneroTransactionInputViniRequest = schema_utils_1.Type.Object({
      src_entr: schema_utils_1.Type.Optional(exports$12.MoneroTransactionSourceEntry),
      vini: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      vini_hmac: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      pseudo_out: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      pseudo_out_hmac: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      orig_idx: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "MoneroTransactionInputViniRequest"
    });
    exports$12.MoneroTransactionInputViniAck = schema_utils_1.Type.Object({}, {
      $id: "MoneroTransactionInputViniAck"
    });
    exports$12.MoneroTransactionAllInputsSetRequest = schema_utils_1.Type.Object({}, {
      $id: "MoneroTransactionAllInputsSetRequest"
    });
    exports$12.MoneroTransactionAllInputsSetAck = schema_utils_1.Type.Object({
      rsig_data: schema_utils_1.Type.Optional(exports$12.MoneroTransactionRsigData)
    }, {
      $id: "MoneroTransactionAllInputsSetAck"
    });
    exports$12.MoneroTransactionSetOutputRequest = schema_utils_1.Type.Object({
      dst_entr: schema_utils_1.Type.Optional(exports$12.MoneroTransactionDestinationEntry),
      dst_entr_hmac: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      rsig_data: schema_utils_1.Type.Optional(exports$12.MoneroTransactionRsigData),
      is_offloaded_bp: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "MoneroTransactionSetOutputRequest"
    });
    exports$12.MoneroTransactionSetOutputAck = schema_utils_1.Type.Object({
      tx_out: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      vouti_hmac: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      rsig_data: schema_utils_1.Type.Optional(exports$12.MoneroTransactionRsigData),
      out_pk: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ecdh_info: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "MoneroTransactionSetOutputAck"
    });
    exports$12.MoneroTransactionAllOutSetRequest = schema_utils_1.Type.Object({
      rsig_data: schema_utils_1.Type.Optional(exports$12.MoneroTransactionRsigData)
    }, {
      $id: "MoneroTransactionAllOutSetRequest"
    });
    exports$12.MoneroRingCtSig = schema_utils_1.Type.Object({
      txn_fee: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      message: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      rv_type: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "MoneroRingCtSig"
    });
    exports$12.MoneroTransactionAllOutSetAck = schema_utils_1.Type.Object({
      extra: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      tx_prefix_hash: schema_utils_1.Type.String(),
      rv: exports$12.MoneroRingCtSig,
      full_message_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "MoneroTransactionAllOutSetAck"
    });
    exports$12.MoneroTransactionSignInputRequest = schema_utils_1.Type.Object({
      src_entr: schema_utils_1.Type.Optional(exports$12.MoneroTransactionSourceEntry),
      vini: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      vini_hmac: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      pseudo_out: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      pseudo_out_hmac: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      pseudo_out_alpha: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      spend_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      orig_idx: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "MoneroTransactionSignInputRequest"
    });
    exports$12.MoneroTransactionSignInputAck = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      pseudo_out: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "MoneroTransactionSignInputAck"
    });
    exports$12.MoneroTransactionFinalRequest = schema_utils_1.Type.Object({}, {
      $id: "MoneroTransactionFinalRequest"
    });
    exports$12.MoneroTransactionFinalAck = schema_utils_1.Type.Object({
      cout_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      salt: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      rand_mult: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      tx_enc_keys: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      opening_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "MoneroTransactionFinalAck"
    });
    exports$12.MoneroSubAddressIndicesList = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.Number(),
      minor_indices: schema_utils_1.Type.Array(schema_utils_1.Type.Number())
    }, {
      $id: "MoneroSubAddressIndicesList"
    });
    exports$12.MoneroKeyImageExportInitRequest = schema_utils_1.Type.Object({
      num: schema_utils_1.Type.Number(),
      hash: schema_utils_1.Type.Uint8Array(),
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      network_type: schema_utils_1.Type.Optional(exports$12.EnumMoneroNetworkType),
      subs: schema_utils_1.Type.Array(exports$12.MoneroSubAddressIndicesList)
    }, {
      $id: "MoneroKeyImageExportInitRequest"
    });
    exports$12.MoneroKeyImageExportInitAck = schema_utils_1.Type.Object({}, {
      $id: "MoneroKeyImageExportInitAck"
    });
    exports$12.MoneroTransferDetails = schema_utils_1.Type.Object({
      out_key: schema_utils_1.Type.Uint8Array(),
      tx_pub_key: schema_utils_1.Type.Uint8Array(),
      additional_tx_pub_keys: schema_utils_1.Type.Array(schema_utils_1.Type.Uint8Array()),
      internal_output_index: schema_utils_1.Type.Number(),
      sub_addr_major: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      sub_addr_minor: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "MoneroTransferDetails"
    });
    exports$12.MoneroKeyImageSyncStepRequest = schema_utils_1.Type.Object({
      tdis: schema_utils_1.Type.Array(exports$12.MoneroTransferDetails)
    }, {
      $id: "MoneroKeyImageSyncStepRequest"
    });
    exports$12.MoneroExportedKeyImage = schema_utils_1.Type.Object({
      iv: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      blob: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "MoneroExportedKeyImage"
    });
    exports$12.MoneroKeyImageSyncStepAck = schema_utils_1.Type.Object({
      kis: schema_utils_1.Type.Array(exports$12.MoneroExportedKeyImage)
    }, {
      $id: "MoneroKeyImageSyncStepAck"
    });
    exports$12.MoneroKeyImageSyncFinalRequest = schema_utils_1.Type.Object({}, {
      $id: "MoneroKeyImageSyncFinalRequest"
    });
    exports$12.MoneroKeyImageSyncFinalAck = schema_utils_1.Type.Object({
      enc_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "MoneroKeyImageSyncFinalAck"
    });
    exports$12.MoneroGetTxKeyRequest = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      network_type: schema_utils_1.Type.Optional(exports$12.EnumMoneroNetworkType),
      salt1: schema_utils_1.Type.String(),
      salt2: schema_utils_1.Type.String(),
      tx_enc_keys: schema_utils_1.Type.String(),
      tx_prefix_hash: schema_utils_1.Type.String(),
      reason: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      view_public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "MoneroGetTxKeyRequest"
    });
    exports$12.MoneroGetTxKeyAck = schema_utils_1.Type.Object({
      salt: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      tx_keys: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      tx_derivations: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "MoneroGetTxKeyAck"
    });
    exports$12.MoneroLiveRefreshStartRequest = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      network_type: schema_utils_1.Type.Optional(exports$12.EnumMoneroNetworkType)
    }, {
      $id: "MoneroLiveRefreshStartRequest"
    });
    exports$12.MoneroLiveRefreshStartAck = schema_utils_1.Type.Object({}, {
      $id: "MoneroLiveRefreshStartAck"
    });
    exports$12.MoneroLiveRefreshStepRequest = schema_utils_1.Type.Object({
      out_key: schema_utils_1.Type.String(),
      recv_deriv: schema_utils_1.Type.String(),
      real_out_idx: schema_utils_1.Type.Number(),
      sub_addr_major: schema_utils_1.Type.Number(),
      sub_addr_minor: schema_utils_1.Type.Number()
    }, {
      $id: "MoneroLiveRefreshStepRequest"
    });
    exports$12.MoneroLiveRefreshStepAck = schema_utils_1.Type.Object({
      salt: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      key_image: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "MoneroLiveRefreshStepAck"
    });
    exports$12.MoneroLiveRefreshFinalRequest = schema_utils_1.Type.Object({}, {
      $id: "MoneroLiveRefreshFinalRequest"
    });
    exports$12.MoneroLiveRefreshFinalAck = schema_utils_1.Type.Object({}, {
      $id: "MoneroLiveRefreshFinalAck"
    });
    exports$12.DebugMoneroDiagRequest = schema_utils_1.Type.Object({
      ins: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      p1: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      p2: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      pd: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      data1: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      data2: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "DebugMoneroDiagRequest"
    });
    exports$12.DebugMoneroDiagAck = schema_utils_1.Type.Object({
      ins: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      p1: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      p2: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      pd: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      data1: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      data2: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "DebugMoneroDiagAck"
    });
    exports$12.NEMGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      network: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "NEMGetAddress"
    });
    exports$12.NEMAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String()
    }, {
      $id: "NEMAddress"
    });
    exports$12.NEMTransactionCommon = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      network: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      timestamp: schema_utils_1.Type.Number(),
      fee: schema_utils_1.Type.Uint(),
      deadline: schema_utils_1.Type.Number(),
      signer: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "NEMTransactionCommon"
    });
    exports$12.NEMMosaic = schema_utils_1.Type.Object({
      namespace: schema_utils_1.Type.String(),
      mosaic: schema_utils_1.Type.String(),
      quantity: schema_utils_1.Type.Number()
    }, {
      $id: "NEMMosaic"
    });
    exports$12.NEMTransfer = schema_utils_1.Type.Object({
      recipient: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.Uint(),
      payload: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      mosaics: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.NEMMosaic))
    }, {
      $id: "NEMTransfer"
    });
    exports$12.NEMProvisionNamespace = schema_utils_1.Type.Object({
      namespace: schema_utils_1.Type.String(),
      parent: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      sink: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Uint()
    }, {
      $id: "NEMProvisionNamespace"
    });
    var NEMMosaicLevy;
    (function(NEMMosaicLevy2) {
      NEMMosaicLevy2[NEMMosaicLevy2["MosaicLevy_Absolute"] = 1] = "MosaicLevy_Absolute";
      NEMMosaicLevy2[NEMMosaicLevy2["MosaicLevy_Percentile"] = 2] = "MosaicLevy_Percentile";
    })(NEMMosaicLevy || (exports$12.NEMMosaicLevy = NEMMosaicLevy = {}));
    exports$12.EnumNEMMosaicLevy = schema_utils_1.Type.Enum(NEMMosaicLevy);
    exports$12.NEMMosaicDefinition = schema_utils_1.Type.Object({
      name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ticker: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      namespace: schema_utils_1.Type.String(),
      mosaic: schema_utils_1.Type.String(),
      divisibility: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      levy: schema_utils_1.Type.Optional(exports$12.EnumNEMMosaicLevy),
      fee: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      levy_address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      levy_namespace: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      levy_mosaic: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      supply: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      mutable_supply: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      transferable: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      description: schema_utils_1.Type.String(),
      networks: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number()))
    }, {
      $id: "NEMMosaicDefinition"
    });
    exports$12.NEMMosaicCreation = schema_utils_1.Type.Object({
      definition: exports$12.NEMMosaicDefinition,
      sink: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Uint()
    }, {
      $id: "NEMMosaicCreation"
    });
    var NEMSupplyChangeType;
    (function(NEMSupplyChangeType2) {
      NEMSupplyChangeType2[NEMSupplyChangeType2["SupplyChange_Increase"] = 1] = "SupplyChange_Increase";
      NEMSupplyChangeType2[NEMSupplyChangeType2["SupplyChange_Decrease"] = 2] = "SupplyChange_Decrease";
    })(NEMSupplyChangeType || (exports$12.NEMSupplyChangeType = NEMSupplyChangeType = {}));
    exports$12.EnumNEMSupplyChangeType = schema_utils_1.Type.Enum(NEMSupplyChangeType);
    exports$12.NEMMosaicSupplyChange = schema_utils_1.Type.Object({
      namespace: schema_utils_1.Type.String(),
      mosaic: schema_utils_1.Type.String(),
      type: exports$12.EnumNEMSupplyChangeType,
      delta: schema_utils_1.Type.Number()
    }, {
      $id: "NEMMosaicSupplyChange"
    });
    var NEMModificationType;
    (function(NEMModificationType2) {
      NEMModificationType2[NEMModificationType2["CosignatoryModification_Add"] = 1] = "CosignatoryModification_Add";
      NEMModificationType2[NEMModificationType2["CosignatoryModification_Delete"] = 2] = "CosignatoryModification_Delete";
    })(NEMModificationType || (exports$12.NEMModificationType = NEMModificationType = {}));
    exports$12.EnumNEMModificationType = schema_utils_1.Type.Enum(NEMModificationType);
    exports$12.NEMCosignatoryModification = schema_utils_1.Type.Object({
      type: exports$12.EnumNEMModificationType,
      public_key: schema_utils_1.Type.String()
    }, {
      $id: "NEMCosignatoryModification"
    });
    exports$12.NEMAggregateModification = schema_utils_1.Type.Object({
      modifications: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.NEMCosignatoryModification)),
      relative_change: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "NEMAggregateModification"
    });
    var NEMImportanceTransferMode;
    (function(NEMImportanceTransferMode2) {
      NEMImportanceTransferMode2[NEMImportanceTransferMode2["ImportanceTransfer_Activate"] = 1] = "ImportanceTransfer_Activate";
      NEMImportanceTransferMode2[NEMImportanceTransferMode2["ImportanceTransfer_Deactivate"] = 2] = "ImportanceTransfer_Deactivate";
    })(NEMImportanceTransferMode || (exports$12.NEMImportanceTransferMode = NEMImportanceTransferMode = {}));
    exports$12.EnumNEMImportanceTransferMode = schema_utils_1.Type.Enum(NEMImportanceTransferMode);
    exports$12.NEMImportanceTransfer = schema_utils_1.Type.Object({
      mode: exports$12.EnumNEMImportanceTransferMode,
      public_key: schema_utils_1.Type.String()
    }, {
      $id: "NEMImportanceTransfer"
    });
    exports$12.NEMSignTx = schema_utils_1.Type.Object({
      transaction: exports$12.NEMTransactionCommon,
      multisig: schema_utils_1.Type.Optional(exports$12.NEMTransactionCommon),
      transfer: schema_utils_1.Type.Optional(exports$12.NEMTransfer),
      cosigning: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      provision_namespace: schema_utils_1.Type.Optional(exports$12.NEMProvisionNamespace),
      mosaic_creation: schema_utils_1.Type.Optional(exports$12.NEMMosaicCreation),
      supply_change: schema_utils_1.Type.Optional(exports$12.NEMMosaicSupplyChange),
      aggregate_modification: schema_utils_1.Type.Optional(exports$12.NEMAggregateModification),
      importance_transfer: schema_utils_1.Type.Optional(exports$12.NEMImportanceTransfer),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "NEMSignTx"
    });
    exports$12.NEMSignedTx = schema_utils_1.Type.Object({
      data: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    }, {
      $id: "NEMSignedTx"
    });
    exports$12.NEMDecryptMessage = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      network: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      public_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      payload: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "NEMDecryptMessage"
    });
    exports$12.NEMDecryptedMessage = schema_utils_1.Type.Object({
      payload: schema_utils_1.Type.String()
    }, {
      $id: "NEMDecryptedMessage"
    });
    exports$12.RippleGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "RippleGetAddress"
    });
    exports$12.RippleAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "RippleAddress"
    });
    exports$12.RipplePayment = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.Uint(),
      destination: schema_utils_1.Type.String(),
      destination_tag: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "RipplePayment"
    });
    exports$12.RippleSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      fee: schema_utils_1.Type.Uint(),
      flags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      sequence: schema_utils_1.Type.Number(),
      last_ledger_sequence: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      payment: exports$12.RipplePayment,
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      payment_req: schema_utils_1.Type.Optional(exports$12.PaymentRequest)
    }, {
      $id: "RippleSignTx"
    });
    exports$12.RippleSignedTx = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      serialized_tx: schema_utils_1.Type.String()
    }, {
      $id: "RippleSignedTx"
    });
    exports$12.SolanaGetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "SolanaGetPublicKey"
    });
    exports$12.SolanaPublicKey = schema_utils_1.Type.Object({
      public_key: schema_utils_1.Type.String()
    }, {
      $id: "SolanaPublicKey"
    });
    exports$12.SolanaGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "SolanaGetAddress"
    });
    exports$12.SolanaAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "SolanaAddress"
    });
    exports$12.SolanaTxTokenAccountInfo = schema_utils_1.Type.Object({
      base_address: schema_utils_1.Type.String(),
      token_program: schema_utils_1.Type.String(),
      token_mint: schema_utils_1.Type.String(),
      token_account: schema_utils_1.Type.String()
    }, {
      $id: "SolanaTxTokenAccountInfo"
    });
    exports$12.SolanaTxAdditionalInfo = schema_utils_1.Type.Object({
      token_accounts_infos: schema_utils_1.Type.Array(exports$12.SolanaTxTokenAccountInfo),
      encoded_token: schema_utils_1.Type.Optional(schema_utils_1.Type.ArrayBuffer())
    }, {
      $id: "SolanaTxAdditionalInfo"
    });
    exports$12.SolanaSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      serialized_tx: schema_utils_1.Type.String(),
      additional_info: schema_utils_1.Type.Optional(exports$12.SolanaTxAdditionalInfo),
      payment_req: schema_utils_1.Type.Optional(exports$12.PaymentRequest)
    }, {
      $id: "SolanaSignTx"
    });
    exports$12.SolanaTxSignature = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String()
    }, {
      $id: "SolanaTxSignature"
    });
    var StellarAssetType;
    (function(StellarAssetType2) {
      StellarAssetType2[StellarAssetType2["NATIVE"] = 0] = "NATIVE";
      StellarAssetType2[StellarAssetType2["ALPHANUM4"] = 1] = "ALPHANUM4";
      StellarAssetType2[StellarAssetType2["ALPHANUM12"] = 2] = "ALPHANUM12";
    })(StellarAssetType || (exports$12.StellarAssetType = StellarAssetType = {}));
    exports$12.EnumStellarAssetType = schema_utils_1.Type.Enum(StellarAssetType);
    exports$12.StellarAsset = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Union([schema_utils_1.Type.Literal(0), schema_utils_1.Type.Literal(1), schema_utils_1.Type.Literal(2), schema_utils_1.Type.Literal("NATIVE"), schema_utils_1.Type.Literal("ALPHANUM4"), schema_utils_1.Type.Literal("ALPHANUM12")]),
      code: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      issuer: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "StellarAsset"
    });
    exports$12.StellarGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "StellarGetAddress"
    });
    exports$12.StellarAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "StellarAddress"
    });
    var StellarMemoType;
    (function(StellarMemoType2) {
      StellarMemoType2[StellarMemoType2["NONE"] = 0] = "NONE";
      StellarMemoType2[StellarMemoType2["TEXT"] = 1] = "TEXT";
      StellarMemoType2[StellarMemoType2["ID"] = 2] = "ID";
      StellarMemoType2[StellarMemoType2["HASH"] = 3] = "HASH";
      StellarMemoType2[StellarMemoType2["RETURN"] = 4] = "RETURN";
    })(StellarMemoType || (exports$12.StellarMemoType = StellarMemoType = {}));
    exports$12.EnumStellarMemoType = schema_utils_1.Type.Enum(StellarMemoType);
    exports$12.StellarSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      network_passphrase: schema_utils_1.Type.String(),
      source_account: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Uint(),
      sequence_number: schema_utils_1.Type.Uint(),
      timebounds_start: schema_utils_1.Type.Number(),
      timebounds_end: schema_utils_1.Type.Number(),
      memo_type: exports$12.EnumStellarMemoType,
      memo_text: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      memo_id: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      memo_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.Buffer(), schema_utils_1.Type.String()])),
      num_operations: schema_utils_1.Type.Number(),
      payment_req: schema_utils_1.Type.Optional(exports$12.PaymentRequest)
    }, {
      $id: "StellarSignTx"
    });
    exports$12.StellarTxOpRequest = schema_utils_1.Type.Object({}, {
      $id: "StellarTxOpRequest"
    });
    exports$12.StellarPaymentOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      destination_account: schema_utils_1.Type.String(),
      asset: exports$12.StellarAsset,
      amount: schema_utils_1.Type.Uint()
    }, {
      $id: "StellarPaymentOp"
    });
    exports$12.StellarCreateAccountOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      new_account: schema_utils_1.Type.String(),
      starting_balance: schema_utils_1.Type.Uint()
    }, {
      $id: "StellarCreateAccountOp"
    });
    exports$12.StellarPathPaymentStrictReceiveOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      send_asset: exports$12.StellarAsset,
      send_max: schema_utils_1.Type.Uint(),
      destination_account: schema_utils_1.Type.String(),
      destination_asset: exports$12.StellarAsset,
      destination_amount: schema_utils_1.Type.Uint(),
      paths: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.StellarAsset))
    }, {
      $id: "StellarPathPaymentStrictReceiveOp"
    });
    exports$12.StellarPathPaymentStrictSendOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      send_asset: exports$12.StellarAsset,
      send_amount: schema_utils_1.Type.Uint(),
      destination_account: schema_utils_1.Type.String(),
      destination_asset: exports$12.StellarAsset,
      destination_min: schema_utils_1.Type.Uint(),
      paths: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.StellarAsset))
    }, {
      $id: "StellarPathPaymentStrictSendOp"
    });
    exports$12.StellarManageSellOfferOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      selling_asset: exports$12.StellarAsset,
      buying_asset: exports$12.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      price_n: schema_utils_1.Type.Number(),
      price_d: schema_utils_1.Type.Number(),
      offer_id: schema_utils_1.Type.Uint()
    }, {
      $id: "StellarManageSellOfferOp"
    });
    exports$12.StellarManageBuyOfferOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      selling_asset: exports$12.StellarAsset,
      buying_asset: exports$12.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      price_n: schema_utils_1.Type.Number(),
      price_d: schema_utils_1.Type.Number(),
      offer_id: schema_utils_1.Type.Uint()
    }, {
      $id: "StellarManageBuyOfferOp"
    });
    exports$12.StellarCreatePassiveSellOfferOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      selling_asset: exports$12.StellarAsset,
      buying_asset: exports$12.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      price_n: schema_utils_1.Type.Number(),
      price_d: schema_utils_1.Type.Number()
    }, {
      $id: "StellarCreatePassiveSellOfferOp"
    });
    var StellarSignerType;
    (function(StellarSignerType2) {
      StellarSignerType2[StellarSignerType2["ACCOUNT"] = 0] = "ACCOUNT";
      StellarSignerType2[StellarSignerType2["PRE_AUTH"] = 1] = "PRE_AUTH";
      StellarSignerType2[StellarSignerType2["HASH"] = 2] = "HASH";
    })(StellarSignerType || (exports$12.StellarSignerType = StellarSignerType = {}));
    exports$12.EnumStellarSignerType = schema_utils_1.Type.Enum(StellarSignerType);
    exports$12.StellarSetOptionsOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      inflation_destination_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      clear_flags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      set_flags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      master_weight: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      low_threshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      medium_threshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      high_threshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      home_domain: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      signer_type: schema_utils_1.Type.Optional(exports$12.EnumStellarSignerType),
      signer_key: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.Buffer(), schema_utils_1.Type.String()])),
      signer_weight: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "StellarSetOptionsOp"
    });
    exports$12.StellarChangeTrustOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      asset: exports$12.StellarAsset,
      limit: schema_utils_1.Type.Uint()
    }, {
      $id: "StellarChangeTrustOp"
    });
    exports$12.StellarAllowTrustOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      trusted_account: schema_utils_1.Type.String(),
      asset_type: exports$12.EnumStellarAssetType,
      asset_code: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      is_authorized: schema_utils_1.Type.Boolean()
    }, {
      $id: "StellarAllowTrustOp"
    });
    exports$12.StellarAccountMergeOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      destination_account: schema_utils_1.Type.String()
    }, {
      $id: "StellarAccountMergeOp"
    });
    exports$12.StellarManageDataOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      key: schema_utils_1.Type.String(),
      value: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.Buffer(), schema_utils_1.Type.String()]))
    }, {
      $id: "StellarManageDataOp"
    });
    exports$12.StellarBumpSequenceOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      bump_to: schema_utils_1.Type.Uint()
    }, {
      $id: "StellarBumpSequenceOp"
    });
    exports$12.StellarClaimClaimableBalanceOp = schema_utils_1.Type.Object({
      source_account: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      balance_id: schema_utils_1.Type.String()
    }, {
      $id: "StellarClaimClaimableBalanceOp"
    });
    exports$12.StellarSignedTx = schema_utils_1.Type.Object({
      public_key: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    }, {
      $id: "StellarSignedTx"
    });
    exports$12.TezosGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "TezosGetAddress"
    });
    exports$12.TezosAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "TezosAddress"
    });
    exports$12.TezosGetPublicKey = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "TezosGetPublicKey"
    });
    exports$12.TezosPublicKey = schema_utils_1.Type.Object({
      public_key: schema_utils_1.Type.String()
    }, {
      $id: "TezosPublicKey"
    });
    var TezosContractType;
    (function(TezosContractType2) {
      TezosContractType2[TezosContractType2["Implicit"] = 0] = "Implicit";
      TezosContractType2[TezosContractType2["Originated"] = 1] = "Originated";
    })(TezosContractType || (exports$12.TezosContractType = TezosContractType = {}));
    exports$12.EnumTezosContractType = schema_utils_1.Type.Enum(TezosContractType);
    exports$12.TezosContractID = schema_utils_1.Type.Object({
      tag: schema_utils_1.Type.Number(),
      hash: schema_utils_1.Type.Uint8Array()
    }, {
      $id: "TezosContractID"
    });
    exports$12.TezosRevealOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.Uint8Array(),
      fee: schema_utils_1.Type.Uint(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      public_key: schema_utils_1.Type.Uint8Array()
    }, {
      $id: "TezosRevealOp"
    });
    exports$12.TezosManagerTransfer = schema_utils_1.Type.Object({
      destination: exports$12.TezosContractID,
      amount: schema_utils_1.Type.Uint()
    }, {
      $id: "TezosManagerTransfer"
    });
    exports$12.TezosParametersManager = schema_utils_1.Type.Object({
      set_delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint8Array()),
      cancel_delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      transfer: schema_utils_1.Type.Optional(exports$12.TezosManagerTransfer)
    }, {
      $id: "TezosParametersManager"
    });
    exports$12.TezosTransactionOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.Uint8Array(),
      fee: schema_utils_1.Type.Uint(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      amount: schema_utils_1.Type.Uint(),
      destination: exports$12.TezosContractID,
      parameters: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      parameters_manager: schema_utils_1.Type.Optional(exports$12.TezosParametersManager)
    }, {
      $id: "TezosTransactionOp"
    });
    exports$12.TezosOriginationOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.Uint8Array(),
      fee: schema_utils_1.Type.Uint(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      manager_pubkey: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      balance: schema_utils_1.Type.Number(),
      spendable: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      delegatable: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint8Array()),
      script: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Array(schema_utils_1.Type.Number())])
    }, {
      $id: "TezosOriginationOp"
    });
    exports$12.TezosDelegationOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.Uint8Array(),
      fee: schema_utils_1.Type.Uint(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      delegate: schema_utils_1.Type.Uint8Array()
    }, {
      $id: "TezosDelegationOp"
    });
    exports$12.TezosProposalOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      period: schema_utils_1.Type.Number(),
      proposals: schema_utils_1.Type.Array(schema_utils_1.Type.String())
    }, {
      $id: "TezosProposalOp"
    });
    var TezosBallotType;
    (function(TezosBallotType2) {
      TezosBallotType2[TezosBallotType2["Yay"] = 0] = "Yay";
      TezosBallotType2[TezosBallotType2["Nay"] = 1] = "Nay";
      TezosBallotType2[TezosBallotType2["Pass"] = 2] = "Pass";
    })(TezosBallotType || (exports$12.TezosBallotType = TezosBallotType = {}));
    exports$12.EnumTezosBallotType = schema_utils_1.Type.Enum(TezosBallotType);
    exports$12.TezosBallotOp = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      period: schema_utils_1.Type.Number(),
      proposal: schema_utils_1.Type.String(),
      ballot: exports$12.EnumTezosBallotType
    }, {
      $id: "TezosBallotOp"
    });
    exports$12.TezosSignTx = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      branch: schema_utils_1.Type.Uint8Array(),
      reveal: schema_utils_1.Type.Optional(exports$12.TezosRevealOp),
      transaction: schema_utils_1.Type.Optional(exports$12.TezosTransactionOp),
      origination: schema_utils_1.Type.Optional(exports$12.TezosOriginationOp),
      delegation: schema_utils_1.Type.Optional(exports$12.TezosDelegationOp),
      proposal: schema_utils_1.Type.Optional(exports$12.TezosProposalOp),
      ballot: schema_utils_1.Type.Optional(exports$12.TezosBallotOp),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "TezosSignTx"
    });
    exports$12.TezosSignedTx = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      sig_op_contents: schema_utils_1.Type.String(),
      operation_hash: schema_utils_1.Type.String()
    }, {
      $id: "TezosSignedTx"
    });
    exports$12.TronGetAddress = schema_utils_1.Type.Object({
      address_n: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      show_display: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "TronGetAddress"
    });
    exports$12.TronAddress = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      mac: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "TronAddress"
    });
    exports$12.MessageType = schema_utils_1.Type.Object({
      TextMemo: exports$12.TextMemo,
      RefundMemo: exports$12.RefundMemo,
      CoinPurchaseMemo: exports$12.CoinPurchaseMemo,
      TextDetailsMemo: exports$12.TextDetailsMemo,
      PaymentRequestMemo: exports$12.PaymentRequestMemo,
      PaymentRequest: exports$12.PaymentRequest,
      HDNodeType: exports$12.HDNodeType,
      HDNodePathType: exports$12.HDNodePathType,
      MultisigRedeemScriptType: exports$12.MultisigRedeemScriptType,
      GetPublicKey: exports$12.GetPublicKey,
      PublicKey: exports$12.PublicKey,
      GetAddress: exports$12.GetAddress,
      Address: exports$12.Address,
      GetOwnershipId: exports$12.GetOwnershipId,
      OwnershipId: exports$12.OwnershipId,
      SignMessage: exports$12.SignMessage,
      MessageSignature: exports$12.MessageSignature,
      VerifyMessage: exports$12.VerifyMessage,
      CoinJoinRequest: exports$12.CoinJoinRequest,
      SignTx: exports$12.SignTx,
      TxRequestDetailsType: exports$12.TxRequestDetailsType,
      TxRequestSerializedType: exports$12.TxRequestSerializedType,
      TxRequest: exports$12.TxRequest,
      TxInputType: exports$12.TxInputType,
      TxOutputBinType: exports$12.TxOutputBinType,
      TxOutputType: exports$12.TxOutputType,
      PrevTx: exports$12.PrevTx,
      PrevInput: exports$12.PrevInput,
      PrevOutput: exports$12.PrevOutput,
      TxAck: exports$12.TxAck,
      TxAckInputWrapper: exports$12.TxAckInputWrapper,
      TxAckInput: exports$12.TxAckInput,
      TxAckOutputWrapper: exports$12.TxAckOutputWrapper,
      TxAckOutput: exports$12.TxAckOutput,
      TxAckPrevMeta: exports$12.TxAckPrevMeta,
      TxAckPrevInputWrapper: exports$12.TxAckPrevInputWrapper,
      TxAckPrevInput: exports$12.TxAckPrevInput,
      TxAckPrevOutputWrapper: exports$12.TxAckPrevOutputWrapper,
      TxAckPrevOutput: exports$12.TxAckPrevOutput,
      TxAckPrevExtraDataWrapper: exports$12.TxAckPrevExtraDataWrapper,
      TxAckPrevExtraData: exports$12.TxAckPrevExtraData,
      GetOwnershipProof: exports$12.GetOwnershipProof,
      OwnershipProof: exports$12.OwnershipProof,
      AuthorizeCoinJoin: exports$12.AuthorizeCoinJoin,
      BleUnpair: exports$12.BleUnpair,
      FirmwareErase: exports$12.FirmwareErase,
      FirmwareRequest: exports$12.FirmwareRequest,
      FirmwareUpload: exports$12.FirmwareUpload,
      ProdTestT1: exports$12.ProdTestT1,
      CardanoBlockchainPointerType: exports$12.CardanoBlockchainPointerType,
      CardanoNativeScript: exports$12.CardanoNativeScript,
      CardanoGetNativeScriptHash: exports$12.CardanoGetNativeScriptHash,
      CardanoNativeScriptHash: exports$12.CardanoNativeScriptHash,
      CardanoAddressParametersType: exports$12.CardanoAddressParametersType,
      CardanoGetAddress: exports$12.CardanoGetAddress,
      CardanoAddress: exports$12.CardanoAddress,
      CardanoGetPublicKey: exports$12.CardanoGetPublicKey,
      CardanoPublicKey: exports$12.CardanoPublicKey,
      CardanoSignTxInit: exports$12.CardanoSignTxInit,
      CardanoTxInput: exports$12.CardanoTxInput,
      CardanoTxOutput: exports$12.CardanoTxOutput,
      CardanoAssetGroup: exports$12.CardanoAssetGroup,
      CardanoToken: exports$12.CardanoToken,
      CardanoTxInlineDatumChunk: exports$12.CardanoTxInlineDatumChunk,
      CardanoTxReferenceScriptChunk: exports$12.CardanoTxReferenceScriptChunk,
      CardanoPoolOwner: exports$12.CardanoPoolOwner,
      CardanoPoolRelayParameters: exports$12.CardanoPoolRelayParameters,
      CardanoPoolMetadataType: exports$12.CardanoPoolMetadataType,
      CardanoPoolParametersType: exports$12.CardanoPoolParametersType,
      CardanoDRep: exports$12.CardanoDRep,
      CardanoTxCertificate: exports$12.CardanoTxCertificate,
      CardanoTxWithdrawal: exports$12.CardanoTxWithdrawal,
      CardanoCVoteRegistrationDelegation: exports$12.CardanoCVoteRegistrationDelegation,
      CardanoCVoteRegistrationParametersType: exports$12.CardanoCVoteRegistrationParametersType,
      CardanoTxAuxiliaryData: exports$12.CardanoTxAuxiliaryData,
      CardanoTxMint: exports$12.CardanoTxMint,
      CardanoTxCollateralInput: exports$12.CardanoTxCollateralInput,
      CardanoTxRequiredSigner: exports$12.CardanoTxRequiredSigner,
      CardanoTxReferenceInput: exports$12.CardanoTxReferenceInput,
      CardanoTxItemAck: exports$12.CardanoTxItemAck,
      CardanoTxAuxiliaryDataSupplement: exports$12.CardanoTxAuxiliaryDataSupplement,
      CardanoTxWitnessRequest: exports$12.CardanoTxWitnessRequest,
      CardanoTxWitnessResponse: exports$12.CardanoTxWitnessResponse,
      CardanoTxHostAck: exports$12.CardanoTxHostAck,
      CardanoTxBodyHash: exports$12.CardanoTxBodyHash,
      CardanoSignTxFinished: exports$12.CardanoSignTxFinished,
      CardanoSignMessageInit: exports$12.CardanoSignMessageInit,
      CardanoMessageDataRequest: exports$12.CardanoMessageDataRequest,
      CardanoMessageDataResponse: exports$12.CardanoMessageDataResponse,
      CardanoMessageSignature: exports$12.CardanoMessageSignature,
      Success: exports$12.Success,
      Failure: exports$12.Failure,
      ButtonRequest: exports$12.ButtonRequest,
      ButtonAck: exports$12.ButtonAck,
      PinMatrixRequest: exports$12.PinMatrixRequest,
      PinMatrixAck: exports$12.PinMatrixAck,
      PassphraseRequest: exports$12.PassphraseRequest,
      PassphraseAck: exports$12.PassphraseAck,
      Deprecated_PassphraseStateRequest: exports$12.Deprecated_PassphraseStateRequest,
      Deprecated_PassphraseStateAck: exports$12.Deprecated_PassphraseStateAck,
      CipherKeyValue: exports$12.CipherKeyValue,
      CipheredKeyValue: exports$12.CipheredKeyValue,
      IdentityType: exports$12.IdentityType,
      SignIdentity: exports$12.SignIdentity,
      SignedIdentity: exports$12.SignedIdentity,
      GetECDHSessionKey: exports$12.GetECDHSessionKey,
      ECDHSessionKey: exports$12.ECDHSessionKey,
      PaymentNotification: exports$12.PaymentNotification,
      DebugLinkGetPairingInfo: exports$12.DebugLinkGetPairingInfo,
      DebugLinkPairingInfo: exports$12.DebugLinkPairingInfo,
      DebugLinkResetDebugEvents: exports$12.DebugLinkResetDebugEvents,
      DebugLinkOptigaSetSecMax: exports$12.DebugLinkOptigaSetSecMax,
      DebugLinkGetGcInfo: exports$12.DebugLinkGetGcInfo,
      DebugLinkGcInfoItem: exports$12.DebugLinkGcInfoItem,
      DebugLinkGcInfo: exports$12.DebugLinkGcInfo,
      EthereumNetworkInfo: exports$12.EthereumNetworkInfo,
      EthereumTokenInfo: exports$12.EthereumTokenInfo,
      SolanaTokenInfo: exports$12.SolanaTokenInfo,
      EosGetPublicKey: exports$12.EosGetPublicKey,
      EosPublicKey: exports$12.EosPublicKey,
      EosTxHeader: exports$12.EosTxHeader,
      EosSignTx: exports$12.EosSignTx,
      EosTxActionRequest: exports$12.EosTxActionRequest,
      EosAsset: exports$12.EosAsset,
      EosPermissionLevel: exports$12.EosPermissionLevel,
      EosAuthorizationKey: exports$12.EosAuthorizationKey,
      EosAuthorizationAccount: exports$12.EosAuthorizationAccount,
      EosAuthorizationWait: exports$12.EosAuthorizationWait,
      EosAuthorization: exports$12.EosAuthorization,
      EosActionCommon: exports$12.EosActionCommon,
      EosActionTransfer: exports$12.EosActionTransfer,
      EosActionDelegate: exports$12.EosActionDelegate,
      EosActionUndelegate: exports$12.EosActionUndelegate,
      EosActionRefund: exports$12.EosActionRefund,
      EosActionBuyRam: exports$12.EosActionBuyRam,
      EosActionBuyRamBytes: exports$12.EosActionBuyRamBytes,
      EosActionSellRam: exports$12.EosActionSellRam,
      EosActionVoteProducer: exports$12.EosActionVoteProducer,
      EosActionUpdateAuth: exports$12.EosActionUpdateAuth,
      EosActionDeleteAuth: exports$12.EosActionDeleteAuth,
      EosActionLinkAuth: exports$12.EosActionLinkAuth,
      EosActionUnlinkAuth: exports$12.EosActionUnlinkAuth,
      EosActionNewAccount: exports$12.EosActionNewAccount,
      EosActionUnknown: exports$12.EosActionUnknown,
      EosTxActionAck: exports$12.EosTxActionAck,
      EosSignedTx: exports$12.EosSignedTx,
      EthereumDefinitions: exports$12.EthereumDefinitions,
      EthereumSignTypedData: exports$12.EthereumSignTypedData,
      EthereumTypedDataStructRequest: exports$12.EthereumTypedDataStructRequest,
      EthereumFieldType: exports$12.EthereumFieldType,
      EthereumStructMember: exports$12.EthereumStructMember,
      EthereumTypedDataStructAck: exports$12.EthereumTypedDataStructAck,
      EthereumTypedDataValueRequest: exports$12.EthereumTypedDataValueRequest,
      EthereumTypedDataValueAck: exports$12.EthereumTypedDataValueAck,
      EthereumGetPublicKey: exports$12.EthereumGetPublicKey,
      EthereumPublicKey: exports$12.EthereumPublicKey,
      EthereumGetAddress: exports$12.EthereumGetAddress,
      EthereumAddress: exports$12.EthereumAddress,
      EthereumSignTx: exports$12.EthereumSignTx,
      EthereumAccessList: exports$12.EthereumAccessList,
      EthereumSignTxEIP1559: exports$12.EthereumSignTxEIP1559,
      EthereumTxRequest: exports$12.EthereumTxRequest,
      EthereumTxAck: exports$12.EthereumTxAck,
      EthereumSignMessage: exports$12.EthereumSignMessage,
      EthereumMessageSignature: exports$12.EthereumMessageSignature,
      EthereumVerifyMessage: exports$12.EthereumVerifyMessage,
      EthereumSignTypedHash: exports$12.EthereumSignTypedHash,
      EthereumTypedDataSignature: exports$12.EthereumTypedDataSignature,
      EvoluGetNode: exports$12.EvoluGetNode,
      EvoluNode: exports$12.EvoluNode,
      EvoluSignRegistrationRequest: exports$12.EvoluSignRegistrationRequest,
      EvoluRegistrationRequest: exports$12.EvoluRegistrationRequest,
      EvoluGetDelegatedIdentityKey: exports$12.EvoluGetDelegatedIdentityKey,
      EvoluDelegatedIdentityKey: exports$12.EvoluDelegatedIdentityKey,
      Initialize: exports$12.Initialize,
      GetFeatures: exports$12.GetFeatures,
      RecoveryDevice: exports$12.RecoveryDevice,
      Features: exports$12.Features,
      LockDevice: exports$12.LockDevice,
      SetBusy: exports$12.SetBusy,
      EndSession: exports$12.EndSession,
      ApplySettings: exports$12.ApplySettings,
      ChangeLanguage: exports$12.ChangeLanguage,
      DataChunkRequest: exports$12.DataChunkRequest,
      DataChunkAck: exports$12.DataChunkAck,
      ApplyFlags: exports$12.ApplyFlags,
      ChangePin: exports$12.ChangePin,
      ChangeWipeCode: exports$12.ChangeWipeCode,
      SdProtect: exports$12.SdProtect,
      Ping: exports$12.Ping,
      Cancel: exports$12.Cancel,
      GetEntropy: exports$12.GetEntropy,
      Entropy: exports$12.Entropy,
      GetFirmwareHash: exports$12.GetFirmwareHash,
      FirmwareHash: exports$12.FirmwareHash,
      AuthenticateDevice: exports$12.AuthenticateDevice,
      AuthenticityProof: exports$12.AuthenticityProof,
      WipeDevice: exports$12.WipeDevice,
      LoadDevice: exports$12.LoadDevice,
      ResetDevice: exports$12.ResetDevice,
      Slip39Group: exports$12.Slip39Group,
      BackupDevice: exports$12.BackupDevice,
      EntropyRequest: exports$12.EntropyRequest,
      EntropyAck: exports$12.EntropyAck,
      EntropyCheckReady: exports$12.EntropyCheckReady,
      EntropyCheckContinue: exports$12.EntropyCheckContinue,
      WordRequest: exports$12.WordRequest,
      WordAck: exports$12.WordAck,
      SetU2FCounter: exports$12.SetU2FCounter,
      GetNextU2FCounter: exports$12.GetNextU2FCounter,
      NextU2FCounter: exports$12.NextU2FCounter,
      DoPreauthorized: exports$12.DoPreauthorized,
      PreauthorizedRequest: exports$12.PreauthorizedRequest,
      CancelAuthorization: exports$12.CancelAuthorization,
      RebootToBootloader: exports$12.RebootToBootloader,
      GetNonce: exports$12.GetNonce,
      Nonce: exports$12.Nonce,
      UnlockPath: exports$12.UnlockPath,
      UnlockedPathRequest: exports$12.UnlockedPathRequest,
      ShowDeviceTutorial: exports$12.ShowDeviceTutorial,
      UnlockBootloader: exports$12.UnlockBootloader,
      SetBrightness: exports$12.SetBrightness,
      GetSerialNumber: exports$12.GetSerialNumber,
      SerialNumber: exports$12.SerialNumber,
      MoneroRctKeyPublic: exports$12.MoneroRctKeyPublic,
      MoneroOutputEntry: exports$12.MoneroOutputEntry,
      MoneroMultisigKLRki: exports$12.MoneroMultisigKLRki,
      MoneroTransactionSourceEntry: exports$12.MoneroTransactionSourceEntry,
      MoneroAccountPublicAddress: exports$12.MoneroAccountPublicAddress,
      MoneroTransactionDestinationEntry: exports$12.MoneroTransactionDestinationEntry,
      MoneroTransactionRsigData: exports$12.MoneroTransactionRsigData,
      MoneroGetAddress: exports$12.MoneroGetAddress,
      MoneroAddress: exports$12.MoneroAddress,
      MoneroGetWatchKey: exports$12.MoneroGetWatchKey,
      MoneroWatchKey: exports$12.MoneroWatchKey,
      MoneroTransactionData: exports$12.MoneroTransactionData,
      MoneroTransactionInitRequest: exports$12.MoneroTransactionInitRequest,
      MoneroTransactionInitAck: exports$12.MoneroTransactionInitAck,
      MoneroTransactionSetInputRequest: exports$12.MoneroTransactionSetInputRequest,
      MoneroTransactionSetInputAck: exports$12.MoneroTransactionSetInputAck,
      MoneroTransactionInputViniRequest: exports$12.MoneroTransactionInputViniRequest,
      MoneroTransactionInputViniAck: exports$12.MoneroTransactionInputViniAck,
      MoneroTransactionAllInputsSetRequest: exports$12.MoneroTransactionAllInputsSetRequest,
      MoneroTransactionAllInputsSetAck: exports$12.MoneroTransactionAllInputsSetAck,
      MoneroTransactionSetOutputRequest: exports$12.MoneroTransactionSetOutputRequest,
      MoneroTransactionSetOutputAck: exports$12.MoneroTransactionSetOutputAck,
      MoneroTransactionAllOutSetRequest: exports$12.MoneroTransactionAllOutSetRequest,
      MoneroRingCtSig: exports$12.MoneroRingCtSig,
      MoneroTransactionAllOutSetAck: exports$12.MoneroTransactionAllOutSetAck,
      MoneroTransactionSignInputRequest: exports$12.MoneroTransactionSignInputRequest,
      MoneroTransactionSignInputAck: exports$12.MoneroTransactionSignInputAck,
      MoneroTransactionFinalRequest: exports$12.MoneroTransactionFinalRequest,
      MoneroTransactionFinalAck: exports$12.MoneroTransactionFinalAck,
      MoneroSubAddressIndicesList: exports$12.MoneroSubAddressIndicesList,
      MoneroKeyImageExportInitRequest: exports$12.MoneroKeyImageExportInitRequest,
      MoneroKeyImageExportInitAck: exports$12.MoneroKeyImageExportInitAck,
      MoneroTransferDetails: exports$12.MoneroTransferDetails,
      MoneroKeyImageSyncStepRequest: exports$12.MoneroKeyImageSyncStepRequest,
      MoneroExportedKeyImage: exports$12.MoneroExportedKeyImage,
      MoneroKeyImageSyncStepAck: exports$12.MoneroKeyImageSyncStepAck,
      MoneroKeyImageSyncFinalRequest: exports$12.MoneroKeyImageSyncFinalRequest,
      MoneroKeyImageSyncFinalAck: exports$12.MoneroKeyImageSyncFinalAck,
      MoneroGetTxKeyRequest: exports$12.MoneroGetTxKeyRequest,
      MoneroGetTxKeyAck: exports$12.MoneroGetTxKeyAck,
      MoneroLiveRefreshStartRequest: exports$12.MoneroLiveRefreshStartRequest,
      MoneroLiveRefreshStartAck: exports$12.MoneroLiveRefreshStartAck,
      MoneroLiveRefreshStepRequest: exports$12.MoneroLiveRefreshStepRequest,
      MoneroLiveRefreshStepAck: exports$12.MoneroLiveRefreshStepAck,
      MoneroLiveRefreshFinalRequest: exports$12.MoneroLiveRefreshFinalRequest,
      MoneroLiveRefreshFinalAck: exports$12.MoneroLiveRefreshFinalAck,
      DebugMoneroDiagRequest: exports$12.DebugMoneroDiagRequest,
      DebugMoneroDiagAck: exports$12.DebugMoneroDiagAck,
      NEMGetAddress: exports$12.NEMGetAddress,
      NEMAddress: exports$12.NEMAddress,
      NEMTransactionCommon: exports$12.NEMTransactionCommon,
      NEMMosaic: exports$12.NEMMosaic,
      NEMTransfer: exports$12.NEMTransfer,
      NEMProvisionNamespace: exports$12.NEMProvisionNamespace,
      NEMMosaicDefinition: exports$12.NEMMosaicDefinition,
      NEMMosaicCreation: exports$12.NEMMosaicCreation,
      NEMMosaicSupplyChange: exports$12.NEMMosaicSupplyChange,
      NEMCosignatoryModification: exports$12.NEMCosignatoryModification,
      NEMAggregateModification: exports$12.NEMAggregateModification,
      NEMImportanceTransfer: exports$12.NEMImportanceTransfer,
      NEMSignTx: exports$12.NEMSignTx,
      NEMSignedTx: exports$12.NEMSignedTx,
      NEMDecryptMessage: exports$12.NEMDecryptMessage,
      NEMDecryptedMessage: exports$12.NEMDecryptedMessage,
      RippleGetAddress: exports$12.RippleGetAddress,
      RippleAddress: exports$12.RippleAddress,
      RipplePayment: exports$12.RipplePayment,
      RippleSignTx: exports$12.RippleSignTx,
      RippleSignedTx: exports$12.RippleSignedTx,
      SolanaGetPublicKey: exports$12.SolanaGetPublicKey,
      SolanaPublicKey: exports$12.SolanaPublicKey,
      SolanaGetAddress: exports$12.SolanaGetAddress,
      SolanaAddress: exports$12.SolanaAddress,
      SolanaTxTokenAccountInfo: exports$12.SolanaTxTokenAccountInfo,
      SolanaTxAdditionalInfo: exports$12.SolanaTxAdditionalInfo,
      SolanaSignTx: exports$12.SolanaSignTx,
      SolanaTxSignature: exports$12.SolanaTxSignature,
      StellarAsset: exports$12.StellarAsset,
      StellarGetAddress: exports$12.StellarGetAddress,
      StellarAddress: exports$12.StellarAddress,
      StellarSignTx: exports$12.StellarSignTx,
      StellarTxOpRequest: exports$12.StellarTxOpRequest,
      StellarPaymentOp: exports$12.StellarPaymentOp,
      StellarCreateAccountOp: exports$12.StellarCreateAccountOp,
      StellarPathPaymentStrictReceiveOp: exports$12.StellarPathPaymentStrictReceiveOp,
      StellarPathPaymentStrictSendOp: exports$12.StellarPathPaymentStrictSendOp,
      StellarManageSellOfferOp: exports$12.StellarManageSellOfferOp,
      StellarManageBuyOfferOp: exports$12.StellarManageBuyOfferOp,
      StellarCreatePassiveSellOfferOp: exports$12.StellarCreatePassiveSellOfferOp,
      StellarSetOptionsOp: exports$12.StellarSetOptionsOp,
      StellarChangeTrustOp: exports$12.StellarChangeTrustOp,
      StellarAllowTrustOp: exports$12.StellarAllowTrustOp,
      StellarAccountMergeOp: exports$12.StellarAccountMergeOp,
      StellarManageDataOp: exports$12.StellarManageDataOp,
      StellarBumpSequenceOp: exports$12.StellarBumpSequenceOp,
      StellarClaimClaimableBalanceOp: exports$12.StellarClaimClaimableBalanceOp,
      StellarSignedTx: exports$12.StellarSignedTx,
      TezosGetAddress: exports$12.TezosGetAddress,
      TezosAddress: exports$12.TezosAddress,
      TezosGetPublicKey: exports$12.TezosGetPublicKey,
      TezosPublicKey: exports$12.TezosPublicKey,
      TezosContractID: exports$12.TezosContractID,
      TezosRevealOp: exports$12.TezosRevealOp,
      TezosManagerTransfer: exports$12.TezosManagerTransfer,
      TezosParametersManager: exports$12.TezosParametersManager,
      TezosTransactionOp: exports$12.TezosTransactionOp,
      TezosOriginationOp: exports$12.TezosOriginationOp,
      TezosDelegationOp: exports$12.TezosDelegationOp,
      TezosProposalOp: exports$12.TezosProposalOp,
      TezosBallotOp: exports$12.TezosBallotOp,
      TezosSignTx: exports$12.TezosSignTx,
      TezosSignedTx: exports$12.TezosSignedTx,
      TronGetAddress: exports$12.TronGetAddress,
      TronAddress: exports$12.TronAddress
    }, {
      $id: "MessageType"
    });
  })(messagesSchema);
  return messagesSchema;
}
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$2;
  hasRequiredLib$2 = 1;
  (function(exports$12) {
    var _a;
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.MessagesSchema = exports$12.loadDefinitions = exports$12.Messages = exports$12.encodeMessage = exports$12.decodeMessage = exports$12.parseConfigure = void 0;
    const tslib_12 = require$$0$1;
    const long_1 = tslib_12.__importDefault(requireUmd());
    const protobuf = tslib_12.__importStar(requireLight());
    const decode_1 = requireDecode();
    const encode_1 = requireEncode();
    const utils_12 = requireUtils();
    _a = (() => {
      protobuf.util.Long = long_1.default;
      protobuf.configure();
      return {
        parseConfigure: utils_12.parseConfigure,
        decodeMessage: decode_1.decodeMessage,
        encodeMessage: encode_1.encodeMessage
      };
    })(), exports$12.parseConfigure = _a.parseConfigure, exports$12.decodeMessage = _a.decodeMessage, exports$12.encodeMessage = _a.encodeMessage;
    exports$12.Messages = tslib_12.__importStar(requireMessages$1());
    var load_definitions_1 = requireLoadDefinitions();
    Object.defineProperty(exports$12, "loadDefinitions", {
      enumerable: true,
      get: function() {
        return load_definitions_1.loadDefinitions;
      }
    });
    exports$12.MessagesSchema = tslib_12.__importStar(requireMessagesSchema());
  })(lib$2);
  return lib$2;
}
(function(exports$12) {
  Object.defineProperty(exports$12, "__esModule", {
    value: true
  });
  exports$12.PROTO = exports$12.DEFAULT_SORTING_STRATEGY = exports$12.FIRMWARE = exports$12.NEM = exports$12.CARDANO = exports$12.NETWORK = exports$12.ERRORS = void 0;
  const tslib_12 = require$$0$1;
  exports$12.ERRORS = tslib_12.__importStar(requireErrors$4());
  exports$12.NETWORK = tslib_12.__importStar(requireNetwork());
  exports$12.CARDANO = tslib_12.__importStar(requireCardano$1());
  exports$12.NEM = tslib_12.__importStar(requireNem());
  exports$12.FIRMWARE = tslib_12.__importStar(requireFirmware$1());
  var utxo_1 = requireUtxo();
  Object.defineProperty(exports$12, "DEFAULT_SORTING_STRATEGY", {
    enumerable: true,
    get: function() {
      return utxo_1.DEFAULT_SORTING_STRATEGY;
    }
  });
  var protobuf_1 = requireLib$2();
  Object.defineProperty(exports$12, "PROTO", {
    enumerable: true,
    get: function() {
      return protobuf_1.MessagesSchema;
    }
  });
})(constants);
var proxyEventEmitter = {};
Object.defineProperty(proxyEventEmitter, "__esModule", {
  value: true
});
proxyEventEmitter.ProxyEventEmitter = void 0;
class ProxyEventEmitter {
  constructor(eventEmitters) {
    __publicField(this, "eventEmitters");
    this.eventEmitters = eventEmitters;
  }
  emit(eventName, ...args) {
    this.eventEmitters.forEach((emitter) => emitter.emit(eventName, ...args));
    return true;
  }
  on(eventName, listener) {
    this.eventEmitters.forEach((emitter) => emitter.on(eventName, listener));
    return this;
  }
  off(eventName, listener) {
    this.eventEmitters.forEach((emitter) => emitter.off(eventName, listener));
    return this;
  }
  once(eventName, listener) {
    this.eventEmitters.forEach((emitter) => emitter.once(eventName, listener));
    return this;
  }
  addListener(eventName, listener) {
    this.eventEmitters.forEach((emitter) => emitter.addListener(eventName, listener));
    return this;
  }
  prependListener(eventName, listener) {
    this.eventEmitters.forEach((emitter) => emitter.prependListener(eventName, listener));
    return this;
  }
  prependOnceListener(eventName, listener) {
    this.eventEmitters.forEach((emitter) => emitter.prependOnceListener(eventName, listener));
    return this;
  }
  removeAllListeners(event) {
    this.eventEmitters.forEach((emitter) => emitter.removeAllListeners(event));
    return this;
  }
  removeListener(eventName, listener) {
    this.eventEmitters.forEach((emitter) => emitter.removeListener(eventName, listener));
    return this;
  }
  setMaxListeners(n) {
    this.eventEmitters.forEach((emitter) => emitter.setMaxListeners(n));
    return this;
  }
  eventNames() {
    return this.eventEmitters[0].eventNames();
  }
  getMaxListeners() {
    return this.eventEmitters[0].getMaxListeners();
  }
  listenerCount(eventName, listener) {
    return this.eventEmitters[0].listenerCount(eventName, listener);
  }
  rawListeners(eventName) {
    return this.eventEmitters[0].rawListeners(eventName);
  }
  listeners(eventName) {
    return this.eventEmitters[0].listeners(eventName);
  }
}
proxyEventEmitter.ProxyEventEmitter = ProxyEventEmitter;
Object.defineProperty(dynamic, "__esModule", {
  value: true
});
dynamic.TrezorConnectDynamic = void 0;
const utils_1$1 = lib$4;
const constants_1 = constants;
const events_1$4 = events;
const proxy_event_emitter_1 = proxyEventEmitter;
class TrezorConnectDynamic {
  constructor({
    implementations,
    getInitTarget,
    handleBeforeCall,
    handleErrorFallback
  }) {
    __publicField(this, "eventEmitter");
    __publicField(this, "currentTarget");
    __publicField(this, "implementations");
    __publicField(this, "getInitTarget");
    __publicField(this, "handleBeforeCall");
    __publicField(this, "handleErrorFallback");
    __publicField(this, "lastSettings");
    __publicField(this, "callPending", 0);
    __publicField(this, "beforeCallSynchronize", (0, utils_1$1.getSynchronize)());
    this.implementations = implementations;
    this.currentTarget = this.implementations[0].type;
    this.getInitTarget = getInitTarget;
    this.handleBeforeCall = handleBeforeCall;
    this.handleErrorFallback = handleErrorFallback;
    this.eventEmitter = new proxy_event_emitter_1.ProxyEventEmitter(this.implementations.map((impl2) => impl2.impl.eventEmitter));
  }
  getTarget() {
    return this.implementations.find((impl2) => impl2.type === this.currentTarget).impl;
  }
  getTargetType() {
    return this.currentTarget;
  }
  async switchTarget(target) {
    if (this.currentTarget === target) {
      return;
    }
    if (!this.lastSettings) {
      throw constants_1.ERRORS.TypedError("Init_ManifestMissing");
    }
    const oldTargetType = this.getTargetType();
    const oldTarget = this.getTarget();
    try {
      this.currentTarget = target;
      await this.getTarget().init(this.lastSettings);
      await oldTarget.dispose();
    } catch {
      this.currentTarget = oldTargetType;
    }
  }
  manifest(manifest) {
    this.lastSettings = {
      ...this.lastSettings,
      manifest
    };
    this.getTarget().manifest(manifest);
  }
  async init(settings2) {
    if (!(settings2 == null ? void 0 : settings2.manifest)) {
      throw constants_1.ERRORS.TypedError("Init_ManifestMissing");
    }
    this.lastSettings = settings2;
    this.currentTarget = this.getInitTarget(settings2);
    this.callPending = 0;
    try {
      return await this.getTarget().init(this.lastSettings);
    } catch (error2) {
      if (await this.handleErrorFallback(error2.code)) {
        return;
      }
      throw error2;
    }
  }
  setTransports({
    transports
  }) {
    this.lastSettings = {
      ...this.lastSettings,
      transports
    };
    this.getTarget().setTransports({
      transports
    });
  }
  async call(params2) {
    try {
      if (this.callPending === 0) {
        await this.beforeCallSynchronize(async () => {
          this.callPending++;
          await this.handleBeforeCall();
        });
      }
      const response = await this.getTarget().call(params2);
      if (!response.success) {
        if (await this.handleErrorFallback(response.payload.code)) {
          return await this.getTarget().call(params2);
        }
      }
      return response;
    } catch (error2) {
      return (0, events_1$4.createErrorMessage)(error2);
    } finally {
      this.callPending--;
    }
  }
  uiResponse(params2) {
    return this.getTarget().uiResponse(params2);
  }
  cancel(error2) {
    return this.getTarget().cancel(error2);
  }
  dispose() {
    this.eventEmitter.removeAllListeners();
    this.callPending = 0;
    return this.getTarget().dispose();
  }
}
dynamic.TrezorConnectDynamic = TrezorConnectDynamic;
var connectSettings$1 = {};
var connectSettings = {};
var thpSettings = {};
Object.defineProperty(thpSettings, "__esModule", {
  value: true
});
thpSettings.parseThpSettings = void 0;
const parseThpSettings = ({
  manifest,
  thp
}) => {
  const settings2 = {
    pairingMethods: []
  };
  if (Array.isArray(thp == null ? void 0 : thp.pairingMethods)) {
    settings2.pairingMethods = thp.pairingMethods;
  } else {
    settings2.pairingMethods = ["CodeEntry"];
  }
  if (typeof (thp == null ? void 0 : thp.hostName) === "string") {
    settings2.hostName = thp.hostName;
  }
  if (typeof (thp == null ? void 0 : thp.appName) === "string") {
    settings2.appName = thp.appName;
  } else if (typeof (manifest == null ? void 0 : manifest.appName) === "string") {
    settings2.appName = manifest == null ? void 0 : manifest.appName;
  }
  if (typeof (thp == null ? void 0 : thp.staticKey) === "string") {
    settings2.staticKey = thp.staticKey;
  }
  if (Array.isArray(thp == null ? void 0 : thp.knownCredentials)) {
    settings2.knownCredentials = thp.knownCredentials.flatMap((k) => {
      if (k && typeof k === "object" && typeof k.credential === "string" && typeof k.trezor_static_public_key === "string") {
        return k;
      }
      return [];
    });
  }
  return settings2;
};
thpSettings.parseThpSettings = parseThpSettings;
var version = {};
(function(exports$12) {
  Object.defineProperty(exports$12, "__esModule", {
    value: true
  });
  exports$12.DEEPLINK_VERSION = exports$12.CONTENT_SCRIPT_VERSION = exports$12.DEFAULT_DOMAIN = exports$12.DEFAULT_DOMAIN_MAJOR_VER = exports$12.VERSION = void 0;
  exports$12.VERSION = "9.7.1";
  const versionN = exports$12.VERSION.split(".").map((s) => parseInt(s, 10));
  const isBeta = exports$12.VERSION.includes("beta");
  exports$12.DEFAULT_DOMAIN_MAJOR_VER = `https://connect.trezor.io/${versionN[0]}/`;
  exports$12.DEFAULT_DOMAIN = isBeta ? `https://connect.trezor.io/${exports$12.VERSION}/` : exports$12.DEFAULT_DOMAIN_MAJOR_VER;
  exports$12.CONTENT_SCRIPT_VERSION = 1;
  exports$12.DEEPLINK_VERSION = 1;
})(version);
(function(exports$12) {
  Object.defineProperty(exports$12, "__esModule", {
    value: true
  });
  exports$12.parseConnectSettings = exports$12.corsValidator = exports$12.parseLocalFirmwares = exports$12.DEFAULT_PRIORITY = void 0;
  const thpSettings_1 = thpSettings;
  const version_1 = version;
  exports$12.DEFAULT_PRIORITY = 2;
  const initialSettings = {
    configSrc: "./data/config.json",
    version: version_1.VERSION,
    debug: false,
    priority: exports$12.DEFAULT_PRIORITY,
    trustedHost: true,
    connectSrc: version_1.DEFAULT_DOMAIN,
    iframeSrc: `${version_1.DEFAULT_DOMAIN}iframe.html`,
    popup: false,
    popupSrc: `${version_1.DEFAULT_DOMAIN}popup.html`,
    webusbSrc: `${version_1.DEFAULT_DOMAIN}webusb.html`,
    transports: void 0,
    pendingTransportEvent: true,
    env: "node",
    lazyLoad: false,
    timestamp: (/* @__PURE__ */ new Date()).getTime(),
    interactionTimeout: 1200,
    sharedLogger: true,
    deeplinkUrl: `${version_1.DEFAULT_DOMAIN}deeplink/${version_1.DEEPLINK_VERSION}/`,
    transportReconnect: true
  };
  const parseManifest = (manifest) => {
    if (!manifest) return;
    if (typeof manifest.email !== "string") return;
    if (typeof manifest.appUrl !== "string") return;
    if (typeof manifest.appName !== "undefined" && typeof manifest.appName !== "string") return;
    if (typeof manifest.appIcon !== "undefined" && typeof manifest.appIcon !== "string") return;
    return {
      email: manifest.email,
      appUrl: manifest.appUrl,
      appName: manifest.appName,
      appIcon: manifest.appIcon
    };
  };
  const parseLocalFirmwares = (localFirmwares) => {
    if (!localFirmwares) return;
    if (typeof localFirmwares.firmwareDir !== "string") return;
    if (!Array.isArray(localFirmwares.firmwareList)) return;
    return {
      firmwareDir: localFirmwares.firmwareDir,
      firmwareList: localFirmwares.firmwareList
    };
  };
  exports$12.parseLocalFirmwares = parseLocalFirmwares;
  const corsValidator = (url) => {
    if (typeof url !== "string") return;
    if (url === "../") return url;
    if (url.match(/^https:\/\/([A-Za-z0-9\-_]+\.)*trezor\.io\//)) return url;
    if (url.match(/^https?:\/\/localhost:[58][0-9]{3}\//)) return url;
    if (url.match(/^https:\/\/([A-Za-z0-9\-_]+\.)*sldev\.cz\//)) return url;
    if (url.match(/^https?:\/\/([A-Za-z0-9\-_]+\.)*trezoriovpjcahpzkrewelclulmszwbqpzmzgub37gbcjlvluxtruqad\.onion\//)) return url;
  };
  exports$12.corsValidator = corsValidator;
  const parseConnectSettings = (input = {}) => {
    const settings2 = {
      ...initialSettings
    };
    if ("debug" in input) {
      if (typeof input.debug === "boolean") {
        settings2.debug = input.debug;
      } else if (typeof input.debug === "string") {
        settings2.debug = input.debug === "true";
      }
    }
    if (input.trustedHost === false) {
      settings2.trustedHost = input.trustedHost;
    }
    if (typeof input.connectSrc === "string") {
      settings2.connectSrc = (0, exports$12.corsValidator)(input.connectSrc);
    } else if (settings2.trustedHost) {
      settings2.connectSrc = input.connectSrc;
    }
    const src = settings2.connectSrc || version_1.DEFAULT_DOMAIN;
    settings2.iframeSrc = `${src}iframe.html`;
    settings2.popupSrc = `${src}popup.html`;
    settings2.webusbSrc = `${src}webusb.html`;
    if (typeof input.transportReconnect === "boolean") {
      settings2.transportReconnect = input.transportReconnect;
    }
    if (typeof input.localFirmwares === "object") {
      settings2.localFirmwares = (0, exports$12.parseLocalFirmwares)(input.localFirmwares);
    }
    if (typeof input.firmwareUpdateSource === "string") {
      settings2.firmwareUpdateSource = input.firmwareUpdateSource;
    }
    if (Array.isArray(input.transports)) {
      settings2.transports = input.transports;
    }
    if (typeof input.popup === "boolean") {
      settings2.popup = input.popup;
    }
    if (typeof input.lazyLoad === "boolean") {
      settings2.lazyLoad = input.lazyLoad;
    }
    if (typeof input.pendingTransportEvent === "boolean") {
      settings2.pendingTransportEvent = input.pendingTransportEvent;
    }
    if (typeof input.extension === "string") {
      settings2.extension = input.extension;
    }
    if (typeof input.env === "string") {
      settings2.env = input.env;
    }
    if (typeof input.timestamp === "number") {
      settings2.timestamp = input.timestamp;
    }
    if (typeof input.interactionTimeout === "number") {
      settings2.interactionTimeout = input.interactionTimeout;
    }
    if (typeof input.manifest === "object") {
      settings2.manifest = parseManifest(input.manifest);
    }
    if (typeof input.sharedLogger === "boolean") {
      settings2.sharedLogger = input.sharedLogger;
    }
    if (typeof input.coreMode === "string" && ["auto", "popup", "iframe", "suite-desktop", "suite-web"].includes(input.coreMode)) {
      settings2.coreMode = input.coreMode;
    }
    if (typeof input._extendWebextensionLifetime === "boolean") {
      settings2._extendWebextensionLifetime = input._extendWebextensionLifetime;
    }
    if (typeof input.binFilesBaseUrl === "string") {
      settings2.binFilesBaseUrl = input.binFilesBaseUrl;
    }
    if (typeof input.enableFirmwareHashCheck === "boolean") {
      settings2.enableFirmwareHashCheck = Boolean(input.enableFirmwareHashCheck);
    }
    if (typeof input.firmwareHashCheckTimeouts === "object" && input.firmwareHashCheckTimeouts !== null) {
      settings2.firmwareHashCheckTimeouts = input.firmwareHashCheckTimeouts;
    }
    if (typeof input.npmVersion === "string") {
      settings2.npmVersion = input.npmVersion;
    }
    settings2.thp = (0, thpSettings_1.parseThpSettings)(input);
    return settings2;
  };
  exports$12.parseConnectSettings = parseConnectSettings;
})(connectSettings);
(function(exports$12) {
  Object.defineProperty(exports$12, "__esModule", {
    value: true
  });
  exports$12.parseConnectSettings = exports$12.getEnv = void 0;
  const connectSettings_12 = connectSettings;
  const getEnv = () => {
    var _a;
    if (typeof chrome !== "undefined" && typeof ((_a = chrome.runtime) == null ? void 0 : _a.onConnect) !== "undefined") {
      return "webextension";
    }
    if (typeof navigator !== "undefined") {
      if (typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative") {
        return "react-native";
      }
      const userAgent = navigator.userAgent.toLowerCase();
      if (userAgent.indexOf(" electron/") > -1) {
        return "electron";
      }
    }
    return "web";
  };
  exports$12.getEnv = getEnv;
  const parseConnectSettings = (input = {}) => {
    const settings2 = {
      popup: true,
      ...input
    };
    let globalSrc;
    if (typeof window !== "undefined") {
      globalSrc = window.__TREZOR_CONNECT_SRC;
    } else if (typeof globalThis !== "undefined") {
      globalSrc = globalThis.__TREZOR_CONNECT_SRC;
    }
    if (typeof globalSrc === "string") {
      settings2.connectSrc = globalSrc;
      settings2.debug = true;
    }
    if (typeof input.env !== "string") {
      settings2.env = (0, exports$12.getEnv)();
    }
    return (0, connectSettings_12.parseConnectSettings)(settings2);
  };
  exports$12.parseConnectSettings = parseConnectSettings;
})(connectSettings$1);
var coreInIframe = {};
var config = {};
var hasRequiredConfig;
function requireConfig() {
  if (hasRequiredConfig) return config;
  hasRequiredConfig = 1;
  Object.defineProperty(config, "__esModule", {
    value: true
  });
  config.config = void 0;
  const constants_12 = requireConstants();
  config.config = {
    webusb: constants_12.TREZOR_USB_DESCRIPTORS,
    whitelist: [{
      origin: "chrome-extension://imloifkgjagghnncjkhggdhalmcnfklk",
      priority: 1
    }, {
      origin: "chrome-extension://niebkpllfhmpfbffbfifagfgoamhpflf",
      priority: 1
    }, {
      origin: "file://",
      priority: 2
    }, {
      origin: "trezor.io",
      priority: 0
    }, {
      origin: "sldev.cz",
      priority: 0
    }, {
      origin: "localhost",
      priority: 0
    }, {
      origin: "trezoriovpjcahpzkrewelclulmszwbqpzmzgub37gbcjlvluxtruqad.onion",
      priority: 0
    }],
    management: [{
      origin: "trezor.io"
    }, {
      origin: "sldev.cz"
    }, {
      origin: "localhost"
    }],
    knownHosts: [{
      origin: "imloifkgjagghnncjkhggdhalmcnfklk",
      label: "Trezor Password Manager (Develop)"
    }, {
      origin: "niebkpllfhmpfbffbfifagfgoamhpflf",
      label: "Trezor Password Manager"
    }, {
      origin: "mnpfhpndmjholfdlhpkjfmjkgppmodaf",
      label: "MetaMask"
    }, {
      origin: "webextension@metamask.io",
      label: "MetaMask"
    }, {
      origin: "nkbihfbeogaeaoehlefnkodbefgpgknn",
      label: "MetaMask"
    }, {
      origin: "bfibaipbbpipfifeecgfehbpmfhdakgo",
      label: "Nightly DEV"
    }, {
      origin: "fiikommddbeccaoicoejoniammnalkfa",
      label: "Nightly"
    }, {
      origin: "bpcdaglidgnlggelgbjfagekoapjmccp",
      label: "Rainbow DEV"
    }, {
      origin: "opfgelmcmbiajamepnmloijbpoleiama",
      label: "Rainbow"
    }, {
      origin: "acmacodkjbdgmoleebolmdjonilkdbch",
      label: "Rabby"
    }, {
      origin: "ehnpnhnhcickeknioaiodjmielfaoajd",
      label: "Ambire DEV"
    }, {
      origin: "ehgjhhccekdedpbkifaojjaefeohnoea",
      label: "Ambire"
    }, {
      origin: "file://",
      label: " "
    }],
    onionDomains: {
      "trezor.io": "trezoriovpjcahpzkrewelclulmszwbqpzmzgub37gbcjlvluxtruqad.onion"
    },
    supportedBrowsers: {
      chrome: {
        version: 59,
        download: "https://www.google.com/chrome/",
        update: "https://support.google.com/chrome/answer/95414"
      },
      mobilechrome: {
        version: 59,
        download: "https://www.google.com/chrome/",
        update: "https://support.google.com/chrome/answer/95414"
      },
      chromium: {
        version: 59,
        download: "https://www.chromium.org/",
        update: "https://www.chromium.org/"
      },
      electron: {
        version: 0,
        download: "https://www.electronjs.org/",
        update: "https://www.electronjs.org/"
      },
      firefox: {
        version: 54,
        download: "https://www.mozilla.org/en-US/firefox/new/",
        update: "https://support.mozilla.org/en-US/kb/update-firefox-latest-version"
      },
      mobilefirefox: {
        version: 54,
        download: "https://www.mozilla.org/en-US/firefox/new/",
        update: "https://support.mozilla.org/en-US/kb/update-firefox-latest-version"
      },
      brave: {
        version: 59,
        download: "https://brave.com/download/",
        update: "https://brave.com/download/"
      },
      edge: {
        version: 79,
        download: "https://www.microsoft.com/en-us/edge",
        update: "https://www.microsoft.com/en-us/edge"
      },
      opera: {
        version: 95,
        download: "https://www.opera.com/download",
        update: "https://www.opera.com/download"
      }
    },
    supportedFirmware: [{
      coin: ["xrp", "txrp"],
      methods: ["getAccountInfo"],
      min: {
        T1B1: "0",
        T2T1: "2.1.0"
      },
      max: void 0,
      comment: ["Since firmware 2.1.0 there is a new protobuf field 'destination_tag' in RippleSignTx"]
    }, {
      coin: ["bnb"],
      min: {
        T1B1: "1.9.0",
        T2T1: "2.3.0"
      },
      comment: ["There were protobuf backwards incompatible changes with introduction of 1.9.0/2.3.0 firmwares"]
    }, {
      coin: ["eth", "tsep", "thod"],
      min: {
        T1B1: "1.8.0",
        T2T1: "2.1.0"
      },
      comment: ["There were protobuf backwards incompatible changes."]
    }, {
      coin: ["ada", "tada"],
      min: {
        T1B1: "0",
        T2T1: "2.4.3"
      },
      comment: ["Since 2.4.3 there is initialize.derive_cardano message"]
    }, {
      methods: ["rippleGetAddress", "rippleSignTransaction"],
      min: {
        T1B1: "0",
        T2T1: "2.1.0"
      },
      comment: ["Since firmware 2.1.0 there is a new protobuf field 'destination_tag' in RippleSignTx"]
    }, {
      methods: ["cardanoGetAddress", "cardanoGetPublicKey"],
      min: {
        T1B1: "0",
        T2T1: "2.4.3"
      },
      comment: ["Since 2.4.3 Cardano derivation behavior has changed"]
    }, {
      methods: ["cardanoSignTransaction"],
      min: {
        T1B1: "0",
        T2T1: "2.6.0"
      },
      comment: ["Before 2.6.0 not all Cardano transactions were supported"]
    }, {
      methods: ["cardanoGetNativeScriptHash"],
      min: {
        T1B1: "0",
        T2T1: "2.4.3"
      },
      comment: ["Since 2.4.3 Cardano derivation behavior has changed"]
    }, {
      methods: ["tezosSignTransaction"],
      min: {
        T1B1: "0",
        T2T1: "2.1.8"
      },
      comment: ["Since 2.1.8 there are new protobuf fields in tezos transaction (Babylon fork)"]
    }, {
      methods: ["stellarSignTransaction"],
      min: {
        T1B1: "1.9.0",
        T2T1: "2.3.0"
      },
      comment: ["There were protobuf backwards incompatible changes with introduction of 1.9.0/2.3.0 firmwares"]
    }, {
      capabilities: ["replaceTransaction", "amountUnit"],
      min: {
        T1B1: "1.9.4",
        T2T1: "2.3.5"
      },
      comment: ["new sign tx process since 1.9.4/2.3.5"]
    }, {
      capabilities: ["decreaseOutput"],
      min: {
        T1B1: "1.10.0",
        T2T1: "2.4.0"
      },
      comment: ["allow reduce output in RBF transaction since 1.10.0/2.4.0"]
    }, {
      capabilities: ["eip1559"],
      min: {
        T1B1: "1.10.4",
        T2T1: "2.4.2"
      },
      comment: ["new eth transaction pricing mechanism (EIP1559) since 1.10.4/2.4.2"]
    }, {
      capabilities: ["taproot", "signMessageNoScriptType"],
      min: {
        T1B1: "1.10.4",
        T2T1: "2.4.3"
      },
      comment: ["new btc accounts taproot since 1.10.4/2.4.3 (BTC + TEST only)", "SignMessage with no_script_type support"]
    }, {
      coin: ["dcr", "tdcr"],
      methods: ["signTransaction"],
      min: {
        T1B1: "1.10.1",
        T2T1: "2.4.0"
      },
      comment: [""]
    }, {
      methods: ["ethereumSignTypedData"],
      min: {
        T1B1: "1.10.5",
        T2T1: "2.4.3"
      },
      comment: ["EIP-712 typed signing support added in 1.10.5/2.4.3"]
    }, {
      capabilities: ["eip712-domain-only"],
      min: {
        T1B1: "1.10.6",
        T2T1: "2.4.4"
      },
      comment: ["EIP-712 domain-only signing, when primaryType=EIP712Domain"]
    }, {
      capabilities: ["coinjoin"],
      methods: ["authorizeCoinjoin", "cancelCoinjoinAuthorization", "getOwnershipId", "getOwnershipProof", "setBusy", "unlockPath"],
      min: {
        T1B1: "1.12.1",
        T2T1: "2.5.3"
      }
    }, {
      capabilities: ["tutorial"],
      methods: ["showDeviceTutorial"],
      min: {
        T1B1: "0",
        T2T1: "0",
        T3T1: "2.8.0"
      }
    }, {
      methods: ["authenticateDevice"],
      min: {
        T1B1: "0",
        T2T1: "0",
        T3T1: "2.8.0"
      }
    }, {
      capabilities: ["tropicDeviceAuthentication"],
      min: {
        T2B1: "0",
        T3B1: "0",
        T3T1: "0",
        T3W1: "2.9.3"
      }
    }, {
      capabilities: ["getFirmwareHash"],
      methods: ["getFirmwareHash"],
      min: {
        T1B1: "1.11.1",
        T2T1: "2.5.1"
      }
    }, {
      methods: ["solanaGetPublicKey", "solanaGetAddress", "solanaSignTransaction"],
      min: {
        T1B1: "0",
        T2T1: "2.6.4",
        T2B1: "2.6.4"
      }
    }, {
      capabilities: ["chunkify"],
      min: {
        T1B1: "0",
        T2T1: "2.6.3",
        T2B1: "2.6.3"
      },
      comment: ["Since firmware 2.6.3 there is a new protobuf field 'chunkify' in almost all getAddress and signTx methods"]
    }, {
      methods: ["changeLanguage"],
      min: {
        T1B1: "0",
        T2T1: "2.7.0",
        T2B1: "2.7.0"
      }
    }, {
      capabilities: ["entropyCheck"],
      min: {
        T1B1: "1.13.1",
        T2T1: "2.8.7",
        T2B1: "2.8.7",
        T3B1: "2.8.7",
        T3T1: "2.8.7"
      }
    }, {
      capabilities: ["evmApproval"],
      min: {
        T1B1: "0",
        T2T1: "2.9.0",
        T2B1: "2.9.0",
        T3B1: "2.9.0",
        T3T1: "2.9.0"
      },
      comment: ["EVM approval flow for ERC20 tokens, introduced in firmware 2.9.0"]
    }, {
      capabilities: ["slip24"],
      methods: ["getNonce"],
      min: {
        T1B1: "0",
        T2T1: "2.9.1",
        T2B1: "2.9.1",
        T3B1: "2.9.1",
        T3T1: "2.9.1"
      },
      comment: ["Since firmware 2.9.1 SLIP-24 is supported"]
    }, {
      methods: ["cardanoSignMessage"],
      min: {
        T1B1: "0",
        T2T1: "2.9.1",
        T2B1: "2.9.1",
        T3B1: "2.9.1",
        T3T1: "2.9.1"
      },
      comment: ["Cardano SignMessage call added in 2.9.1"]
    }, {
      capabilities: ["evolu"],
      methods: ["evoluGetNode", "evoluSignRegistrationRequest", "evoluGetDelegatedIdentityKey"],
      min: {
        T1B1: "0",
        T2T1: "2.9.5",
        T2B1: "2.9.5",
        T3B1: "2.9.5",
        T3T1: "2.9.5"
      }
    }, {
      capabilities: ["monero"],
      methods: ["moneroGetAddress", "moneroGetWatchKey", "moneroKeyImageSync", "moneroSignTransaction"],
      min: {
        T1B1: "0",
        T2T1: "2.5.3",
        T2B1: "2.5.3"
      }
    }]
  };
  return config;
}
var debug = {};
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug;
  hasRequiredDebug = 1;
  Object.defineProperty(debug, "__esModule", {
    value: true
  });
  debug.getLog = debug.enableLogByPrefix = debug.enableLog = debug.setLogWriter = debug.initLog = void 0;
  const utils_12 = lib$4;
  const green = "#bada55";
  const blue = "#20abd8";
  const orange = "#f4a744";
  const yellow = "#fbd948";
  const colors = {
    "@trezor/connect": `color: ${blue}; background: #000;`,
    "@trezor/connect-web": `color: ${blue}; background: #000;`,
    "@trezor/connect-webextension": `color: ${blue}; background: #000;`,
    IFrame: `color: ${orange}; background: #000;`,
    Core: `color: ${orange}; background: #000;`,
    DeviceList: `color: ${green}; background: #000;`,
    Device: `color: ${green}; background: #000;`,
    DeviceCommands: `color: ${green}; background: #000;`,
    "@trezor/transport": `color: ${green}; background: #000;`,
    InteractionTimeout: `color: ${green}; background: #000;`,
    "@trezor/connect-popup": `color: ${yellow}; background: #000;`
  };
  const logsManager2 = new utils_12.LogsManager({
    colors
  });
  debug.initLog = logsManager2.initLog.bind(logsManager2);
  debug.setLogWriter = logsManager2.setLogWriter.bind(logsManager2);
  debug.enableLog = logsManager2.enableLog.bind(logsManager2);
  debug.enableLogByPrefix = logsManager2.enableLogByPrefix.bind(logsManager2);
  debug.getLog = logsManager2.getLog.bind(logsManager2);
  return debug;
}
var iframe$1 = {};
var urlUtils = {};
var hasRequiredUrlUtils;
function requireUrlUtils() {
  if (hasRequiredUrlUtils) return urlUtils;
  hasRequiredUrlUtils = 1;
  Object.defineProperty(urlUtils, "__esModule", {
    value: true
  });
  urlUtils.getOnionDomain = urlUtils.getHost = urlUtils.getOrigin = void 0;
  const utils_12 = lib$4;
  const getOrigin = (url) => {
    if (typeof url !== "string") return "unknown";
    if (url.indexOf("file://") === 0) return "file://";
    const [origin] = url.match(/^https?:\/\/[^/]+/) ?? [];
    return origin ?? "unknown";
  };
  urlUtils.getOrigin = getOrigin;
  const getHost = (url) => {
    if (typeof url !== "string") return;
    const [, , uri] = url.match(/^(https?):\/\/([^:/]+)?/i) ?? [];
    if (uri) {
      const parts = uri.split(".");
      if (parts[parts.length - 1] === "localhost") return "localhost";
      return parts.length > 2 ? parts.slice(parts.length - 2, parts.length).join(".") : uri;
    }
  };
  urlUtils.getHost = getHost;
  const getOnionDomain = (url, dict) => {
    if (Array.isArray(url)) return url.map((u) => (0, utils_12.urlToOnion)(u, dict) ?? u);
    if (typeof url === "string") return (0, utils_12.urlToOnion)(url, dict) ?? url;
    return url;
  };
  urlUtils.getOnionDomain = getOnionDomain;
  return urlUtils;
}
var inlineStyles = {};
var hasRequiredInlineStyles;
function requireInlineStyles() {
  if (hasRequiredInlineStyles) return inlineStyles;
  hasRequiredInlineStyles = 1;
  Object.defineProperty(inlineStyles, "__esModule", {
    value: true
  });
  const css = '.trezorconnect-container{position:fixed!important;display:-webkit-box!important;display:-webkit-flex!important;display:-ms-flexbox!important;display:flex!important;-webkit-box-orient:vertical!important;-webkit-box-direction:normal!important;-webkit-flex-direction:column!important;-ms-flex-direction:column!important;flex-direction:column!important;-webkit-box-align:center!important;-webkit-align-items:center!important;-ms-flex-align:center!important;align-items:center!important;z-index:10000!important;width:100%!important;height:100%!important;top:0!important;left:0!important;background:rgba(0,0,0,.35)!important;overflow:auto!important;padding:20px!important;margin:0!important}.trezorconnect-container .trezorconnect-window{position:relative!important;display:block!important;width:370px!important;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif!important;margin:auto!important;border-radius:3px!important;background-color:#fff!important;text-align:center!important;overflow:hidden!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head{text-align:left;padding:12px 24px!important;display:-webkit-box!important;display:-webkit-flex!important;display:-ms-flexbox!important;display:flex!important;-webkit-box-align:center!important;-webkit-align-items:center!important;-ms-flex-align:center!important;align-items:center!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-logo{-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close{cursor:pointer!important;height:24px!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close svg{fill:#757575;-webkit-transition:fill .3s ease-in-out!important;transition:fill .3s ease-in-out!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close:hover svg{fill:#494949}.trezorconnect-container .trezorconnect-window .trezorconnect-body{padding:24px 24px 32px!important;background:#FBFBFB!important;border-top:1px solid #EBEBEB}.trezorconnect-container .trezorconnect-window .trezorconnect-body h3{color:#505050!important;font-size:16px!important;font-weight:500!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body p{margin:8px 0 24px!important;font-weight:400!important;color:#A9A9A9!important;font-size:12px!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button{width:100%!important;padding:12px 24px!important;margin:0!important;border-radius:3px!important;font-size:14px!important;font-weight:300!important;cursor:pointer!important;background:#01B757!important;color:#fff!important;border:0!important;-webkit-transition:background-color .3s ease-in-out!important;transition:background-color .3s ease-in-out!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button:hover{background-color:#00AB51!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button:active{background-color:#009546!important}/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImlucHV0IiwiJHN0ZGluIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNBLHlCQUNJLFNBQUEsZ0JBQ0EsUUFBQSxzQkFDQSxRQUFBLHVCQUNBLFFBQUEsc0JBRUEsUUFBQSxlQUNBLG1CQUFBLG1CQUNBLHNCQUFBLGlCQUNBLHVCQUFBLGlCQUNBLG1CQUFBLGlCQUNBLGVBQUEsaUJBRUEsa0JBQUEsaUJBQ0Esb0JBQUEsaUJBQ0EsZUFBQSxpQkNmTSxZQUFhLGlCREFyQixRQUFTLGdCQWtCSCxNQUFBLGVBQ0EsT0FBQSxlQUNBLElBQUEsWUFDQSxLQUFBLFlBQ0EsV0FBQSwwQkFDQSxTQUFBLGVBQ0EsUUFBQSxlQUNBLE9BQUEsWUNkUiwrQ0RYRSxTQUFVLG1CQTZCQSxRQUFBLGdCQUNBLE1BQUEsZ0JBQ0EsWUFBQSxjQUFBLG1CQUFBLFdBQUEsT0FBQSxpQkFBQSxNQUFBLHFCQUNBLE9BQUEsZUNmVixjQUFlLGNEakJmLGlCQWlCRSxlQWtCWSxXQUFBLGlCQ2ZkLFNBQVUsaUJEbUJJLG1FQUNBLFdBQUEsS0NoQmQsUUFBUyxLQUFLLGVEeEJkLFFBQVMsc0JBMENTLFFBQUEsdUJBQ0EsUUFBQSxzQkNmbEIsUUFBUyxlRGlCSyxrQkE1QlosaUJBOEJvQixvQkFBQSxpQkNoQmxCLGVBQWdCLGlCRC9CWixZQWlCTixpQkFzQ1EsdUZBQ0EsaUJBQUEsRUNwQlYsYUFBYyxFRHBDVixTQUFVLEVBMkRBLEtBQUEsRUFFQSx3RkNwQmQsT0FBUSxrQkR6Q1IsT0FBUSxlQWlFTSw0RkFDQSxLQUFBLFFBQ0EsbUJBQUEsS0FBQSxJQUFBLHNCQ3BCZCxXQUFZLEtBQUssSUFBSyxzQkR3QlIsa0dBQ0EsS0FBQSxRQUVBLG1FQUNBLFFBQUEsS0FBQSxLQUFBLGVBQ0EsV0FBQSxrQkFDQSxXQUFBLElBQUEsTUFBQSxRQUVBLHNFQUNBLE1BQUEsa0JBQ0EsVUFBQSxlQ3JCZCxZQUFhLGNEd0JLLHFFQ3JCbEIsT0FBUSxJQUFJLEVBQUksZUR3QkYsWUFBQSxjQUNJLE1BQUEsa0JDdEJsQixVQUFXLGVBRWIsMEVBQ0UsTUFBTyxlQUNQLFFBQVMsS0FBSyxlQUNkLE9BQVEsWUFDUixjQUFlLGNBQ2YsVUFBVyxlQUNYLFlBQWEsY0FDYixPQUFRLGtCQUNSLFdBQVksa0JBQ1osTUFBTyxlQUNQLE9BQVEsWUFDUixtQkFBb0IsaUJBQWlCLElBQUssc0JBQzFDLFdBQVksaUJBQWlCLElBQUssc0JBRXBDLGdGQUNFLGlCQUFrQixrQkFFcEIsaUZBQ0UsaUJBQWtCIn0= */';
  inlineStyles.default = css;
  return inlineStyles;
}
var hasRequiredIframe;
function requireIframe() {
  if (hasRequiredIframe) return iframe$1;
  hasRequiredIframe = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.initIframeLogger = exports$12.clearTimeout = exports$12.postMessage = exports$12.init = exports$12.dispose = exports$12.error = exports$12.timeout = exports$12.initPromise = exports$12.origin = exports$12.instance = void 0;
    const tslib_12 = require$$0$1;
    const ERRORS2 = tslib_12.__importStar(requireErrors$4());
    const events_12 = events;
    const debug_12 = requireDebug();
    const urlUtils_1 = requireUrlUtils();
    const utils_12 = lib$4;
    const inlineStyles_1 = tslib_12.__importDefault(requireInlineStyles());
    exports$12.initPromise = (0, utils_12.createDeferred)();
    exports$12.timeout = 0;
    const dispose = () => {
      if (exports$12.instance && exports$12.instance.parentNode) {
        try {
          exports$12.instance.parentNode.removeChild(exports$12.instance);
        } catch {
        }
      }
      exports$12.instance = null;
      exports$12.timeout = 0;
    };
    exports$12.dispose = dispose;
    const handleIframeBlocked = () => {
      window.clearTimeout(exports$12.timeout);
      exports$12.error = ERRORS2.TypedError("Init_IframeBlocked");
      (0, exports$12.dispose)();
      exports$12.initPromise.reject(exports$12.error);
    };
    const injectStyleSheet = () => {
      if (!exports$12.instance) {
        throw ERRORS2.TypedError("Init_IframeBlocked");
      }
      const doc = exports$12.instance.ownerDocument;
      const head = doc.head || doc.getElementsByTagName("head")[0];
      const style = document.createElement("style");
      style.setAttribute("type", "text/css");
      style.setAttribute("id", "TrezorConnectStylesheet");
      if (style.styleSheet) {
        style.styleSheet.cssText = inlineStyles_1.default;
        head.appendChild(style);
      } else {
        style.appendChild(document.createTextNode(inlineStyles_1.default));
        head.append(style);
      }
    };
    const init = async (settings2) => {
      exports$12.initPromise = (0, utils_12.createDeferred)();
      const existedFrame = document.getElementById("trezorconnect");
      if (existedFrame) {
        exports$12.instance = existedFrame;
      } else {
        exports$12.instance = document.createElement("iframe");
        exports$12.instance.frameBorder = "0";
        exports$12.instance.width = "0px";
        exports$12.instance.height = "0px";
        exports$12.instance.style.position = "absolute";
        exports$12.instance.style.display = "none";
        exports$12.instance.style.border = "0px";
        exports$12.instance.style.width = "0px";
        exports$12.instance.style.height = "0px";
        exports$12.instance.id = "trezorconnect";
      }
      let src;
      if (settings2.env === "web") {
        const manifestString = settings2.manifest ? JSON.stringify(settings2.manifest) : "undefined";
        const manifest = `version=${settings2.version}&manifest=${encodeURIComponent(btoa(JSON.stringify(manifestString)))}`;
        src = `${settings2.iframeSrc}?${manifest}`;
      } else {
        src = settings2.iframeSrc;
      }
      if (!src.startsWith("http://") && !src.startsWith("https://")) {
        return;
      }
      exports$12.instance.setAttribute("src", src);
      if (navigator.usb) {
        exports$12.instance.setAttribute("allow", "usb");
      }
      exports$12.origin = (0, urlUtils_1.getOrigin)(exports$12.instance.src);
      exports$12.timeout = window.setTimeout(() => {
        exports$12.initPromise.reject(ERRORS2.TypedError("Init_IframeTimeout"));
      }, 1e4);
      const onLoad = () => {
        var _a, _b;
        if (!exports$12.instance) {
          exports$12.initPromise.reject(ERRORS2.TypedError("Init_IframeBlocked"));
          return;
        }
        try {
          const iframeOrigin = (_a = exports$12.instance.contentWindow) == null ? void 0 : _a.location.origin;
          if (!iframeOrigin || iframeOrigin === "null") {
            handleIframeBlocked();
            return;
          }
        } catch {
        }
        let extension;
        if (typeof chrome !== "undefined" && chrome.runtime && typeof chrome.runtime.onConnect !== "undefined") {
          chrome.runtime.onConnect.addListener(() => {
          });
          extension = chrome.runtime.id;
        }
        (_b = exports$12.instance.contentWindow) == null ? void 0 : _b.postMessage({
          type: events_12.IFRAME.INIT,
          payload: {
            settings: settings2,
            extension
          }
        }, exports$12.origin);
        exports$12.instance.onload = null;
      };
      if (exports$12.instance.attachEvent) {
        exports$12.instance.attachEvent("onload", onLoad);
      } else {
        exports$12.instance.onload = onLoad;
      }
      if (document.body) {
        document.body.appendChild(exports$12.instance);
        injectStyleSheet();
      }
      try {
        await exports$12.initPromise.promise;
      } catch (e) {
        if (exports$12.instance) {
          if (exports$12.instance.parentNode) {
            exports$12.instance.parentNode.removeChild(exports$12.instance);
          }
          exports$12.instance = null;
        }
        throw e;
      } finally {
        window.clearTimeout(exports$12.timeout);
        exports$12.timeout = 0;
      }
    };
    exports$12.init = init;
    const postMessage = (message2) => {
      var _a;
      if (!exports$12.instance) {
        throw ERRORS2.TypedError("Init_IframeBlocked");
      }
      (_a = exports$12.instance.contentWindow) == null ? void 0 : _a.postMessage(message2, exports$12.origin);
    };
    exports$12.postMessage = postMessage;
    const clearTimeout2 = () => {
      window.clearTimeout(exports$12.timeout);
    };
    exports$12.clearTimeout = clearTimeout2;
    const initIframeLogger = () => {
      const logWriterFactory = () => ({
        add: (message2) => {
          (0, exports$12.postMessage)({
            type: events_12.IFRAME.LOG,
            payload: message2
          });
        }
      });
      (0, debug_12.setLogWriter)(logWriterFactory);
    };
    exports$12.initIframeLogger = initIframeLogger;
  })(iframe$1);
  return iframe$1;
}
var popup$2 = {};
var serviceworkerWindow = {};
var abstract = {};
var hasRequiredAbstract;
function requireAbstract() {
  if (hasRequiredAbstract) return abstract;
  hasRequiredAbstract = 1;
  Object.defineProperty(abstract, "__esModule", {
    value: true
  });
  abstract.AbstractMessageChannel = void 0;
  const utils_12 = lib$4;
  class AbstractMessageChannel extends utils_12.TypedEmitter {
    constructor({
      sendFn,
      channel,
      logger,
      lazyHandshake = false,
      legacyMode = false
    }) {
      super();
      __publicField(this, "messagePromises", {});
      __publicField(this, "messagesQueue", []);
      __publicField(this, "messageID", 0);
      __publicField(this, "isConnected", false);
      __publicField(this, "handshakeMaxRetries", 5);
      __publicField(this, "handshakeRetryInterval", 2e3);
      __publicField(this, "handshakeFinished");
      __publicField(this, "lazyHandshake");
      __publicField(this, "legacyMode");
      __publicField(this, "logger");
      __publicField(this, "sendFn");
      __publicField(this, "channel");
      this.channel = channel;
      this.sendFn = sendFn;
      this.lazyHandshake = lazyHandshake;
      this.legacyMode = legacyMode;
      this.logger = logger;
    }
    init() {
      if (!this.handshakeFinished) {
        this.handshakeFinished = (0, utils_12.createDeferred)();
        if (this.legacyMode) {
          setTimeout(() => {
            var _a;
            (_a = this.handshakeFinished) == null ? void 0 : _a.resolve();
          }, 500);
        }
        if (!this.lazyHandshake) {
          this.handshakeWithPeer();
        }
      }
      return this.handshakeFinished.promise;
    }
    handshakeWithPeer() {
      var _a;
      (_a = this.logger) == null ? void 0 : _a.log(this.channel.here, "handshake");
      return (0, utils_12.scheduleAction)(async () => {
        var _a2;
        this.postMessage({
          type: "channel-handshake-request",
          data: {
            success: true,
            payload: void 0
          }
        }, {
          usePromise: false,
          useQueue: false
        });
        await ((_a2 = this.handshakeFinished) == null ? void 0 : _a2.promise);
      }, {
        attempts: this.handshakeMaxRetries,
        timeout: this.handshakeRetryInterval
      }).then(() => {
        var _a2;
        (_a2 = this.logger) == null ? void 0 : _a2.log(this.channel.here, "handshake confirmed");
        this.messagesQueue.forEach((message2) => {
          message2.channel = this.channel;
          this.sendFn(message2);
        });
        this.messagesQueue = [];
      }).catch(() => {
        var _a2;
        (_a2 = this.handshakeFinished) == null ? void 0 : _a2.reject(new Error("handshake failed"));
        this.handshakeFinished = void 0;
      });
    }
    onMessage(_message) {
      var _a, _b;
      let message2 = _message;
      if (this.legacyMode && message2.type === void 0 && "data" in message2 && typeof message2.data === "object" && message2.data !== null && "type" in message2.data && typeof message2.data.type === "string") {
        message2 = message2.data;
      }
      const {
        channel,
        id,
        type: type2,
        ...data
      } = message2;
      if (!this.legacyMode) {
        if (!(channel == null ? void 0 : channel.peer) || channel.peer !== this.channel.here) {
          return;
        }
        if (!(channel == null ? void 0 : channel.here) || this.channel.peer !== channel.here) {
          return;
        }
      }
      if (type2 === "channel-handshake-request") {
        this.postMessage({
          type: "channel-handshake-confirm",
          data: {
            success: true,
            payload: void 0
          }
        }, {
          usePromise: false,
          useQueue: false
        });
        if (this.lazyHandshake) {
          this.handshakeWithPeer();
        }
        return;
      }
      if (type2 === "channel-handshake-confirm") {
        (_a = this.handshakeFinished) == null ? void 0 : _a.resolve(void 0);
        return;
      }
      if (this.messagePromises[id]) {
        this.messagePromises[id].resolve({
          id,
          ...data
        });
        delete this.messagePromises[id];
      }
      const messagePromisesLength = Object.keys(this.messagePromises).length;
      if (messagePromisesLength > 5) {
        (_b = this.logger) == null ? void 0 : _b.warn(`too many message promises (${messagePromisesLength}). this feels unexpected!`);
      }
      this.emit("message", message2);
    }
    postMessage(message2, {
      usePromise = true,
      useQueue = true
    } = {}) {
      message2.channel = this.channel;
      if (!usePromise) {
        try {
          this.sendFn(message2);
        } catch {
          if (useQueue) {
            this.messagesQueue.push(message2);
          }
        }
        return;
      }
      this.messageID++;
      message2.id = this.messageID;
      this.messagePromises[message2.id] = (0, utils_12.createDeferred)();
      try {
        this.sendFn(message2);
      } catch {
        if (useQueue) {
          this.messagesQueue.push(message2);
        }
      }
      return this.messagePromises[message2.id].promise;
    }
    resolveMessagePromises(resolvePayload) {
      Object.keys(this.messagePromises).forEach((id) => this.messagePromises[id].resolve({
        id,
        payload: resolvePayload
      }));
    }
    clear() {
      this.handshakeFinished = void 0;
    }
  }
  abstract.AbstractMessageChannel = AbstractMessageChannel;
  return abstract;
}
var hasRequiredServiceworkerWindow;
function requireServiceworkerWindow() {
  if (hasRequiredServiceworkerWindow) return serviceworkerWindow;
  hasRequiredServiceworkerWindow = 1;
  Object.defineProperty(serviceworkerWindow, "__esModule", {
    value: true
  });
  serviceworkerWindow.ServiceWorkerWindowChannel = void 0;
  const abstract_1 = requireAbstract();
  class ServiceWorkerWindowChannel extends abstract_1.AbstractMessageChannel {
    constructor({
      name,
      channel,
      logger,
      lazyHandshake,
      legacyMode,
      allowSelfOrigin = false,
      currentId
    }) {
      super({
        channel,
        sendFn: (message2) => {
          if (!this.port) throw new Error("port not assigned");
          this.port.postMessage(message2);
        },
        logger,
        lazyHandshake,
        legacyMode
      });
      __publicField(this, "port");
      __publicField(this, "name");
      __publicField(this, "allowSelfOrigin");
      __publicField(this, "currentId");
      this.name = name;
      this.allowSelfOrigin = allowSelfOrigin;
      this.currentId = currentId;
      this.connect();
    }
    connect() {
      chrome.runtime.onConnect.addListener((port) => {
        var _a, _b, _c, _d;
        if (port.name !== this.name) return;
        if (((_a = this.currentId) == null ? void 0 : _a.call(this)) && ((_b = this.currentId) == null ? void 0 : _b.call(this)) !== ((_d = (_c = port.sender) == null ? void 0 : _c.tab) == null ? void 0 : _d.id)) return;
        this.port = port;
        this.port.onMessage.addListener((message2, {
          sender
        }) => {
          var _a2, _b2, _c2, _d2, _e;
          if (!sender) {
            (_a2 = this.logger) == null ? void 0 : _a2.error("service-worker-window", "no sender");
            return;
          }
          const {
            origin
          } = sender;
          const whitelist = ["https://connect.trezor.io", "https://staging-connect.trezor.io", "https://suite.corp.sldev.cz", "https://dev.suite.sldev.cz", "http://localhost:8088", "https://suite.trezor.io", "https://staging-suite.trezor.io", "http://localhost:8000"];
          const webextensionId = (_b2 = chrome == null ? void 0 : chrome.runtime) == null ? void 0 : _b2.id;
          if (webextensionId) {
            whitelist.push(`chrome-extension://${webextensionId}`);
          }
          const webextensionUrl = (_c2 = chrome == null ? void 0 : chrome.runtime) == null ? void 0 : _c2.getURL("");
          if (webextensionUrl) {
            whitelist.push(webextensionUrl.slice(0, -1));
          }
          if (!origin) {
            (_d2 = this.logger) == null ? void 0 : _d2.error("connect-webextension/messageChannel/extensionPort/onMessage", "no origin");
            return;
          }
          if (!whitelist.includes(origin)) {
            (_e = this.logger) == null ? void 0 : _e.error("connect-webextension/messageChannel/extensionPort/onMessage", "origin not whitelisted", origin);
            return;
          }
          if (origin === self.origin && !this.allowSelfOrigin) {
            return;
          }
          this.onMessage(message2);
        });
      });
      this.isConnected = true;
    }
    disconnect() {
      var _a;
      if (!this.isConnected) return;
      (_a = this.port) == null ? void 0 : _a.disconnect();
      this.clear();
      this.isConnected = false;
    }
  }
  serviceworkerWindow.ServiceWorkerWindowChannel = ServiceWorkerWindowChannel;
  return serviceworkerWindow;
}
var windowWindow = {};
var hasRequiredWindowWindow;
function requireWindowWindow() {
  if (hasRequiredWindowWindow) return windowWindow;
  hasRequiredWindowWindow = 1;
  Object.defineProperty(windowWindow, "__esModule", {
    value: true
  });
  windowWindow.WindowWindowChannel = void 0;
  const abstract_1 = requireAbstract();
  class WindowWindowChannel extends abstract_1.AbstractMessageChannel {
    constructor({
      windowHere,
      windowPeer,
      channel,
      logger,
      origin,
      legacyMode
    }) {
      super({
        channel,
        sendFn: (message2) => {
          var _a;
          (_a = windowPeer()) == null ? void 0 : _a.postMessage(message2, origin);
        },
        logger,
        legacyMode
      });
      __publicField(this, "_windowHere");
      __publicField(this, "_listener");
      this._listener = this.listener.bind(this);
      this._windowHere = windowHere;
      this.connect();
    }
    listener(event) {
      const message2 = {
        ...event.data,
        success: true,
        origin: event.origin,
        payload: event.data.payload || {},
        channel: event.data.channel || {
          peer: this.channel.here,
          here: this.channel.peer
        }
      };
      this.onMessage(message2);
    }
    connect() {
      this._windowHere.addEventListener("message", this._listener);
      this.isConnected = true;
    }
    disconnect() {
      if (!this.isConnected) return;
      this._windowHere.removeEventListener("message", this._listener);
      this.isConnected = false;
    }
  }
  windowWindow.WindowWindowChannel = WindowWindowChannel;
  return windowWindow;
}
var showPopupRequest = {};
var hasRequiredShowPopupRequest;
function requireShowPopupRequest() {
  if (hasRequiredShowPopupRequest) return showPopupRequest;
  hasRequiredShowPopupRequest = 1;
  Object.defineProperty(showPopupRequest, "__esModule", {
    value: true
  });
  showPopupRequest.showPopupRequest = void 0;
  const LAYER_ID = "TrezorConnectInteractionLayer";
  const HTML = `
    <div class="trezorconnect-container" id="${LAYER_ID}">
        <div class="trezorconnect-window">
            <div class="trezorconnect-head">
                <svg class="trezorconnect-logo" x="0px" y="0px" viewBox="0 0 163.7 41.9" width="78px" height="20px" preserveAspectRatio="xMinYMin meet">
                    <polygon points="101.1,12.8 118.2,12.8 118.2,17.3 108.9,29.9 118.2,29.9 118.2,35.2 101.1,35.2 101.1,30.7 110.4,18.1 101.1,18.1"/>
                    <path d="M158.8,26.9c2.1-0.8,4.3-2.9,4.3-6.6c0-4.5-3.1-7.4-7.7-7.4h-10.5v22.3h5.8v-7.5h2.2l4.1,7.5h6.7L158.8,26.9z M154.7,22.5 h-4V18h4c1.5,0,2.5,0.9,2.5,2.2C157.2,21.6,156.2,22.5,154.7,22.5z"/>
                    <path d="M130.8,12.5c-6.8,0-11.6,4.9-11.6,11.5s4.9,11.5,11.6,11.5s11.7-4.9,11.7-11.5S137.6,12.5,130.8,12.5z M130.8,30.3 c-3.4,0-5.7-2.6-5.7-6.3c0-3.8,2.3-6.3,5.7-6.3c3.4,0,5.8,2.6,5.8,6.3C136.6,27.7,134.2,30.3,130.8,30.3z"/>
                    <polygon points="82.1,12.8 98.3,12.8 98.3,18 87.9,18 87.9,21.3 98,21.3 98,26.4 87.9,26.4 87.9,30 98.3,30 98.3,35.2 82.1,35.2 "/>
                    <path d="M24.6,9.7C24.6,4.4,20,0,14.4,0S4.2,4.4,4.2,9.7v3.1H0v22.3h0l14.4,6.7l14.4-6.7h0V12.9h-4.2V9.7z M9.4,9.7 c0-2.5,2.2-4.5,5-4.5s5,2,5,4.5v3.1H9.4V9.7z M23,31.5l-8.6,4l-8.6-4V18.1H23V31.5z"/>
                    <path d="M79.4,20.3c0-4.5-3.1-7.4-7.7-7.4H61.2v22.3H67v-7.5h2.2l4.1,7.5H80l-4.9-8.3C77.2,26.1,79.4,24,79.4,20.3z M71,22.5h-4V18 h4c1.5,0,2.5,0.9,2.5,2.2C73.5,21.6,72.5,22.5,71,22.5z"/>
                    <polygon points="40.5,12.8 58.6,12.8 58.6,18.1 52.4,18.1 52.4,35.2 46.6,35.2 46.6,18.1 40.5,18.1 "/>
                </svg>
                <div class="trezorconnect-close">
                    <svg x="0px" y="0px" viewBox="24 24 60 60" width="24px" height="24px" preserveAspectRatio="xMinYMin meet">
                        <polygon class="st0" points="40,67.9 42.1,70 55,57.1 67.9,70 70,67.9 57.1,55 70,42.1 67.9,40 55,52.9 42.1,40 40,42.1 52.9,55 "/>
                    </svg>
                </div>
            </div>
            <div class="trezorconnect-body">
                <h3>Popup was blocked</h3>
                <p>Please click to "Continue" to open popup manually</p>
                <button class="trezorconnect-open">Continue</button>
            </div>
        </div>
    </div>
`;
  const showPopupRequest$1 = (open, cancel) => {
    if (document.getElementById(LAYER_ID)) {
      return;
    }
    const div = document.createElement("div");
    div.id = LAYER_ID;
    div.className = "trezorconnect-container";
    div.innerHTML = HTML;
    if (document.body) {
      document.body.appendChild(div);
    }
    const button2 = div.getElementsByClassName("trezorconnect-open")[0];
    button2.onclick = () => {
      open();
      if (document.body) {
        document.body.removeChild(div);
      }
    };
    const close = div.getElementsByClassName("trezorconnect-close")[0];
    close.onclick = () => {
      cancel();
      if (document.body) {
        document.body.removeChild(div);
      }
    };
  };
  showPopupRequest.showPopupRequest = showPopupRequest$1;
  return showPopupRequest;
}
var hasRequiredPopup;
function requirePopup() {
  if (hasRequiredPopup) return popup$2;
  hasRequiredPopup = 1;
  Object.defineProperty(popup$2, "__esModule", {
    value: true
  });
  popup$2.PopupManager = void 0;
  const tslib_12 = require$$0$1;
  const events_12 = tslib_12.__importDefault(requireEvents());
  const version_1 = version;
  const events_22 = events;
  const urlUtils_1 = requireUrlUtils();
  const serviceworker_window_1 = requireServiceworkerWindow();
  const window_window_1 = requireWindowWindow();
  const utils_12 = lib$4;
  const showPopupRequest_1 = requireShowPopupRequest();
  const checkIfTabExists = (tabId) => new Promise((resolve) => {
    if (!tabId) return resolve(false);
    function callback() {
      if (chrome.runtime.lastError) {
        resolve(false);
      } else {
        resolve(true);
      }
    }
    chrome.tabs.get(tabId, callback);
  });
  const POPUP_REQUEST_TIMEOUT = 850;
  const POPUP_CLOSE_INTERVAL = 500;
  const POPUP_OPEN_TIMEOUT = 5e3;
  class PopupManager extends events_12.default {
    constructor(settings2, {
      logger
    }) {
      var _a;
      super();
      __publicField(this, "popupWindow");
      __publicField(this, "settings");
      __publicField(this, "origin");
      __publicField(this, "locked", false);
      __publicField(this, "channel");
      __publicField(this, "channelIframe");
      __publicField(this, "handshakePromise");
      __publicField(this, "iframeHandshakePromise");
      __publicField(this, "popupPromise");
      __publicField(this, "requestTimeout");
      __publicField(this, "openTimeout");
      __publicField(this, "closeInterval");
      __publicField(this, "extensionTabId", 0);
      __publicField(this, "logger");
      __publicField(this, "injectContentScript", (tabId) => {
        chrome.permissions.getAll((permissions) => {
          var _a;
          if ((_a = permissions.permissions) == null ? void 0 : _a.includes("scripting")) {
            (0, utils_12.scheduleAction)(() => chrome.scripting.executeScript({
              target: {
                tabId
              },
              func: () => {
              }
            }).then(() => {
              this.logger.debug("content script injected");
            }).catch((error2) => {
              this.logger.error("content script injection error", error2);
              throw error2;
            }), {
              attempts: new Array(3).fill({
                timeout: 100
              })
            });
          }
        });
      });
      this.settings = settings2;
      this.origin = (0, urlUtils_1.getOrigin)(settings2.popupSrc);
      this.logger = logger;
      if (this.isWebExtensionWithTab()) {
        this.channel = new serviceworker_window_1.ServiceWorkerWindowChannel({
          name: "trezor-connect",
          channel: {
            here: "@trezor/connect-webextension",
            peer: "@trezor/connect-content-script"
          },
          logger,
          currentId: () => {
            var _a2, _b;
            if (((_a2 = this.popupWindow) == null ? void 0 : _a2.mode) === "tab") return (_b = this.popupWindow) == null ? void 0 : _b.tab.id;
          },
          legacyMode: !this.settings.useCoreInPopup
        });
      } else {
        this.channel = new window_window_1.WindowWindowChannel({
          windowHere: window,
          windowPeer: () => {
            var _a2, _b;
            if (((_a2 = this.popupWindow) == null ? void 0 : _a2.mode) === "window") return (_b = this.popupWindow) == null ? void 0 : _b.window;
          },
          channel: {
            here: "@trezor/connect-web",
            peer: "@trezor/connect-popup"
          },
          logger,
          origin: this.origin,
          legacyMode: !this.settings.useCoreInPopup
        });
      }
      if (!this.settings.useCoreInPopup) {
        this.iframeHandshakePromise = (0, utils_12.createDeferred)(events_22.IFRAME.LOADED);
        this.channelIframe = new window_window_1.WindowWindowChannel({
          windowHere: window,
          windowPeer: () => window,
          channel: {
            here: "@trezor/connect-web",
            peer: "@trezor/connect-iframe"
          },
          logger,
          origin: this.origin
        });
        (_a = this.channelIframe) == null ? void 0 : _a.on("message", this.handleMessage.bind(this));
      }
      if (this.settings.useCoreInPopup) {
        this.handshakePromise = (0, utils_12.createDeferred)();
        this.channel.on("message", this.handleCoreMessage.bind(this));
        return;
      } else if (this.isWebExtensionWithTab()) {
        this.channel.on("message", this.handleExtensionMessage.bind(this));
      } else {
        this.channel.on("message", this.handleMessage.bind(this));
      }
      this.channel.init();
    }
    async request() {
      var _a, _b, _c, _d, _e;
      if (this.settings.useCoreInPopup && ((_a = this.popupWindow) == null ? void 0 : _a.mode) === "tab") {
        const currentPopupExists = await checkIfTabExists((_c = (_b = this.popupWindow) == null ? void 0 : _b.tab) == null ? void 0 : _c.id);
        if (!currentPopupExists) {
          this.clear();
        }
      }
      if (this.locked) {
        if (((_d = this.popupWindow) == null ? void 0 : _d.mode) === "tab" && this.popupWindow.tab.id) {
          chrome.tabs.update(this.popupWindow.tab.id, {
            active: true
          });
        } else if (((_e = this.popupWindow) == null ? void 0 : _e.mode) === "window") {
          this.popupWindow.window.focus();
        }
        return;
      }
      if (this.popupWindow && !this.locked) {
        this.close();
      }
      const openFn = this.open.bind(this);
      this.locked = true;
      const timeout = this.settings.env === "webextension" ? 1 : POPUP_REQUEST_TIMEOUT;
      this.requestTimeout = setTimeout(() => {
        this.requestTimeout = void 0;
        openFn();
      }, timeout);
    }
    unlock() {
      this.locked = false;
    }
    open() {
      const src = this.settings.popupSrc;
      this.popupPromise = (0, utils_12.createDeferred)(events_22.POPUP.LOADED);
      const url = this.buildPopupUrl(src);
      this.openWrapper(url);
      this.closeInterval = setInterval(() => {
        if (!this.popupWindow) return;
        if (this.popupWindow.mode === "tab" && this.popupWindow.tab.id) {
          chrome.tabs.get(this.popupWindow.tab.id, (tab) => {
            if (!tab) {
              this.emitClosed();
              this.clear();
            }
          });
        } else if (this.popupWindow.mode === "window" && this.popupWindow.window.closed) {
          this.clear();
          this.emitClosed();
        }
      }, POPUP_CLOSE_INTERVAL);
      if (this.settings.useCoreInPopup) {
        return;
      }
      this.openTimeout = setTimeout(() => {
        this.clear();
        (0, showPopupRequest_1.showPopupRequest)(this.open.bind(this), () => {
          this.emitClosed();
        });
      }, POPUP_OPEN_TIMEOUT);
    }
    buildPopupUrl(src) {
      var _a;
      const params2 = new URLSearchParams();
      params2.set("version", version_1.VERSION);
      params2.set("env", this.settings.env);
      if (this.settings.env === "webextension" && ((_a = chrome == null ? void 0 : chrome.runtime) == null ? void 0 : _a.id)) {
        params2.set("extension-id", chrome.runtime.id);
        params2.set("cs-ver", version_1.CONTENT_SCRIPT_VERSION.toString());
      }
      return src + "?" + params2.toString();
    }
    openWrapper(url) {
      if (this.isWebExtensionWithTab()) {
        chrome.windows.getCurrent((currentWindow) => {
          this.logger.debug("opening popup. currentWindow: ", currentWindow);
          if (currentWindow.type !== "normal") {
            chrome.windows.create({
              url
            }, (newWindow) => {
              chrome.tabs.query({
                windowId: newWindow == null ? void 0 : newWindow.id,
                active: true
              }, (tabs) => {
                this.popupWindow = {
                  mode: "tab",
                  tab: tabs[0]
                };
                this.injectContentScript(tabs[0].id);
              });
            });
          } else {
            chrome.tabs.query({
              currentWindow: true,
              active: true
            }, (tabs) => {
              this.extensionTabId = tabs[0].id;
              chrome.tabs.create({
                url,
                index: tabs[0].index + 1
              }, (tab) => {
                this.popupWindow = {
                  mode: "tab",
                  tab
                };
                this.injectContentScript(tab.id);
              });
            });
          }
        });
      } else {
        const windowResult = window.open(url, "modal");
        if (!windowResult) return;
        this.popupWindow = {
          mode: "window",
          window: windowResult
        };
      }
      if (!this.channel.isConnected) {
        this.channel.connect();
      }
    }
    handleCoreMessage(message2) {
      var _a;
      if (message2.type === events_22.POPUP.BOOTSTRAP) {
        this.channel.init();
      } else if (message2.type === events_22.POPUP.LOADED) {
        this.handleMessage(message2);
        this.channel.postMessage({
          type: events_22.POPUP.INIT,
          payload: {
            settings: this.settings,
            useCore: true
          }
        });
      } else if (message2.type === events_22.POPUP.CORE_LOADED) {
        this.channel.postMessage({
          type: events_22.POPUP.HANDSHAKE,
          payload: {
            settings: this.settings
          }
        });
        (_a = this.handshakePromise) == null ? void 0 : _a.resolve();
      } else if (message2.type === events_22.POPUP.CLOSED) {
        this.emitClosed();
      } else if (message2.type === events_22.POPUP.CONTENT_SCRIPT_LOADED) {
        const {
          contentScriptVersion
        } = message2.payload;
        if (contentScriptVersion !== version_1.CONTENT_SCRIPT_VERSION) {
          console.warn(`Content script version mismatch. Expected ${version_1.CONTENT_SCRIPT_VERSION}, got ${contentScriptVersion}`);
        }
      } else if (message2.event === events_22.DEVICE_EVENT) {
        this.emit(events_22.DEVICE_EVENT, message2);
      }
    }
    handleExtensionMessage(data) {
      if (data.type === events_22.POPUP.ERROR || data.type === events_22.POPUP.LOADED || data.type === events_22.POPUP.BOOTSTRAP) {
        this.handleMessage(data);
      } else if (data.type === events_22.POPUP.EXTENSION_USB_PERMISSIONS) {
        chrome.tabs.query({
          currentWindow: true,
          active: true
        }, (tabs) => {
          chrome.tabs.create({
            url: "trezor-usb-permissions.html",
            index: tabs[0].index + 1
          }, (_tab) => {
          });
        });
      } else if (data.type === events_22.POPUP.CLOSE_WINDOW) {
        this.clear();
      }
    }
    handleMessage(data) {
      var _a, _b;
      if (data.type === events_22.IFRAME.LOADED) {
        (_a = this.iframeHandshakePromise) == null ? void 0 : _a.resolve(data.payload);
      } else if (data.type === events_22.POPUP.BOOTSTRAP) {
        if (this.openTimeout) clearTimeout(this.openTimeout);
      } else if (data.type === events_22.POPUP.ERROR && this.popupWindow) {
        const errorMessage = data.payload && typeof data.payload.error === "string" ? data.payload.error : null;
        this.emit(events_22.POPUP.CLOSED, errorMessage ? `Popup error: ${errorMessage}` : null);
        this.clear();
      } else if (data.type === events_22.POPUP.LOADED) {
        if (this.openTimeout) clearTimeout(this.openTimeout);
        if (this.popupPromise) {
          this.popupPromise.resolve();
          this.popupPromise = void 0;
        }
        (_b = this.iframeHandshakePromise) == null ? void 0 : _b.promise.then((payload) => {
          this.channel.postMessage({
            type: events_22.POPUP.INIT,
            payload: {
              ...payload,
              settings: this.settings
            }
          });
        });
      } else if (data.type === events_22.POPUP.CANCEL_POPUP_REQUEST) {
        clearTimeout(this.requestTimeout);
        if (this.popupPromise) {
          this.close();
        }
        this.unlock();
      } else if (data.type === events_22.UI.CLOSE_UI_WINDOW) {
        this.clear(false);
      }
    }
    clear(focus = true) {
      this.locked = false;
      this.popupPromise = void 0;
      this.handshakePromise = (0, utils_12.createDeferred)();
      if (this.channel) {
        this.channel.disconnect();
      }
      if (this.requestTimeout) {
        clearTimeout(this.requestTimeout);
        this.requestTimeout = void 0;
      }
      if (this.openTimeout) {
        clearTimeout(this.openTimeout);
        this.openTimeout = void 0;
      }
      if (this.closeInterval) {
        clearInterval(this.closeInterval);
        this.closeInterval = void 0;
      }
      if (focus && this.extensionTabId) {
        chrome.tabs.update(this.extensionTabId, {
          active: true
        });
        this.extensionTabId = 0;
      }
    }
    close() {
      var _a;
      if (!this.popupWindow) return;
      this.logger.debug("closing popup");
      if (this.popupWindow.mode === "tab") {
        let _e = chrome.runtime.lastError;
        if (this.popupWindow.tab.id) {
          chrome.tabs.remove(this.popupWindow.tab.id, () => {
            _e = chrome.runtime.lastError;
            if (_e) {
              this.logger.error("closed with error", _e);
            }
          });
        }
      } else if (this.popupWindow.mode === "window") {
        this.popupWindow.window.close();
      }
      this.popupWindow = void 0;
      if ((_a = this.settings) == null ? void 0 : _a.useCoreInPopup) {
        this.channel.clear();
      }
    }
    isWebExtensionWithTab() {
      var _a;
      return ((_a = this.settings) == null ? void 0 : _a.env) === "webextension" && typeof chrome !== "undefined" && typeof (chrome == null ? void 0 : chrome.tabs) !== "undefined";
    }
    emitClosed() {
      var _a;
      if ((_a = this.settings) == null ? void 0 : _a.useCoreInPopup) {
        this.channel.resolveMessagePromises({
          code: "Method_Interrupted",
          error: events_22.POPUP.CLOSED
        });
      }
      this.emit(events_22.POPUP.CLOSED);
    }
  }
  popup$2.PopupManager = PopupManager;
  return popup$2;
}
var button = {};
var hasRequiredButton;
function requireButton() {
  if (hasRequiredButton) return button;
  hasRequiredButton = 1;
  Object.defineProperty(button, "__esModule", {
    value: true
  });
  const render = (className = "", url) => {
    const query = className || ".trezor-webusb-button";
    const buttons = document.querySelectorAll(query);
    const src = `${url}?${Date.now()}`;
    buttons.forEach((b) => {
      if (b.getElementsByTagName("iframe").length < 1) {
        const bounds = b.getBoundingClientRect();
        const btnIframe = document.createElement("iframe");
        btnIframe.frameBorder = "0";
        btnIframe.width = `${Math.round(bounds.width)}px`;
        btnIframe.height = `${Math.round(bounds.height)}px`;
        btnIframe.style.position = "absolute";
        btnIframe.style.top = "0px";
        btnIframe.style.left = "0px";
        btnIframe.style.zIndex = "1";
        btnIframe.setAttribute("allow", "usb");
        btnIframe.setAttribute("scrolling", "no");
        btnIframe.src = src;
        b.append(btnIframe);
      }
    });
  };
  button.default = render;
  return button;
}
Object.defineProperty(coreInIframe, "__esModule", {
  value: true
});
coreInIframe.TrezorConnect = coreInIframe.CoreInIframe = void 0;
const tslib_1$3 = require$$0$1;
const events_1$3 = tslib_1$3.__importDefault(requireEvents());
const ERRORS$3 = tslib_1$3.__importStar(requireErrors$4());
const config_1 = requireConfig();
const events_2$3 = events;
const factory_1$3 = factory;
const debug_1$2 = requireDebug();
const createDeferredManager_1 = requireCreateDeferredManager();
const connectSettings_1$3 = connectSettings$1;
const iframe = tslib_1$3.__importStar(requireIframe());
const popup$1 = tslib_1$3.__importStar(requirePopup());
const button_1 = tslib_1$3.__importDefault(requireButton());
class CoreInIframe {
  constructor() {
    __publicField(this, "eventEmitter", new events_1$3.default());
    __publicField(this, "_settings");
    __publicField(this, "_log");
    __publicField(this, "_popupManager");
    __publicField(this, "_messagePromises");
    __publicField(this, "boundHandleMessage", this.handleMessage.bind(this));
    __publicField(this, "boundDispose", this.dispose.bind(this));
    this._settings = (0, connectSettings_1$3.parseConnectSettings)();
    this._log = (0, debug_1$2.initLog)("@trezor/connect-web");
    this._messagePromises = (0, createDeferredManager_1.createDeferredManager)({
      initialId: 1
    });
  }
  initPopupManager() {
    const pm = new popup$1.PopupManager(this._settings, {
      logger: this._log
    });
    pm.on(events_2$3.POPUP.CLOSED, (error2) => {
      iframe.postMessage({
        type: events_2$3.POPUP.CLOSED,
        payload: error2 ? {
          error: error2
        } : null
      });
    });
    return pm;
  }
  manifest(data) {
    this._settings = (0, connectSettings_1$3.parseConnectSettings)({
      ...this._settings,
      manifest: data
    });
  }
  dispose() {
    this.eventEmitter.removeAllListeners();
    iframe.dispose();
    this._settings = (0, connectSettings_1$3.parseConnectSettings)();
    if (this._popupManager) {
      this._popupManager.close();
    }
    window.removeEventListener("message", this.boundHandleMessage);
    window.removeEventListener("unload", this.boundDispose);
    return Promise.resolve(void 0);
  }
  cancel(error2) {
    if (this._popupManager) {
      this._popupManager.emit(events_2$3.POPUP.CLOSED, error2);
    }
  }
  handleMessage(messageEvent) {
    if (messageEvent.origin !== iframe.origin) return;
    const message2 = (0, events_2$3.parseMessage)(messageEvent.data);
    this._log.log("handleMessage", message2);
    switch (message2.event) {
      case events_2$3.RESPONSE_EVENT: {
        const {
          id = 0,
          success,
          payload,
          device: device2
        } = message2;
        const resolved = this._messagePromises.resolve(id, {
          id,
          success,
          payload,
          device: device2
        });
        if (!resolved) this._log.warn(`Unknown message id ${id}`);
        break;
      }
      case events_2$3.DEVICE_EVENT:
        this.eventEmitter.emit(message2.event, message2);
        this.eventEmitter.emit(message2.type, message2.payload);
        break;
      case events_2$3.TRANSPORT_EVENT:
        this.eventEmitter.emit(message2.event, message2);
        this.eventEmitter.emit(message2.type, message2.payload);
        break;
      case events_2$3.BLOCKCHAIN_EVENT:
        this.eventEmitter.emit(message2.event, message2);
        this.eventEmitter.emit(message2.type, message2.payload);
        break;
      case events_2$3.UI_EVENT:
        if (message2.type === events_2$3.IFRAME.BOOTSTRAP) {
          iframe.clearTimeout();
          break;
        }
        if (message2.type === events_2$3.IFRAME.LOADED) {
          iframe.initPromise.resolve();
        }
        if (message2.type === events_2$3.IFRAME.ERROR) {
          iframe.initPromise.reject(message2.payload.error);
        }
        this.eventEmitter.emit(message2.event, message2);
        this.eventEmitter.emit(message2.type, message2.payload);
        break;
      default:
        this._log.log("Undefined message", messageEvent.data);
    }
  }
  async init(settings2) {
    var _a, _b;
    if (iframe.instance) {
      throw ERRORS$3.TypedError("Init_AlreadyInitialized");
    }
    this._settings = (0, connectSettings_1$3.parseConnectSettings)({
      ...this._settings,
      ...settings2
    });
    if (!this._settings.manifest) {
      throw ERRORS$3.TypedError("Init_ManifestMissing");
    }
    if (!((_a = this._settings.transports) == null ? void 0 : _a.length)) {
      this._settings.transports = ["BridgeTransport", "WebUsbTransport"];
    }
    if (!this._settings.coreMode) {
      this._settings.coreMode = "auto";
    }
    if (this._settings.lazyLoad) {
      this._settings.lazyLoad = false;
      return;
    }
    if (!this._popupManager) {
      this._popupManager = this.initPopupManager();
    }
    this._log.enabled = !!this._settings.debug;
    window.addEventListener("message", this.boundHandleMessage);
    window.addEventListener("unload", this.boundDispose);
    await iframe.init(this._settings);
    if (this._settings.coreMode === "auto") {
      const {
        promiseId,
        promise: promise2
      } = this._messagePromises.create();
      this._log.debug("coreMode = auto, Checking bridge availability");
      iframe.postMessage({
        id: promiseId,
        type: events_2$3.TRANSPORT.GET_INFO
      });
      const response = await promise2;
      this._log.debug("Bridge availability response", response);
      if (response.payload === void 0 && navigator.usb && ((_b = this._settings.transports) == null ? void 0 : _b.includes("WebUsbTransport"))) {
        throw ERRORS$3.TypedError("Transport_Missing");
      }
    }
    if (this._settings.sharedLogger !== false) {
      iframe.initIframeLogger();
    }
  }
  setTransports() {
    throw new Error("Unsupported right now");
  }
  async call(params2) {
    if (!iframe.instance && !iframe.timeout) {
      this._settings = (0, connectSettings_1$3.parseConnectSettings)(this._settings);
      if (!this._settings.manifest) {
        return (0, events_2$3.createErrorMessage)(ERRORS$3.TypedError("Init_ManifestMissing"));
      }
      if (!this._popupManager) {
        this._popupManager = this.initPopupManager();
      }
      try {
        await this.init(this._settings);
      } catch (error2) {
        if (this._popupManager) {
          this._popupManager.clear();
        }
        return (0, events_2$3.createErrorMessage)(error2);
      }
    }
    if (iframe.timeout) {
      await iframe.initPromise.promise;
    }
    if (iframe.error) {
      return (0, events_2$3.createErrorMessage)(iframe.error);
    }
    if (this._settings.popup && this._popupManager) {
      this._popupManager.request();
    }
    try {
      const {
        promiseId,
        promise: promise2
      } = this._messagePromises.create();
      iframe.postMessage({
        id: promiseId,
        type: events_2$3.IFRAME.CALL,
        payload: params2
      });
      const response = await promise2;
      if (response) {
        if (!response.success && response.payload.code !== "Device_CallInProgress" && this._popupManager) {
          this._popupManager.unlock();
        }
        return response;
      }
      if (this._popupManager) {
        this._popupManager.unlock();
      }
      return (0, events_2$3.createErrorMessage)(ERRORS$3.TypedError("Method_NoResponse"));
    } catch (error2) {
      this._log.error("__call error", error2);
      if (this._popupManager) {
        this._popupManager.clear(false);
      }
      return (0, events_2$3.createErrorMessage)(error2);
    }
  }
  uiResponse(response) {
    if (!iframe.instance) {
      throw ERRORS$3.TypedError("Init_NotInitialized");
    }
    iframe.postMessage(response);
  }
  renderWebUSBButton(className) {
    (0, button_1.default)(className, this._settings.webusbSrc);
  }
  disableWebUSB() {
    if (!iframe.instance) {
      throw ERRORS$3.TypedError("Init_NotInitialized");
    }
    iframe.postMessage({
      type: events_2$3.TRANSPORT.DISABLE_WEBUSB
    });
  }
  async requestWebUSBDevice() {
    try {
      await window.navigator.usb.requestDevice({
        filters: config_1.config.webusb
      });
      iframe.postMessage({
        type: events_2$3.TRANSPORT.REQUEST_DEVICE
      });
    } catch {
    }
  }
}
coreInIframe.CoreInIframe = CoreInIframe;
const impl$3 = new CoreInIframe();
coreInIframe.TrezorConnect = (0, factory_1$3.factory)({
  eventEmitter: impl$3.eventEmitter,
  init: impl$3.init.bind(impl$3),
  call: impl$3.call.bind(impl$3),
  setTransports: impl$3.setTransports.bind(impl$3),
  manifest: impl$3.manifest.bind(impl$3),
  uiResponse: impl$3.uiResponse.bind(impl$3),
  cancel: impl$3.cancel.bind(impl$3),
  dispose: impl$3.dispose.bind(impl$3)
}, {
  renderWebUSBButton: impl$3.renderWebUSBButton.bind(impl$3),
  disableWebUSB: impl$3.disableWebUSB.bind(impl$3),
  requestWebUSBDevice: impl$3.requestWebUSBDevice.bind(impl$3)
});
var coreInPopup = {};
Object.defineProperty(coreInPopup, "__esModule", {
  value: true
});
coreInPopup.TrezorConnect = coreInPopup.CoreInPopup = void 0;
const tslib_1$2 = require$$0$1;
const events_1$2 = tslib_1$2.__importDefault(requireEvents());
const ERRORS$2 = tslib_1$2.__importStar(requireErrors$4());
const events_2$2 = events;
const factory_1$2 = factory;
const debug_1$1 = requireDebug();
const utils_1 = lib$4;
const connectSettings_1$2 = connectSettings$1;
const popup = tslib_1$2.__importStar(requirePopup());
class CoreInPopup {
  constructor() {
    __publicField(this, "eventEmitter", new events_1$2.default());
    __publicField(this, "_settings");
    __publicField(this, "logger");
    __publicField(this, "popupManagerLogger");
    __publicField(this, "_popupManager");
    this._settings = (0, connectSettings_1$2.parseConnectSettings)();
    this.logger = (0, debug_1$1.initLog)("@trezor/connect-web");
    this.popupManagerLogger = (0, debug_1$1.initLog)("@trezor/connect-web/popupManager");
  }
  logWriterFactory(popupManager) {
    return {
      add: (message2) => {
        popupManager.channel.postMessage({
          event: events_2$2.UI_EVENT,
          type: events_2$2.IFRAME.LOG,
          payload: message2
        }, {
          usePromise: false,
          useQueue: true
        });
      }
    };
  }
  manifest(data) {
    this._settings = (0, connectSettings_1$2.parseConnectSettings)({
      ...this._settings,
      manifest: data
    });
  }
  dispose() {
    this.eventEmitter.removeAllListeners();
    this._settings = (0, connectSettings_1$2.parseConnectSettings)();
    if (this._popupManager) {
      this._popupManager.close();
    }
    return Promise.resolve(void 0);
  }
  cancel(error2) {
    if (this._popupManager) {
      this._popupManager.emit(events_2$2.POPUP.CLOSED, error2);
    }
  }
  init(settings2) {
    var _a, _b;
    const oldSettings = (0, connectSettings_1$2.parseConnectSettings)({
      ...this._settings
    });
    const newSettings = (0, connectSettings_1$2.parseConnectSettings)({
      ...this._settings,
      ...settings2
    });
    if (!((_a = newSettings.transports) == null ? void 0 : _a.length)) {
      newSettings.transports = ["BridgeTransport", "WebUsbTransport"];
    }
    newSettings.useCoreInPopup = true;
    if (typeof window !== "undefined" && ((_b = window == null ? void 0 : window.location) == null ? void 0 : _b.origin)) {
      newSettings.origin = window.location.origin;
    }
    const equalSettings = JSON.stringify(oldSettings) === JSON.stringify(newSettings);
    this._settings = newSettings;
    if (!this._popupManager || !equalSettings) {
      if (this._popupManager) this._popupManager.close();
      this._popupManager = new popup.PopupManager(this._settings, {
        logger: this.popupManagerLogger
      });
      this._popupManager.on(events_2$2.DEVICE_EVENT, (event) => {
        this.eventEmitter.emit(events_2$2.DEVICE_EVENT, event);
      });
      (0, debug_1$1.setLogWriter)(() => this.logWriterFactory(this._popupManager));
    }
    this.logger.enabled = !!settings2.debug;
    if (!this._settings.manifest) {
      throw ERRORS$2.TypedError("Init_ManifestMissing");
    }
    this.logger.debug("initiated");
    return Promise.resolve();
  }
  setTransports() {
    throw new Error("Unsupported right now");
  }
  async call(params2) {
    this.logger.debug("call", params2);
    if (!this._popupManager) {
      return (0, events_2$2.createErrorMessage)(ERRORS$2.TypedError("Init_NotInitialized"));
    }
    if (this._settings.popup) {
      await this._popupManager.request();
    }
    const popupClosed = (0, utils_1.createDeferred)();
    const popupClosedHandler = () => {
      this.logger.log("Popup closed during initialization");
      popupClosed.reject(ERRORS$2.TypedError("Method_Interrupted"));
    };
    this._popupManager.once(events_2$2.POPUP.CLOSED, popupClosedHandler);
    try {
      this.logger.debug("call: popup initialing");
      await Promise.race([popupClosed.promise, this.callInit()]);
      this.logger.debug("call: popup initialized");
      const response = await this._popupManager.channel.postMessage({
        type: events_2$2.IFRAME.CALL,
        payload: params2
      });
      this.logger.debug("call: response: ", response);
      if (response) {
        if (this._popupManager && response.success) {
          this._popupManager.clear();
        }
        return {
          success: response.success,
          payload: response.payload,
          device: response.device
        };
      }
      throw ERRORS$2.TypedError("Method_NoResponse");
    } catch (error2) {
      this.logger.error("call: error", error2);
      this._popupManager.clear(false);
      return (0, events_2$2.createErrorMessage)(error2);
    } finally {
      this._popupManager.removeListener(events_2$2.POPUP.CLOSED, popupClosedHandler);
    }
  }
  async callInit() {
    var _a, _b;
    if (!this._popupManager) {
      throw ERRORS$2.TypedError("Init_NotInitialized");
    }
    await this._popupManager.channel.init();
    if (this._settings.env === "webextension") {
      await ((_a = this._popupManager.popupPromise) == null ? void 0 : _a.promise);
      this._popupManager.channel.postMessage({
        type: events_2$2.POPUP.INIT,
        payload: {
          settings: this._settings,
          useCore: true
        }
      });
    }
    await ((_b = this._popupManager.handshakePromise) == null ? void 0 : _b.promise);
  }
  uiResponse(response) {
    var _a, _b;
    const {
      type: type2,
      payload
    } = response;
    (_b = (_a = this._popupManager) == null ? void 0 : _a.channel) == null ? void 0 : _b.postMessage({
      event: events_2$2.UI_EVENT,
      type: type2,
      payload
    });
  }
  renderWebUSBButton() {
  }
  disableWebUSB() {
    throw ERRORS$2.TypedError("Method_InvalidPackage");
  }
  requestWebUSBDevice() {
    throw ERRORS$2.TypedError("Method_InvalidPackage");
  }
}
coreInPopup.CoreInPopup = CoreInPopup;
const impl$2 = new CoreInPopup();
coreInPopup.TrezorConnect = (0, factory_1$2.factory)({
  eventEmitter: impl$2.eventEmitter,
  init: impl$2.init.bind(impl$2),
  call: impl$2.call.bind(impl$2),
  setTransports: impl$2.setTransports.bind(impl$2),
  manifest: impl$2.manifest.bind(impl$2),
  uiResponse: impl$2.uiResponse.bind(impl$2),
  cancel: impl$2.cancel.bind(impl$2),
  dispose: impl$2.dispose.bind(impl$2)
});
var coreInSuiteDesktop = {};
var lib$1 = {};
var client = {};
var wsBrowser = {};
var hasRequiredWsBrowser;
function requireWsBrowser() {
  if (hasRequiredWsBrowser) return wsBrowser;
  hasRequiredWsBrowser = 1;
  Object.defineProperty(wsBrowser, "__esModule", {
    value: true
  });
  const events_12 = requireEvents();
  const client_12 = requireClient();
  const _WSWrapper = class _WSWrapper extends events_12.EventEmitter {
    constructor(url, _protocols, _websocketOptions) {
      super();
      __publicField(this, "_ws");
      this._ws = new WebSocket(url);
      this._ws.onclose = () => {
        this.emit("close");
      };
      this._ws.onopen = () => {
        this.emit("open");
      };
      this._ws.onerror = (_event) => {
        this.emit("error", new client_12.WebsocketError(`WsWrapper error. Ready state: ${this.readyState}`));
      };
      this._ws.onmessage = (message2) => {
        this.emit("message", message2.data);
      };
    }
    close() {
      if (this.readyState === _WSWrapper.OPEN) {
        this._ws.close();
      }
    }
    send(message2) {
      if (this.readyState !== _WSWrapper.OPEN) {
        throw new client_12.WebsocketError(`Connection is not open. state: ${this.readyState}`);
      }
      this._ws.send(message2);
    }
    get readyState() {
      return this._ws.readyState;
    }
  };
  __publicField(_WSWrapper, "CONNECTING", 0);
  __publicField(_WSWrapper, "OPEN", 1);
  __publicField(_WSWrapper, "CLOSING", 2);
  __publicField(_WSWrapper, "CLOSED", 3);
  let WSWrapper = _WSWrapper;
  wsBrowser.default = WSWrapper;
  return wsBrowser;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  Object.defineProperty(client, "__esModule", {
    value: true
  });
  client.WebsocketClient = client.WebsocketError = void 0;
  const tslib_12 = require$$0$1;
  const ws_1 = tslib_12.__importDefault(requireWsBrowser());
  const utils_12 = lib$4;
  const DEFAULT_TIMEOUT = 20 * 1e3;
  const DEFAULT_PING_TIMEOUT = 50 * 1e3;
  class WebsocketError extends Error {
  }
  client.WebsocketError = WebsocketError;
  class WebsocketClient extends utils_12.TypedEmitter {
    constructor(options) {
      super();
      __publicField(this, "options");
      __publicField(this, "messages");
      __publicField(this, "emitter", this);
      __publicField(this, "ws");
      __publicField(this, "pingTimeout");
      __publicField(this, "connectPromise");
      this.options = options;
      this.messages = (0, utils_12.createDeferredManager)({
        timeout: this.options.timeout || DEFAULT_TIMEOUT,
        onTimeout: (promiseId) => this.onMessageTimeout(promiseId)
      });
    }
    ping() {
      return this.sendMessage({
        type: "ping"
      });
    }
    initWebsocket({
      url,
      timeout,
      headers,
      agent
    }) {
      if (typeof url !== "string") {
        throw new WebsocketError("websocket_no_url");
      }
      if (url.startsWith("http")) {
        url = url.replace("http", "ws");
      }
      return new ws_1.default(url, {
        timeout,
        headers: {
          Origin: "https://node.trezor.io",
          ...headers
        },
        agent
      });
    }
    setPingTimeout() {
      clearTimeout(this.pingTimeout);
      const doPing = () => {
        if (this.isConnected()) {
          return this.onPing().catch(() => {
          });
        }
      };
      this.pingTimeout = this.isConnected() ? setTimeout(doPing, this.options.pingTimeout || DEFAULT_PING_TIMEOUT) : void 0;
    }
    onPing() {
      return this.ping();
    }
    onMessageTimeout(_promiseId) {
      const {
        ws
      } = this;
      if (!ws) return;
      this.messages.rejectAll(new WebsocketError("websocket_timeout"));
      ws.close();
    }
    onError() {
      this.onClose();
    }
    sendMessage(message2, {
      timeout
    } = {}) {
      var _a, _b;
      const {
        ws
      } = this;
      if (!ws || !this.isConnected()) throw new WebsocketError("websocket_not_initialized");
      const {
        promiseId,
        promise: promise2
      } = this.messages.create(timeout);
      const req = {
        id: promiseId.toString(),
        ...message2
      };
      this.setPingTimeout();
      (_b = (_a = this.options).onSending) == null ? void 0 : _b.call(_a, message2);
      ws.send(JSON.stringify(req));
      return promise2;
    }
    sendRawMessage(message2) {
      const {
        ws
      } = this;
      if (!ws || !this.isConnected()) throw new WebsocketError("websocket_not_initialized");
      ws.send(message2, {
        binary: typeof message2 !== "string"
      });
      this.setPingTimeout();
    }
    onMessage(message2, messageValidation) {
      try {
        const data = JSON.parse(message2.toString());
        const messageId = Number(data.id);
        try {
          const payload = messageValidation ? messageValidation(data) : data;
          if (payload) {
            this.messages.resolve(messageId, payload);
          }
        } catch (error2) {
          this.messages.reject(messageId, error2);
        }
      } catch {
      } finally {
        this.setPingTimeout();
      }
    }
    async connect() {
      var _a;
      if (this.connectPromise) {
        return this.connectPromise;
      }
      if (this.isConnected()) return Promise.resolve();
      if (((_a = this.ws) == null ? void 0 : _a.readyState) === ws_1.default.CLOSING) {
        await new Promise((resolve) => this.emitter.once("disconnected", resolve));
      }
      const dfd = (0, utils_12.createDeferred)();
      this.connectPromise = dfd.promise;
      const ws = this.createWebsocket ? this.createWebsocket() : this.initWebsocket(this.options);
      const connectionTimeout = setTimeout(() => {
        this.onClose();
        dfd.reject(new WebsocketError("websocket_timeout"));
        try {
          ws.close();
        } catch {
        }
      }, this.options.connectionTimeout || this.options.timeout || DEFAULT_TIMEOUT);
      ws.once("error", (error2) => {
        clearTimeout(connectionTimeout);
        this.onClose();
        dfd.reject(new WebsocketError(error2.message));
      });
      ws.on("open", () => {
        clearTimeout(connectionTimeout);
        this.init();
        dfd.resolve();
      });
      this.ws = ws;
      return dfd.promise.finally(() => {
        this.connectPromise = void 0;
      });
    }
    init() {
      const {
        ws
      } = this;
      if (!ws || !this.isConnected()) {
        throw Error("Websocket init cannot be called");
      }
      ws.removeAllListeners();
      ws.on("error", (_error) => this.onError());
      ws.on("message", (message2) => this.onMessage(message2));
      ws.on("close", () => {
        this.emitter.emit("disconnected");
        this.onClose();
      });
    }
    disconnect() {
      var _a;
      if (this.isConnected()) {
        const disconnectPromise = new Promise((resolve) => {
          var _a2;
          (_a2 = this.ws) == null ? void 0 : _a2.once("close", resolve);
        });
        (_a = this.ws) == null ? void 0 : _a.close();
        return disconnectPromise;
      }
      return Promise.resolve();
    }
    isConnected() {
      var _a;
      return ((_a = this.ws) == null ? void 0 : _a.readyState) === ws_1.default.OPEN;
    }
    onClose() {
      var _a, _b;
      clearTimeout(this.pingTimeout);
      (_a = this.ws) == null ? void 0 : _a.removeAllListeners();
      (_b = this.ws) == null ? void 0 : _b.on("error", () => {
      });
      this.messages.rejectAll(new WebsocketError("Websocket closed unexpectedly"));
    }
    dispose() {
      this.removeAllListeners();
      this.disconnect();
      this.onClose();
    }
  }
  client.WebsocketClient = WebsocketClient;
  return client;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1;
  hasRequiredLib$1 = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.WebsocketClient = void 0;
    var client_12 = requireClient();
    Object.defineProperty(exports$12, "WebsocketClient", {
      enumerable: true,
      get: function() {
        return client_12.WebsocketClient;
      }
    });
  })(lib$1);
  return lib$1;
}
Object.defineProperty(coreInSuiteDesktop, "__esModule", {
  value: true
});
coreInSuiteDesktop.TrezorConnect = coreInSuiteDesktop.CoreInSuiteDesktop = void 0;
const tslib_1$1 = require$$0$1;
const events_1$1 = tslib_1$1.__importDefault(requireEvents());
const ERRORS$1 = tslib_1$1.__importStar(requireErrors$4());
const events_2$1 = events;
const factory_1$1 = factory;
const websocket_client_1 = requireLib$1();
const client_1 = requireClient();
const connectSettings_1$1 = connectSettings$1;
class CoreInSuiteDesktop {
  constructor() {
    __publicField(this, "eventEmitter", new events_1$1.default());
    __publicField(this, "_settings");
    __publicField(this, "ws");
    __publicField(this, "localNetworkPermissionState", "unknown");
    this._settings = (0, connectSettings_1$1.parseConnectSettings)();
    this.ws = new websocket_client_1.WebsocketClient({
      url: "ws://127.0.0.1:21335/connect-ws"
    });
  }
  manifest(data) {
    this._settings = (0, connectSettings_1$1.parseConnectSettings)({
      ...this._settings,
      manifest: data
    });
  }
  dispose() {
    this.eventEmitter.removeAllListeners();
    this._settings = (0, connectSettings_1$1.parseConnectSettings)();
    this.ws.dispose();
    return Promise.resolve(void 0);
  }
  cancel(_error) {
    this.ws.sendMessage({
      type: events_2$1.POPUP.CLOSED,
      payload: {
        error: _error
      }
    });
  }
  async handshake() {
    if (!this.ws) {
      throw ERRORS$1.TypedError("Desktop_ConnectionMissing", "No websocket connection");
    }
    try {
      const response = await this.ws.sendMessage({
        type: events_2$1.POPUP.HANDSHAKE,
        payload: {
          settings: this._settings
        }
      }, {
        timeout: 3e3
      });
      if (!response) {
        throw ERRORS$1.TypedError("Desktop_ConnectionMissing", "No response");
      }
      return response;
    } catch (err) {
      throw ERRORS$1.TypedError("Desktop_ConnectionMissing", err.message);
    }
  }
  async init(settings2) {
    var _a;
    const permission = await navigator.permissions.query({
      name: "local-network-access"
    }).catch(() => void 0);
    if (permission) {
      this.localNetworkPermissionState = permission.state;
      permission.onchange = () => {
        this.localNetworkPermissionState = permission.state;
      };
    }
    const newSettings = (0, connectSettings_1$1.parseConnectSettings)({
      ...this._settings,
      ...settings2
    });
    if (!newSettings.manifest || !newSettings.manifest.appName) {
      throw ERRORS$1.TypedError("Init_ManifestMissing", "Manifest is missing or manifest.appName is not set");
    }
    if (!((_a = newSettings.transports) == null ? void 0 : _a.length)) {
      newSettings.transports = ["BridgeTransport", "WebUsbTransport"];
    }
    this._settings = newSettings;
    return await this.connect();
  }
  error(err) {
    if (err instanceof client_1.WebsocketError) {
      if (this.localNetworkPermissionState === "denied") {
        return ERRORS$1.TypedError("Browser_LocalNetworkPermissionMissing");
      } else {
        return ERRORS$1.TypedError("Desktop_ConnectionMissing", err.message);
      }
    }
    return err;
  }
  async connect() {
    try {
      await this.ws.connect();
    } catch (err) {
      throw this.error(err);
    }
  }
  setTransports() {
    throw new Error("Method_InvalidPackage");
  }
  async call(params2) {
    try {
      if (!this.ws.isConnected()) {
        await this.connect();
      }
      await this.handshake();
      const response = await this.ws.sendMessage({
        type: events_2$1.IFRAME.CALL,
        payload: params2
      }, {
        timeout: 0
      });
      if (!response) {
        throw ERRORS$1.TypedError("Desktop_ConnectionMissing", "No response");
      }
      return response;
    } catch (err) {
      return {
        success: false,
        payload: ERRORS$1.serializeError(this.error(err))
      };
    }
  }
  uiResponse(_response) {
    throw ERRORS$1.TypedError("Method_InvalidPackage");
  }
  disableWebUSB() {
    throw ERRORS$1.TypedError("Method_InvalidPackage");
  }
  requestWebUSBDevice() {
    throw ERRORS$1.TypedError("Method_InvalidPackage");
  }
  renderWebUSBButton() {
  }
}
coreInSuiteDesktop.CoreInSuiteDesktop = CoreInSuiteDesktop;
const impl$1 = new CoreInSuiteDesktop();
coreInSuiteDesktop.TrezorConnect = (0, factory_1$1.factory)({
  eventEmitter: impl$1.eventEmitter,
  init: impl$1.init.bind(impl$1),
  call: impl$1.call.bind(impl$1),
  setTransports: impl$1.setTransports.bind(impl$1),
  manifest: impl$1.manifest.bind(impl$1),
  uiResponse: impl$1.uiResponse.bind(impl$1),
  cancel: impl$1.cancel.bind(impl$1),
  dispose: impl$1.dispose.bind(impl$1)
});
var coreInSuiteWeb = {};
Object.defineProperty(coreInSuiteWeb, "__esModule", {
  value: true
});
coreInSuiteWeb.TrezorConnect = coreInSuiteWeb.CoreInSuiteWeb = void 0;
const tslib_1 = require$$0$1;
const events_1 = tslib_1.__importDefault(requireEvents());
const ERRORS = tslib_1.__importStar(requireErrors$4());
const events_2 = events;
const factory_1 = factory;
const debug_1 = requireDebug();
const connectSettings_1 = connectSettings$1;
const popup_1 = requirePopup();
class CoreInSuiteWeb {
  constructor() {
    __publicField(this, "eventEmitter", new events_1.default());
    __publicField(this, "_settings");
    __publicField(this, "_popupManager");
    __publicField(this, "logger");
    this._settings = (0, connectSettings_1.parseConnectSettings)();
    this.logger = (0, debug_1.initLog)("@trezor/connect-web");
  }
  manifest(data) {
    this._settings = (0, connectSettings_1.parseConnectSettings)({
      ...this._settings,
      manifest: data
    });
  }
  dispose() {
    this.eventEmitter.removeAllListeners();
    this._settings = (0, connectSettings_1.parseConnectSettings)();
    return Promise.resolve(void 0);
  }
  init(settings2) {
    this._settings = (0, connectSettings_1.parseConnectSettings)({
      ...this._settings,
      ...settings2
    });
    this.logger.enabled = !!this._settings.debug;
    if (!this._settings.manifest) {
      throw ERRORS.TypedError("Init_ManifestMissing");
    }
    if (!this._popupManager) {
      this._popupManager = new popup_1.PopupManager({
        ...this._settings,
        useCoreInPopup: true,
        popupSrc: this.getSuiteUrl()
      }, {
        logger: this.logger
      });
      this._popupManager.on(events_2.DEVICE_EVENT, (event) => {
        this.eventEmitter.emit(events_2.DEVICE_EVENT, event);
      });
    }
    this.logger.debug("initiated");
    return Promise.resolve();
  }
  getSuiteUrl() {
    var _a, _b, _c;
    if ((_a = this._settings.connectSrc) == null ? void 0 : _a.startsWith("http://localhost")) {
      return "http://localhost:8000/connect-popup";
    }
    if ((_b = this._settings.connectSrc) == null ? void 0 : _b.startsWith("https://dev.suite.sldev.cz/connect/")) {
      const branch = (_c = this._settings.connectSrc) == null ? void 0 : _c.replace("https://dev.suite.sldev.cz/connect/", "");
      return `https://dev.suite.sldev.cz/suite-web/${branch}web/connect-popup`;
    }
    return "https://suite.trezor.io/web/connect-popup";
  }
  async call(params2) {
    var _a;
    this.logger.debug("call", params2);
    if (!this._popupManager) {
      return (0, events_2.createErrorMessage)(ERRORS.TypedError("Init_NotInitialized"));
    }
    await this._popupManager.request();
    await this._popupManager.channel.init();
    await ((_a = this._popupManager.handshakePromise) == null ? void 0 : _a.promise);
    try {
      const response = await this._popupManager.channel.postMessage({
        type: events_2.IFRAME.CALL,
        payload: params2
      });
      this.logger.debug("call: response: ", response);
      if (!(response == null ? void 0 : response.payload)) {
        throw ERRORS.TypedError("Method_NoResponse");
      }
      if (response.payload.error && response.payload.code) {
        throw response.payload;
      }
      return {
        success: response.payload.success,
        payload: response.payload.payload,
        device: response.payload.device
      };
    } catch (error2) {
      this.logger.error("call: error", error2);
      return (0, events_2.createErrorMessage)(error2);
    }
  }
  cancel(_error) {
    var _a, _b;
    (_b = (_a = this._popupManager) == null ? void 0 : _a.channel) == null ? void 0 : _b.postMessage({
      type: events_2.POPUP.CLOSED,
      payload: {
        error: _error
      }
    });
  }
  setTransports() {
    throw new Error("Method_InvalidPackage");
  }
  uiResponse(_response) {
    throw ERRORS.TypedError("Method_InvalidPackage");
  }
  disableWebUSB() {
    throw ERRORS.TypedError("Method_InvalidPackage");
  }
  requestWebUSBDevice() {
    throw ERRORS.TypedError("Method_InvalidPackage");
  }
  renderWebUSBButton() {
  }
}
coreInSuiteWeb.CoreInSuiteWeb = CoreInSuiteWeb;
const impl = new CoreInSuiteWeb();
coreInSuiteWeb.TrezorConnect = (0, factory_1.factory)({
  eventEmitter: impl.eventEmitter,
  init: impl.init.bind(impl),
  call: impl.call.bind(impl),
  setTransports: impl.setTransports.bind(impl),
  manifest: impl.manifest.bind(impl),
  uiResponse: impl.uiResponse.bind(impl),
  cancel: impl.cancel.bind(impl),
  dispose: impl.dispose.bind(impl)
});
var exports$1 = {};
var types$1 = {};
var api = {};
var hasRequiredApi;
function requireApi() {
  if (hasRequiredApi) return api;
  hasRequiredApi = 1;
  Object.defineProperty(api, "__esModule", {
    value: true
  });
  return api;
}
var account = {};
var hasRequiredAccount;
function requireAccount() {
  if (hasRequiredAccount) return account;
  hasRequiredAccount = 1;
  Object.defineProperty(account, "__esModule", {
    value: true
  });
  return account;
}
var coinInfo = {};
var lib = {};
var firmwareUtils = {};
var modeUtils = {};
var hasRequiredModeUtils;
function requireModeUtils() {
  if (hasRequiredModeUtils) return modeUtils;
  hasRequiredModeUtils = 1;
  Object.defineProperty(modeUtils, "__esModule", {
    value: true
  });
  modeUtils.isDeviceInBootloaderMode = void 0;
  const isDeviceInBootloaderMode = (device2) => {
    var _a;
    return !!((_a = device2 == null ? void 0 : device2.features) == null ? void 0 : _a.bootloader_mode);
  };
  modeUtils.isDeviceInBootloaderMode = isDeviceInBootloaderMode;
  return modeUtils;
}
var types = {};
var hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1) return types;
  hasRequiredTypes$1 = 1;
  Object.defineProperty(types, "__esModule", {
    value: true
  });
  types.FirmwareType = void 0;
  var FirmwareType;
  (function(FirmwareType2) {
    FirmwareType2["BitcoinOnly"] = "bitcoin-only";
    FirmwareType2["Universal"] = "universal";
  })(FirmwareType || (types.FirmwareType = FirmwareType = {}));
  return types;
}
var hasRequiredFirmwareUtils;
function requireFirmwareUtils() {
  if (hasRequiredFirmwareUtils) return firmwareUtils;
  hasRequiredFirmwareUtils = 1;
  Object.defineProperty(firmwareUtils, "__esModule", {
    value: true
  });
  firmwareUtils.isBitcoinOnlyDevice = firmwareUtils.hasBitcoinOnlyFirmware = firmwareUtils.getFirmwareVersion = firmwareUtils.getFirmwareVersionArray = firmwareUtils.getFirmwareRevision = firmwareUtils.getFirmwareSource = void 0;
  const modeUtils_1 = requireModeUtils();
  const types_1 = requireTypes$1();
  const getFirmwareSource = (device2) => {
    var _a, _b, _c, _d;
    if ((device2 == null ? void 0 : device2.mode) === "bootloader") {
      return "NA - bootloader";
    }
    if (((_b = (_a = device2 == null ? void 0 : device2.authenticityChecks) == null ? void 0 : _a.firmwareRevision) == null ? void 0 : _b.success) && ((_d = (_c = device2 == null ? void 0 : device2.authenticityChecks) == null ? void 0 : _c.firmwareHash) == null ? void 0 : _d.success)) {
      return "official";
    }
    return "unknown";
  };
  firmwareUtils.getFirmwareSource = getFirmwareSource;
  const getFirmwareRevision = (device2) => {
    var _a;
    return ((_a = device2 == null ? void 0 : device2.features) == null ? void 0 : _a.revision) || "";
  };
  firmwareUtils.getFirmwareRevision = getFirmwareRevision;
  const getFirmwareVersionArray = (device2) => {
    if (!(device2 == null ? void 0 : device2.features)) {
      return null;
    }
    const {
      features
    } = device2;
    if ((0, modeUtils_1.isDeviceInBootloaderMode)(device2)) {
      return features.fw_major ? [features.fw_major, features.fw_minor, features.fw_patch] : null;
    }
    return [features.major_version, features.minor_version, features.patch_version];
  };
  firmwareUtils.getFirmwareVersionArray = getFirmwareVersionArray;
  const getFirmwareVersion = (device2) => {
    if (!(device2 == null ? void 0 : device2.features)) {
      return "";
    }
    const {
      features
    } = device2;
    if ((0, modeUtils_1.isDeviceInBootloaderMode)(device2)) {
      return features.fw_major ? `${features.fw_major}.${features.fw_minor}.${features.fw_patch}` : "";
    }
    return `${features.major_version}.${features.minor_version}.${features.patch_version}`;
  };
  firmwareUtils.getFirmwareVersion = getFirmwareVersion;
  const hasBitcoinOnlyFirmware = (device2) => (device2 == null ? void 0 : device2.firmwareType) === types_1.FirmwareType.BitcoinOnly;
  firmwareUtils.hasBitcoinOnlyFirmware = hasBitcoinOnlyFirmware;
  const isBitcoinOnlyDevice = (device2) => {
    var _a;
    return !!((_a = device2 == null ? void 0 : device2.features) == null ? void 0 : _a.unit_btconly) && (device2 == null ? void 0 : device2.firmwareType) !== types_1.FirmwareType.Universal;
  };
  firmwareUtils.isBitcoinOnlyDevice = isBitcoinOnlyDevice;
  return firmwareUtils;
}
var bootloaderUtils = {};
var hasRequiredBootloaderUtils;
function requireBootloaderUtils() {
  if (hasRequiredBootloaderUtils) return bootloaderUtils;
  hasRequiredBootloaderUtils = 1;
  Object.defineProperty(bootloaderUtils, "__esModule", {
    value: true
  });
  bootloaderUtils.getBootloaderVersion = bootloaderUtils.getBootloaderHash = void 0;
  const modeUtils_1 = requireModeUtils();
  const getBootloaderHash = (device2) => {
    var _a;
    return ((_a = device2 == null ? void 0 : device2.features) == null ? void 0 : _a.bootloader_hash) || "";
  };
  bootloaderUtils.getBootloaderHash = getBootloaderHash;
  const getBootloaderVersion = (device2) => {
    if (!(device2 == null ? void 0 : device2.features)) {
      return "";
    }
    const {
      features
    } = device2;
    if ((0, modeUtils_1.isDeviceInBootloaderMode)(device2) && features.major_version) {
      return `${features.major_version}.${features.minor_version}.${features.patch_version}`;
    }
    return "";
  };
  bootloaderUtils.getBootloaderVersion = getBootloaderVersion;
  return bootloaderUtils;
}
var deviceModelInternal = {};
var hasRequiredDeviceModelInternal;
function requireDeviceModelInternal() {
  if (hasRequiredDeviceModelInternal) return deviceModelInternal;
  hasRequiredDeviceModelInternal = 1;
  Object.defineProperty(deviceModelInternal, "__esModule", {
    value: true
  });
  deviceModelInternal.DeviceModelInternal = void 0;
  var DeviceModelInternal;
  (function(DeviceModelInternal2) {
    DeviceModelInternal2["T1B1"] = "T1B1";
    DeviceModelInternal2["T2T1"] = "T2T1";
    DeviceModelInternal2["T2B1"] = "T2B1";
    DeviceModelInternal2["T3B1"] = "T3B1";
    DeviceModelInternal2["T3T1"] = "T3T1";
    DeviceModelInternal2["T3W1"] = "T3W1";
    DeviceModelInternal2["UNKNOWN"] = "UNKNOWN";
  })(DeviceModelInternal || (deviceModelInternal.DeviceModelInternal = DeviceModelInternal = {}));
  return deviceModelInternal;
}
var deviceModelInternalUtils = {};
var hasRequiredDeviceModelInternalUtils;
function requireDeviceModelInternalUtils() {
  if (hasRequiredDeviceModelInternalUtils) return deviceModelInternalUtils;
  hasRequiredDeviceModelInternalUtils = 1;
  Object.defineProperty(deviceModelInternalUtils, "__esModule", {
    value: true
  });
  deviceModelInternalUtils.getNarrowedDeviceModelInternal = void 0;
  const deviceModelInternal_1 = requireDeviceModelInternal();
  const getNarrowedDeviceModelInternal = (model) => model === deviceModelInternal_1.DeviceModelInternal.T2B1 ? deviceModelInternal_1.DeviceModelInternal.T3B1 : model;
  deviceModelInternalUtils.getNarrowedDeviceModelInternal = getNarrowedDeviceModelInternal;
  return deviceModelInternalUtils;
}
var models = {};
var hasRequiredModels;
function requireModels() {
  if (hasRequiredModels) return models;
  hasRequiredModels = 1;
  Object.defineProperty(models, "__esModule", {
    value: true
  });
  models.models = void 0;
  const safe3Model = {
    name: "Trezor Safe 3",
    colors: {
      "1": "Cosmic Black",
      "2": "Stellar Silver",
      "3": "Solar Gold",
      "4": "Galactic Rose",
      "5": "Bitcoin Orange"
    }
  };
  models.models = {
    UNKNOWN: {
      name: "Unknown",
      colors: safe3Model.colors
    },
    T1B1: {
      name: "Trezor Model One",
      colors: {}
    },
    T2T1: {
      name: "Trezor Model T",
      colors: {}
    },
    T2B1: safe3Model,
    T3B1: safe3Model,
    T3T1: {
      name: "Trezor Safe 5",
      colors: {
        "1": "Black Graphite",
        "2": "Violet Ore",
        "3": "Green Beryl",
        "4": "Bitcoin Orange",
        "5": "Freedom Edition"
      }
    },
    T3W1: {
      name: "Trezor Safe 7",
      colors: {
        "1": "Charcoal Black",
        "2": "Obsidian Green",
        "3": "Bitcoin Orange"
      },
      frontColors: {
        "1": "1",
        "2": "2",
        "3": "1"
      }
    }
  };
  return models;
}
var deviceColorUtils = {};
var hasRequiredDeviceColorUtils;
function requireDeviceColorUtils() {
  if (hasRequiredDeviceColorUtils) return deviceColorUtils;
  hasRequiredDeviceColorUtils = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.getDeviceColorVariant = exports$12.normalizeDeviceColorVariant = void 0;
    const normalizeDeviceColorVariant = (colorVariant) => colorVariant || 1;
    exports$12.normalizeDeviceColorVariant = normalizeDeviceColorVariant;
    const getDeviceColorVariant = (device2) => {
      var _a, _b, _c;
      return (0, exports$12.normalizeDeviceColorVariant)(((_a = device2 == null ? void 0 : device2.features) == null ? void 0 : _a.unit_color) ?? ((_c = (_b = device2 == null ? void 0 : device2.thp) == null ? void 0 : _b.properties) == null ? void 0 : _c.model_variant));
    };
    exports$12.getDeviceColorVariant = getDeviceColorVariant;
  })(deviceColorUtils);
  return deviceColorUtils;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    const tslib_12 = require$$0$1;
    tslib_12.__exportStar(requireFirmwareUtils(), exports$12);
    tslib_12.__exportStar(requireBootloaderUtils(), exports$12);
    tslib_12.__exportStar(requireModeUtils(), exports$12);
    tslib_12.__exportStar(requireTypes$1(), exports$12);
    tslib_12.__exportStar(requireDeviceModelInternal(), exports$12);
    tslib_12.__exportStar(requireDeviceModelInternalUtils(), exports$12);
    tslib_12.__exportStar(requireModels(), exports$12);
    tslib_12.__exportStar(requireDeviceColorUtils(), exports$12);
  })(lib);
  return lib;
}
var fees = {};
var hasRequiredFees;
function requireFees() {
  if (hasRequiredFees) return fees;
  hasRequiredFees = 1;
  Object.defineProperty(fees, "__esModule", {
    value: true
  });
  fees.SelectFeeLevel = fees.FeeLevel = fees.FeeInfo = void 0;
  const schema_utils_1 = requireLib$3();
  fees.FeeInfo = schema_utils_1.Type.Object({
    blockTime: schema_utils_1.Type.Number(),
    minFee: schema_utils_1.Type.Number(),
    maxFee: schema_utils_1.Type.Number(),
    minPriorityFee: schema_utils_1.Type.Number(),
    dustLimit: schema_utils_1.Type.Number()
  });
  fees.FeeLevel = schema_utils_1.Type.Object({
    label: schema_utils_1.Type.Union([schema_utils_1.Type.Literal("high"), schema_utils_1.Type.Literal("normal"), schema_utils_1.Type.Literal("economy"), schema_utils_1.Type.Literal("low"), schema_utils_1.Type.Literal("custom")]),
    blocks: schema_utils_1.Type.Number(),
    feePerUnit: schema_utils_1.Type.String(),
    feePerTx: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
    feeLimit: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
    baseFeePerGas: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
    maxFeePerGas: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
    maxPriorityFeePerGas: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
  });
  fees.SelectFeeLevel = schema_utils_1.Type.Union([schema_utils_1.Type.Object({
    name: schema_utils_1.Type.String(),
    fee: schema_utils_1.Type.Literal("0"),
    feePerByte: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
    blocks: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
    disabled: schema_utils_1.Type.Literal(true)
  }), schema_utils_1.Type.Object({
    name: schema_utils_1.Type.String(),
    fee: schema_utils_1.Type.String(),
    feePerByte: schema_utils_1.Type.String(),
    blocks: schema_utils_1.Type.Number(),
    minutes: schema_utils_1.Type.Number(),
    total: schema_utils_1.Type.String()
  })]);
  return fees;
}
var hasRequiredCoinInfo;
function requireCoinInfo() {
  if (hasRequiredCoinInfo) return coinInfo;
  hasRequiredCoinInfo = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.CoinInfo = exports$12.MiscNetworkInfo = exports$12.EthereumNetworkInfoDefinitionValues = exports$12.EthereumNetworkInfo = exports$12.BitcoinNetworkInfo = exports$12.BlockchainLink = exports$12.CoinSupport = exports$12.CoinObj = exports$12.Network = exports$12.Bip32 = void 0;
    const device_utils_1 = requireLib();
    const schema_utils_1 = requireLib$3();
    const fees_1 = requireFees();
    exports$12.Bip32 = schema_utils_1.Type.Object({
      public: schema_utils_1.Type.Number(),
      private: schema_utils_1.Type.Number()
    });
    exports$12.Network = schema_utils_1.Type.Object({
      messagePrefix: schema_utils_1.Type.String(),
      bech32: schema_utils_1.Type.String(),
      bip32: exports$12.Bip32,
      pubKeyHash: schema_utils_1.Type.Number(),
      scriptHash: schema_utils_1.Type.Number(),
      wif: schema_utils_1.Type.Number(),
      forkId: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    });
    exports$12.CoinObj = schema_utils_1.Type.Object({
      coin: schema_utils_1.Type.String(),
      identity: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports$12.CoinSupport = schema_utils_1.Type.Composite([schema_utils_1.Type.Object({
      connect: schema_utils_1.Type.Boolean()
    }), schema_utils_1.Type.Record(schema_utils_1.Type.KeyOfEnum(device_utils_1.DeviceModelInternal), schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Literal(false)]))]);
    exports$12.BlockchainLink = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.String(),
      url: schema_utils_1.Type.Array(schema_utils_1.Type.String())
    });
    const Common = schema_utils_1.Type.Object({
      label: schema_utils_1.Type.String(),
      name: schema_utils_1.Type.String(),
      shortcut: schema_utils_1.Type.String(),
      slip44: schema_utils_1.Type.Number(),
      support: exports$12.CoinSupport,
      decimals: schema_utils_1.Type.Number(),
      blockchainLink: schema_utils_1.Type.Optional(exports$12.BlockchainLink),
      blockTime: schema_utils_1.Type.Number(),
      minFee: schema_utils_1.Type.Number(),
      maxFee: schema_utils_1.Type.Number(),
      minPriorityFee: schema_utils_1.Type.Number(),
      defaultFees: schema_utils_1.Type.Array(fees_1.FeeLevel)
    });
    exports$12.BitcoinNetworkInfo = schema_utils_1.Type.Intersect([Common, schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("bitcoin"),
      cashAddrPrefix: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      curveName: schema_utils_1.Type.String(),
      dustLimit: schema_utils_1.Type.Number(),
      forceBip143: schema_utils_1.Type.Boolean(),
      hashGenesisBlock: schema_utils_1.Type.String(),
      maxAddressLength: schema_utils_1.Type.Number(),
      maxFeeSatoshiKb: schema_utils_1.Type.Number(),
      minAddressLength: schema_utils_1.Type.Number(),
      minFeeSatoshiKb: schema_utils_1.Type.Number(),
      segwit: schema_utils_1.Type.Boolean(),
      xPubMagic: schema_utils_1.Type.Number(),
      xPubMagicSegwitNative: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      xPubMagicSegwit: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      taproot: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      network: exports$12.Network,
      isBitcoin: schema_utils_1.Type.Boolean()
    })]);
    exports$12.EthereumNetworkInfo = schema_utils_1.Type.Intersect([Common, schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("ethereum"),
      chainId: schema_utils_1.Type.Number(),
      network: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined())
    })]);
    exports$12.EthereumNetworkInfoDefinitionValues = schema_utils_1.Type.Omit(exports$12.EthereumNetworkInfo, ["minFee", "maxFee", "defaultFees", "minPriorityFee", "blockTime"]);
    exports$12.MiscNetworkInfo = schema_utils_1.Type.Intersect([Common, schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Union([schema_utils_1.Type.Literal("misc"), schema_utils_1.Type.Literal("nem")]),
      curve: schema_utils_1.Type.String(),
      network: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined())
    })]);
    exports$12.CoinInfo = schema_utils_1.Type.Union([exports$12.BitcoinNetworkInfo, exports$12.EthereumNetworkInfo, exports$12.MiscNetworkInfo]);
  })(coinInfo);
  return coinInfo;
}
var device = {};
var hasRequiredDevice;
function requireDevice() {
  if (hasRequiredDevice) return device;
  hasRequiredDevice = 1;
  Object.defineProperty(device, "__esModule", {
    value: true
  });
  device.asProofOfDelegatedIdentity = device.asBluetoothDeviceId = device.asDeviceUniquePath = void 0;
  const asDeviceUniquePath = (id) => id;
  device.asDeviceUniquePath = asDeviceUniquePath;
  const asBluetoothDeviceId = (id) => id;
  device.asBluetoothDeviceId = asBluetoothDeviceId;
  const asProofOfDelegatedIdentity = (value2) => value2;
  device.asProofOfDelegatedIdentity = asProofOfDelegatedIdentity;
  return device;
}
var firmware = {};
var hasRequiredFirmware;
function requireFirmware() {
  if (hasRequiredFirmware) return firmware;
  hasRequiredFirmware = 1;
  Object.defineProperty(firmware, "__esModule", {
    value: true
  });
  return firmware;
}
var params = {};
var hasRequiredParams;
function requireParams() {
  if (hasRequiredParams) return params;
  hasRequiredParams = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.PublicKey = exports$12.GetPublicKey = exports$12.GetAddress = exports$12.DerivationPath = exports$12.Bundle = void 0;
    const schema_utils_1 = requireLib$3();
    const Bundle = (type2) => schema_utils_1.Type.Object({
      bundle: schema_utils_1.Type.Array(type2, {
        minItems: 1
      })
    });
    exports$12.Bundle = Bundle;
    exports$12.DerivationPath = schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Array(schema_utils_1.Type.Number())], {
      description: "Derivation Path (BIP32).",
      $id: "DerivationPath"
    });
    exports$12.GetAddress = schema_utils_1.Type.Object({
      path: exports$12.DerivationPath,
      address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      showOnTrezor: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean({
        default: true
      })),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      useEventListener: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports$12.GetPublicKey = schema_utils_1.Type.Object({
      path: exports$12.DerivationPath,
      showOnTrezor: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      suppressBackupWarning: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports$12.PublicKey = schema_utils_1.Type.Object({
      publicKey: schema_utils_1.Type.String(),
      path: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      serializedPath: schema_utils_1.Type.String()
    });
  })(params);
  return params;
}
var settings = {};
var hasRequiredSettings;
function requireSettings() {
  if (hasRequiredSettings) return settings;
  hasRequiredSettings = 1;
  Object.defineProperty(settings, "__esModule", {
    value: true
  });
  return settings;
}
var cardano = {};
var hasRequiredCardano;
function requireCardano() {
  if (hasRequiredCardano) return cardano;
  hasRequiredCardano = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.CardanoSignedMessage = exports$12.CardanoMessageHeaders = exports$12.CardanoMessageUnprotectedHeaders = exports$12.CardanoMessageProtectedHeaders = exports$12.CardanoSignMessage = exports$12.CardanoSignedTxData = exports$12.CardanoAuxiliaryDataSupplement = exports$12.CardanoSignedTxWitness = exports$12.CardanoSignTransactionExtended = exports$12.CardanoSignTransaction = exports$12.CardanoAuxiliaryData = exports$12.CardanoCVoteRegistrationParameters = exports$12.CardanoCVoteRegistrationDelegation = exports$12.CardanoReferenceInput = exports$12.CardanoRequiredSigner = exports$12.CardanoCollateralInput = exports$12.CardanoMint = exports$12.CardanoWithdrawal = exports$12.CardanoCertificate = exports$12.CardanoDRep = exports$12.CardanoPoolParameters = exports$12.CardanoPoolMargin = exports$12.CardanoPoolMetadata = exports$12.CardanoPoolRelay = exports$12.CardanoPoolOwner = exports$12.CardanoOutput = exports$12.CardanoAssetGroup = exports$12.CardanoToken = exports$12.CardanoInput = exports$12.CardanoGetPublicKey = exports$12.CardanoNativeScriptHash = exports$12.CardanoGetNativeScriptHash = exports$12.CardanoNativeScript = exports$12.CardanoGetAddress = exports$12.CardanoAddressParameters = exports$12.CardanoCertificatePointer = void 0;
    const schema_utils_1 = requireLib$3();
    const constants_12 = constants;
    const params_1 = requireParams();
    exports$12.CardanoCertificatePointer = schema_utils_1.Type.Object({
      blockIndex: schema_utils_1.Type.Number(),
      txIndex: schema_utils_1.Type.Number(),
      certificateIndex: schema_utils_1.Type.Number()
    });
    exports$12.CardanoAddressParameters = schema_utils_1.Type.Object({
      addressType: constants_12.PROTO.EnumCardanoAddressType,
      path: schema_utils_1.Type.Optional(params_1.DerivationPath),
      stakingPath: schema_utils_1.Type.Optional(params_1.DerivationPath),
      stakingKeyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      certificatePointer: schema_utils_1.Type.Optional(exports$12.CardanoCertificatePointer),
      paymentScriptHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      stakingScriptHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports$12.CardanoGetAddress = schema_utils_1.Type.Object({
      addressParameters: exports$12.CardanoAddressParameters,
      protocolMagic: schema_utils_1.Type.Number(),
      networkId: schema_utils_1.Type.Number(),
      address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      showOnTrezor: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      derivationType: schema_utils_1.Type.Optional(constants_12.PROTO.EnumCardanoDerivationType),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports$12.CardanoNativeScript = schema_utils_1.Type.Recursive((This) => schema_utils_1.Type.Object({
      type: constants_12.PROTO.EnumCardanoNativeScriptType,
      scripts: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(This)),
      keyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      keyPath: schema_utils_1.Type.Optional(params_1.DerivationPath),
      requiredSignaturesCount: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      invalidBefore: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      invalidHereafter: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }));
    exports$12.CardanoGetNativeScriptHash = schema_utils_1.Type.Object({
      script: exports$12.CardanoNativeScript,
      displayFormat: constants_12.PROTO.EnumCardanoNativeScriptHashDisplayFormat,
      derivationType: schema_utils_1.Type.Optional(constants_12.PROTO.EnumCardanoDerivationType)
    });
    exports$12.CardanoNativeScriptHash = schema_utils_1.Type.Object({
      scriptHash: schema_utils_1.Type.String()
    });
    exports$12.CardanoGetPublicKey = schema_utils_1.Type.Intersect([params_1.GetPublicKey, schema_utils_1.Type.Object({
      derivationType: schema_utils_1.Type.Optional(constants_12.PROTO.EnumCardanoDerivationType)
    })]);
    exports$12.CardanoInput = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Optional(params_1.DerivationPath),
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    });
    exports$12.CardanoToken = schema_utils_1.Type.Object({
      assetNameBytes: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      mintAmount: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports$12.CardanoAssetGroup = schema_utils_1.Type.Object({
      policyId: schema_utils_1.Type.String(),
      tokenAmounts: schema_utils_1.Type.Array(exports$12.CardanoToken)
    });
    exports$12.CardanoOutput = schema_utils_1.Type.Intersect([schema_utils_1.Type.Union([schema_utils_1.Type.Object({
      addressParameters: exports$12.CardanoAddressParameters
    }), schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String()
    })]), schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.String(),
      tokenBundle: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.CardanoAssetGroup)),
      datumHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      format: schema_utils_1.Type.Optional(constants_12.PROTO.EnumCardanoTxOutputSerializationFormat),
      inlineDatum: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      referenceScript: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    })]);
    exports$12.CardanoPoolOwner = schema_utils_1.Type.Object({
      stakingKeyPath: schema_utils_1.Type.Optional(params_1.DerivationPath),
      stakingKeyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports$12.CardanoPoolRelay = schema_utils_1.Type.Object({
      type: constants_12.PROTO.EnumCardanoPoolRelayType,
      ipv4Address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ipv6Address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      port: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      hostName: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports$12.CardanoPoolMetadata = schema_utils_1.Type.Object({
      url: schema_utils_1.Type.String(),
      hash: schema_utils_1.Type.String()
    });
    exports$12.CardanoPoolMargin = schema_utils_1.Type.Object({
      numerator: schema_utils_1.Type.String(),
      denominator: schema_utils_1.Type.String()
    });
    exports$12.CardanoPoolParameters = schema_utils_1.Type.Object({
      poolId: schema_utils_1.Type.String(),
      vrfKeyHash: schema_utils_1.Type.String(),
      pledge: schema_utils_1.Type.String(),
      cost: schema_utils_1.Type.String(),
      margin: exports$12.CardanoPoolMargin,
      rewardAccount: schema_utils_1.Type.String(),
      owners: schema_utils_1.Type.Array(exports$12.CardanoPoolOwner, {
        minItems: 1
      }),
      relays: schema_utils_1.Type.Array(exports$12.CardanoPoolRelay),
      metadata: schema_utils_1.Type.Optional(exports$12.CardanoPoolMetadata)
    });
    exports$12.CardanoDRep = schema_utils_1.Type.Object({
      type: constants_12.PROTO.EnumCardanoDRepType,
      keyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      scriptHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports$12.CardanoCertificate = schema_utils_1.Type.Object({
      type: constants_12.PROTO.EnumCardanoCertificateType,
      path: schema_utils_1.Type.Optional(params_1.DerivationPath),
      pool: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      poolParameters: schema_utils_1.Type.Optional(exports$12.CardanoPoolParameters),
      scriptHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      keyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      deposit: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      dRep: schema_utils_1.Type.Optional(exports$12.CardanoDRep)
    });
    exports$12.CardanoWithdrawal = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Optional(params_1.DerivationPath),
      amount: schema_utils_1.Type.String(),
      scriptHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      keyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports$12.CardanoMint = schema_utils_1.Type.Array(exports$12.CardanoAssetGroup);
    exports$12.CardanoCollateralInput = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Optional(params_1.DerivationPath),
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    });
    exports$12.CardanoRequiredSigner = schema_utils_1.Type.Object({
      keyPath: schema_utils_1.Type.Optional(params_1.DerivationPath),
      keyHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports$12.CardanoReferenceInput = schema_utils_1.Type.Object({
      prev_hash: schema_utils_1.Type.String(),
      prev_index: schema_utils_1.Type.Number()
    });
    exports$12.CardanoCVoteRegistrationDelegation = schema_utils_1.Type.Object({
      votePublicKey: schema_utils_1.Type.String(),
      weight: schema_utils_1.Type.Number()
    });
    exports$12.CardanoCVoteRegistrationParameters = schema_utils_1.Type.Object({
      votePublicKey: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      stakingPath: params_1.DerivationPath,
      paymentAddressParameters: schema_utils_1.Type.Optional(exports$12.CardanoAddressParameters),
      nonce: schema_utils_1.Type.String(),
      format: schema_utils_1.Type.Optional(constants_12.PROTO.EnumCardanoCVoteRegistrationFormat),
      delegations: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.CardanoCVoteRegistrationDelegation)),
      votingPurpose: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      paymentAddress: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports$12.CardanoAuxiliaryData = schema_utils_1.Type.Object({
      hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      cVoteRegistrationParameters: schema_utils_1.Type.Optional(exports$12.CardanoCVoteRegistrationParameters)
    });
    exports$12.CardanoSignTransaction = schema_utils_1.Type.Object({
      inputs: schema_utils_1.Type.Array(exports$12.CardanoInput),
      outputs: schema_utils_1.Type.Array(exports$12.CardanoOutput),
      fee: schema_utils_1.Type.Uint(),
      ttl: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      certificates: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.CardanoCertificate)),
      withdrawals: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.CardanoWithdrawal)),
      validityIntervalStart: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      auxiliaryData: schema_utils_1.Type.Optional(exports$12.CardanoAuxiliaryData),
      mint: schema_utils_1.Type.Optional(exports$12.CardanoMint),
      scriptDataHash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      collateralInputs: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.CardanoCollateralInput)),
      requiredSigners: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.CardanoRequiredSigner)),
      collateralReturn: schema_utils_1.Type.Optional(exports$12.CardanoOutput),
      totalCollateral: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      referenceInputs: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.CardanoReferenceInput)),
      additionalWitnessRequests: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(params_1.DerivationPath)),
      protocolMagic: schema_utils_1.Type.Number(),
      networkId: schema_utils_1.Type.Number(),
      signingMode: constants_12.PROTO.EnumCardanoTxSigningMode,
      derivationType: schema_utils_1.Type.Optional(constants_12.PROTO.EnumCardanoDerivationType),
      includeNetworkId: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      tagCborSets: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports$12.CardanoSignTransactionExtended = schema_utils_1.Type.Intersect([exports$12.CardanoSignTransaction, schema_utils_1.Type.Object({
      unsignedTx: schema_utils_1.Type.Object({
        body: schema_utils_1.Type.String(),
        hash: schema_utils_1.Type.String()
      }),
      testnet: schema_utils_1.Type.Boolean()
    })]);
    exports$12.CardanoSignedTxWitness = schema_utils_1.Type.Object({
      type: constants_12.PROTO.EnumCardanoTxWitnessType,
      pubKey: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String(),
      chainCode: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports$12.CardanoAuxiliaryDataSupplement = schema_utils_1.Type.Object({
      type: constants_12.PROTO.EnumCardanoTxAuxiliaryDataSupplementType,
      auxiliaryDataHash: schema_utils_1.Type.String(),
      cVoteRegistrationSignature: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports$12.CardanoSignedTxData = schema_utils_1.Type.Object({
      hash: schema_utils_1.Type.String(),
      witnesses: schema_utils_1.Type.Array(exports$12.CardanoSignedTxWitness),
      auxiliaryDataSupplement: schema_utils_1.Type.Optional(exports$12.CardanoAuxiliaryDataSupplement)
    });
    exports$12.CardanoSignMessage = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      payload: schema_utils_1.Type.String(),
      preferHexDisplay: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      networkId: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      protocolMagic: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      addressParameters: schema_utils_1.Type.Optional(exports$12.CardanoAddressParameters),
      derivationType: schema_utils_1.Type.Optional(constants_12.PROTO.EnumCardanoDerivationType)
    });
    exports$12.CardanoMessageProtectedHeaders = schema_utils_1.Type.Object({
      1: schema_utils_1.Type.Literal(constants_12.CARDANO.ALGORITHM_IDS.EdDSA),
      address: schema_utils_1.Type.String()
    });
    exports$12.CardanoMessageUnprotectedHeaders = schema_utils_1.Type.Object({
      hashed: schema_utils_1.Type.Boolean(),
      version: schema_utils_1.Type.Number()
    });
    exports$12.CardanoMessageHeaders = schema_utils_1.Type.Object({
      protected: exports$12.CardanoMessageProtectedHeaders,
      unprotected: exports$12.CardanoMessageUnprotectedHeaders
    });
    exports$12.CardanoSignedMessage = schema_utils_1.Type.Object({
      headers: exports$12.CardanoMessageHeaders,
      payload: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String(),
      pubKey: schema_utils_1.Type.String(),
      coseSignature: schema_utils_1.Type.String(),
      coseKey: schema_utils_1.Type.String()
    });
  })(cardano);
  return cardano;
}
var bitcoin = {};
var hasRequiredBitcoin;
function requireBitcoin() {
  if (hasRequiredBitcoin) return bitcoin;
  hasRequiredBitcoin = 1;
  Object.defineProperty(bitcoin, "__esModule", {
    value: true
  });
  bitcoin.VerifyMessage = bitcoin.SignMessage = void 0;
  const schema_utils_1 = requireLib$3();
  const params_1 = requireParams();
  bitcoin.SignMessage = schema_utils_1.Type.Object({
    path: params_1.DerivationPath,
    coin: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
    message: schema_utils_1.Type.String(),
    hex: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
    no_script_type: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
  });
  bitcoin.VerifyMessage = schema_utils_1.Type.Object({
    address: schema_utils_1.Type.String(),
    signature: schema_utils_1.Type.String(),
    message: schema_utils_1.Type.String(),
    coin: schema_utils_1.Type.String(),
    hex: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
  });
  return bitcoin;
}
var eos = {};
var hasRequiredEos;
function requireEos() {
  if (hasRequiredEos) return eos;
  hasRequiredEos = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.EosSignTransaction = exports$12.EosSDKTransaction = exports$12.EosTxAction = exports$12.EosTxActionCommon = exports$12.EosAuthorization = exports$12.EosTxHeader = exports$12.EosPublicKey = void 0;
    const schema_utils_1 = requireLib$3();
    const constants_12 = constants;
    const params_1 = requireParams();
    exports$12.EosPublicKey = schema_utils_1.Type.Object({
      wifPublicKey: schema_utils_1.Type.String(),
      rawPublicKey: schema_utils_1.Type.String(),
      path: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      serializedPath: schema_utils_1.Type.String()
    });
    exports$12.EosTxHeader = schema_utils_1.Type.Object({
      expiration: schema_utils_1.Type.Union([schema_utils_1.Type.Uint(), schema_utils_1.Type.String()]),
      refBlockNum: schema_utils_1.Type.Number(),
      refBlockPrefix: schema_utils_1.Type.Number(),
      maxNetUsageWords: schema_utils_1.Type.Number(),
      maxCpuUsageMs: schema_utils_1.Type.Number(),
      delaySec: schema_utils_1.Type.Number()
    });
    exports$12.EosAuthorization = schema_utils_1.Type.Object({
      threshold: schema_utils_1.Type.Number(),
      keys: schema_utils_1.Type.Array(constants_12.PROTO.EosAuthorizationKey),
      accounts: schema_utils_1.Type.Array(schema_utils_1.Type.Object({
        permission: constants_12.PROTO.EosPermissionLevel,
        weight: schema_utils_1.Type.Number()
      })),
      waits: schema_utils_1.Type.Array(constants_12.PROTO.EosAuthorizationWait)
    });
    exports$12.EosTxActionCommon = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.String(),
      authorization: schema_utils_1.Type.Array(constants_12.PROTO.EosPermissionLevel)
    });
    exports$12.EosTxAction = schema_utils_1.Type.Union([schema_utils_1.Type.Intersect([exports$12.EosTxActionCommon, schema_utils_1.Type.Object({
      name: schema_utils_1.Type.Literal("transfer"),
      data: schema_utils_1.Type.Object({
        from: schema_utils_1.Type.String(),
        to: schema_utils_1.Type.String(),
        quantity: schema_utils_1.Type.String(),
        memo: schema_utils_1.Type.String()
      })
    })]), schema_utils_1.Type.Intersect([exports$12.EosTxActionCommon, schema_utils_1.Type.Object({
      name: schema_utils_1.Type.Literal("delegatebw"),
      data: schema_utils_1.Type.Object({
        from: schema_utils_1.Type.String(),
        receiver: schema_utils_1.Type.String(),
        stake_net_quantity: schema_utils_1.Type.String(),
        stake_cpu_quantity: schema_utils_1.Type.String(),
        transfer: schema_utils_1.Type.Boolean()
      })
    })]), schema_utils_1.Type.Intersect([exports$12.EosTxActionCommon, schema_utils_1.Type.Object({
      name: schema_utils_1.Type.Literal("undelegatebw"),
      data: schema_utils_1.Type.Object({
        from: schema_utils_1.Type.String(),
        receiver: schema_utils_1.Type.String(),
        unstake_net_quantity: schema_utils_1.Type.String(),
        unstake_cpu_quantity: schema_utils_1.Type.String()
      })
    })]), schema_utils_1.Type.Intersect([exports$12.EosTxActionCommon, schema_utils_1.Type.Object({
      name: schema_utils_1.Type.Literal("buyram"),
      data: schema_utils_1.Type.Object({
        payer: schema_utils_1.Type.String(),
        receiver: schema_utils_1.Type.String(),
        quant: schema_utils_1.Type.String()
      })
    })]), schema_utils_1.Type.Intersect([exports$12.EosTxActionCommon, schema_utils_1.Type.Object({
      name: schema_utils_1.Type.Literal("buyrambytes"),
      data: constants_12.PROTO.EosActionBuyRamBytes
    })]), schema_utils_1.Type.Intersect([exports$12.EosTxActionCommon, schema_utils_1.Type.Object({
      name: schema_utils_1.Type.Literal("sellram"),
      data: constants_12.PROTO.EosActionSellRam
    })]), schema_utils_1.Type.Intersect([exports$12.EosTxActionCommon, schema_utils_1.Type.Object({
      name: schema_utils_1.Type.Literal("voteproducer"),
      data: schema_utils_1.Type.Object({
        voter: schema_utils_1.Type.String(),
        proxy: schema_utils_1.Type.String(),
        producers: schema_utils_1.Type.Array(schema_utils_1.Type.String())
      })
    })]), schema_utils_1.Type.Intersect([exports$12.EosTxActionCommon, schema_utils_1.Type.Object({
      name: schema_utils_1.Type.Literal("refund"),
      data: constants_12.PROTO.EosActionRefund
    })]), schema_utils_1.Type.Intersect([exports$12.EosTxActionCommon, schema_utils_1.Type.Object({
      name: schema_utils_1.Type.Literal("updateauth"),
      data: schema_utils_1.Type.Object({
        account: schema_utils_1.Type.String(),
        permission: schema_utils_1.Type.String(),
        parent: schema_utils_1.Type.String(),
        auth: exports$12.EosAuthorization
      })
    })]), schema_utils_1.Type.Intersect([exports$12.EosTxActionCommon, schema_utils_1.Type.Object({
      name: schema_utils_1.Type.Literal("deleteauth"),
      data: constants_12.PROTO.EosActionDeleteAuth
    })]), schema_utils_1.Type.Intersect([exports$12.EosTxActionCommon, schema_utils_1.Type.Object({
      name: schema_utils_1.Type.Literal("linkauth"),
      data: constants_12.PROTO.EosActionLinkAuth
    })]), schema_utils_1.Type.Intersect([exports$12.EosTxActionCommon, schema_utils_1.Type.Object({
      name: schema_utils_1.Type.Literal("unlinkauth"),
      data: constants_12.PROTO.EosActionUnlinkAuth
    })]), schema_utils_1.Type.Intersect([exports$12.EosTxActionCommon, schema_utils_1.Type.Object({
      name: schema_utils_1.Type.Literal("newaccount"),
      data: schema_utils_1.Type.Object({
        creator: schema_utils_1.Type.String(),
        name: schema_utils_1.Type.String(),
        owner: exports$12.EosAuthorization,
        active: exports$12.EosAuthorization
      })
    })])]);
    exports$12.EosSDKTransaction = schema_utils_1.Type.Object({
      chainId: schema_utils_1.Type.String(),
      header: exports$12.EosTxHeader,
      actions: schema_utils_1.Type.Array(schema_utils_1.Type.Union([exports$12.EosTxAction, schema_utils_1.Type.Intersect([exports$12.EosTxActionCommon, schema_utils_1.Type.Object({
        name: schema_utils_1.Type.String(),
        data: schema_utils_1.Type.String()
      })])]))
    });
    exports$12.EosSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      transaction: exports$12.EosSDKTransaction,
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
  })(eos);
  return eos;
}
var ripple = {};
var hasRequiredRipple;
function requireRipple() {
  if (hasRequiredRipple) return ripple;
  hasRequiredRipple = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.RippleSignedTx = exports$12.RippleSignTransaction = exports$12.RippleTransaction = exports$12.RipplePayment = void 0;
    const schema_utils_1 = requireLib$3();
    const params_1 = requireParams();
    exports$12.RipplePayment = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.String(),
      destination: schema_utils_1.Type.String(),
      destinationTag: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    });
    exports$12.RippleTransaction = schema_utils_1.Type.Object({
      fee: schema_utils_1.Type.String(),
      flags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      sequence: schema_utils_1.Type.Number(),
      maxLedgerVersion: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      payment: exports$12.RipplePayment
    });
    exports$12.RippleSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      transaction: exports$12.RippleTransaction,
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports$12.RippleSignedTx = schema_utils_1.Type.Object({
      serializedTx: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    });
  })(ripple);
  return ripple;
}
var ethereum = {};
var hasRequiredEthereum;
function requireEthereum() {
  if (hasRequiredEthereum) return ethereum;
  hasRequiredEthereum = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.EthereumVerifyMessage = exports$12.EthereumSignTypedHash = exports$12.EthereumSignTypedData = exports$12.EthereumSignTypedDataMessage = exports$12.EthereumSignTypedDataTypes = exports$12.EthereumSignedTx = exports$12.EthereumSignTransaction = exports$12.EthereumTransactionEIP1559 = exports$12.EthereumAccessList = exports$12.EthereumTransaction = exports$12.EthereumSignMessage = void 0;
    const schema_utils_1 = requireLib$3();
    const constants_12 = constants;
    const params_1 = requireParams();
    exports$12.EthereumSignMessage = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      message: schema_utils_1.Type.String(),
      hex: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports$12.EthereumTransaction = schema_utils_1.Type.Object({
      to: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      value: schema_utils_1.Type.String(),
      gasPrice: schema_utils_1.Type.String(),
      gasLimit: schema_utils_1.Type.String(),
      maxFeePerGas: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      maxPriorityFeePerGas: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      nonce: schema_utils_1.Type.String(),
      data: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      chainId: schema_utils_1.Type.Number(),
      txType: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      payment_req: schema_utils_1.Type.Optional(constants_12.PROTO.PaymentRequest)
    });
    exports$12.EthereumAccessList = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      storageKeys: schema_utils_1.Type.Array(schema_utils_1.Type.String())
    });
    exports$12.EthereumTransactionEIP1559 = schema_utils_1.Type.Object({
      to: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Null()]),
      value: schema_utils_1.Type.String(),
      gasLimit: schema_utils_1.Type.String(),
      gasPrice: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      nonce: schema_utils_1.Type.String(),
      data: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      chainId: schema_utils_1.Type.Number(),
      maxFeePerGas: schema_utils_1.Type.String(),
      maxPriorityFeePerGas: schema_utils_1.Type.String(),
      accessList: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.EthereumAccessList)),
      payment_req: schema_utils_1.Type.Optional(constants_12.PROTO.PaymentRequest)
    });
    exports$12.EthereumSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      transaction: schema_utils_1.Type.Union([exports$12.EthereumTransaction, exports$12.EthereumTransactionEIP1559]),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports$12.EthereumSignedTx = schema_utils_1.Type.Object({
      v: schema_utils_1.Type.String(),
      r: schema_utils_1.Type.String(),
      s: schema_utils_1.Type.String(),
      serializedTx: schema_utils_1.Type.String()
    });
    const EthereumSignTypedDataTypeProperty = schema_utils_1.Type.Object({
      name: schema_utils_1.Type.String(),
      type: schema_utils_1.Type.String()
    });
    exports$12.EthereumSignTypedDataTypes = schema_utils_1.Type.Object({
      EIP712Domain: schema_utils_1.Type.Array(EthereumSignTypedDataTypeProperty)
    }, {
      additionalProperties: schema_utils_1.Type.Array(EthereumSignTypedDataTypeProperty)
    });
    exports$12.EthereumSignTypedDataMessage = schema_utils_1.Type.Object({
      types: exports$12.EthereumSignTypedDataTypes,
      primaryType: schema_utils_1.Type.String(),
      domain: schema_utils_1.Type.Object({
        name: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        version: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        chainId: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.Number(), schema_utils_1.Type.BigInt(), schema_utils_1.Type.String()])),
        verifyingContract: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        salt: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.ArrayBuffer(), schema_utils_1.Type.String()]))
      }),
      message: schema_utils_1.Type.Object({}, {
        additionalProperties: schema_utils_1.Type.Any()
      })
    });
    exports$12.EthereumSignTypedData = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      data: exports$12.EthereumSignTypedDataMessage,
      metamask_v4_compat: schema_utils_1.Type.Boolean(),
      domain_separator_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      message_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined()),
      show_message_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports$12.EthereumSignTypedHash = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      data: exports$12.EthereumSignTypedDataMessage,
      metamask_v4_compat: schema_utils_1.Type.Boolean(),
      domain_separator_hash: schema_utils_1.Type.String(),
      message_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      show_message_hash: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports$12.EthereumVerifyMessage = schema_utils_1.Type.Object({
      address: schema_utils_1.Type.String(),
      message: schema_utils_1.Type.String(),
      hex: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      signature: schema_utils_1.Type.String()
    });
  })(ethereum);
  return ethereum;
}
var monero = {};
var hasRequiredMonero;
function requireMonero() {
  if (hasRequiredMonero) return monero;
  hasRequiredMonero = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.MoneroSignedTransaction = exports$12.MoneroRingCtSig = exports$12.MoneroSignTransaction = exports$12.MoneroTransactionData = exports$12.MoneroTransactionRsigData = exports$12.MoneroTransactionDestinationEntry = exports$12.MoneroAccountPublicAddress = exports$12.MoneroTransactionSourceEntry = exports$12.MoneroMultisigKLRki = exports$12.MoneroOutputEntry = exports$12.MoneroKeyImageSyncResult = exports$12.MoneroExportedKeyImage = exports$12.MoneroKeyImageSync = exports$12.MoneroSubAddressIndicesList = exports$12.MoneroTransferDetails = exports$12.MoneroWatchKey = exports$12.MoneroGetWatchKey = exports$12.MoneroGetAddress = void 0;
    const schema_utils_1 = requireLib$3();
    const constants_12 = constants;
    const params_1 = requireParams();
    exports$12.MoneroGetAddress = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      address: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      showOnTrezor: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      networkType: schema_utils_1.Type.Optional(constants_12.PROTO.EnumMoneroNetworkType),
      account: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      minor: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      paymentId: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "MoneroGetAddress"
    });
    exports$12.MoneroGetWatchKey = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      networkType: schema_utils_1.Type.Optional(constants_12.PROTO.EnumMoneroNetworkType)
    }, {
      $id: "MoneroGetWatchKey"
    });
    exports$12.MoneroWatchKey = schema_utils_1.Type.Object({
      watch_key: schema_utils_1.Type.String(),
      address: schema_utils_1.Type.String()
    }, {
      $id: "MoneroWatchKey"
    });
    exports$12.MoneroTransferDetails = schema_utils_1.Type.Object({
      out_key: schema_utils_1.Type.String(),
      tx_pub_key: schema_utils_1.Type.String(),
      additional_tx_pub_keys: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.Array(schema_utils_1.Type.String()), schema_utils_1.Type.String()])),
      internal_output_index: schema_utils_1.Type.Number(),
      sub_addr_major: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      sub_addr_minor: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "MoneroTransferDetails"
    });
    exports$12.MoneroSubAddressIndicesList = schema_utils_1.Type.Object({
      account: schema_utils_1.Type.Number(),
      minor_indices: schema_utils_1.Type.Array(schema_utils_1.Type.Number())
    }, {
      $id: "MoneroSubAddressIndicesList"
    });
    exports$12.MoneroKeyImageSync = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      networkType: schema_utils_1.Type.Optional(constants_12.PROTO.EnumMoneroNetworkType),
      subs: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.MoneroSubAddressIndicesList)),
      tdis: schema_utils_1.Type.Array(exports$12.MoneroTransferDetails)
    }, {
      $id: "MoneroKeyImageSync"
    });
    exports$12.MoneroExportedKeyImage = schema_utils_1.Type.Object({
      iv: schema_utils_1.Type.String(),
      key_image: schema_utils_1.Type.String()
    }, {
      $id: "MoneroExportedKeyImage"
    });
    exports$12.MoneroKeyImageSyncResult = schema_utils_1.Type.Object({
      key_images: schema_utils_1.Type.Array(exports$12.MoneroExportedKeyImage),
      signature: schema_utils_1.Type.String()
    }, {
      $id: "MoneroKeyImageSyncResult"
    });
    exports$12.MoneroOutputEntry = schema_utils_1.Type.Object({
      idx: schema_utils_1.Type.Number(),
      key: schema_utils_1.Type.Object({
        dest: schema_utils_1.Type.String(),
        commitment: schema_utils_1.Type.String()
      })
    }, {
      $id: "MoneroOutputEntry"
    });
    exports$12.MoneroMultisigKLRki = schema_utils_1.Type.Object({
      K: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      L: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      R: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      ki: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    }, {
      $id: "MoneroMultisigKLRki"
    });
    exports$12.MoneroTransactionSourceEntry = schema_utils_1.Type.Object({
      outputs: schema_utils_1.Type.Array(exports$12.MoneroOutputEntry),
      real_output: schema_utils_1.Type.Number(),
      real_out_tx_key: schema_utils_1.Type.String(),
      real_out_additional_tx_keys: schema_utils_1.Type.Array(schema_utils_1.Type.String()),
      real_output_in_tx_index: schema_utils_1.Type.Number(),
      amount: schema_utils_1.Type.Number(),
      rct: schema_utils_1.Type.Boolean(),
      mask: schema_utils_1.Type.String(),
      subaddr_minor: schema_utils_1.Type.Number(),
      multisig_kLRki: schema_utils_1.Type.Optional(exports$12.MoneroMultisigKLRki)
    }, {
      $id: "MoneroTransactionSourceEntry"
    });
    exports$12.MoneroAccountPublicAddress = schema_utils_1.Type.Object({
      spend_public_key: schema_utils_1.Type.String(),
      view_public_key: schema_utils_1.Type.String()
    });
    exports$12.MoneroTransactionDestinationEntry = schema_utils_1.Type.Object({
      amount: schema_utils_1.Type.Number(),
      addr: exports$12.MoneroAccountPublicAddress,
      is_subaddress: schema_utils_1.Type.Boolean(),
      original: schema_utils_1.Type.String(),
      is_integrated: schema_utils_1.Type.Boolean()
    }, {
      $id: "MoneroTransactionDestinationEntry"
    });
    exports$12.MoneroTransactionRsigData = schema_utils_1.Type.Object({
      rsig_type: schema_utils_1.Type.Number(),
      offload_type: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      grouping: schema_utils_1.Type.Array(schema_utils_1.Type.Number()),
      mask: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      rsig: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      rsig_parts: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.String())),
      bp_version: schema_utils_1.Type.Number()
    }, {
      $id: "MoneroTransactionRsigData"
    });
    exports$12.MoneroTransactionData = schema_utils_1.Type.Object({
      version: schema_utils_1.Type.Number(),
      payment_id: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      unlock_time: schema_utils_1.Type.Number(),
      outputs: schema_utils_1.Type.Array(exports$12.MoneroTransactionDestinationEntry),
      change_dts: schema_utils_1.Type.Optional(exports$12.MoneroTransactionDestinationEntry),
      num_inputs: schema_utils_1.Type.Number(),
      mixin: schema_utils_1.Type.Number(),
      fee: schema_utils_1.Type.Number(),
      account: schema_utils_1.Type.Number(),
      rsig_data: exports$12.MoneroTransactionRsigData,
      minor_indices: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      integrated_indices: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      client_version: schema_utils_1.Type.Number(),
      hard_fork: schema_utils_1.Type.Number(),
      monero_version: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    }, {
      $id: "MoneroTransactionData"
    });
    exports$12.MoneroSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      networkType: constants_12.PROTO.EnumMoneroNetworkType,
      tsx_data: exports$12.MoneroTransactionData,
      inputs: schema_utils_1.Type.Array(exports$12.MoneroTransactionSourceEntry)
    }, {
      $id: "MoneroSignTransaction"
    });
    exports$12.MoneroRingCtSig = schema_utils_1.Type.Object({
      txn_fee: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      message: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      rv_type: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
    }, {
      $id: "MoneroRingCtSig"
    });
    exports$12.MoneroSignedTransaction = schema_utils_1.Type.Object({
      signatures: schema_utils_1.Type.Array(schema_utils_1.Type.String()),
      tx_prefix_hash: schema_utils_1.Type.String(),
      rv: exports$12.MoneroRingCtSig,
      cout_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      salt: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      rand_mult: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      tx_enc_keys: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      opening_key: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      pseudo_outs: schema_utils_1.Type.Array(schema_utils_1.Type.String())
    }, {
      $id: "MoneroSignedTransaction"
    });
  })(monero);
  return monero;
}
var solana = {};
var hasRequiredSolana;
function requireSolana() {
  if (hasRequiredSolana) return solana;
  hasRequiredSolana = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.SolanaComposedTransaction = exports$12.SolanaComposeTransaction = exports$12.SolanaProgramName = exports$12.SolanaSignedTransaction = exports$12.SolanaSignTransaction = exports$12.SolanaTxAdditionalInfo = exports$12.SolanaTxTokenAccountInfo = exports$12.SolanaPublicKey = void 0;
    const schema_utils_1 = requireLib$3();
    const params_1 = requireParams();
    exports$12.SolanaPublicKey = schema_utils_1.Type.Intersect([params_1.PublicKey, schema_utils_1.Type.Object({
      publicKey: schema_utils_1.Type.String(),
      publicKeyBase58: schema_utils_1.Type.String()
    })]);
    exports$12.SolanaTxTokenAccountInfo = schema_utils_1.Type.Object({
      baseAddress: schema_utils_1.Type.String(),
      tokenProgram: schema_utils_1.Type.String(),
      tokenMint: schema_utils_1.Type.String(),
      tokenAccount: schema_utils_1.Type.String(),
      symbol: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports$12.SolanaTxAdditionalInfo = schema_utils_1.Type.Object({
      tokenAccountsInfos: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.SolanaTxTokenAccountInfo, {
        minItems: 1
      })),
      isDevnet: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports$12.SolanaSignTransaction = schema_utils_1.Type.Object({
      path: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Array(schema_utils_1.Type.Number())]),
      serializedTx: schema_utils_1.Type.String(),
      additionalInfo: schema_utils_1.Type.Optional(exports$12.SolanaTxAdditionalInfo),
      serialize: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
    exports$12.SolanaSignedTransaction = schema_utils_1.Type.Object({
      signature: schema_utils_1.Type.String(),
      serializedTx: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports$12.SolanaProgramName = schema_utils_1.Type.Union([schema_utils_1.Type.Literal("spl-token"), schema_utils_1.Type.Literal("spl-token-2022")]);
    const SolanaComposeTransactionCommon = {
      fromAddress: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.String(),
      blockHash: schema_utils_1.Type.String(),
      lastValidBlockHeight: schema_utils_1.Type.Number(),
      priorityFees: schema_utils_1.Type.Optional(schema_utils_1.Type.Object({
        computeUnitPrice: schema_utils_1.Type.String(),
        computeUnitLimit: schema_utils_1.Type.String()
      })),
      token: schema_utils_1.Type.Optional(schema_utils_1.Type.Object({
        mint: schema_utils_1.Type.String(),
        program: exports$12.SolanaProgramName,
        decimals: schema_utils_1.Type.Number(),
        accounts: schema_utils_1.Type.Array(schema_utils_1.Type.Object({
          publicKey: schema_utils_1.Type.String(),
          balance: schema_utils_1.Type.String()
        }))
      })),
      coin: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      identity: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    };
    const SolanaComposeSerializedTransaction = schema_utils_1.Type.Object({
      ...SolanaComposeTransactionCommon,
      toAddress: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      serializedTx: schema_utils_1.Type.String()
    });
    const SolanaComposeTransactionRaw = schema_utils_1.Type.Object({
      ...SolanaComposeTransactionCommon,
      toAddress: schema_utils_1.Type.String(),
      serializedTx: schema_utils_1.Type.Optional(schema_utils_1.Type.Undefined())
    });
    exports$12.SolanaComposeTransaction = schema_utils_1.Type.Union([SolanaComposeSerializedTransaction, SolanaComposeTransactionRaw]);
    exports$12.SolanaComposedTransaction = schema_utils_1.Type.Object({
      serializedTx: schema_utils_1.Type.String(),
      additionalInfo: schema_utils_1.Type.Object({
        newAccountProgramName: schema_utils_1.Type.Optional(exports$12.SolanaProgramName),
        tokenAccountInfo: schema_utils_1.Type.Optional(exports$12.SolanaTxTokenAccountInfo)
      })
    });
  })(solana);
  return solana;
}
var stellar = {};
var hasRequiredStellar;
function requireStellar() {
  if (hasRequiredStellar) return stellar;
  hasRequiredStellar = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.StellarOperationMessage = exports$12.StellarSignedTx = exports$12.StellarSignTransaction = exports$12.StellarTransaction = exports$12.StellarOperation = exports$12.StellarClaimClaimableBalanceOperation = exports$12.StellarInflationOperation = exports$12.StellarBumpSequenceOperation = exports$12.StellarManageDataOperation = exports$12.StellarAccountMergeOperation = exports$12.StellarAllowTrustOperation = exports$12.StellarChangeTrustOperation = exports$12.StellarSetOptionsOperation = exports$12.StellarManageBuyOfferOperation = exports$12.StellarManageSellOfferOperation = exports$12.StellarPassiveSellOfferOperation = exports$12.StellarPathPaymentStrictSendOperation = exports$12.StellarPathPaymentStrictReceiveOperation = exports$12.StellarPaymentOperation = exports$12.StellarCreateAccountOperation = exports$12.StellarAsset = void 0;
    const schema_utils_1 = requireLib$3();
    const constants_12 = constants;
    const params_1 = requireParams();
    exports$12.StellarAsset = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Union([constants_12.PROTO.EnumStellarAssetType, schema_utils_1.Type.KeyOfEnum(constants_12.PROTO.StellarAssetType)]),
      code: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      issuer: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports$12.StellarCreateAccountOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("createAccount"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      destination: schema_utils_1.Type.String(),
      startingBalance: schema_utils_1.Type.String()
    });
    exports$12.StellarPaymentOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("payment"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      destination: schema_utils_1.Type.String(),
      asset: exports$12.StellarAsset,
      amount: schema_utils_1.Type.String()
    });
    exports$12.StellarPathPaymentStrictReceiveOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("pathPaymentStrictReceive"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      sendAsset: exports$12.StellarAsset,
      sendMax: schema_utils_1.Type.Uint(),
      destination: schema_utils_1.Type.String(),
      destAsset: exports$12.StellarAsset,
      destAmount: schema_utils_1.Type.Uint(),
      path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.StellarAsset))
    });
    exports$12.StellarPathPaymentStrictSendOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("pathPaymentStrictSend"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      sendAsset: exports$12.StellarAsset,
      sendAmount: schema_utils_1.Type.Uint(),
      destination: schema_utils_1.Type.String(),
      destAsset: exports$12.StellarAsset,
      destMin: schema_utils_1.Type.Uint(),
      path: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(exports$12.StellarAsset))
    });
    exports$12.StellarPassiveSellOfferOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("createPassiveSellOffer"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      buying: exports$12.StellarAsset,
      selling: exports$12.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      price: schema_utils_1.Type.Object({
        n: schema_utils_1.Type.Number(),
        d: schema_utils_1.Type.Number()
      })
    });
    exports$12.StellarManageSellOfferOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("manageSellOffer"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      buying: exports$12.StellarAsset,
      selling: exports$12.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      offerId: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      price: schema_utils_1.Type.Object({
        n: schema_utils_1.Type.Number(),
        d: schema_utils_1.Type.Number()
      })
    });
    exports$12.StellarManageBuyOfferOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("manageBuyOffer"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      buying: exports$12.StellarAsset,
      selling: exports$12.StellarAsset,
      amount: schema_utils_1.Type.Uint(),
      offerId: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      price: schema_utils_1.Type.Object({
        n: schema_utils_1.Type.Number(),
        d: schema_utils_1.Type.Number()
      })
    });
    exports$12.StellarSetOptionsOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("setOptions"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      signer: schema_utils_1.Type.Optional(schema_utils_1.Type.Object({
        type: constants_12.PROTO.EnumStellarSignerType,
        key: schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Buffer()]),
        weight: schema_utils_1.Type.Optional(schema_utils_1.Type.Number())
      })),
      inflationDest: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      clearFlags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      setFlags: schema_utils_1.Type.Optional(schema_utils_1.Type.Number()),
      masterWeight: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      lowThreshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      medThreshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      highThreshold: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
      homeDomain: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports$12.StellarChangeTrustOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("changeTrust"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      line: exports$12.StellarAsset,
      limit: schema_utils_1.Type.String()
    });
    exports$12.StellarAllowTrustOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("allowTrust"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      trustor: schema_utils_1.Type.String(),
      assetCode: schema_utils_1.Type.String(),
      assetType: constants_12.PROTO.EnumStellarAssetType,
      authorize: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.Boolean(), schema_utils_1.Type.Undefined()]))
    });
    exports$12.StellarAccountMergeOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("accountMerge"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      destination: schema_utils_1.Type.String()
    });
    exports$12.StellarManageDataOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("manageData"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      name: schema_utils_1.Type.String(),
      value: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Buffer()]))
    });
    exports$12.StellarBumpSequenceOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("bumpSequence"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      bumpTo: schema_utils_1.Type.Uint()
    });
    exports$12.StellarInflationOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("inflation"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String())
    });
    exports$12.StellarClaimClaimableBalanceOperation = schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("claimClaimableBalance"),
      source: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      balanceId: schema_utils_1.Type.String()
    });
    exports$12.StellarOperation = schema_utils_1.Type.Union([exports$12.StellarCreateAccountOperation, exports$12.StellarPaymentOperation, exports$12.StellarPathPaymentStrictReceiveOperation, exports$12.StellarPathPaymentStrictSendOperation, exports$12.StellarPassiveSellOfferOperation, exports$12.StellarManageSellOfferOperation, exports$12.StellarManageBuyOfferOperation, exports$12.StellarSetOptionsOperation, exports$12.StellarChangeTrustOperation, exports$12.StellarAllowTrustOperation, exports$12.StellarAccountMergeOperation, exports$12.StellarInflationOperation, exports$12.StellarManageDataOperation, exports$12.StellarBumpSequenceOperation, exports$12.StellarClaimClaimableBalanceOperation]);
    exports$12.StellarTransaction = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Number(),
      sequence: schema_utils_1.Type.Uint(),
      timebounds: schema_utils_1.Type.Optional(schema_utils_1.Type.Object({
        minTime: schema_utils_1.Type.Number(),
        maxTime: schema_utils_1.Type.Number()
      })),
      memo: schema_utils_1.Type.Optional(schema_utils_1.Type.Object({
        type: constants_12.PROTO.EnumStellarMemoType,
        id: schema_utils_1.Type.Optional(schema_utils_1.Type.Uint()),
        text: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
        hash: schema_utils_1.Type.Optional(schema_utils_1.Type.Union([schema_utils_1.Type.String(), schema_utils_1.Type.Buffer()]))
      })),
      operations: schema_utils_1.Type.Array(exports$12.StellarOperation)
    });
    exports$12.StellarSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      networkPassphrase: schema_utils_1.Type.String(),
      transaction: exports$12.StellarTransaction
    });
    exports$12.StellarSignedTx = schema_utils_1.Type.Object({
      publicKey: schema_utils_1.Type.String(),
      signature: schema_utils_1.Type.String()
    });
    exports$12.StellarOperationMessage = schema_utils_1.Type.Union([schema_utils_1.Type.Intersect([schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("StellarCreateAccountOp")
    }), constants_12.PROTO.StellarCreateAccountOp]), schema_utils_1.Type.Intersect([schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("StellarPaymentOp")
    }), constants_12.PROTO.StellarPaymentOp]), schema_utils_1.Type.Intersect([schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("StellarPathPaymentStrictReceiveOp")
    }), constants_12.PROTO.StellarPathPaymentStrictReceiveOp]), schema_utils_1.Type.Intersect([schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("StellarPathPaymentStrictSendOp")
    }), constants_12.PROTO.StellarPathPaymentStrictSendOp]), schema_utils_1.Type.Intersect([schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("StellarManageSellOfferOp")
    }), constants_12.PROTO.StellarManageSellOfferOp]), schema_utils_1.Type.Intersect([schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("StellarManageBuyOfferOp")
    }), constants_12.PROTO.StellarManageBuyOfferOp]), schema_utils_1.Type.Intersect([schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("StellarCreatePassiveSellOfferOp")
    }), constants_12.PROTO.StellarCreatePassiveSellOfferOp]), schema_utils_1.Type.Intersect([schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("StellarSetOptionsOp")
    }), constants_12.PROTO.StellarSetOptionsOp]), schema_utils_1.Type.Intersect([schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("StellarChangeTrustOp")
    }), constants_12.PROTO.StellarChangeTrustOp]), schema_utils_1.Type.Intersect([schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("StellarAllowTrustOp")
    }), constants_12.PROTO.StellarAllowTrustOp]), schema_utils_1.Type.Intersect([schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("StellarAccountMergeOp")
    }), constants_12.PROTO.StellarAccountMergeOp]), schema_utils_1.Type.Intersect([schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("StellarManageDataOp")
    }), constants_12.PROTO.StellarManageDataOp]), schema_utils_1.Type.Intersect([schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("StellarBumpSequenceOp")
    }), constants_12.PROTO.StellarBumpSequenceOp]), schema_utils_1.Type.Intersect([schema_utils_1.Type.Object({
      type: schema_utils_1.Type.Literal("StellarClaimClaimableBalanceOp")
    }), constants_12.PROTO.StellarClaimClaimableBalanceOp])]);
  })(stellar);
  return stellar;
}
var tezos = {};
var hasRequiredTezos;
function requireTezos() {
  if (hasRequiredTezos) return tezos;
  hasRequiredTezos = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.TezosSignTransaction = exports$12.TezosOperation = exports$12.TezosDelegationOperation = exports$12.TezosOriginationOperation = exports$12.TezosTransactionOperation = exports$12.TezosParametersManager = exports$12.TezosManagerTransfer = exports$12.TezosRevealOperation = void 0;
    const schema_utils_1 = requireLib$3();
    const params_1 = requireParams();
    exports$12.TezosRevealOperation = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Number(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      public_key: schema_utils_1.Type.String()
    });
    exports$12.TezosManagerTransfer = schema_utils_1.Type.Object({
      destination: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.Number()
    });
    exports$12.TezosParametersManager = schema_utils_1.Type.Object({
      set_delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      cancel_delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean()),
      transfer: schema_utils_1.Type.Optional(exports$12.TezosManagerTransfer)
    });
    exports$12.TezosTransactionOperation = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      destination: schema_utils_1.Type.String(),
      amount: schema_utils_1.Type.Number(),
      counter: schema_utils_1.Type.Number(),
      fee: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number(),
      parameters: schema_utils_1.Type.Optional(schema_utils_1.Type.Array(schema_utils_1.Type.Number())),
      parameters_manager: schema_utils_1.Type.Optional(exports$12.TezosParametersManager)
    });
    exports$12.TezosOriginationOperation = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      balance: schema_utils_1.Type.Number(),
      delegate: schema_utils_1.Type.Optional(schema_utils_1.Type.String()),
      script: params_1.DerivationPath,
      fee: schema_utils_1.Type.Number(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number()
    });
    exports$12.TezosDelegationOperation = schema_utils_1.Type.Object({
      source: schema_utils_1.Type.String(),
      delegate: schema_utils_1.Type.String(),
      fee: schema_utils_1.Type.Number(),
      counter: schema_utils_1.Type.Number(),
      gas_limit: schema_utils_1.Type.Number(),
      storage_limit: schema_utils_1.Type.Number()
    });
    exports$12.TezosOperation = schema_utils_1.Type.Object({
      reveal: schema_utils_1.Type.Optional(exports$12.TezosRevealOperation),
      transaction: schema_utils_1.Type.Optional(exports$12.TezosTransactionOperation),
      origination: schema_utils_1.Type.Optional(exports$12.TezosOriginationOperation),
      delegation: schema_utils_1.Type.Optional(exports$12.TezosDelegationOperation)
    });
    exports$12.TezosSignTransaction = schema_utils_1.Type.Object({
      path: params_1.DerivationPath,
      branch: schema_utils_1.Type.String(),
      operation: exports$12.TezosOperation,
      chunkify: schema_utils_1.Type.Optional(schema_utils_1.Type.Boolean())
    });
  })(tezos);
  return tezos;
}
var messages = {};
var protobufDefinitions = {};
var hasRequiredProtobufDefinitions;
function requireProtobufDefinitions() {
  if (hasRequiredProtobufDefinitions) return protobufDefinitions;
  hasRequiredProtobufDefinitions = 1;
  Object.defineProperty(protobufDefinitions, "__esModule", {
    value: true
  });
  protobufDefinitions.getProtobufDefinitions = void 0;
  const getProtobufDefinitions = () => ({
    ThpPairingMethod: {
      values: {
        SkipPairing: 1,
        CodeEntry: 2,
        QrCode: 3,
        NFC: 4
      }
    },
    ThpDeviceProperties: {
      fields: {
        internal_model: {
          rule: "required",
          type: "string",
          id: 1
        },
        model_variant: {
          type: "uint32",
          id: 2,
          options: {
            default: 0
          }
        },
        protocol_version_major: {
          rule: "required",
          type: "uint32",
          id: 3
        },
        protocol_version_minor: {
          rule: "required",
          type: "uint32",
          id: 4
        },
        pairing_methods: {
          rule: "repeated",
          type: "ThpPairingMethod",
          id: 5,
          options: {
            packed: false
          }
        }
      }
    },
    ThpHandshakeCompletionReqNoisePayload: {
      fields: {
        host_pairing_credential: {
          type: "bytes",
          id: 1
        }
      }
    },
    ThpCreateNewSession: {
      fields: {
        passphrase: {
          type: "string",
          id: 1
        },
        on_device: {
          type: "bool",
          id: 2,
          options: {
            default: false
          }
        },
        derive_cardano: {
          type: "bool",
          id: 3,
          options: {
            default: false
          }
        }
      }
    },
    ThpPairingRequest: {
      fields: {
        host_name: {
          rule: "required",
          type: "string",
          id: 1
        },
        app_name: {
          rule: "required",
          type: "string",
          id: 2
        }
      }
    },
    ThpPairingRequestApproved: {
      fields: {}
    },
    ThpSelectMethod: {
      fields: {
        selected_pairing_method: {
          rule: "required",
          type: "ThpPairingMethod",
          id: 1
        }
      }
    },
    ThpPairingPreparationsFinished: {
      fields: {}
    },
    ThpCodeEntryCommitment: {
      fields: {
        commitment: {
          rule: "required",
          type: "bytes",
          id: 1
        }
      }
    },
    ThpCodeEntryChallenge: {
      fields: {
        challenge: {
          rule: "required",
          type: "bytes",
          id: 1
        }
      }
    },
    ThpCodeEntryCpaceTrezor: {
      fields: {
        cpace_trezor_public_key: {
          rule: "required",
          type: "bytes",
          id: 1
        }
      }
    },
    ThpCodeEntryCpaceHostTag: {
      fields: {
        cpace_host_public_key: {
          rule: "required",
          type: "bytes",
          id: 1
        },
        tag: {
          rule: "required",
          type: "bytes",
          id: 2
        }
      }
    },
    ThpCodeEntrySecret: {
      fields: {
        secret: {
          rule: "required",
          type: "bytes",
          id: 1
        }
      }
    },
    ThpQrCodeTag: {
      fields: {
        tag: {
          rule: "required",
          type: "bytes",
          id: 1
        }
      }
    },
    ThpQrCodeSecret: {
      fields: {
        secret: {
          rule: "required",
          type: "bytes",
          id: 1
        }
      }
    },
    ThpNfcTagHost: {
      fields: {
        tag: {
          rule: "required",
          type: "bytes",
          id: 1
        }
      }
    },
    ThpNfcTagTrezor: {
      fields: {
        tag: {
          rule: "required",
          type: "bytes",
          id: 1
        }
      }
    },
    ThpCredentialRequest: {
      fields: {
        host_static_public_key: {
          rule: "required",
          type: "bytes",
          id: 1
        },
        autoconnect: {
          type: "bool",
          id: 2,
          options: {
            default: false
          }
        },
        credential: {
          type: "bytes",
          id: 3
        }
      }
    },
    ThpCredentialResponse: {
      fields: {
        trezor_static_public_key: {
          rule: "required",
          type: "bytes",
          id: 1
        },
        credential: {
          rule: "required",
          type: "bytes",
          id: 2
        }
      }
    },
    ThpEndRequest: {
      fields: {}
    },
    ThpEndResponse: {
      fields: {}
    },
    MessageType: {
      options: {
        "(has_bitcoin_only_values)": true,
        "(wire_enum)": true
      },
      values: {
        ThpCreateNewSession: 1e3,
        ThpCredentialRequest: 1016,
        ThpCredentialResponse: 1017,
        ThpPairingRequest: 1008,
        ThpPairingRequestApproved: 1009,
        ThpSelectMethod: 1010,
        ThpPairingPreparationsFinished: 1011,
        ThpEndRequest: 1018,
        ThpEndResponse: 1019,
        ThpCodeEntryCommitment: 1024,
        ThpCodeEntryChallenge: 1025,
        ThpCodeEntryCpaceTrezor: 1026,
        ThpCodeEntryCpaceHostTag: 1027,
        ThpCodeEntrySecret: 1028,
        ThpQrCodeTag: 1032,
        ThpQrCodeSecret: 1033,
        ThpNfcTagHost: 1040,
        ThpNfcTagTrezor: 1041
      }
    }
  });
  protobufDefinitions.getProtobufDefinitions = getProtobufDefinitions;
  return protobufDefinitions;
}
var messageTypes = {};
var hasRequiredMessageTypes;
function requireMessageTypes() {
  if (hasRequiredMessageTypes) return messageTypes;
  hasRequiredMessageTypes = 1;
  Object.defineProperty(messageTypes, "__esModule", {
    value: true
  });
  return messageTypes;
}
var protobufTypes = {};
var hasRequiredProtobufTypes;
function requireProtobufTypes() {
  if (hasRequiredProtobufTypes) return protobufTypes;
  hasRequiredProtobufTypes = 1;
  Object.defineProperty(protobufTypes, "__esModule", {
    value: true
  });
  protobufTypes.ThpPairingMethod = void 0;
  var ThpPairingMethod;
  (function(ThpPairingMethod2) {
    ThpPairingMethod2[ThpPairingMethod2["SkipPairing"] = 1] = "SkipPairing";
    ThpPairingMethod2[ThpPairingMethod2["CodeEntry"] = 2] = "CodeEntry";
    ThpPairingMethod2[ThpPairingMethod2["QrCode"] = 3] = "QrCode";
    ThpPairingMethod2[ThpPairingMethod2["NFC"] = 4] = "NFC";
  })(ThpPairingMethod || (protobufTypes.ThpPairingMethod = ThpPairingMethod = {}));
  return protobufTypes;
}
var hasRequiredMessages;
function requireMessages() {
  if (hasRequiredMessages) return messages;
  hasRequiredMessages = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.getProtobufDefinitions = void 0;
    const tslib_12 = require$$0$1;
    var protobufDefinitions_1 = requireProtobufDefinitions();
    Object.defineProperty(exports$12, "getProtobufDefinitions", {
      enumerable: true,
      get: function() {
        return protobufDefinitions_1.getProtobufDefinitions;
      }
    });
    tslib_12.__exportStar(requireMessageTypes(), exports$12);
    tslib_12.__exportStar(requireProtobufTypes(), exports$12);
  })(messages);
  return messages;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types$1;
  hasRequiredTypes = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.ThpPairingMethod = exports$12.FirmwareType = void 0;
    const tslib_12 = require$$0$1;
    tslib_12.__exportStar(requireApi(), exports$12);
    tslib_12.__exportStar(requireAccount(), exports$12);
    tslib_12.__exportStar(requireCoinInfo(), exports$12);
    tslib_12.__exportStar(requireDevice(), exports$12);
    tslib_12.__exportStar(requireFees(), exports$12);
    tslib_12.__exportStar(requireFirmware(), exports$12);
    tslib_12.__exportStar(requireParams(), exports$12);
    tslib_12.__exportStar(requireSettings(), exports$12);
    tslib_12.__exportStar(requireCardano(), exports$12);
    tslib_12.__exportStar(requireBitcoin(), exports$12);
    tslib_12.__exportStar(requireEos(), exports$12);
    tslib_12.__exportStar(requireRipple(), exports$12);
    tslib_12.__exportStar(requireEthereum(), exports$12);
    tslib_12.__exportStar(requireMonero(), exports$12);
    tslib_12.__exportStar(requireSolana(), exports$12);
    tslib_12.__exportStar(requireStellar(), exports$12);
    tslib_12.__exportStar(requireTezos(), exports$12);
    var device_utils_1 = requireLib();
    Object.defineProperty(exports$12, "FirmwareType", {
      enumerable: true,
      get: function() {
        return device_utils_1.FirmwareType;
      }
    });
    var messages_1 = requireMessages();
    Object.defineProperty(exports$12, "ThpPairingMethod", {
      enumerable: true,
      get: function() {
        return messages_1.ThpPairingMethod;
      }
    });
  })(types$1);
  return types$1;
}
var hasRequiredExports;
function requireExports() {
  if (hasRequiredExports) return exports$1;
  hasRequiredExports = 1;
  (function(exports$12) {
    Object.defineProperty(exports$12, "__esModule", {
      value: true
    });
    exports$12.parseConnectSettings = void 0;
    const tslib_12 = require$$0$1;
    tslib_12.__exportStar(constants, exports$12);
    tslib_12.__exportStar(events, exports$12);
    tslib_12.__exportStar(requireTypes(), exports$12);
    var connectSettings_12 = connectSettings;
    Object.defineProperty(exports$12, "parseConnectSettings", {
      enumerable: true,
      get: function() {
        return connectSettings_12.parseConnectSettings;
      }
    });
  })(exports$1);
  return exports$1;
}
(function(exports$12) {
  Object.defineProperty(exports$12, "__esModule", {
    value: true
  });
  const tslib_12 = require$$0$1;
  const factory_12 = factory;
  const dynamic_1 = dynamic;
  const connectSettings_12 = connectSettings$1;
  const core_in_iframe_1 = coreInIframe;
  const core_in_popup_1 = coreInPopup;
  const core_in_suite_desktop_1 = coreInSuiteDesktop;
  const core_in_suite_web_1 = coreInSuiteWeb;
  const IFRAME_ERRORS = ["Init_IframeBlocked", "Init_IframeTimeout", "Transport_Missing"];
  const impl2 = new dynamic_1.TrezorConnectDynamic({
    implementations: [{
      type: "iframe",
      impl: new core_in_iframe_1.CoreInIframe()
    }, {
      type: "core-in-popup",
      impl: new core_in_popup_1.CoreInPopup()
    }, {
      type: "core-in-suite-desktop",
      impl: new core_in_suite_desktop_1.CoreInSuiteDesktop()
    }, {
      type: "core-in-suite-web",
      impl: new core_in_suite_web_1.CoreInSuiteWeb()
    }],
    getInitTarget: (settings2) => {
      if (settings2.coreMode === "iframe") {
        return "iframe";
      } else if (settings2.coreMode === "popup") {
        return "core-in-popup";
      } else if (settings2.coreMode === "suite-desktop") {
        return "core-in-suite-desktop";
      } else if (settings2.coreMode === "suite-web") {
        return "core-in-suite-web";
      } else {
        if (settings2.coreMode && settings2.coreMode !== "auto") {
          console.warn(`Invalid coreMode: ${settings2.coreMode}`);
        }
        return "iframe";
      }
    },
    handleBeforeCall: async () => {
      var _a, _b, _c;
      const isCoreModeDesktop = ((_a = impl2.lastSettings) == null ? void 0 : _a.coreMode) === "suite-desktop";
      const isCoreModeAuto = ((_b = impl2.lastSettings) == null ? void 0 : _b.coreMode) === "auto" || ((_c = impl2.lastSettings) == null ? void 0 : _c.coreMode) === void 0;
      if (isCoreModeDesktop || isCoreModeAuto) {
        await impl2.switchTarget("core-in-suite-desktop");
      }
    },
    handleErrorFallback: async (errorCode) => {
      var _a, _b, _c, _d, _e;
      const env = (0, connectSettings_12.getEnv)();
      const isCoreModeDisabled = ((_a = impl2.lastSettings) == null ? void 0 : _a.popup) === false || env === "webextension";
      const isCoreModeAuto = ((_b = impl2.lastSettings) == null ? void 0 : _b.coreMode) === "auto" || ((_c = impl2.lastSettings) == null ? void 0 : _c.coreMode) === void 0;
      if (impl2.getTargetType() === "core-in-suite-desktop" && (errorCode === "Desktop_ConnectionMissing" || errorCode === "Method_Unsupported")) {
        await impl2.switchTarget("iframe");
        return true;
      }
      if (!isCoreModeDisabled && isCoreModeAuto && IFRAME_ERRORS.includes(errorCode)) {
        const webUsbUnavailableInBrowser = !(navigator == null ? void 0 : navigator.usb);
        const webUsbDisabledInSettings = ((_e = (_d = impl2.lastSettings) == null ? void 0 : _d.transports) == null ? void 0 : _e.includes("WebUsbTransport")) === false;
        if (errorCode === "Transport_Missing" && (webUsbUnavailableInBrowser || webUsbDisabledInSettings)) {
          return false;
        }
        await impl2.switchTarget("core-in-popup");
        return true;
      }
      return false;
    }
  });
  const TrezorConnect = (0, factory_12.factory)({
    eventEmitter: impl2.eventEmitter,
    init: impl2.init.bind(impl2),
    call: impl2.call.bind(impl2),
    setTransports: impl2.setTransports.bind(impl2),
    manifest: impl2.manifest.bind(impl2),
    uiResponse: impl2.uiResponse.bind(impl2),
    cancel: impl2.cancel.bind(impl2),
    dispose: impl2.dispose.bind(impl2)
  }, {
    renderWebUSBButton: impl2.getTarget().renderWebUSBButton.bind(impl2),
    disableWebUSB: impl2.getTarget().disableWebUSB.bind(impl2),
    requestWebUSBDevice: impl2.getTarget().requestWebUSBDevice.bind(impl2)
  });
  exports$12.default = TrezorConnect;
  tslib_12.__exportStar(requireExports(), exports$12);
})(lib$5);
const index = /* @__PURE__ */ getDefaultExportFromCjs(lib$5);
const index$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [lib$5]);
export {
  index$1 as i
};
