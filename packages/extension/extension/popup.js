const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["TransportWebBLE.js","index2.js","events.js","index3.js","tslib.es6.js","TransportWebHID.js","hid-framing.js","TransportWebUSB.js","Solana.js","index.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a, _b;
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a.prototype = f2.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a, k2, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$1 = Symbol.for("react.element"), n$1 = Symbol.for("react.portal"), p$2 = Symbol.for("react.fragment"), q$1 = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v$1 = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z$1 = Symbol.iterator;
function A$3(a) {
  if (null === a || "object" !== typeof a) return null;
  a = z$1 && a[z$1] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = D$1;
  this.updater = e || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a, b) {
  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b, "setState");
};
E$1.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = D$1;
  this.updater = e || B$1;
}
var H$1 = G$1.prototype = new F();
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$3(a, b, e) {
  var d, c = {}, k2 = null, h = null;
  if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k2 = "" + b.key), b) J.call(b, d) && !L$1.hasOwnProperty(d) && (c[d] = b[d]);
  var g = arguments.length - 2;
  if (1 === g) c.children = e;
  else if (1 < g) {
    for (var f2 = Array(g), m2 = 0; m2 < g; m2++) f2[m2] = arguments[m2 + 2];
    c.children = f2;
  }
  if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
  return { $$typeof: l$1, type: a, key: k2, ref: h, props: c, _owner: K$1.current };
}
function N$1(a, b) {
  return { $$typeof: l$1, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
}
function O$1(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l$1;
}
function escape(a) {
  var b = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b[a2];
  });
}
var P$1 = /\/+/g;
function Q$1(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}
function R$1(a, b, e, d, c) {
  var k2 = typeof a;
  if ("undefined" === k2 || "boolean" === k2) a = null;
  var h = false;
  if (null === a) h = true;
  else switch (k2) {
    case "string":
    case "number":
      h = true;
      break;
    case "object":
      switch (a.$$typeof) {
        case l$1:
        case n$1:
          h = true;
      }
  }
  if (h) return h = a, c = c(h), a = "" === d ? "." + Q$1(h, 0) : d, I$1(c) ? (e = "", null != a && (e = a.replace(P$1, "$&/") + "/"), R$1(c, b, e, "", function(a2) {
    return a2;
  })) : null != c && (O$1(c) && (c = N$1(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P$1, "$&/") + "/") + a)), b.push(c)), 1;
  h = 0;
  d = "" === d ? "." : d + ":";
  if (I$1(a)) for (var g = 0; g < a.length; g++) {
    k2 = a[g];
    var f2 = d + Q$1(k2, g);
    h += R$1(k2, b, e, f2, c);
  }
  else if (f2 = A$3(a), "function" === typeof f2) for (a = f2.call(a), g = 0; !(k2 = a.next()).done; ) k2 = k2.value, f2 = d + Q$1(k2, g++), h += R$1(k2, b, e, f2, c);
  else if ("object" === k2) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
  return h;
}
function S$3(a, b, e) {
  if (null == a) return a;
  var d = [], c = 0;
  R$1(a, d, "", "", function(a2) {
    return b.call(e, a2, c++);
  });
  return d;
}
function T$1(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    b.then(function(b2) {
      if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
    }, function(b2) {
      if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
    });
    -1 === a._status && (a._status = 0, a._result = b);
  }
  if (1 === a._status) return a._result.default;
  throw a._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
function X$3() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$3, forEach: function(a, b, e) {
  S$3(a, function() {
    b.apply(this, arguments);
  }, e);
}, count: function(a) {
  var b = 0;
  S$3(a, function() {
    b++;
  });
  return b;
}, toArray: function(a) {
  return S$3(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O$1(a)) throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$2;
react_production_min.Profiler = r;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$1;
react_production_min.Suspense = w;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$3;
react_production_min.cloneElement = function(a, b, e) {
  if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d = C$1({}, a.props), c = a.key, k2 = a.ref, h = a._owner;
  if (null != b) {
    void 0 !== b.ref && (k2 = b.ref, h = K$1.current);
    void 0 !== b.key && (c = "" + b.key);
    if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
    for (f2 in b) J.call(b, f2) && !L$1.hasOwnProperty(f2) && (d[f2] = void 0 === b[f2] && void 0 !== g ? g[f2] : b[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2) d.children = e;
  else if (1 < f2) {
    g = Array(f2);
    for (var m2 = 0; m2 < f2; m2++) g[m2] = arguments[m2 + 2];
    d.children = g;
  }
  return { $$typeof: l$1, type: a.type, key: c, ref: k2, props: d, _owner: h };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M$3;
react_production_min.createFactory = function(a) {
  var b = M$3.bind(null, a);
  b.type = a;
  return b;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v$1, render: a };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a) {
  return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T$1 };
};
react_production_min.memo = function(a, b) {
  return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
};
react_production_min.startTransition = function(a) {
  var b = V$1.transition;
  V$1.transition = {};
  try {
    a();
  } finally {
    V$1.transition = b;
  }
};
react_production_min.unstable_act = X$3;
react_production_min.useCallback = function(a, b) {
  return U$1.current.useCallback(a, b);
};
react_production_min.useContext = function(a) {
  return U$1.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U$1.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b) {
  return U$1.current.useEffect(a, b);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a, b, e) {
  return U$1.current.useImperativeHandle(a, b, e);
};
react_production_min.useInsertionEffect = function(a, b) {
  return U$1.current.useInsertionEffect(a, b);
};
react_production_min.useLayoutEffect = function(a, b) {
  return U$1.current.useLayoutEffect(a, b);
};
react_production_min.useMemo = function(a, b) {
  return U$1.current.useMemo(a, b);
};
react_production_min.useReducer = function(a, b, e) {
  return U$1.current.useReducer(a, b, e);
};
react_production_min.useRef = function(a) {
  return U$1.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U$1.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b, e) {
  return U$1.current.useSyncExternalStore(a, b, e);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = reactExports, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m$1 = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$1 = { key: true, ref: true, __self: true, __source: true };
function q(c, a, g) {
  var b, d = {}, e = null, h = null;
  void 0 !== g && (e = "" + g);
  void 0 !== a.key && (e = "" + a.key);
  void 0 !== a.ref && (h = a.ref);
  for (b in a) m$1.call(a, b) && !p$1.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
  return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports$1) {
  function f2(a, b) {
    var c = a.length;
    a.push(b);
    a: for (; 0 < c; ) {
      var d = c - 1 >>> 1, e = a[d];
      if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
      else break a;
    }
  }
  function h(a) {
    return 0 === a.length ? null : a[0];
  }
  function k2(a) {
    if (0 === a.length) return null;
    var b = a[0], c = a.pop();
    if (c !== b) {
      a[0] = c;
      a: for (var d = 0, e = a.length, w2 = e >>> 1; d < w2; ) {
        var m2 = 2 * (d + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
        if (0 > g(C2, c)) n2 < e && 0 > g(x2, C2) ? (a[d] = x2, a[n2] = c, d = n2) : (a[d] = C2, a[m2] = c, d = m2);
        else if (n2 < e && 0 > g(x2, c)) a[d] = x2, a[n2] = c, d = n2;
        else break a;
      }
    }
    return b;
  }
  function g(a, b) {
    var c = a.sortIndex - b.sortIndex;
    return 0 !== c ? c : a.id - b.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports$1.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports$1.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D3 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a) {
    for (var b = h(t2); null !== b; ) {
      if (null === b.callback) k2(t2);
      else if (b.startTime <= a) k2(t2), b.sortIndex = b.expirationTime, f2(r2, b);
      else break;
      b = h(t2);
    }
  }
  function H2(a) {
    B2 = false;
    G2(a);
    if (!A2) if (null !== h(r2)) A2 = true, I2(J2);
    else {
      var b = h(t2);
      null !== b && K2(H2, b.startTime - a);
    }
  }
  function J2(a, b) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c = y2;
    try {
      G2(b);
      for (v2 = h(r2); null !== v2 && (!(v2.expirationTime > b) || a && !M2()); ) {
        var d = v2.callback;
        if ("function" === typeof d) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e = d(v2.expirationTime <= b);
          b = exports$1.unstable_now();
          "function" === typeof e ? v2.callback = e : v2 === h(r2) && k2(r2);
          G2(b);
        } else k2(r2);
        v2 = h(r2);
      }
      if (null !== v2) var w2 = true;
      else {
        var m2 = h(t2);
        null !== m2 && K2(H2, m2.startTime - b);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports$1.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a = exports$1.unstable_now();
      Q2 = a;
      var b = true;
      try {
        b = O2(true, a);
      } finally {
        b ? S2() : (N2 = false, O2 = null);
      }
    } else N2 = false;
  }
  var S2;
  if ("function" === typeof F2) S2 = function() {
    F2(R2);
  };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else S2 = function() {
    D3(R2, 0);
  };
  function I2(a) {
    O2 = a;
    N2 || (N2 = true, S2());
  }
  function K2(a, b) {
    L2 = D3(function() {
      a(exports$1.unstable_now());
    }, b);
  }
  exports$1.unstable_IdlePriority = 5;
  exports$1.unstable_ImmediatePriority = 1;
  exports$1.unstable_LowPriority = 4;
  exports$1.unstable_NormalPriority = 3;
  exports$1.unstable_Profiling = null;
  exports$1.unstable_UserBlockingPriority = 2;
  exports$1.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports$1.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports$1.unstable_forceFrameRate = function(a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
  };
  exports$1.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports$1.unstable_getFirstCallbackNode = function() {
    return h(r2);
  };
  exports$1.unstable_next = function(a) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b = 3;
        break;
      default:
        b = y2;
    }
    var c = y2;
    y2 = b;
    try {
      return a();
    } finally {
      y2 = c;
    }
  };
  exports$1.unstable_pauseExecution = function() {
  };
  exports$1.unstable_requestPaint = function() {
  };
  exports$1.unstable_runWithPriority = function(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c = y2;
    y2 = a;
    try {
      return b();
    } finally {
      y2 = c;
    }
  };
  exports$1.unstable_scheduleCallback = function(a, b, c) {
    var d = exports$1.unstable_now();
    "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
    switch (a) {
      case 1:
        var e = -1;
        break;
      case 2:
        e = 250;
        break;
      case 5:
        e = 1073741823;
        break;
      case 4:
        e = 1e4;
        break;
      default:
        e = 5e3;
    }
    e = c + e;
    a = { id: u2++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
    c > d ? (a.sortIndex = c, f2(t2, a), null === h(r2) && a === h(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c - d))) : (a.sortIndex = e, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
    return a;
  };
  exports$1.unstable_shouldYield = M2;
  exports$1.unstable_wrapCallback = function(a) {
    var b = y2;
    return function() {
      var c = y2;
      y2 = b;
      try {
        return a.apply(this, arguments);
      } finally {
        y2 = c;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a, b) {
  ha(a, b);
  ha(a + "Capture", b);
}
function ha(a, b) {
  ea[a] = b;
  for (a = 0; a < b.length; a++) da.add(b[a]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a) {
  if (ja.call(ma, a)) return true;
  if (ja.call(la, a)) return false;
  if (ka.test(a)) return ma[a] = true;
  la[a] = true;
  return false;
}
function pa(a, b, c, d) {
  if (null !== c && 0 === c.type) return false;
  switch (typeof b) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d) return false;
      if (null !== c) return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function qa(a, b, c, d) {
  if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
  if (d) return false;
  if (null !== c) switch (c.type) {
    case 3:
      return !b;
    case 4:
      return false === b;
    case 5:
      return isNaN(b);
    case 6:
      return isNaN(b) || 1 > b;
  }
  return false;
}
function v(a, b, c, d, e, f2, g) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
  this.attributeName = d;
  this.attributeNamespace = e;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = f2;
  this.removeEmptyString = g;
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z[a] = new v(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b = a[0];
  z[b] = new v(b, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z[a] = new v(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z[a] = new v(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z[a] = new v(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z[a] = new v(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b = a.replace(
    ra,
    sa
  );
  z[b] = new v(b, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b = a.replace(ra, sa);
  z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b = a.replace(ra, sa);
  z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
});
z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
});
function ta(a, b, c, d) {
  var e = z.hasOwnProperty(b) ? z[b] : null;
  if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a) {
  if (null === a || "object" !== typeof a) return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var A$2 = Object.assign, La;
function Ma(a) {
  if (void 0 === La) try {
    throw Error();
  } catch (c) {
    var b = c.stack.trim().match(/\n( *(at )?)/);
    La = b && b[1] || "";
  }
  return "\n" + La + a;
}
var Na = false;
function Oa(a, b) {
  if (!a || Na) return "";
  Na = true;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b) if (b = function() {
      throw Error();
    }, Object.defineProperty(b.prototype, "props", { set: function() {
      throw Error();
    } }), "object" === typeof Reflect && Reflect.construct) {
      try {
        Reflect.construct(b, []);
      } catch (l2) {
        var d = l2;
      }
      Reflect.construct(a, [], b);
    } else {
      try {
        b.call();
      } catch (l2) {
        d = l2;
      }
      a.call(b.prototype);
    }
    else {
      try {
        throw Error();
      } catch (l2) {
        d = l2;
      }
      a();
    }
  } catch (l2) {
    if (l2 && d && "string" === typeof l2.stack) {
      for (var e = l2.stack.split("\n"), f2 = d.stack.split("\n"), g = e.length - 1, h = f2.length - 1; 1 <= g && 0 <= h && e[g] !== f2[h]; ) h--;
      for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f2[h]) {
        if (1 !== g || 1 !== h) {
          do
            if (g--, h--, 0 > h || e[g] !== f2[h]) {
              var k2 = "\n" + e[g].replace(" at new ", " at ");
              a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
              return k2;
            }
          while (1 <= g && 0 <= h);
        }
        break;
      }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}
function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, false), a;
    case 11:
      return a = Oa(a.type.render, false), a;
    case 1:
      return a = Oa(a.type, true), a;
    default:
      return "";
  }
}
function Qa(a) {
  if (null == a) return null;
  if ("function" === typeof a) return a.displayName || a.name || null;
  if ("string" === typeof a) return a;
  switch (a) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a) switch (a.$$typeof) {
    case Ca:
      return (a.displayName || "Context") + ".Consumer";
    case Ba:
      return (a._context.displayName || "Context") + ".Provider";
    case Da:
      var b = a.render;
      a = a.displayName;
      a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      return a;
    case Ga:
      return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
    case Ha:
      b = a._payload;
      a = a._init;
      try {
        return Qa(a(b));
      } catch (c) {
      }
  }
  return null;
}
function Ra(a) {
  var b = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b.displayName || "Context") + ".Consumer";
    case 10:
      return (b._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b);
    case 8:
      return b === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b) return b.displayName || b.name || null;
      if ("string" === typeof b) return b;
  }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function Ua(a) {
  var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
  if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
    var e = c.get, f2 = c.set;
    Object.defineProperty(a, b, { configurable: true, get: function() {
      return e.call(this);
    }, set: function(a2) {
      d = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b, { enumerable: c.enumerable });
    return { getValue: function() {
      return d;
    }, setValue: function(a2) {
      d = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a) return false;
  var b = a._valueTracker;
  if (!b) return true;
  var c = b.getValue();
  var d = "";
  a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b.setValue(a), true) : false;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a) return null;
  try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}
function Ya(a, b) {
  var c = b.checked;
  return A$2({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
}
function Za(a, b) {
  var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
  c = Sa(null != b.value ? b.value : c);
  a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
}
function ab(a, b) {
  b = b.checked;
  null != b && ta(a, "checked", b, false);
}
function bb(a, b) {
  ab(a, b);
  var c = Sa(b.value), d = b.type;
  if (null != c) if ("number" === d) {
    if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
  } else a.value !== "" + c && (a.value = "" + c);
  else if ("submit" === d || "reset" === d) {
    a.removeAttribute("value");
    return;
  }
  b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
  null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function db(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d = b.type;
    if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
    b = "" + a._wrapperState.initialValue;
    c || b === a.value || (a.value = b);
    a.defaultValue = b;
  }
  c = a.name;
  "" !== c && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c && (a.name = c);
}
function cb(a, b, c) {
  if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}
var eb = Array.isArray;
function fb(a, b, c, d) {
  a = a.options;
  if (b) {
    b = {};
    for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
    for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
  } else {
    c = "" + Sa(c);
    b = null;
    for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = true;
        d && (a[e].defaultSelected = true);
        return;
      }
      null !== b || a[e].disabled || (b = a[e]);
    }
    null !== b && (b.selected = true);
  }
}
function gb(a, b) {
  if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
  return A$2({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b) {
  var c = b.value;
  if (null == c) {
    c = b.children;
    b = b.defaultValue;
    if (null != c) {
      if (null != b) throw Error(p(92));
      if (eb(c)) {
        if (1 < c.length) throw Error(p(93));
        c = c[0];
      }
      b = c;
    }
    null == b && (b = "");
    c = b;
  }
  a._wrapperState = { initialValue: Sa(c) };
}
function ib(a, b) {
  var c = Sa(b.value), d = Sa(b.defaultValue);
  null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
  null != d && (a.defaultValue = "" + d);
}
function jb(a) {
  var b = a.textContent;
  b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
}
function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var mb, nb = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b, c, d, e);
    });
  } : a;
}(function(a, b) {
  if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
    for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
    for (; b.firstChild; ) a.appendChild(b.firstChild);
  }
});
function ob(a, b) {
  if (b) {
    var c = a.firstChild;
    if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;
      return;
    }
  }
  a.textContent = b;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a) {
  qb.forEach(function(b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b] = pb[a];
  });
});
function rb(a, b, c) {
  return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
}
function sb(a, b) {
  a = a.style;
  for (var c in b) if (b.hasOwnProperty(c)) {
    var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
    "float" === c && (c = "cssFloat");
    d ? a.setProperty(c, e) : a[c] = e;
  }
}
var tb = A$2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a, b) {
  if (b) {
    if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
    if (null != b.dangerouslySetInnerHTML) {
      if (null != b.children) throw Error(p(60));
      if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
    }
    if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
  }
}
function vb(a, b) {
  if (-1 === a.indexOf("-")) return "string" === typeof b.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb) throw Error(p(280));
    var b = a.stateNode;
    b && (b = Db(b), yb(a.stateNode, a.type, b));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b = Ab;
    Ab = zb = null;
    Bb(a);
    if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
  }
}
function Gb(a, b) {
  return a(b);
}
function Hb() {
}
var Ib = false;
function Jb(a, b, c) {
  if (Ib) return a(b, c);
  Ib = true;
  try {
    return Gb(a, b, c);
  } finally {
    if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
  }
}
function Kb(a, b) {
  var c = a.stateNode;
  if (null === c) return null;
  var d = Db(c);
  if (null === d) return null;
  c = d[b];
  a: switch (b) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
      a = !d;
      break a;
    default:
      a = false;
  }
  if (a) return null;
  if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
  return c;
}
var Lb = false;
if (ia) try {
  var Mb = {};
  Object.defineProperty(Mb, "passive", { get: function() {
    Lb = true;
  } });
  window.addEventListener("test", Mb, Mb);
  window.removeEventListener("test", Mb, Mb);
} catch (a) {
  Lb = false;
}
function Nb(a, b, c, d, e, f2, g, h, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b.apply(c, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
  Ob = true;
  Pb = a;
} };
function Tb(a, b, c, d, e, f2, g, h, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a, b, c, d, e, f2, g, h, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else throw Error(p(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a) {
  var b = a, c = a;
  if (a.alternate) for (; b.return; ) b = b.return;
  else {
    a = b;
    do
      b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
    while (a);
  }
  return 3 === b.tag ? c : null;
}
function Wb(a) {
  if (13 === a.tag) {
    var b = a.memoizedState;
    null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
    if (null !== b) return b.dehydrated;
  }
  return null;
}
function Xb(a) {
  if (Vb(a) !== a) throw Error(p(188));
}
function Yb(a) {
  var b = a.alternate;
  if (!b) {
    b = Vb(a);
    if (null === b) throw Error(p(188));
    return b !== a ? null : a;
  }
  for (var c = a, d = b; ; ) {
    var e = c.return;
    if (null === e) break;
    var f2 = e.alternate;
    if (null === f2) {
      d = e.return;
      if (null !== d) {
        c = d;
        continue;
      }
      break;
    }
    if (e.child === f2.child) {
      for (f2 = e.child; f2; ) {
        if (f2 === c) return Xb(e), a;
        if (f2 === d) return Xb(e), b;
        f2 = f2.sibling;
      }
      throw Error(p(188));
    }
    if (c.return !== d.return) c = e, d = f2;
    else {
      for (var g = false, h = e.child; h; ) {
        if (h === c) {
          g = true;
          c = e;
          d = f2;
          break;
        }
        if (h === d) {
          g = true;
          d = e;
          c = f2;
          break;
        }
        h = h.sibling;
      }
      if (!g) {
        for (h = f2.child; h; ) {
          if (h === c) {
            g = true;
            c = f2;
            d = e;
            break;
          }
          if (h === d) {
            g = true;
            d = f2;
            c = e;
            break;
          }
          h = h.sibling;
        }
        if (!g) throw Error(p(189));
      }
    }
    if (c.alternate !== d) throw Error(p(190));
  }
  if (3 !== c.tag) throw Error(p(188));
  return c.stateNode.current === c ? a : b;
}
function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}
function $b(a) {
  if (5 === a.tag || 6 === a.tag) return a;
  for (a = a.child; null !== a; ) {
    var b = $b(a);
    if (null !== b) return b;
    a = a.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot) try {
    lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
  } catch (b) {
  }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function uc(a, b) {
  var c = a.pendingLanes;
  if (0 === c) return 0;
  var d = 0, e = a.suspendedLanes, f2 = a.pingedLanes, g = c & 268435455;
  if (0 !== g) {
    var h = g & ~e;
    0 !== h ? d = tc(h) : (f2 &= g, 0 !== f2 && (d = tc(f2)));
  } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f2 && (d = tc(f2));
  if (0 === d) return 0;
  if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f2 = b & -b, e >= f2 || 16 === e && 0 !== (f2 & 4194240))) return b;
  0 !== (d & 4) && (d |= c & 16);
  b = a.entangledLanes;
  if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
  return d;
}
function vc(a, b) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a, b) {
  for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
    var g = 31 - oc(f2), h = 1 << g, k2 = e[g];
    if (-1 === k2) {
      if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
    } else k2 <= b && (a.expiredLanes |= h);
    f2 &= ~h;
  }
}
function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}
function zc(a) {
  for (var b = [], c = 0; 31 > c; c++) b.push(a);
  return b;
}
function Ac(a, b, c) {
  a.pendingLanes |= b;
  536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b = 31 - oc(b);
  a[b] = c;
}
function Bc(a, b) {
  var c = a.pendingLanes & ~b;
  a.pendingLanes = b;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b;
  a.mutableReadLanes &= b;
  a.entangledLanes &= b;
  b = a.entanglements;
  var d = a.eventTimes;
  for (a = a.expirationTimes; 0 < c; ) {
    var e = 31 - oc(c), f2 = 1 << e;
    b[e] = 0;
    d[e] = -1;
    a[e] = -1;
    c &= ~f2;
  }
}
function Cc(a, b) {
  var c = a.entangledLanes |= b;
  for (a = a.entanglements; c; ) {
    var d = 31 - oc(c), e = 1 << d;
    e & b | a[d] & b && (a[d] |= b);
    c &= ~e;
  }
}
var C = 0;
function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a, b) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b.pointerId);
  }
}
function Tc(a, b, c, d, e, f2) {
  if (null === a || a.nativeEvent !== f2) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f2, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
  a.eventSystemFlags |= d;
  b = a.targetContainers;
  null !== e && -1 === b.indexOf(e) && b.push(e);
  return a;
}
function Uc(a, b, c, d, e) {
  switch (b) {
    case "focusin":
      return Lc = Tc(Lc, a, b, c, d, e), true;
    case "dragenter":
      return Mc = Tc(Mc, a, b, c, d, e), true;
    case "mouseover":
      return Nc = Tc(Nc, a, b, c, d, e), true;
    case "pointerover":
      var f2 = e.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a, b, c, d, e));
      return true;
    case "gotpointercapture":
      return f2 = e.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b, c, d, e)), true;
  }
  return false;
}
function Vc(a) {
  var b = Wc(a.target);
  if (null !== b) {
    var c = Vb(b);
    if (null !== c) {
      if (b = c.tag, 13 === b) {
        if (b = Wb(c), null !== b) {
          a.blockedOn = b;
          Ic(a.priority, function() {
            Gc(c);
          });
          return;
        }
      } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
        a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function Xc(a) {
  if (null !== a.blockedOn) return false;
  for (var b = a.targetContainers; 0 < b.length; ) {
    var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
    if (null === c) {
      c = a.nativeEvent;
      var d = new c.constructor(c.type, c);
      wb = d;
      c.target.dispatchEvent(d);
      wb = null;
    } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
    b.shift();
  }
  return true;
}
function Zc(a, b, c) {
  Xc(a) && c.delete(b);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a, b) {
  a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a) {
  function b(b2) {
    return ad(b2, a);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a);
    for (var c = 1; c < Kc.length; c++) {
      var d = Kc[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b);
  Pc.forEach(b);
  for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
  for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a, b, c, d) {
  var e = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a, b, c, d);
  } finally {
    C = e, cd.transition = f2;
  }
}
function gd(a, b, c, d) {
  var e = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a, b, c, d);
  } finally {
    C = e, cd.transition = f2;
  }
}
function fd(a, b, c, d) {
  if (dd) {
    var e = Yc(a, b, c, d);
    if (null === e) hd(a, b, d, id, c), Sc(a, d);
    else if (Uc(e, a, b, c, d)) d.stopPropagation();
    else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e; ) {
        var f2 = Cb(e);
        null !== f2 && Ec(f2);
        f2 = Yc(a, b, c, d);
        null === f2 && hd(a, b, d, id, c);
        if (f2 === e) break;
        e = f2;
      }
      null !== e && d.stopPropagation();
    } else hd(a, b, d, null, c);
  }
}
var id = null;
function Yc(a, b, c, d) {
  id = null;
  a = xb(d);
  a = Wc(a);
  if (null !== a) if (b = Vb(a), null === b) a = null;
  else if (c = b.tag, 13 === c) {
    a = Wb(b);
    if (null !== a) return a;
    a = null;
  } else if (3 === c) {
    if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
    a = null;
  } else b !== a && (a = null);
  id = a;
  return null;
}
function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md) return md;
  var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f2 = e.length;
  for (a = 0; a < c && b[a] === e[a]; a++) ;
  var g = c - a;
  for (d = 1; d <= g && b[c - d] === e[f2 - d]; d++) ;
  return md = e.slice(a, 1 < d ? 1 - d : void 0);
}
function od(a) {
  var b = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b(b2, d, e, f2, g) {
    this._reactName = b2;
    this._targetInst = e;
    this.type = d;
    this.nativeEvent = f2;
    this.target = g;
    this.currentTarget = null;
    for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f2) : f2[c]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$2(b.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$2({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$2({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a) return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = A$2({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$2({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$2({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$2({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b = this.nativeEvent;
  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
}
function zd() {
  return Pd;
}
var Qd = A$2({}, ud, { key: function(a) {
  if (a.key) {
    var b = Md[a.key] || a.key;
    if ("Unidentified" !== b) return b;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$2({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$2({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$2({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b.keyCode);
    case "keydown":
      return 229 !== b.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b) {
  switch (a) {
    case "compositionend":
      return he(b);
    case "keypress":
      if (32 !== b.which) return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b) {
  if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length) return b.char;
        if (b.which) return String.fromCharCode(b.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b.locale ? null : b.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
}
function ne(a, b, c, d) {
  Eb(d);
  b = oe(b, "onChange");
  0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
}
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b = ue(a);
  if (Wa(b)) return a;
}
function ve(a, b) {
  if ("change" === a) return b;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b = [];
    ne(b, qe, a, xb(a));
    Jb(re, b);
  }
}
function Ce(a, b, c) {
  "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
}
function Ee(a, b) {
  if ("click" === a) return te(b);
}
function Fe(a, b) {
  if ("input" === a || "change" === a) return te(b);
}
function Ge(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a, b) {
  if (He(a, b)) return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
  var c = Object.keys(a), d = Object.keys(b);
  if (c.length !== d.length) return false;
  for (d = 0; d < c.length; d++) {
    var e = c[d];
    if (!ja.call(b, e) || !He(a[e], b[e])) return false;
  }
  return true;
}
function Je(a) {
  for (; a && a.firstChild; ) a = a.firstChild;
  return a;
}
function Ke(a, b) {
  var c = Je(a);
  a = 0;
  for (var d; c; ) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;
      if (a <= b && d >= b) return { node: c, offset: b - a };
      a = d;
    }
    a: {
      for (; c; ) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = Je(c);
  }
}
function Le(a, b) {
  return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
}
function Me() {
  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
    try {
      var c = "string" === typeof b.contentWindow.location.href;
    } catch (d) {
      c = false;
    }
    if (c) a = b.contentWindow;
    else break;
    b = Xa(a.document);
  }
  return b;
}
function Ne(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
}
function Oe(a) {
  var b = Me(), c = a.focusedElem, d = a.selectionRange;
  if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
    if (null !== d && Ne(c)) {
      if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
      else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e = c.textContent.length, f2 = Math.min(d.start, e);
        d = void 0 === d.end ? f2 : Math.min(d.end, e);
        !a.extend && f2 > d && (e = d, d = f2, f2 = e);
        e = Ke(c, f2);
        var g = Ke(
          c,
          d
        );
        e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f2 > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
      }
    }
    b = [];
    for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    "function" === typeof c.focus && c.focus();
    for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b, c) {
  var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
  Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
}
function Ve(a, b) {
  var c = {};
  c[a.toLowerCase()] = b.toLowerCase();
  c["Webkit" + a] = "webkit" + b;
  c["Moz" + a] = "moz" + b;
  return c;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a) {
  if (Xe[a]) return Xe[a];
  if (!We[a]) return a;
  var b = We[a], c;
  for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
  return a;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b) {
  df.set(a, b);
  fa(b, [a]);
}
for (var gf$2 = 0; gf$2 < ef.length; gf$2++) {
  var hf = ef[gf$2], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Ub(d, b, void 0, a);
  a.currentTarget = null;
}
function se(a, b) {
  b = 0 !== (b & 4);
  for (var c = 0; c < a.length; c++) {
    var d = a[c], e = d.event;
    d = d.listeners;
    a: {
      var f2 = void 0;
      if (b) for (var g = d.length - 1; 0 <= g; g--) {
        var h = d[g], k2 = h.instance, l2 = h.currentTarget;
        h = h.listener;
        if (k2 !== f2 && e.isPropagationStopped()) break a;
        nf(e, h, l2);
        f2 = k2;
      }
      else for (g = 0; g < d.length; g++) {
        h = d[g];
        k2 = h.instance;
        l2 = h.currentTarget;
        h = h.listener;
        if (k2 !== f2 && e.isPropagationStopped()) break a;
        nf(e, h, l2);
        f2 = k2;
      }
    }
  }
  if (Qb) throw a = Rb, Qb = false, Rb = null, a;
}
function D(a, b) {
  var c = b[of];
  void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
  var d = a + "__bubble";
  c.has(d) || (pf(b, a, 2, false), c.add(d));
}
function qf(a, b, c) {
  var d = 0;
  b && (d |= 4);
  pf(c, a, d, b);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = true;
    da.forEach(function(b2) {
      "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
    });
    var b = 9 === a.nodeType ? a : a.ownerDocument;
    null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
  }
}
function pf(a, b, c, d) {
  switch (jd(b)) {
    case 1:
      var e = ed;
      break;
    case 4:
      e = gd;
      break;
    default:
      e = fd;
  }
  c = e.bind(null, b, c, a);
  e = void 0;
  !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
  d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
}
function hd(a, b, c, d, e) {
  var f2 = d;
  if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
    if (null === d) return;
    var g = d.tag;
    if (3 === g || 4 === g) {
      var h = d.stateNode.containerInfo;
      if (h === e || 8 === h.nodeType && h.parentNode === e) break;
      if (4 === g) for (g = d.return; null !== g; ) {
        var k2 = g.tag;
        if (3 === k2 || 4 === k2) {
          if (k2 = g.stateNode.containerInfo, k2 === e || 8 === k2.nodeType && k2.parentNode === e) return;
        }
        g = g.return;
      }
      for (; null !== h; ) {
        g = Wc(h);
        if (null === g) return;
        k2 = g.tag;
        if (5 === k2 || 6 === k2) {
          d = f2 = g;
          continue a;
        }
        h = h.parentNode;
      }
    }
    d = d.return;
  }
  Jb(function() {
    var d2 = f2, e2 = xb(c), g2 = [];
    a: {
      var h2 = df.get(a);
      if (void 0 !== h2) {
        var k3 = td, n2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c)) break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h2 ? h2 + "Capture" : null : h2;
        t2 = [];
        for (var w2 = d2, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2) break;
          w2 = w2.return;
        }
        0 < t2.length && (h2 = new k3(h2, n2, null, c, e2), g2.push({ event: h2, listeners: t2 }));
      }
    }
    if (0 === (b & 7)) {
      a: {
        h2 = "mouseover" === a || "pointerover" === a;
        k3 = "mouseout" === a || "pointerout" === a;
        if (h2 && c !== wb && (n2 = c.relatedTarget || c.fromElement) && (Wc(n2) || n2[uf])) break a;
        if (k3 || h2) {
          h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
          if (k3) {
            if (n2 = c.relatedTarget || c.toElement, k3 = d2, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
          } else k3 = null, n2 = d2;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a || "pointerover" === a) t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h2 : ue(k3);
            u2 = null == n2 ? h2 : ue(n2);
            h2 = new t2(F2, w2 + "leave", k3, c, e2);
            h2.target = J2;
            h2.relatedTarget = u2;
            F2 = null;
            Wc(e2) === d2 && (t2 = new t2(x2, w2 + "enter", n2, c, e2), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2) b: {
              t2 = k3;
              x2 = n2;
              w2 = 0;
              for (u2 = t2; u2; u2 = vf(u2)) w2++;
              u2 = 0;
              for (F2 = x2; F2; F2 = vf(F2)) u2++;
              for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
              for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
              for (; w2--; ) {
                if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                t2 = vf(t2);
                x2 = vf(x2);
              }
              t2 = null;
            }
            else t2 = null;
            null !== k3 && wf(g2, h2, k3, t2, false);
            null !== n2 && null !== J2 && wf(g2, J2, n2, t2, true);
          }
        }
      }
      a: {
        h2 = d2 ? ue(d2) : window;
        k3 = h2.nodeName && h2.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h2.type) var na = ve;
        else if (me(h2)) if (we) na = Fe;
        else {
          na = De;
          var xa = Ce;
        }
        else (k3 = h2.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
        if (na && (na = na(a, d2))) {
          ne(g2, na, c, e2);
          break a;
        }
        xa && xa(a, h2, d2);
        "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
      }
      xa = d2 ? ue(d2) : window;
      switch (a) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g2, c, e2);
          break;
        case "selectionchange":
          if (Pe) break;
        case "keydown":
        case "keyup":
          Ue(g2, c, e2);
      }
      var $a;
      if (ae) b: {
        switch (a) {
          case "compositionstart":
            var ba = "onCompositionStart";
            break b;
          case "compositionend":
            ba = "onCompositionEnd";
            break b;
          case "compositionupdate":
            ba = "onCompositionUpdate";
            break b;
        }
        ba = void 0;
      }
      else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
    }
    se(g2, b);
  });
}
function tf(a, b, c) {
  return { instance: a, listener: b, currentTarget: c };
}
function oe(a, b) {
  for (var c = b + "Capture", d = []; null !== a; ) {
    var e = a, f2 = e.stateNode;
    5 === e.tag && null !== f2 && (e = f2, f2 = Kb(a, c), null != f2 && d.unshift(tf(a, f2, e)), f2 = Kb(a, b), null != f2 && d.push(tf(a, f2, e)));
    a = a.return;
  }
  return d;
}
function vf(a) {
  if (null === a) return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function wf(a, b, c, d, e) {
  for (var f2 = b._reactName, g = []; null !== c && c !== d; ) {
    var h = c, k2 = h.alternate, l2 = h.stateNode;
    if (null !== k2 && k2 === d) break;
    5 === h.tag && null !== l2 && (h = l2, e ? (k2 = Kb(c, f2), null != k2 && g.unshift(tf(c, k2, h))) : e || (k2 = Kb(c, f2), null != k2 && g.push(tf(c, k2, h))));
    c = c.return;
  }
  0 !== g.length && a.push({ event: b, listeners: g });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
function Af(a, b, c) {
  b = zf(b);
  if (zf(a) !== b && c) throw Error(p(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a, b) {
  return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
  return Hf.resolve(null).then(a).catch(If);
} : Ff;
function If(a) {
  setTimeout(function() {
    throw a;
  });
}
function Kf(a, b) {
  var c = b, d = 0;
  do {
    var e = c.nextSibling;
    a.removeChild(c);
    if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
      if (0 === d) {
        a.removeChild(e);
        bd(b);
        return;
      }
      d--;
    } else "$" !== c && "$?" !== c && "$!" !== c || d++;
    c = e;
  } while (c);
  bd(b);
}
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b = a.nodeType;
    if (1 === b || 3 === b) break;
    if (8 === b) {
      b = a.data;
      if ("$" === b || "$!" === b || "$?" === b) break;
      if ("/$" === b) return null;
    }
  }
  return a;
}
function Mf(a) {
  a = a.previousSibling;
  for (var b = 0; a; ) {
    if (8 === a.nodeType) {
      var c = a.data;
      if ("$" === c || "$!" === c || "$?" === c) {
        if (0 === b) return a;
        b--;
      } else "/$" === c && b++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a) {
  var b = a[Of];
  if (b) return b;
  for (var c = a.parentNode; c; ) {
    if (b = c[uf] || c[Of]) {
      c = b.alternate;
      if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
        if (c = a[Of]) return c;
        a = Mf(a);
      }
      return b;
    }
    a = c;
    c = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;
  throw Error(p(33));
}
function Db(a) {
  return a[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a) {
  return { current: a };
}
function E(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a, b) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a, b) {
  var c = a.type.contextTypes;
  if (!c) return Vf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
  var e = {}, f2;
  for (f2 in c) e[f2] = b[f2];
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
  return e;
}
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a, b, c) {
  if (H.current !== Vf) throw Error(p(168));
  G(H, b);
  G(Wf, c);
}
function bg(a, b, c) {
  var d = a.stateNode;
  b = b.childContextTypes;
  if ("function" !== typeof d.getChildContext) return c;
  d = d.getChildContext();
  for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
  return A$2({}, c, d);
}
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a);
  G(Wf, Wf.current);
  return true;
}
function dg(a, b, c) {
  var d = a.stateNode;
  if (!d) throw Error(p(169));
  c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
  G(Wf, c);
}
var eg = null, fg = false, gg = false;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
function ig(a) {
  fg = true;
  hg(a);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a = 0, b = C;
    try {
      var c = eg;
      for (C = 1; a < c.length; a++) {
        var d = c[a];
        do
          d = d(true);
        while (null !== d);
      }
      eg = null;
      fg = false;
    } catch (e) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
    } finally {
      C = b, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a, b) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b;
}
function ug(a, b, c) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d = rg;
  a = sg;
  var e = 32 - oc(d) - 1;
  d &= ~(1 << e);
  c += 1;
  var f2 = 32 - oc(b) + e;
  if (30 < f2) {
    var g = e - e % 5;
    f2 = (d & (1 << g) - 1).toString(32);
    d >>= g;
    e -= g;
    rg = 1 << 32 - oc(b) + e | c << e | d;
    sg = f2 + a;
  } else rg = 1 << f2 | c << e | d, sg = a;
}
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
function wg(a) {
  for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a, b) {
  var c = Bg(5, null, null, 0);
  c.elementType = "DELETED";
  c.stateNode = b;
  c.return = a;
  b = a.deletions;
  null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
}
function Cg(a, b) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
      return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
    case 6:
      return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
    case 13:
      return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
function Eg(a) {
  if (I) {
    var b = yg;
    if (b) {
      var c = b;
      if (!Cg(a, b)) {
        if (Dg(a)) throw Error(p(418));
        b = Lf(c.nextSibling);
        var d = xg;
        b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
      }
    } else {
      if (Dg(a)) throw Error(p(418));
      a.flags = a.flags & -4097 | 2;
      I = false;
      xg = a;
    }
  }
}
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
  xg = a;
}
function Gg(a) {
  if (a !== xg) return false;
  if (!I) return Fg(a), I = true, false;
  var b;
  (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
  if (b && (b = yg)) {
    if (Dg(a)) throw Hg(), Error(p(418));
    for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a) throw Error(p(317));
    a: {
      a = a.nextSibling;
      for (b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("/$" === c) {
            if (0 === b) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b--;
          } else "$" !== c && "$!" !== c && "$?" !== c || b++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a = yg; a; ) a = Lf(a.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a, b, c) {
  a = c.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c._owner) {
      c = c._owner;
      if (c) {
        if (1 !== c.tag) throw Error(p(309));
        var d = c.stateNode;
      }
      if (!d) throw Error(p(147, a));
      var e = d, f2 = "" + a;
      if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f2) return b.ref;
      b = function(a2) {
        var b2 = e.refs;
        null === a2 ? delete b2[f2] : b2[f2] = a2;
      };
      b._stringRef = f2;
      return b;
    }
    if ("string" !== typeof a) throw Error(p(284));
    if (!c._owner) throw Error(p(290, a));
  }
  return a;
}
function Mg(a, b) {
  a = Object.prototype.toString.call(b);
  throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
}
function Ng(a) {
  var b = a._init;
  return b(a._payload);
}
function Og(a) {
  function b(b2, c2) {
    if (a) {
      var d2 = b2.deletions;
      null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
    }
  }
  function c(c2, d2) {
    if (!a) return null;
    for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
    return null;
  }
  function d(a2, b2) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
    return a2;
  }
  function e(a2, b2) {
    a2 = Pg(a2, b2);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b2, c2, d2) {
    b2.index = d2;
    if (!a) return b2.flags |= 1048576, c2;
    d2 = b2.alternate;
    if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
    b2.flags |= 2;
    return c2;
  }
  function g(b2) {
    a && null === b2.alternate && (b2.flags |= 2);
    return b2;
  }
  function h(a2, b2, c2, d2) {
    if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e(b2, c2);
    b2.return = a2;
    return b2;
  }
  function k2(a2, b2, c2, d2) {
    var f3 = c2.type;
    if (f3 === ya) return m2(a2, b2, c2.props.children, d2, c2.key);
    if (null !== b2 && (b2.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b2.type)) return d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2;
    d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
    d2.ref = Lg(a2, b2, c2);
    d2.return = a2;
    return d2;
  }
  function l2(a2, b2, c2, d2) {
    if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e(b2, c2.children || []);
    b2.return = a2;
    return b2;
  }
  function m2(a2, b2, c2, d2, f3) {
    if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d2, f3), b2.return = a2, b2;
    b2 = e(b2, c2);
    b2.return = a2;
    return b2;
  }
  function q2(a2, b2, c2) {
    if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
    if ("object" === typeof b2 && null !== b2) {
      switch (b2.$$typeof) {
        case va:
          return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
        case wa:
          return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
        case Ha:
          var d2 = b2._init;
          return q2(a2, d2(b2._payload), c2);
      }
      if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
      Mg(a2, b2);
    }
    return null;
  }
  function r2(a2, b2, c2, d2) {
    var e2 = null !== b2 ? b2.key : null;
    if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d2);
    if ("object" === typeof c2 && null !== c2) {
      switch (c2.$$typeof) {
        case va:
          return c2.key === e2 ? k2(a2, b2, c2, d2) : null;
        case wa:
          return c2.key === e2 ? l2(a2, b2, c2, d2) : null;
        case Ha:
          return e2 = c2._init, r2(
            a2,
            b2,
            e2(c2._payload),
            d2
          );
      }
      if (eb(c2) || Ka(c2)) return null !== e2 ? null : m2(a2, b2, c2, d2, null);
      Mg(a2, c2);
    }
    return null;
  }
  function y2(a2, b2, c2, d2, e2) {
    if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
    if ("object" === typeof d2 && null !== d2) {
      switch (d2.$$typeof) {
        case va:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k2(b2, a2, d2, e2);
        case wa:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l2(b2, a2, d2, e2);
        case Ha:
          var f3 = d2._init;
          return y2(a2, b2, c2, f3(d2._payload), e2);
      }
      if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m2(b2, a2, d2, e2, null);
      Mg(b2, d2);
    }
    return null;
  }
  function n2(e2, g2, h2, k3) {
    for (var l3 = null, m3 = null, u2 = g2, w2 = g2 = 0, x2 = null; null !== u2 && w2 < h2.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e2, u2, h2[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a && u2 && null === n3.alternate && b(e2, u2);
      g2 = f2(n3, g2, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h2.length) return c(e2, u2), I && tg(e2, w2), l3;
    if (null === u2) {
      for (; w2 < h2.length; w2++) u2 = q2(e2, h2[w2], k3), null !== u2 && (g2 = f2(u2, g2, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e2, w2);
      return l3;
    }
    for (u2 = d(e2, u2); w2 < h2.length; w2++) x2 = y2(u2, e2, w2, h2[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g2 = f2(x2, g2, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a && u2.forEach(function(a2) {
      return b(e2, a2);
    });
    I && tg(e2, w2);
    return l3;
  }
  function t2(e2, g2, h2, k3) {
    var l3 = Ka(h2);
    if ("function" !== typeof l3) throw Error(p(150));
    h2 = l3.call(h2);
    if (null == h2) throw Error(p(151));
    for (var u2 = l3 = null, m3 = g2, w2 = g2 = 0, x2 = null, n3 = h2.next(); null !== m3 && !n3.done; w2++, n3 = h2.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e2, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a && m3 && null === t3.alternate && b(e2, m3);
      g2 = f2(t3, g2, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done) return c(
      e2,
      m3
    ), I && tg(e2, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h2.next()) n3 = q2(e2, n3.value, k3), null !== n3 && (g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e2, w2);
      return l3;
    }
    for (m3 = d(e2, m3); !n3.done; w2++, n3 = h2.next()) n3 = y2(m3, e2, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a && m3.forEach(function(a2) {
      return b(e2, a2);
    });
    I && tg(e2, w2);
    return l3;
  }
  function J2(a2, d2, f3, h2) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d2; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c(a2, l3.sibling);
                    d2 = e(l3, f3.props.children);
                    d2.return = a2;
                    a2 = d2;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                  c(a2, l3.sibling);
                  d2 = e(l3, f3.props);
                  d2.ref = Lg(a2, l3, f3);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                }
                c(a2, l3);
                break;
              } else b(a2, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d2 = Tg(f3.props.children, a2.mode, h2, f3.key), d2.return = a2, a2 = d2) : (h2 = Rg(f3.type, f3.key, f3.props, null, a2.mode, h2), h2.ref = Lg(a2, d2, f3), h2.return = a2, a2 = h2);
          }
          return g(a2);
        case wa:
          a: {
            for (l3 = f3.key; null !== d2; ) {
              if (d2.key === l3) if (4 === d2.tag && d2.stateNode.containerInfo === f3.containerInfo && d2.stateNode.implementation === f3.implementation) {
                c(a2, d2.sibling);
                d2 = e(d2, f3.children || []);
                d2.return = a2;
                a2 = d2;
                break a;
              } else {
                c(a2, d2);
                break;
              }
              else b(a2, d2);
              d2 = d2.sibling;
            }
            d2 = Sg(f3, a2.mode, h2);
            d2.return = a2;
            a2 = d2;
          }
          return g(a2);
        case Ha:
          return l3 = f3._init, J2(a2, d2, l3(f3._payload), h2);
      }
      if (eb(f3)) return n2(a2, d2, f3, h2);
      if (Ka(f3)) return t2(a2, d2, f3, h2);
      Mg(a2, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f3), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f3, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a) {
  var b = Wg.current;
  E(Wg);
  a._currentValue = b;
}
function bh(a, b, c) {
  for (; null !== a; ) {
    var d = a.alternate;
    (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
    if (a === c) break;
    a = a.return;
  }
}
function ch(a, b) {
  Xg = a;
  Zg = Yg = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
}
function eh(a) {
  var b = a._currentValue;
  if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
    if (null === Xg) throw Error(p(308));
    Yg = a;
    Xg.dependencies = { lanes: 0, firstContext: a };
  } else Yg = Yg.next = a;
  return b;
}
var fh = null;
function gh(a) {
  null === fh ? fh = [a] : fh.push(a);
}
function hh(a, b, c, d) {
  var e = b.interleaved;
  null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
  b.interleaved = c;
  return ih(a, d);
}
function ih(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  null !== c && (c.lanes |= b);
  c = a;
  for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
  return 3 === c.tag ? c.stateNode : null;
}
var jh = false;
function kh(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a, b) {
  a = a.updateQueue;
  b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function mh(a, b) {
  return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
}
function nh(a, b, c) {
  var d = a.updateQueue;
  if (null === d) return null;
  d = d.shared;
  if (0 !== (K & 2)) {
    var e = d.pending;
    null === e ? b.next = b : (b.next = e.next, e.next = b);
    d.pending = b;
    return ih(a, c);
  }
  e = d.interleaved;
  null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
  d.interleaved = b;
  return ih(a, c);
}
function oh(a, b, c) {
  b = b.updateQueue;
  if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
    var d = b.lanes;
    d &= a.pendingLanes;
    c |= d;
    b.lanes = c;
    Cc(a, c);
  }
}
function ph(a, b) {
  var c = a.updateQueue, d = a.alternate;
  if (null !== d && (d = d.updateQueue, c === d)) {
    var e = null, f2 = null;
    c = c.firstBaseUpdate;
    if (null !== c) {
      do {
        var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
        null === f2 ? e = f2 = g : f2 = f2.next = g;
        c = c.next;
      } while (null !== c);
      null === f2 ? e = f2 = b : f2 = f2.next = b;
    } else e = f2 = b;
    c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f2, shared: d.shared, effects: d.effects };
    a.updateQueue = c;
    return;
  }
  a = c.lastBaseUpdate;
  null === a ? c.firstBaseUpdate = b : a.next = b;
  c.lastBaseUpdate = b;
}
function qh(a, b, c, d) {
  var e = a.updateQueue;
  jh = false;
  var f2 = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
  if (null !== h) {
    e.shared.pending = null;
    var k2 = h, l2 = k2.next;
    k2.next = null;
    null === g ? f2 = l2 : g.next = l2;
    g = k2;
    var m2 = a.alternate;
    null !== m2 && (m2 = m2.updateQueue, h = m2.lastBaseUpdate, h !== g && (null === h ? m2.firstBaseUpdate = l2 : h.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e.baseState;
    g = 0;
    m2 = l2 = k2 = null;
    h = f2;
    do {
      var r2 = h.lane, y2 = h.eventTime;
      if ((d & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h.tag,
          payload: h.payload,
          callback: h.callback,
          next: null
        });
        a: {
          var n2 = a, t2 = h;
          r2 = b;
          y2 = c;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2) break a;
              q2 = A$2({}, q2, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h.callback && 0 !== h.lane && (a.flags |= 64, r2 = e.effects, null === r2 ? e.effects = [h] : r2.push(h));
      } else y2 = { eventTime: y2, lane: r2, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g |= r2;
      h = h.next;
      if (null === h) if (h = e.shared.pending, null === h) break;
      else r2 = h, h = r2.next, r2.next = null, e.lastBaseUpdate = r2, e.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e.baseState = k2;
    e.firstBaseUpdate = l2;
    e.lastBaseUpdate = m2;
    b = e.shared.interleaved;
    if (null !== b) {
      e = b;
      do
        g |= e.lane, e = e.next;
      while (e !== b);
    } else null === f2 && (e.shared.lanes = 0);
    rh |= g;
    a.lanes = g;
    a.memoizedState = q2;
  }
}
function sh(a, b, c) {
  a = b.effects;
  b.effects = null;
  if (null !== a) for (b = 0; b < a.length; b++) {
    var d = a[b], e = d.callback;
    if (null !== e) {
      d.callback = null;
      d = c;
      if ("function" !== typeof e) throw Error(p(191, e));
      e.call(d);
    }
  }
}
var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
function xh(a) {
  if (a === th) throw Error(p(174));
  return a;
}
function yh(a, b) {
  G(wh, b);
  G(vh, a);
  G(uh, th);
  a = b.nodeType;
  switch (a) {
    case 9:
    case 11:
      b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
      break;
    default:
      a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
  }
  E(uh);
  G(uh, b);
}
function zh() {
  E(uh);
  E(vh);
  E(wh);
}
function Ah(a) {
  xh(wh.current);
  var b = xh(uh.current);
  var c = lb(b, a.type);
  b !== c && (G(vh, a), G(uh, c));
}
function Bh(a) {
  vh.current === a && (E(uh), E(vh));
}
var L = Uf(0);
function Ch(a) {
  for (var b = a; null !== b; ) {
    if (13 === b.tag) {
      var c = b.memoizedState;
      if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
    } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
      if (0 !== (b.flags & 128)) return b;
    } else if (null !== b.child) {
      b.child.return = b;
      b = b.child;
      continue;
    }
    if (b === a) break;
    for (; null === b.sibling; ) {
      if (null === b.return || b.return === a) return null;
      b = b.return;
    }
    b.sibling.return = b.return;
    b = b.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M$2 = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function P() {
  throw Error(p(321));
}
function Mh(a, b) {
  if (null === b) return false;
  for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
  return true;
}
function Nh(a, b, c, d, e, f2) {
  Hh = f2;
  M$2 = b;
  b.memoizedState = null;
  b.updateQueue = null;
  b.lanes = 0;
  Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
  a = c(d, e);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f2) throw Error(p(301));
      f2 += 1;
      O = N = null;
      b.updateQueue = null;
      Fh.current = Qh;
      a = c(d, e);
    } while (Jh);
  }
  Fh.current = Rh;
  b = null !== N && null !== N.next;
  Hh = 0;
  O = N = M$2 = null;
  Ih = false;
  if (b) throw Error(p(300));
  return a;
}
function Sh() {
  var a = 0 !== Kh;
  Kh = 0;
  return a;
}
function Th() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O ? M$2.memoizedState = O = a : O = O.next = a;
  return O;
}
function Uh() {
  if (null === N) {
    var a = M$2.alternate;
    a = null !== a ? a.memoizedState : null;
  } else a = N.next;
  var b = null === O ? M$2.memoizedState : O.next;
  if (null !== b) O = b, N = a;
  else {
    if (null === a) throw Error(p(310));
    N = a;
    a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
    null === O ? M$2.memoizedState = O = a : O = O.next = a;
  }
  return O;
}
function Vh(a, b) {
  return "function" === typeof b ? b(a) : b;
}
function Wh(a) {
  var b = Uh(), c = b.queue;
  if (null === c) throw Error(p(311));
  c.lastRenderedReducer = a;
  var d = N, e = d.baseQueue, f2 = c.pending;
  if (null !== f2) {
    if (null !== e) {
      var g = e.next;
      e.next = f2.next;
      f2.next = g;
    }
    d.baseQueue = e = f2;
    c.pending = null;
  }
  if (null !== e) {
    f2 = e.next;
    d = d.baseState;
    var h = g = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d = l2.hasEagerState ? l2.eagerState : a(d, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h = k2 = q2, g = d) : k2 = k2.next = q2;
        M$2.lanes |= m2;
        rh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g = d : k2.next = h;
    He(d, b.memoizedState) || (dh = true);
    b.memoizedState = d;
    b.baseState = g;
    b.baseQueue = k2;
    c.lastRenderedState = d;
  }
  a = c.interleaved;
  if (null !== a) {
    e = a;
    do
      f2 = e.lane, M$2.lanes |= f2, rh |= f2, e = e.next;
    while (e !== a);
  } else null === e && (c.lanes = 0);
  return [b.memoizedState, c.dispatch];
}
function Xh(a) {
  var b = Uh(), c = b.queue;
  if (null === c) throw Error(p(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch, e = c.pending, f2 = b.memoizedState;
  if (null !== e) {
    c.pending = null;
    var g = e = e.next;
    do
      f2 = a(f2, g.action), g = g.next;
    while (g !== e);
    He(f2, b.memoizedState) || (dh = true);
    b.memoizedState = f2;
    null === b.baseQueue && (b.baseState = f2);
    c.lastRenderedState = f2;
  }
  return [f2, d];
}
function Yh() {
}
function Zh(a, b) {
  var c = M$2, d = Uh(), e = b(), f2 = !He(d.memoizedState, e);
  f2 && (d.memoizedState = e, dh = true);
  d = d.queue;
  $h(ai.bind(null, c, d, a), [a]);
  if (d.getSnapshot !== b || f2 || null !== O && O.memoizedState.tag & 1) {
    c.flags |= 2048;
    bi(9, ci.bind(null, c, d, e, b), void 0, null);
    if (null === Q) throw Error(p(349));
    0 !== (Hh & 30) || di(c, b, e);
  }
  return e;
}
function di(a, b, c) {
  a.flags |= 16384;
  a = { getSnapshot: b, value: c };
  b = M$2.updateQueue;
  null === b ? (b = { lastEffect: null, stores: null }, M$2.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
}
function ci(a, b, c, d) {
  b.value = c;
  b.getSnapshot = d;
  ei(b) && fi(a);
}
function ai(a, b, c) {
  return c(function() {
    ei(b) && fi(a);
  });
}
function ei(a) {
  var b = a.getSnapshot;
  a = a.value;
  try {
    var c = b();
    return !He(a, c);
  } catch (d) {
    return true;
  }
}
function fi(a) {
  var b = ih(a, 1);
  null !== b && gi(b, a, 1, -1);
}
function hi(a) {
  var b = Th();
  "function" === typeof a && (a = a());
  b.memoizedState = b.baseState = a;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
  b.queue = a;
  a = a.dispatch = ii.bind(null, M$2, a);
  return [b.memoizedState, a];
}
function bi(a, b, c, d) {
  a = { tag: a, create: b, destroy: c, deps: d, next: null };
  b = M$2.updateQueue;
  null === b ? (b = { lastEffect: null, stores: null }, M$2.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
  return a;
}
function ji() {
  return Uh().memoizedState;
}
function ki(a, b, c, d) {
  var e = Th();
  M$2.flags |= a;
  e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
}
function li(a, b, c, d) {
  var e = Uh();
  d = void 0 === d ? null : d;
  var f2 = void 0;
  if (null !== N) {
    var g = N.memoizedState;
    f2 = g.destroy;
    if (null !== d && Mh(d, g.deps)) {
      e.memoizedState = bi(b, c, f2, d);
      return;
    }
  }
  M$2.flags |= a;
  e.memoizedState = bi(1 | b, c, f2, d);
}
function mi(a, b) {
  return ki(8390656, 8, a, b);
}
function $h(a, b) {
  return li(2048, 8, a, b);
}
function ni(a, b) {
  return li(4, 2, a, b);
}
function oi(a, b) {
  return li(4, 4, a, b);
}
function pi(a, b) {
  if ("function" === typeof b) return a = a(), b(a), function() {
    b(null);
  };
  if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
    b.current = null;
  };
}
function qi(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return li(4, 4, pi.bind(null, b, a), c);
}
function ri() {
}
function si(a, b) {
  var c = Uh();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Mh(b, d[1])) return d[0];
  c.memoizedState = [a, b];
  return a;
}
function ti(a, b) {
  var c = Uh();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Mh(b, d[1])) return d[0];
  a = a();
  c.memoizedState = [a, b];
  return a;
}
function ui(a, b, c) {
  if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
  He(c, b) || (c = yc(), M$2.lanes |= c, rh |= c, a.baseState = true);
  return b;
}
function vi(a, b) {
  var c = C;
  C = 0 !== c && 4 > c ? c : 4;
  a(true);
  var d = Gh.transition;
  Gh.transition = {};
  try {
    a(false), b();
  } finally {
    C = c, Gh.transition = d;
  }
}
function wi() {
  return Uh().memoizedState;
}
function xi(a, b, c) {
  var d = yi(a);
  c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
  if (zi(a)) Ai(b, c);
  else if (c = hh(a, b, c, d), null !== c) {
    var e = R();
    gi(c, a, d, e);
    Bi(c, b, d);
  }
}
function ii(a, b, c) {
  var d = yi(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
  if (zi(a)) Ai(b, e);
  else {
    var f2 = a.alternate;
    if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b.lastRenderedReducer, null !== f2)) try {
      var g = b.lastRenderedState, h = f2(g, c);
      e.hasEagerState = true;
      e.eagerState = h;
      if (He(h, g)) {
        var k2 = b.interleaved;
        null === k2 ? (e.next = e, gh(b)) : (e.next = k2.next, k2.next = e);
        b.interleaved = e;
        return;
      }
    } catch (l2) {
    } finally {
    }
    c = hh(a, b, e, d);
    null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
  }
}
function zi(a) {
  var b = a.alternate;
  return a === M$2 || null !== b && b === M$2;
}
function Ai(a, b) {
  Jh = Ih = true;
  var c = a.pending;
  null === c ? b.next = b : (b.next = c.next, c.next = b);
  a.pending = b;
}
function Bi(a, b, c) {
  if (0 !== (c & 4194240)) {
    var d = b.lanes;
    d &= a.pendingLanes;
    c |= d;
    b.lanes = c;
    Cc(a, c);
  }
}
var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b) {
  Th().memoizedState = [a, void 0 === b ? null : b];
  return a;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b, a),
    c
  );
}, useLayoutEffect: function(a, b) {
  return ki(4194308, 4, a, b);
}, useInsertionEffect: function(a, b) {
  return ki(4, 2, a, b);
}, useMemo: function(a, b) {
  var c = Th();
  b = void 0 === b ? null : b;
  a = a();
  c.memoizedState = [a, b];
  return a;
}, useReducer: function(a, b, c) {
  var d = Th();
  b = void 0 !== c ? c(b) : b;
  d.memoizedState = d.baseState = b;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
  d.queue = a;
  a = a.dispatch = xi.bind(null, M$2, a);
  return [d.memoizedState, a];
}, useRef: function(a) {
  var b = Th();
  a = { current: a };
  return b.memoizedState = a;
}, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
  return Th().memoizedState = a;
}, useTransition: function() {
  var a = hi(false), b = a[0];
  a = vi.bind(null, a[1]);
  Th().memoizedState = a;
  return [b, a];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a, b, c) {
  var d = M$2, e = Th();
  if (I) {
    if (void 0 === c) throw Error(p(407));
    c = c();
  } else {
    c = b();
    if (null === Q) throw Error(p(349));
    0 !== (Hh & 30) || di(d, b, c);
  }
  e.memoizedState = c;
  var f2 = { value: c, getSnapshot: b };
  e.queue = f2;
  mi(ai.bind(
    null,
    d,
    f2,
    a
  ), [a]);
  d.flags |= 2048;
  bi(9, ci.bind(null, d, f2, c, b), void 0, null);
  return c;
}, useId: function() {
  var a = Th(), b = Q.identifierPrefix;
  if (I) {
    var c = sg;
    var d = rg;
    c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
    b = ":" + b + "R" + c;
    c = Kh++;
    0 < c && (b += "H" + c.toString(32));
    b += ":";
  } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
  return a.memoizedState = b;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni,
  useLayoutEffect: oi,
  useMemo: ti,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri,
  useDeferredValue: function(a) {
    var b = Uh();
    return ui(b, N.memoizedState, a);
  },
  useTransition: function() {
    var a = Wh(Vh)[0], b = Uh().memoizedState;
    return [a, b];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri, useDeferredValue: function(a) {
  var b = Uh();
  return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
}, useTransition: function() {
  var a = Xh(Vh)[0], b = Uh().memoizedState;
  return [a, b];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
function Ci(a, b) {
  if (a && a.defaultProps) {
    b = A$2({}, b);
    a = a.defaultProps;
    for (var c in a) void 0 === b[c] && (b[c] = a[c]);
    return b;
  }
  return b;
}
function Di(a, b, c, d) {
  b = a.memoizedState;
  c = c(d, b);
  c = null === c || void 0 === c ? b : A$2({}, b, c);
  a.memoizedState = c;
  0 === a.lanes && (a.updateQueue.baseState = c);
}
var Ei = { isMounted: function(a) {
  return (a = a._reactInternals) ? Vb(a) === a : false;
}, enqueueSetState: function(a, b, c) {
  a = a._reactInternals;
  var d = R(), e = yi(a), f2 = mh(d, e);
  f2.payload = b;
  void 0 !== c && null !== c && (f2.callback = c);
  b = nh(a, f2, e);
  null !== b && (gi(b, a, e, d), oh(b, a, e));
}, enqueueReplaceState: function(a, b, c) {
  a = a._reactInternals;
  var d = R(), e = yi(a), f2 = mh(d, e);
  f2.tag = 1;
  f2.payload = b;
  void 0 !== c && null !== c && (f2.callback = c);
  b = nh(a, f2, e);
  null !== b && (gi(b, a, e, d), oh(b, a, e));
}, enqueueForceUpdate: function(a, b) {
  a = a._reactInternals;
  var c = R(), d = yi(a), e = mh(c, d);
  e.tag = 2;
  void 0 !== b && null !== b && (e.callback = b);
  b = nh(a, e, d);
  null !== b && (gi(b, a, d, c), oh(b, a, d));
} };
function Fi(a, b, c, d, e, f2, g) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f2, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f2) : true;
}
function Gi(a, b, c) {
  var d = false, e = Vf;
  var f2 = b.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f2 = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
  b = new b(c, f2);
  a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
  b.updater = Ei;
  a.stateNode = b;
  b._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b;
}
function Hi(a, b, c, d) {
  a = b.state;
  "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
  "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
  b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
}
function Ii(a, b, c, d) {
  var e = a.stateNode;
  e.props = c;
  e.state = a.memoizedState;
  e.refs = {};
  kh(a);
  var f2 = b.contextType;
  "object" === typeof f2 && null !== f2 ? e.context = eh(f2) : (f2 = Zf(b) ? Xf : H.current, e.context = Yf(a, f2));
  e.state = a.memoizedState;
  f2 = b.getDerivedStateFromProps;
  "function" === typeof f2 && (Di(a, b, f2, c), e.state = a.memoizedState);
  "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
  "function" === typeof e.componentDidMount && (a.flags |= 4194308);
}
function Ji(a, b) {
  try {
    var c = "", d = b;
    do
      c += Pa(d), d = d.return;
    while (d);
    var e = c;
  } catch (f2) {
    e = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b, stack: e, digest: null };
}
function Ki(a, b, c) {
  return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
}
function Li(a, b) {
  try {
    console.error(b.value);
  } catch (c) {
    setTimeout(function() {
      throw c;
    });
  }
}
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a, b, c) {
  c = mh(-1, c);
  c.tag = 3;
  c.payload = { element: null };
  var d = b.value;
  c.callback = function() {
    Oi || (Oi = true, Pi = d);
    Li(a, b);
  };
  return c;
}
function Qi(a, b, c) {
  c = mh(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;
  if ("function" === typeof d) {
    var e = b.value;
    c.payload = function() {
      return d(e);
    };
    c.callback = function() {
      Li(a, b);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c.callback = function() {
    Li(a, b);
    "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c2 = b.stack;
    this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
  });
  return c;
}
function Si(a, b, c) {
  var d = a.pingCache;
  if (null === d) {
    d = a.pingCache = new Mi();
    var e = /* @__PURE__ */ new Set();
    d.set(b, e);
  } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
  e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
}
function Ui(a) {
  do {
    var b;
    if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
    if (b) return a;
    a = a.return;
  } while (null !== a);
  return null;
}
function Vi(a, b, c, d, e) {
  if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e;
  return a;
}
var Wi = ua.ReactCurrentOwner, dh = false;
function Xi(a, b, c, d) {
  b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
}
function Yi(a, b, c, d, e) {
  c = c.render;
  var f2 = b.ref;
  ch(b, e);
  d = Nh(a, b, c, d, f2, e);
  c = Sh();
  if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
  I && c && vg(b);
  b.flags |= 1;
  Xi(a, b, d, e);
  return b.child;
}
function $i(a, b, c, d, e) {
  if (null === a) {
    var f2 = c.type;
    if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f2, bj(a, b, f2, d, e);
    a = Rg(c.type, null, d, b, b.mode, e);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  f2 = a.child;
  if (0 === (a.lanes & e)) {
    var g = f2.memoizedProps;
    c = c.compare;
    c = null !== c ? c : Ie;
    if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
  }
  b.flags |= 1;
  a = Pg(f2, d);
  a.ref = b.ref;
  a.return = b;
  return b.child = a;
}
function bj(a, b, c, d, e) {
  if (null !== a) {
    var f2 = a.memoizedProps;
    if (Ie(f2, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f2, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);
    else return b.lanes = a.lanes, Zi(a, b, e);
  }
  return cj(a, b, c, d, e);
}
function dj(a, b, c) {
  var d = b.pendingProps, e = d.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
  else {
    if (0 === (c & 1073741824)) return a = null !== f2 ? f2.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
    b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
    d = null !== f2 ? f2.baseLanes : c;
    G(ej, fj);
    fj |= d;
  }
  else null !== f2 ? (d = f2.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
  Xi(a, b, e, c);
  return b.child;
}
function gj(a, b) {
  var c = b.ref;
  if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
}
function cj(a, b, c, d, e) {
  var f2 = Zf(c) ? Xf : H.current;
  f2 = Yf(b, f2);
  ch(b, e);
  c = Nh(a, b, c, d, f2, e);
  d = Sh();
  if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
  I && d && vg(b);
  b.flags |= 1;
  Xi(a, b, c, e);
  return b.child;
}
function hj(a, b, c, d, e) {
  if (Zf(c)) {
    var f2 = true;
    cg(b);
  } else f2 = false;
  ch(b, e);
  if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;
  else if (null === a) {
    var g = b.stateNode, h = b.memoizedProps;
    g.props = h;
    var k2 = g.context, l2 = c.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c) ? Xf : H.current, l2 = Yf(b, l2));
    var m2 = c.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k2 !== l2) && Hi(b, g, d, l2);
    jh = false;
    var r2 = b.memoizedState;
    g.state = r2;
    qh(b, d, g, e);
    k2 = b.memoizedState;
    h !== d || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b, c, m2, d), k2 = b.memoizedState), (h = jh || Fi(b, c, h, d, r2, k2, l2)) ? (q2 || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k2), g.props = d, g.state = k2, g.context = l2, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
  } else {
    g = b.stateNode;
    lh(a, b);
    h = b.memoizedProps;
    l2 = b.type === b.elementType ? h : Ci(b.type, h);
    g.props = l2;
    q2 = b.pendingProps;
    r2 = g.context;
    k2 = c.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c) ? Xf : H.current, k2 = Yf(b, k2));
    var y2 = c.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q2 || r2 !== k2) && Hi(b, g, d, k2);
    jh = false;
    r2 = b.memoizedState;
    g.state = r2;
    qh(b, d, g, e);
    var n2 = b.memoizedState;
    h !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b, c, y2, d), n2 = b.memoizedState), (l2 = jh || Fi(b, c, l2, d, r2, n2, k2) || false) ? (m2 || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n2, k2), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n2, k2)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n2), g.props = d, g.state = n2, g.context = k2, d = l2) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), d = false);
  }
  return jj(a, b, c, d, f2, e);
}
function jj(a, b, c, d, e, f2) {
  gj(a, b);
  var g = 0 !== (b.flags & 128);
  if (!d && !g) return e && dg(b, c, false), Zi(a, b, f2);
  d = b.stateNode;
  Wi.current = b;
  var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
  b.flags |= 1;
  null !== a && g ? (b.child = Ug(b, a.child, null, f2), b.child = Ug(b, null, h, f2)) : Xi(a, b, h, f2);
  b.memoizedState = d.state;
  e && dg(b, c, true);
  return b.child;
}
function kj(a) {
  var b = a.stateNode;
  b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
  yh(a, b.containerInfo);
}
function lj(a, b, c, d, e) {
  Ig();
  Jg(e);
  b.flags |= 256;
  Xi(a, b, c, d);
  return b.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a) {
  return { baseLanes: a, cachePool: null, transitions: null };
}
function oj(a, b, c) {
  var d = b.pendingProps, e = L.current, f2 = false, g = 0 !== (b.flags & 128), h;
  (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
  if (h) f2 = true, b.flags &= -129;
  else if (null === a || null !== a.memoizedState) e |= 1;
  G(L, e & 1);
  if (null === a) {
    Eg(b);
    a = b.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
    g = d.children;
    a = d.fallback;
    return f2 ? (d = b.mode, f2 = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g) : f2 = pj(g, d, 0, null), a = Tg(a, d, c, null), f2.return = b, a.return = b, f2.sibling = a, b.child = f2, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
  }
  e = a.memoizedState;
  if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
  if (f2) {
    f2 = d.fallback;
    g = b.mode;
    e = a.child;
    h = e.sibling;
    var k2 = { mode: "hidden", children: d.children };
    0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k2, b.deletions = null) : (d = Pg(e, k2), d.subtreeFlags = e.subtreeFlags & 14680064);
    null !== h ? f2 = Pg(h, f2) : (f2 = Tg(f2, g, c, null), f2.flags |= 2);
    f2.return = b;
    d.return = b;
    d.sibling = f2;
    b.child = d;
    d = f2;
    f2 = b.child;
    g = a.child.memoizedState;
    g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
    f2.memoizedState = g;
    f2.childLanes = a.childLanes & ~c;
    b.memoizedState = mj;
    return d;
  }
  f2 = a.child;
  a = f2.sibling;
  d = Pg(f2, { mode: "visible", children: d.children });
  0 === (b.mode & 1) && (d.lanes = c);
  d.return = b;
  d.sibling = null;
  null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
  b.child = d;
  b.memoizedState = null;
  return d;
}
function qj(a, b) {
  b = pj({ mode: "visible", children: b }, a.mode, 0, null);
  b.return = a;
  return a.child = b;
}
function sj(a, b, c, d) {
  null !== d && Jg(d);
  Ug(b, a.child, null, c);
  a = qj(b, b.pendingProps.children);
  a.flags |= 2;
  b.memoizedState = null;
  return a;
}
function rj(a, b, c, d, e, f2, g) {
  if (c) {
    if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
    if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
    f2 = d.fallback;
    e = b.mode;
    d = pj({ mode: "visible", children: d.children }, e, 0, null);
    f2 = Tg(f2, e, g, null);
    f2.flags |= 2;
    d.return = b;
    f2.return = b;
    d.sibling = f2;
    b.child = d;
    0 !== (b.mode & 1) && Ug(b, a.child, null, g);
    b.child.memoizedState = nj(g);
    b.memoizedState = mj;
    return f2;
  }
  if (0 === (b.mode & 1)) return sj(a, b, g, null);
  if ("$!" === e.data) {
    d = e.nextSibling && e.nextSibling.dataset;
    if (d) var h = d.dgst;
    d = h;
    f2 = Error(p(419));
    d = Ki(f2, d, void 0);
    return sj(a, b, g, d);
  }
  h = 0 !== (g & a.childLanes);
  if (dh || h) {
    d = Q;
    if (null !== d) {
      switch (g & -g) {
        case 4:
          e = 2;
          break;
        case 16:
          e = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e = 32;
          break;
        case 536870912:
          e = 268435456;
          break;
        default:
          e = 0;
      }
      e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
      0 !== e && e !== f2.retryLane && (f2.retryLane = e, ih(a, e), gi(d, a, e, -1));
    }
    tj();
    d = Ki(Error(p(421)));
    return sj(a, b, g, d);
  }
  if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
  a = f2.treeContext;
  yg = Lf(e.nextSibling);
  xg = b;
  I = true;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
  b = qj(b, d.children);
  b.flags |= 4096;
  return b;
}
function vj(a, b, c) {
  a.lanes |= b;
  var d = a.alternate;
  null !== d && (d.lanes |= b);
  bh(a.return, b, c);
}
function wj(a, b, c, d, e) {
  var f2 = a.memoizedState;
  null === f2 ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f2.isBackwards = b, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d, f2.tail = c, f2.tailMode = e);
}
function xj(a, b, c) {
  var d = b.pendingProps, e = d.revealOrder, f2 = d.tail;
  Xi(a, b, d.children, c);
  d = L.current;
  if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
  else {
    if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
      if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
      else if (19 === a.tag) vj(a, c, b);
      else if (null !== a.child) {
        a.child.return = a;
        a = a.child;
        continue;
      }
      if (a === b) break a;
      for (; null === a.sibling; ) {
        if (null === a.return || a.return === b) break a;
        a = a.return;
      }
      a.sibling.return = a.return;
      a = a.sibling;
    }
    d &= 1;
  }
  G(L, d);
  if (0 === (b.mode & 1)) b.memoizedState = null;
  else switch (e) {
    case "forwards":
      c = b.child;
      for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
      c = e;
      null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
      wj(b, false, e, c, f2);
      break;
    case "backwards":
      c = null;
      e = b.child;
      for (b.child = null; null !== e; ) {
        a = e.alternate;
        if (null !== a && null === Ch(a)) {
          b.child = e;
          break;
        }
        a = e.sibling;
        e.sibling = c;
        c = e;
        e = a;
      }
      wj(b, true, c, null, f2);
      break;
    case "together":
      wj(b, false, null, null, void 0);
      break;
    default:
      b.memoizedState = null;
  }
  return b.child;
}
function ij(a, b) {
  0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
}
function Zi(a, b, c) {
  null !== a && (b.dependencies = a.dependencies);
  rh |= b.lanes;
  if (0 === (c & b.childLanes)) return null;
  if (null !== a && b.child !== a.child) throw Error(p(153));
  if (null !== b.child) {
    a = b.child;
    c = Pg(a, a.pendingProps);
    b.child = c;
    for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
    c.sibling = null;
  }
  return b.child;
}
function yj(a, b, c) {
  switch (b.tag) {
    case 3:
      kj(b);
      Ig();
      break;
    case 5:
      Ah(b);
      break;
    case 1:
      Zf(b.type) && cg(b);
      break;
    case 4:
      yh(b, b.stateNode.containerInfo);
      break;
    case 10:
      var d = b.type._context, e = b.memoizedProps.value;
      G(Wg, d._currentValue);
      d._currentValue = e;
      break;
    case 13:
      d = b.memoizedState;
      if (null !== d) {
        if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
        if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
        G(L, L.current & 1);
        a = Zi(a, b, c);
        return null !== a ? a.sibling : null;
      }
      G(L, L.current & 1);
      break;
    case 19:
      d = 0 !== (c & b.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d) return xj(a, b, c);
        b.flags |= 128;
      }
      e = b.memoizedState;
      null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
      G(L, L.current);
      if (d) break;
      else return null;
    case 22:
    case 23:
      return b.lanes = 0, dj(a, b, c);
  }
  return Zi(a, b, c);
}
var zj, Aj, Bj, Cj;
zj = function(a, b) {
  for (var c = b.child; null !== c; ) {
    if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
    else if (4 !== c.tag && null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b) break;
    for (; null === c.sibling; ) {
      if (null === c.return || c.return === b) return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
};
Aj = function() {
};
Bj = function(a, b, c, d) {
  var e = a.memoizedProps;
  if (e !== d) {
    a = b.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c) {
      case "input":
        e = Ya(a, e);
        d = Ya(a, d);
        f2 = [];
        break;
      case "select":
        e = A$2({}, e, { value: void 0 });
        d = A$2({}, d, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e = gb(a, e);
        d = gb(a, d);
        f2 = [];
        break;
      default:
        "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
    }
    ub(c, d);
    var g;
    c = null;
    for (l2 in e) if (!d.hasOwnProperty(l2) && e.hasOwnProperty(l2) && null != e[l2]) if ("style" === l2) {
      var h = e[l2];
      for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
    } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d) {
      var k2 = d[l2];
      h = null != e ? e[l2] : void 0;
      if (d.hasOwnProperty(l2) && k2 !== h && (null != k2 || null != h)) if ("style" === l2) if (h) {
        for (g in h) !h.hasOwnProperty(g) || k2 && k2.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
        for (g in k2) k2.hasOwnProperty(g) && h[g] !== k2[g] && (c || (c = {}), c[g] = k2[g]);
      } else c || (f2 || (f2 = []), f2.push(
        l2,
        c
      )), c = k2;
      else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h = h ? h.__html : void 0, null != k2 && h !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c && (f2 = f2 || []).push("style", c);
    var l2 = f2;
    if (b.updateQueue = l2) b.flags |= 4;
  }
};
Cj = function(a, b, c, d) {
  c !== d && (b.flags |= 4);
};
function Dj(a, b) {
  if (!I) switch (a.tailMode) {
    case "hidden":
      b = a.tail;
      for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
      null === c ? a.tail = null : c.sibling = null;
      break;
    case "collapsed":
      c = a.tail;
      for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
      null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
  }
}
function S$2(a) {
  var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
  if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
  else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
  a.subtreeFlags |= d;
  a.childLanes = c;
  return b;
}
function Ej(a, b, c) {
  var d = b.pendingProps;
  wg(b);
  switch (b.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$2(b), null;
    case 1:
      return Zf(b.type) && $f(), S$2(b), null;
    case 3:
      d = b.stateNode;
      zh();
      E(Wf);
      E(H);
      Eh();
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a, b);
      S$2(b);
      return null;
    case 5:
      Bh(b);
      var e = xh(wh.current);
      c = b.type;
      if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
      else {
        if (!d) {
          if (null === b.stateNode) throw Error(p(166));
          S$2(b);
          return null;
        }
        a = xh(uh.current);
        if (Gg(b)) {
          d = b.stateNode;
          c = b.type;
          var f2 = b.memoizedProps;
          d[Of] = b;
          d[Pf] = f2;
          a = 0 !== (b.mode & 1);
          switch (c) {
            case "dialog":
              D("cancel", d);
              D("close", d);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d);
              break;
            case "video":
            case "audio":
              for (e = 0; e < lf.length; e++) D(lf[e], d);
              break;
            case "source":
              D("error", d);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d
              );
              D("load", d);
              break;
            case "details":
              D("toggle", d);
              break;
            case "input":
              Za(d, f2);
              D("invalid", d);
              break;
            case "select":
              d._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d);
              break;
            case "textarea":
              hb(d, f2), D("invalid", d);
          }
          ub(c, f2);
          e = null;
          for (var g in f2) if (f2.hasOwnProperty(g)) {
            var h = f2[g];
            "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f2.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f2.suppressHydrationWarning && Af(
              d.textContent,
              h,
              a
            ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
          }
          switch (c) {
            case "input":
              Va(d);
              db(d, f2, true);
              break;
            case "textarea":
              Va(d);
              jb(d);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d.onclick = Bf);
          }
          d = e;
          b.updateQueue = d;
          null !== d && (b.flags |= 4);
        } else {
          g = 9 === e.nodeType ? e : e.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
          a[Of] = b;
          a[Pf] = d;
          zj(a, b, false, false);
          b.stateNode = a;
          a: {
            g = vb(c, d);
            switch (c) {
              case "dialog":
                D("cancel", a);
                D("close", a);
                e = d;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a);
                e = d;
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++) D(lf[e], a);
                e = d;
                break;
              case "source":
                D("error", a);
                e = d;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a
                );
                D("load", a);
                e = d;
                break;
              case "details":
                D("toggle", a);
                e = d;
                break;
              case "input":
                Za(a, d);
                e = Ya(a, d);
                D("invalid", a);
                break;
              case "option":
                e = d;
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d.multiple };
                e = A$2({}, d, { value: void 0 });
                D("invalid", a);
                break;
              case "textarea":
                hb(a, d);
                e = gb(a, d);
                D("invalid", a);
                break;
              default:
                e = d;
            }
            ub(c, e);
            h = e;
            for (f2 in h) if (h.hasOwnProperty(f2)) {
              var k2 = h[f2];
              "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g));
            }
            switch (c) {
              case "input":
                Va(a);
                db(a, d, false);
                break;
              case "textarea":
                Va(a);
                jb(a);
                break;
              case "option":
                null != d.value && a.setAttribute("value", "" + Sa(d.value));
                break;
              case "select":
                a.multiple = !!d.multiple;
                f2 = d.value;
                null != f2 ? fb(a, !!d.multiple, f2, false) : null != d.defaultValue && fb(
                  a,
                  !!d.multiple,
                  d.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e.onClick && (a.onclick = Bf);
            }
            switch (c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d = !!d.autoFocus;
                break a;
              case "img":
                d = true;
                break a;
              default:
                d = false;
            }
          }
          d && (b.flags |= 4);
        }
        null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
      }
      S$2(b);
      return null;
    case 6:
      if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
      else {
        if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
        c = xh(wh.current);
        xh(uh.current);
        if (Gg(b)) {
          d = b.stateNode;
          c = b.memoizedProps;
          d[Of] = b;
          if (f2 = d.nodeValue !== c) {
            if (a = xg, null !== a) switch (a.tag) {
              case 3:
                Af(d.nodeValue, c, 0 !== (a.mode & 1));
                break;
              case 5:
                true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
            }
          }
          f2 && (b.flags |= 4);
        } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
      }
      S$2(b);
      return null;
    case 13:
      E(L);
      d = b.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f2 = false;
        else if (f2 = Gg(b), null !== d && null !== d.dehydrated) {
          if (null === a) {
            if (!f2) throw Error(p(318));
            f2 = b.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2) throw Error(p(317));
            f2[Of] = b;
          } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
          S$2(b);
          f2 = false;
        } else null !== zg && (Fj(zg), zg = null), f2 = true;
        if (!f2) return b.flags & 65536 ? b : null;
      }
      if (0 !== (b.flags & 128)) return b.lanes = c, b;
      d = null !== d;
      d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
      null !== b.updateQueue && (b.flags |= 4);
      S$2(b);
      return null;
    case 4:
      return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S$2(b), null;
    case 10:
      return ah(b.type._context), S$2(b), null;
    case 17:
      return Zf(b.type) && $f(), S$2(b), null;
    case 19:
      E(L);
      f2 = b.memoizedState;
      if (null === f2) return S$2(b), null;
      d = 0 !== (b.flags & 128);
      g = f2.rendering;
      if (null === g) if (d) Dj(f2, false);
      else {
        if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
          g = Ch(a);
          if (null !== g) {
            b.flags |= 128;
            Dj(f2, false);
            d = g.updateQueue;
            null !== d && (b.updateQueue = d, b.flags |= 4);
            b.subtreeFlags = 0;
            d = c;
            for (c = b.child; null !== c; ) f2 = c, a = d, f2.flags &= 14680066, g = f2.alternate, null === g ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g.childLanes, f2.lanes = g.lanes, f2.child = g.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g.memoizedProps, f2.memoizedState = g.memoizedState, f2.updateQueue = g.updateQueue, f2.type = g.type, a = g.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
            G(L, L.current & 1 | 2);
            return b.child;
          }
          a = a.sibling;
        }
        null !== f2.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f2, false), b.lanes = 4194304);
      }
      else {
        if (!d) if (a = Ch(g), null !== a) {
          if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g.alternate && !I) return S$2(b), null;
        } else 2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f2, false), b.lanes = 4194304);
        f2.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f2.last, null !== c ? c.sibling = g : b.child = g, f2.last = g);
      }
      if (null !== f2.tail) return b = f2.tail, f2.rendering = b, f2.tail = b.sibling, f2.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
      S$2(b);
      return null;
    case 22:
    case 23:
      return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S$2(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S$2(b), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p(156, b.tag));
}
function Ij(a, b) {
  wg(b);
  switch (b.tag) {
    case 1:
      return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
    case 3:
      return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
    case 5:
      return Bh(b), null;
    case 13:
      E(L);
      a = b.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b.alternate) throw Error(p(340));
        Ig();
      }
      a = b.flags;
      return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
    case 19:
      return E(L), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Lj(a, b) {
  var c = a.ref;
  if (null !== c) if ("function" === typeof c) try {
    c(null);
  } catch (d) {
    W(a, b, d);
  }
  else c.current = null;
}
function Mj(a, b, c) {
  try {
    c();
  } catch (d) {
    W(a, b, d);
  }
}
var Nj = false;
function Oj(a, b) {
  Cf = dd;
  a = Me();
  if (Ne(a)) {
    if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
    else a: {
      c = (c = a.ownerDocument) && c.defaultView || window;
      var d = c.getSelection && c.getSelection();
      if (d && 0 !== d.rangeCount) {
        c = d.anchorNode;
        var e = d.anchorOffset, f2 = d.focusNode;
        d = d.focusOffset;
        try {
          c.nodeType, f2.nodeType;
        } catch (F2) {
          c = null;
          break a;
        }
        var g = 0, h = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
        b: for (; ; ) {
          for (var y2; ; ) {
            q2 !== c || 0 !== e && 3 !== q2.nodeType || (h = g + e);
            q2 !== f2 || 0 !== d && 3 !== q2.nodeType || (k2 = g + d);
            3 === q2.nodeType && (g += q2.nodeValue.length);
            if (null === (y2 = q2.firstChild)) break;
            r2 = q2;
            q2 = y2;
          }
          for (; ; ) {
            if (q2 === a) break b;
            r2 === c && ++l2 === e && (h = g);
            r2 === f2 && ++m2 === d && (k2 = g);
            if (null !== (y2 = q2.nextSibling)) break;
            q2 = r2;
            r2 = q2.parentNode;
          }
          q2 = y2;
        }
        c = -1 === h || -1 === k2 ? null : { start: h, end: k2 };
      } else c = null;
    }
    c = c || { start: 0, end: 0 };
  } else c = null;
  Df = { focusedElem: a, selectionRange: c };
  dd = false;
  for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
  else for (; null !== V; ) {
    b = V;
    try {
      var n2 = b.alternate;
      if (0 !== (b.flags & 1024)) switch (b.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (null !== n2) {
            var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b.stateNode, w2 = x2.getSnapshotBeforeUpdate(b.elementType === b.type ? t2 : Ci(b.type, t2), J2);
            x2.__reactInternalSnapshotBeforeUpdate = w2;
          }
          break;
        case 3:
          var u2 = b.stateNode.containerInfo;
          1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(p(163));
      }
    } catch (F2) {
      W(b, b.return, F2);
    }
    a = b.sibling;
    if (null !== a) {
      a.return = b.return;
      V = a;
      break;
    }
    V = b.return;
  }
  n2 = Nj;
  Nj = false;
  return n2;
}
function Pj(a, b, c) {
  var d = b.updateQueue;
  d = null !== d ? d.lastEffect : null;
  if (null !== d) {
    var e = d = d.next;
    do {
      if ((e.tag & a) === a) {
        var f2 = e.destroy;
        e.destroy = void 0;
        void 0 !== f2 && Mj(b, c, f2);
      }
      e = e.next;
    } while (e !== d);
  }
}
function Qj(a, b) {
  b = b.updateQueue;
  b = null !== b ? b.lastEffect : null;
  if (null !== b) {
    var c = b = b.next;
    do {
      if ((c.tag & a) === a) {
        var d = c.create;
        c.destroy = d();
      }
      c = c.next;
    } while (c !== b);
  }
}
function Rj(a) {
  var b = a.ref;
  if (null !== b) {
    var c = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c;
        break;
      default:
        a = c;
    }
    "function" === typeof b ? b(a) : b.current = a;
  }
}
function Sj(a) {
  var b = a.alternate;
  null !== b && (a.alternate = null, Sj(b));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Tj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function Uj(a) {
  a: for (; ; ) {
    for (; null === a.sibling; ) {
      if (null === a.return || Tj(a.return)) return null;
      a = a.return;
    }
    a.sibling.return = a.return;
    for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
      if (a.flags & 2) continue a;
      if (null === a.child || 4 === a.tag) continue a;
      else a.child.return = a, a = a.child;
    }
    if (!(a.flags & 2)) return a.stateNode;
  }
}
function Vj(a, b, c) {
  var d = a.tag;
  if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
  else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
}
function Wj(a, b, c) {
  var d = a.tag;
  if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
  else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
}
var X$2 = null, Xj = false;
function Yj(a, b, c) {
  for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
}
function Zj(a, b, c) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
    lc.onCommitFiberUnmount(kc, c);
  } catch (h) {
  }
  switch (c.tag) {
    case 5:
      U || Lj(c, b);
    case 6:
      var d = X$2, e = Xj;
      X$2 = null;
      Yj(a, b, c);
      X$2 = d;
      Xj = e;
      null !== X$2 && (Xj ? (a = X$2, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X$2.removeChild(c.stateNode));
      break;
    case 18:
      null !== X$2 && (Xj ? (a = X$2, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X$2, c.stateNode));
      break;
    case 4:
      d = X$2;
      e = Xj;
      X$2 = c.stateNode.containerInfo;
      Xj = true;
      Yj(a, b, c);
      X$2 = d;
      Xj = e;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
        e = d = d.next;
        do {
          var f2 = e, g = f2.destroy;
          f2 = f2.tag;
          void 0 !== g && (0 !== (f2 & 2) ? Mj(c, b, g) : 0 !== (f2 & 4) && Mj(c, b, g));
          e = e.next;
        } while (e !== d);
      }
      Yj(a, b, c);
      break;
    case 1:
      if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
        d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
      } catch (h) {
        W(c, b, h);
      }
      Yj(a, b, c);
      break;
    case 21:
      Yj(a, b, c);
      break;
    case 22:
      c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
      break;
    default:
      Yj(a, b, c);
  }
}
function ak(a) {
  var b = a.updateQueue;
  if (null !== b) {
    a.updateQueue = null;
    var c = a.stateNode;
    null === c && (c = a.stateNode = new Kj());
    b.forEach(function(b2) {
      var d = bk.bind(null, a, b2);
      c.has(b2) || (c.add(b2), b2.then(d, d));
    });
  }
}
function ck(a, b) {
  var c = b.deletions;
  if (null !== c) for (var d = 0; d < c.length; d++) {
    var e = c[d];
    try {
      var f2 = a, g = b, h = g;
      a: for (; null !== h; ) {
        switch (h.tag) {
          case 5:
            X$2 = h.stateNode;
            Xj = false;
            break a;
          case 3:
            X$2 = h.stateNode.containerInfo;
            Xj = true;
            break a;
          case 4:
            X$2 = h.stateNode.containerInfo;
            Xj = true;
            break a;
        }
        h = h.return;
      }
      if (null === X$2) throw Error(p(160));
      Zj(f2, g, e);
      X$2 = null;
      Xj = false;
      var k2 = e.alternate;
      null !== k2 && (k2.return = null);
      e.return = null;
    } catch (l2) {
      W(e, b, l2);
    }
  }
  if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
}
function dk(a, b) {
  var c = a.alternate, d = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b, a);
      ek(a);
      if (d & 4) {
        try {
          Pj(3, a, a.return), Qj(3, a);
        } catch (t2) {
          W(a, a.return, t2);
        }
        try {
          Pj(5, a, a.return);
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 1:
      ck(b, a);
      ek(a);
      d & 512 && null !== c && Lj(c, c.return);
      break;
    case 5:
      ck(b, a);
      ek(a);
      d & 512 && null !== c && Lj(c, c.return);
      if (a.flags & 32) {
        var e = a.stateNode;
        try {
          ob(e, "");
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      if (d & 4 && (e = a.stateNode, null != e)) {
        var f2 = a.memoizedProps, g = null !== c ? c.memoizedProps : f2, h = a.type, k2 = a.updateQueue;
        a.updateQueue = null;
        if (null !== k2) try {
          "input" === h && "radio" === f2.type && null != f2.name && ab(e, f2);
          vb(h, g);
          var l2 = vb(h, f2);
          for (g = 0; g < k2.length; g += 2) {
            var m2 = k2[g], q2 = k2[g + 1];
            "style" === m2 ? sb(e, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e, q2) : "children" === m2 ? ob(e, q2) : ta(e, m2, q2, l2);
          }
          switch (h) {
            case "input":
              bb(e, f2);
              break;
            case "textarea":
              ib(e, f2);
              break;
            case "select":
              var r2 = e._wrapperState.wasMultiple;
              e._wrapperState.wasMultiple = !!f2.multiple;
              var y2 = f2.value;
              null != y2 ? fb(e, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                e,
                !!f2.multiple,
                f2.defaultValue,
                true
              ) : fb(e, !!f2.multiple, f2.multiple ? [] : "", false));
          }
          e[Pf] = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 6:
      ck(b, a);
      ek(a);
      if (d & 4) {
        if (null === a.stateNode) throw Error(p(162));
        e = a.stateNode;
        f2 = a.memoizedProps;
        try {
          e.nodeValue = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 3:
      ck(b, a);
      ek(a);
      if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
        bd(b.containerInfo);
      } catch (t2) {
        W(a, a.return, t2);
      }
      break;
    case 4:
      ck(b, a);
      ek(a);
      break;
    case 13:
      ck(b, a);
      ek(a);
      e = a.child;
      e.flags & 8192 && (f2 = null !== e.memoizedState, e.stateNode.isHidden = f2, !f2 || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
      d & 4 && ak(a);
      break;
    case 22:
      m2 = null !== c && null !== c.memoizedState;
      a.mode & 1 ? (U = (l2 = U) || m2, ck(b, a), U = l2) : ck(b, a);
      ek(a);
      if (d & 8192) {
        l2 = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1)) for (V = a, m2 = a.child; null !== m2; ) {
          for (q2 = V = m2; null !== V; ) {
            r2 = V;
            y2 = r2.child;
            switch (r2.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Pj(4, r2, r2.return);
                break;
              case 1:
                Lj(r2, r2.return);
                var n2 = r2.stateNode;
                if ("function" === typeof n2.componentWillUnmount) {
                  d = r2;
                  c = r2.return;
                  try {
                    b = d, n2.props = b.memoizedProps, n2.state = b.memoizedState, n2.componentWillUnmount();
                  } catch (t2) {
                    W(d, c, t2);
                  }
                }
                break;
              case 5:
                Lj(r2, r2.return);
                break;
              case 22:
                if (null !== r2.memoizedState) {
                  gk(q2);
                  continue;
                }
            }
            null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
          }
          m2 = m2.sibling;
        }
        a: for (m2 = null, q2 = a; ; ) {
          if (5 === q2.tag) {
            if (null === m2) {
              m2 = q2;
              try {
                e = q2.stateNode, l2 ? (f2 = e.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h = q2.stateNode, k2 = q2.memoizedProps.style, g = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h.style.display = rb("display", g));
              } catch (t2) {
                W(a, a.return, t2);
              }
            }
          } else if (6 === q2.tag) {
            if (null === m2) try {
              q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
            } catch (t2) {
              W(a, a.return, t2);
            }
          } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
            q2.child.return = q2;
            q2 = q2.child;
            continue;
          }
          if (q2 === a) break a;
          for (; null === q2.sibling; ) {
            if (null === q2.return || q2.return === a) break a;
            m2 === q2 && (m2 = null);
            q2 = q2.return;
          }
          m2 === q2 && (m2 = null);
          q2.sibling.return = q2.return;
          q2 = q2.sibling;
        }
      }
      break;
    case 19:
      ck(b, a);
      ek(a);
      d & 4 && ak(a);
      break;
    case 21:
      break;
    default:
      ck(
        b,
        a
      ), ek(a);
  }
}
function ek(a) {
  var b = a.flags;
  if (b & 2) {
    try {
      a: {
        for (var c = a.return; null !== c; ) {
          if (Tj(c)) {
            var d = c;
            break a;
          }
          c = c.return;
        }
        throw Error(p(160));
      }
      switch (d.tag) {
        case 5:
          var e = d.stateNode;
          d.flags & 32 && (ob(e, ""), d.flags &= -33);
          var f2 = Uj(a);
          Wj(a, f2, e);
          break;
        case 3:
        case 4:
          var g = d.stateNode.containerInfo, h = Uj(a);
          Vj(a, h, g);
          break;
        default:
          throw Error(p(161));
      }
    } catch (k2) {
      W(a, a.return, k2);
    }
    a.flags &= -3;
  }
  b & 4096 && (a.flags &= -4097);
}
function hk(a, b, c) {
  V = a;
  ik(a);
}
function ik(a, b, c) {
  for (var d = 0 !== (a.mode & 1); null !== V; ) {
    var e = V, f2 = e.child;
    if (22 === e.tag && d) {
      var g = null !== e.memoizedState || Jj;
      if (!g) {
        var h = e.alternate, k2 = null !== h && null !== h.memoizedState || U;
        h = Jj;
        var l2 = U;
        Jj = g;
        if ((U = k2) && !l2) for (V = e; null !== V; ) g = V, k2 = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k2 ? (k2.return = g, V = k2) : jk(e);
        for (; null !== f2; ) V = f2, ik(f2), f2 = f2.sibling;
        V = e;
        Jj = h;
        U = l2;
      }
      kk(a);
    } else 0 !== (e.subtreeFlags & 8772) && null !== f2 ? (f2.return = e, V = f2) : kk(a);
  }
}
function kk(a) {
  for (; null !== V; ) {
    var b = V;
    if (0 !== (b.flags & 8772)) {
      var c = b.alternate;
      try {
        if (0 !== (b.flags & 8772)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            U || Qj(5, b);
            break;
          case 1:
            var d = b.stateNode;
            if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
            else {
              var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
              d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
            }
            var f2 = b.updateQueue;
            null !== f2 && sh(b, f2, d);
            break;
          case 3:
            var g = b.updateQueue;
            if (null !== g) {
              c = null;
              if (null !== b.child) switch (b.child.tag) {
                case 5:
                  c = b.child.stateNode;
                  break;
                case 1:
                  c = b.child.stateNode;
              }
              sh(b, g, c);
            }
            break;
          case 5:
            var h = b.stateNode;
            if (null === c && b.flags & 4) {
              c = h;
              var k2 = b.memoizedProps;
              switch (b.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k2.autoFocus && c.focus();
                  break;
                case "img":
                  k2.src && (c.src = k2.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (null === b.memoizedState) {
              var l2 = b.alternate;
              if (null !== l2) {
                var m2 = l2.memoizedState;
                if (null !== m2) {
                  var q2 = m2.dehydrated;
                  null !== q2 && bd(q2);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(p(163));
        }
        U || b.flags & 512 && Rj(b);
      } catch (r2) {
        W(b, b.return, r2);
      }
    }
    if (b === a) {
      V = null;
      break;
    }
    c = b.sibling;
    if (null !== c) {
      c.return = b.return;
      V = c;
      break;
    }
    V = b.return;
  }
}
function gk(a) {
  for (; null !== V; ) {
    var b = V;
    if (b === a) {
      V = null;
      break;
    }
    var c = b.sibling;
    if (null !== c) {
      c.return = b.return;
      V = c;
      break;
    }
    V = b.return;
  }
}
function jk(a) {
  for (; null !== V; ) {
    var b = V;
    try {
      switch (b.tag) {
        case 0:
        case 11:
        case 15:
          var c = b.return;
          try {
            Qj(4, b);
          } catch (k2) {
            W(b, c, k2);
          }
          break;
        case 1:
          var d = b.stateNode;
          if ("function" === typeof d.componentDidMount) {
            var e = b.return;
            try {
              d.componentDidMount();
            } catch (k2) {
              W(b, e, k2);
            }
          }
          var f2 = b.return;
          try {
            Rj(b);
          } catch (k2) {
            W(b, f2, k2);
          }
          break;
        case 5:
          var g = b.return;
          try {
            Rj(b);
          } catch (k2) {
            W(b, g, k2);
          }
      }
    } catch (k2) {
      W(b, b.return, k2);
    }
    if (b === a) {
      V = null;
      break;
    }
    var h = b.sibling;
    if (null !== h) {
      h.return = b.return;
      V = h;
      break;
    }
    V = b.return;
  }
}
var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y$2 = null, Z$2 = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R() {
  return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
}
function yi(a) {
  if (0 === (a.mode & 1)) return 1;
  if (0 !== (K & 2) && 0 !== Z$2) return Z$2 & -Z$2;
  if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
  a = C;
  if (0 !== a) return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}
function gi(a, b, c, d) {
  if (50 < yk) throw yk = 0, zk = null, Error(p(185));
  Ac(a, c, d);
  if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z$2)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
}
function Dk(a, b) {
  var c = a.callbackNode;
  wc(a, b);
  var d = uc(a, a === Q ? Z$2 : 0);
  if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
  else if (b = d & -d, a.callbackPriority !== b) {
    null != c && bc(c);
    if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
      0 === (K & 6) && jg();
    }), c = null;
    else {
      switch (Dc(d)) {
        case 1:
          c = fc;
          break;
        case 4:
          c = gc;
          break;
        case 16:
          c = hc;
          break;
        case 536870912:
          c = jc;
          break;
        default:
          c = hc;
      }
      c = Fk(c, Gk.bind(null, a));
    }
    a.callbackPriority = b;
    a.callbackNode = c;
  }
}
function Gk(a, b) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K & 6)) throw Error(p(327));
  var c = a.callbackNode;
  if (Hk() && a.callbackNode !== c) return null;
  var d = uc(a, a === Q ? Z$2 : 0);
  if (0 === d) return null;
  if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
  else {
    b = d;
    var e = K;
    K |= 2;
    var f2 = Jk();
    if (Q !== a || Z$2 !== b) uk = null, Gj = B() + 500, Kk(a, b);
    do
      try {
        Lk();
        break;
      } catch (h) {
        Mk(a, h);
      }
    while (1);
    $g();
    mk.current = f2;
    K = e;
    null !== Y$2 ? b = 0 : (Q = null, Z$2 = 0, b = T);
  }
  if (0 !== b) {
    2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
    if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
    if (6 === b) Ck(a, d);
    else {
      e = a.current.alternate;
      if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f2 = xc(a), 0 !== f2 && (d = f2, b = Nk(a, f2))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
      a.finishedWork = e;
      a.finishedLanes = d;
      switch (b) {
        case 0:
        case 1:
          throw Error(p(345));
        case 2:
          Pk(a, tk, uk);
          break;
        case 3:
          Ck(a, d);
          if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
            if (0 !== uc(a, 0)) break;
            e = a.suspendedLanes;
            if ((e & d) !== d) {
              R();
              a.pingedLanes |= a.suspendedLanes & e;
              break;
            }
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 4:
          Ck(a, d);
          if ((d & 4194240) === d) break;
          b = a.eventTimes;
          for (e = -1; 0 < d; ) {
            var g = 31 - oc(d);
            f2 = 1 << g;
            g = b[g];
            g > e && (e = g);
            d &= ~f2;
          }
          d = e;
          d = B() - d;
          d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
          if (10 < d) {
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 5:
          Pk(a, tk, uk);
          break;
        default:
          throw Error(p(329));
      }
    }
  }
  Dk(a, B());
  return a.callbackNode === c ? Gk.bind(null, a) : null;
}
function Nk(a, b) {
  var c = sk;
  a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
  a = Ik(a, b);
  2 !== a && (b = tk, tk = c, null !== b && Fj(b));
  return a;
}
function Fj(a) {
  null === tk ? tk = a : tk.push.apply(tk, a);
}
function Ok(a) {
  for (var b = a; ; ) {
    if (b.flags & 16384) {
      var c = b.updateQueue;
      if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
        var e = c[d], f2 = e.getSnapshot;
        e = e.value;
        try {
          if (!He(f2(), e)) return false;
        } catch (g) {
          return false;
        }
      }
    }
    c = b.child;
    if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
    else {
      if (b === a) break;
      for (; null === b.sibling; ) {
        if (null === b.return || b.return === a) return true;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
  }
  return true;
}
function Ck(a, b) {
  b &= ~rk;
  b &= ~qk;
  a.suspendedLanes |= b;
  a.pingedLanes &= ~b;
  for (a = a.expirationTimes; 0 < b; ) {
    var c = 31 - oc(b), d = 1 << c;
    a[c] = -1;
    b &= ~d;
  }
}
function Ek(a) {
  if (0 !== (K & 6)) throw Error(p(327));
  Hk();
  var b = uc(a, 0);
  if (0 === (b & 1)) return Dk(a, B()), null;
  var c = Ik(a, b);
  if (0 !== a.tag && 2 === c) {
    var d = xc(a);
    0 !== d && (b = d, c = Nk(a, d));
  }
  if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
  if (6 === c) throw Error(p(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b;
  Pk(a, tk, uk);
  Dk(a, B());
  return null;
}
function Qk(a, b) {
  var c = K;
  K |= 1;
  try {
    return a(b);
  } finally {
    K = c, 0 === K && (Gj = B() + 500, fg && jg());
  }
}
function Rk(a) {
  null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
  var b = K;
  K |= 1;
  var c = ok.transition, d = C;
  try {
    if (ok.transition = null, C = 1, a) return a();
  } finally {
    C = d, ok.transition = c, K = b, 0 === (K & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E(ej);
}
function Kk(a, b) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  -1 !== c && (a.timeoutHandle = -1, Gf(c));
  if (null !== Y$2) for (c = Y$2.return; null !== c; ) {
    var d = c;
    wg(d);
    switch (d.tag) {
      case 1:
        d = d.type.childContextTypes;
        null !== d && void 0 !== d && $f();
        break;
      case 3:
        zh();
        E(Wf);
        E(H);
        Eh();
        break;
      case 5:
        Bh(d);
        break;
      case 4:
        zh();
        break;
      case 13:
        E(L);
        break;
      case 19:
        E(L);
        break;
      case 10:
        ah(d.type._context);
        break;
      case 22:
      case 23:
        Hj();
    }
    c = c.return;
  }
  Q = a;
  Y$2 = a = Pg(a.current, null);
  Z$2 = fj = b;
  T = 0;
  pk = null;
  rk = qk = rh = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
      c.interleaved = null;
      var e = d.next, f2 = c.pending;
      if (null !== f2) {
        var g = f2.next;
        f2.next = e;
        d.next = g;
      }
      c.pending = d;
    }
    fh = null;
  }
  return a;
}
function Mk(a, b) {
  do {
    var c = Y$2;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d = M$2.memoizedState; null !== d; ) {
          var e = d.queue;
          null !== e && (e.pending = null);
          d = d.next;
        }
        Ih = false;
      }
      Hh = 0;
      O = N = M$2 = null;
      Jh = false;
      Kh = 0;
      nk.current = null;
      if (null === c || null === c.return) {
        T = 1;
        pk = b;
        Y$2 = null;
        break;
      }
      a: {
        var f2 = a, g = c.return, h = c, k2 = b;
        b = Z$2;
        h.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Ui(g);
          if (null !== y2) {
            y2.flags &= -257;
            Vi(y2, g, h, f2, b);
            y2.mode & 1 && Si(f2, l2, b);
            b = y2;
            k2 = l2;
            var n2 = b.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b.updateQueue = t2;
            } else n2.add(k2);
            break a;
          } else {
            if (0 === (b & 1)) {
              Si(f2, l2, b);
              tj();
              break a;
            }
            k2 = Error(p(426));
          }
        } else if (I && h.mode & 1) {
          var J2 = Ui(g);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g, h, f2, b);
            Jg(Ji(k2, h));
            break a;
          }
        }
        f2 = k2 = Ji(k2, h);
        4 !== T && (T = 2);
        null === sk ? sk = [f2] : sk.push(f2);
        f2 = g;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b &= -b;
              f2.lanes |= b;
              var x2 = Ni(f2, k2, b);
              ph(f2, x2);
              break a;
            case 1:
              h = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                f2.flags |= 65536;
                b &= -b;
                f2.lanes |= b;
                var F2 = Qi(f2, h, b);
                ph(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Sk(c);
    } catch (na) {
      b = na;
      Y$2 === c && null !== c && (Y$2 = c = c.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a = mk.current;
  mk.current = Rh;
  return null === a ? Rh : a;
}
function tj() {
  if (0 === T || 3 === T || 2 === T) T = 4;
  null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z$2);
}
function Ik(a, b) {
  var c = K;
  K |= 2;
  var d = Jk();
  if (Q !== a || Z$2 !== b) uk = null, Kk(a, b);
  do
    try {
      Tk();
      break;
    } catch (e) {
      Mk(a, e);
    }
  while (1);
  $g();
  K = c;
  mk.current = d;
  if (null !== Y$2) throw Error(p(261));
  Q = null;
  Z$2 = 0;
  return T;
}
function Tk() {
  for (; null !== Y$2; ) Uk(Y$2);
}
function Lk() {
  for (; null !== Y$2 && !cc(); ) Uk(Y$2);
}
function Uk(a) {
  var b = Vk(a.alternate, a, fj);
  a.memoizedProps = a.pendingProps;
  null === b ? Sk(a) : Y$2 = b;
  nk.current = null;
}
function Sk(a) {
  var b = a;
  do {
    var c = b.alternate;
    a = b.return;
    if (0 === (b.flags & 32768)) {
      if (c = Ej(c, b, fj), null !== c) {
        Y$2 = c;
        return;
      }
    } else {
      c = Ij(c, b);
      if (null !== c) {
        c.flags &= 32767;
        Y$2 = c;
        return;
      }
      if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
      else {
        T = 6;
        Y$2 = null;
        return;
      }
    }
    b = b.sibling;
    if (null !== b) {
      Y$2 = b;
      return;
    }
    Y$2 = b = a;
  } while (null !== b);
  0 === T && (T = 5);
}
function Pk(a, b, c) {
  var d = C, e = ok.transition;
  try {
    ok.transition = null, C = 1, Wk(a, b, c, d);
  } finally {
    ok.transition = e, C = d;
  }
  return null;
}
function Wk(a, b, c, d) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K & 6)) throw Error(p(327));
  c = a.finishedWork;
  var e = a.finishedLanes;
  if (null === c) return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current) throw Error(p(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f2 = c.lanes | c.childLanes;
  Bc(a, f2);
  a === Q && (Y$2 = Q = null, Z$2 = 0);
  0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f2 = 0 !== (c.flags & 15990);
  if (0 !== (c.subtreeFlags & 15990) || f2) {
    f2 = ok.transition;
    ok.transition = null;
    var g = C;
    C = 1;
    var h = K;
    K |= 4;
    nk.current = null;
    Oj(a, c);
    dk(c, a);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c;
    hk(c);
    dc();
    K = h;
    C = g;
    ok.transition = f2;
  } else a.current = c;
  vk && (vk = false, wk = a, xk = e);
  f2 = a.pendingLanes;
  0 === f2 && (Ri = null);
  mc(c.stateNode);
  Dk(a, B());
  if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
  if (Oi) throw Oi = false, a = Pi, Pi = null, a;
  0 !== (xk & 1) && 0 !== a.tag && Hk();
  f2 = a.pendingLanes;
  0 !== (f2 & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a = Dc(xk), b = ok.transition, c = C;
    try {
      ok.transition = null;
      C = 16 > a ? 16 : a;
      if (null === wk) var d = false;
      else {
        a = wk;
        wk = null;
        xk = 0;
        if (0 !== (K & 6)) throw Error(p(331));
        var e = K;
        K |= 4;
        for (V = a.current; null !== V; ) {
          var f2 = V, g = f2.child;
          if (0 !== (V.flags & 16)) {
            var h = f2.deletions;
            if (null !== h) {
              for (var k2 = 0; k2 < h.length; k2++) {
                var l2 = h[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2) q2.return = m2, V = q2;
                  else for (; null !== V; ) {
                    m2 = V;
                    var r2 = m2.sibling, y2 = m2.return;
                    Sj(m2);
                    if (m2 === l2) {
                      V = null;
                      break;
                    }
                    if (null !== r2) {
                      r2.return = y2;
                      V = r2;
                      break;
                    }
                    V = y2;
                  }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g) g.return = f2, V = g;
          else b: for (; null !== V; ) {
            f2 = V;
            if (0 !== (f2.flags & 2048)) switch (f2.tag) {
              case 0:
              case 11:
              case 15:
                Pj(9, f2, f2.return);
            }
            var x2 = f2.sibling;
            if (null !== x2) {
              x2.return = f2.return;
              V = x2;
              break b;
            }
            V = f2.return;
          }
        }
        var w2 = a.current;
        for (V = w2; null !== V; ) {
          g = V;
          var u2 = g.child;
          if (0 !== (g.subtreeFlags & 2064) && null !== u2) u2.return = g, V = u2;
          else b: for (g = w2; null !== V; ) {
            h = V;
            if (0 !== (h.flags & 2048)) try {
              switch (h.tag) {
                case 0:
                case 11:
                case 15:
                  Qj(9, h);
              }
            } catch (na) {
              W(h, h.return, na);
            }
            if (h === g) {
              V = null;
              break b;
            }
            var F2 = h.sibling;
            if (null !== F2) {
              F2.return = h.return;
              V = F2;
              break b;
            }
            V = h.return;
          }
        }
        K = e;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
          lc.onPostCommitFiberRoot(kc, a);
        } catch (na) {
        }
        d = true;
      }
      return d;
    } finally {
      C = c, ok.transition = b;
    }
  }
  return false;
}
function Xk(a, b, c) {
  b = Ji(c, b);
  b = Ni(a, b, 1);
  a = nh(a, b, 1);
  b = R();
  null !== a && (Ac(a, 1, b), Dk(a, b));
}
function W(a, b, c) {
  if (3 === a.tag) Xk(a, a, c);
  else for (; null !== b; ) {
    if (3 === b.tag) {
      Xk(b, a, c);
      break;
    } else if (1 === b.tag) {
      var d = b.stateNode;
      if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
        a = Ji(c, a);
        a = Qi(b, a, 1);
        b = nh(b, a, 1);
        a = R();
        null !== b && (Ac(b, 1, a), Dk(b, a));
        break;
      }
    }
    b = b.return;
  }
}
function Ti(a, b, c) {
  var d = a.pingCache;
  null !== d && d.delete(b);
  b = R();
  a.pingedLanes |= a.suspendedLanes & c;
  Q === a && (Z$2 & c) === c && (4 === T || 3 === T && (Z$2 & 130023424) === Z$2 && 500 > B() - fk ? Kk(a, 0) : rk |= c);
  Dk(a, b);
}
function Yk(a, b) {
  0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c = R();
  a = ih(a, b);
  null !== a && (Ac(a, b, c), Dk(a, c));
}
function uj(a) {
  var b = a.memoizedState, c = 0;
  null !== b && (c = b.retryLane);
  Yk(a, c);
}
function bk(a, b) {
  var c = 0;
  switch (a.tag) {
    case 13:
      var d = a.stateNode;
      var e = a.memoizedState;
      null !== e && (c = e.retryLane);
      break;
    case 19:
      d = a.stateNode;
      break;
    default:
      throw Error(p(314));
  }
  null !== d && d.delete(b);
  Yk(a, c);
}
var Vk;
Vk = function(a, b, c) {
  if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
  else {
    if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
    dh = 0 !== (a.flags & 131072) ? true : false;
  }
  else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
  b.lanes = 0;
  switch (b.tag) {
    case 2:
      var d = b.type;
      ij(a, b);
      a = b.pendingProps;
      var e = Yf(b, H.current);
      ch(b, c);
      e = Nh(null, b, d, a, e, c);
      var f2 = Sh();
      b.flags |= 1;
      "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f2 = true, cg(b)) : f2 = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f2, c)) : (b.tag = 0, I && f2 && vg(b), Xi(null, b, e, c), b = b.child);
      return b;
    case 16:
      d = b.elementType;
      a: {
        ij(a, b);
        a = b.pendingProps;
        e = d._init;
        d = e(d._payload);
        b.type = d;
        e = b.tag = Zk(d);
        a = Ci(d, a);
        switch (e) {
          case 0:
            b = cj(null, b, d, a, c);
            break a;
          case 1:
            b = hj(null, b, d, a, c);
            break a;
          case 11:
            b = Yi(null, b, d, a, c);
            break a;
          case 14:
            b = $i(null, b, d, Ci(d.type, a), c);
            break a;
        }
        throw Error(p(
          306,
          d,
          ""
        ));
      }
      return b;
    case 0:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
    case 1:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
    case 3:
      a: {
        kj(b);
        if (null === a) throw Error(p(387));
        d = b.pendingProps;
        f2 = b.memoizedState;
        e = f2.element;
        lh(a, b);
        qh(b, d, null, c);
        var g = b.memoizedState;
        d = g.element;
        if (f2.isDehydrated) if (f2 = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f2, b.memoizedState = f2, b.flags & 256) {
          e = Ji(Error(p(423)), b);
          b = lj(a, b, d, c, e);
          break a;
        } else if (d !== e) {
          e = Ji(Error(p(424)), b);
          b = lj(a, b, d, c, e);
          break a;
        } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
        else {
          Ig();
          if (d === e) {
            b = Zi(a, b, c);
            break a;
          }
          Xi(a, b, d, c);
        }
        b = b.child;
      }
      return b;
    case 5:
      return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f2 = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f2 && Ef(d, f2) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
    case 6:
      return null === a && Eg(b), null;
    case 13:
      return oj(a, b, c);
    case 4:
      return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
    case 11:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
    case 7:
      return Xi(a, b, b.pendingProps, c), b.child;
    case 8:
      return Xi(a, b, b.pendingProps.children, c), b.child;
    case 12:
      return Xi(a, b, b.pendingProps.children, c), b.child;
    case 10:
      a: {
        d = b.type._context;
        e = b.pendingProps;
        f2 = b.memoizedProps;
        g = e.value;
        G(Wg, d._currentValue);
        d._currentValue = g;
        if (null !== f2) if (He(f2.value, g)) {
          if (f2.children === e.children && !Wf.current) {
            b = Zi(a, b, c);
            break a;
          }
        } else for (f2 = b.child, null !== f2 && (f2.return = b); null !== f2; ) {
          var h = f2.dependencies;
          if (null !== h) {
            g = f2.child;
            for (var k2 = h.firstContext; null !== k2; ) {
              if (k2.context === d) {
                if (1 === f2.tag) {
                  k2 = mh(-1, c & -c);
                  k2.tag = 2;
                  var l2 = f2.updateQueue;
                  if (null !== l2) {
                    l2 = l2.shared;
                    var m2 = l2.pending;
                    null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                    l2.pending = k2;
                  }
                }
                f2.lanes |= c;
                k2 = f2.alternate;
                null !== k2 && (k2.lanes |= c);
                bh(
                  f2.return,
                  c,
                  b
                );
                h.lanes |= c;
                break;
              }
              k2 = k2.next;
            }
          } else if (10 === f2.tag) g = f2.type === b.type ? null : f2.child;
          else if (18 === f2.tag) {
            g = f2.return;
            if (null === g) throw Error(p(341));
            g.lanes |= c;
            h = g.alternate;
            null !== h && (h.lanes |= c);
            bh(g, c, b);
            g = f2.sibling;
          } else g = f2.child;
          if (null !== g) g.return = f2;
          else for (g = f2; null !== g; ) {
            if (g === b) {
              g = null;
              break;
            }
            f2 = g.sibling;
            if (null !== f2) {
              f2.return = g.return;
              g = f2;
              break;
            }
            g = g.return;
          }
          f2 = g;
        }
        Xi(a, b, e.children, c);
        b = b.child;
      }
      return b;
    case 9:
      return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
    case 14:
      return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
    case 15:
      return bj(a, b, b.type, b.pendingProps, c);
    case 17:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
    case 19:
      return xj(a, b, c);
    case 22:
      return dj(a, b, c);
  }
  throw Error(p(156, b.tag));
};
function Fk(a, b) {
  return ac(a, b);
}
function $k(a, b, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a, b, c, d) {
  return new $k(a, b, c, d);
}
function aj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function Zk(a) {
  if ("function" === typeof a) return aj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da) return 11;
    if (a === Ga) return 14;
  }
  return 2;
}
function Pg(a, b) {
  var c = a.alternate;
  null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
  c.flags = a.flags & 14680064;
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b = a.dependencies;
  c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}
function Rg(a, b, c, d, e, f2) {
  var g = 2;
  d = a;
  if ("function" === typeof a) aj(a) && (g = 1);
  else if ("string" === typeof a) g = 5;
  else a: switch (a) {
    case ya:
      return Tg(c.children, e, f2, b);
    case za:
      g = 8;
      e |= 8;
      break;
    case Aa:
      return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f2, a;
    case Ea:
      return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f2, a;
    case Fa:
      return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f2, a;
    case Ia:
      return pj(c, e, f2, b);
    default:
      if ("object" === typeof a && null !== a) switch (a.$$typeof) {
        case Ba:
          g = 10;
          break a;
        case Ca:
          g = 9;
          break a;
        case Da:
          g = 11;
          break a;
        case Ga:
          g = 14;
          break a;
        case Ha:
          g = 16;
          d = null;
          break a;
      }
      throw Error(p(130, null == a ? a : typeof a, ""));
  }
  b = Bg(g, c, b, e);
  b.elementType = a;
  b.type = d;
  b.lanes = f2;
  return b;
}
function Tg(a, b, c, d) {
  a = Bg(7, a, d, b);
  a.lanes = c;
  return a;
}
function pj(a, b, c, d) {
  a = Bg(22, a, d, b);
  a.elementType = Ia;
  a.lanes = c;
  a.stateNode = { isHidden: false };
  return a;
}
function Qg(a, b, c) {
  a = Bg(6, a, null, b);
  a.lanes = c;
  return a;
}
function Sg(a, b, c) {
  b = Bg(4, null !== a.children ? a.children : [], a.key, b);
  b.lanes = c;
  b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b;
}
function al(a, b, c, d, e) {
  this.tag = b;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d;
  this.onRecoverableError = e;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a, b, c, d, e, f2, g, h, k2) {
  a = new al(a, b, c, h, k2);
  1 === b ? (b = 1, true === f2 && (b |= 8)) : b = 0;
  f2 = Bg(3, null, null, b);
  a.current = f2;
  f2.stateNode = a;
  f2.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f2);
  return a;
}
function cl(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
}
function dl(a) {
  if (!a) return Vf;
  a = a._reactInternals;
  a: {
    if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
    var b = a;
    do {
      switch (b.tag) {
        case 3:
          b = b.stateNode.context;
          break a;
        case 1:
          if (Zf(b.type)) {
            b = b.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b = b.return;
    } while (null !== b);
    throw Error(p(171));
  }
  if (1 === a.tag) {
    var c = a.type;
    if (Zf(c)) return bg(a, c, b);
  }
  return b;
}
function el(a, b, c, d, e, f2, g, h, k2) {
  a = bl(c, d, true, a, e, f2, g, h, k2);
  a.context = dl(null);
  c = a.current;
  d = R();
  e = yi(c);
  f2 = mh(d, e);
  f2.callback = void 0 !== b && null !== b ? b : null;
  nh(c, f2, e);
  a.current.lanes = e;
  Ac(a, e, d);
  Dk(a, d);
  return a;
}
function fl(a, b, c, d) {
  var e = b.current, f2 = R(), g = yi(e);
  c = dl(c);
  null === b.context ? b.context = c : b.pendingContext = c;
  b = mh(f2, g);
  b.payload = { element: a };
  d = void 0 === d ? null : d;
  null !== d && (b.callback = d);
  a = nh(e, b, g);
  null !== a && (gi(a, e, g, f2), oh(a, e, g));
  return g;
}
function gl(a) {
  a = a.current;
  if (!a.child) return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function hl(a, b) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c = a.retryLane;
    a.retryLane = 0 !== c && c < b ? c : b;
  }
}
function il(a, b) {
  hl(a, b);
  (a = a.alternate) && hl(a, b);
}
function jl() {
  return null;
}
var kl = "function" === typeof reportError ? reportError : function(a) {
  console.error(a);
};
function ll(a) {
  this._internalRoot = a;
}
ml.prototype.render = ll.prototype.render = function(a) {
  var b = this._internalRoot;
  if (null === b) throw Error(p(409));
  fl(a, b, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b = a.containerInfo;
    Rk(function() {
      fl(null, a, null, null);
    });
    b[uf] = null;
  }
};
function ml(a) {
  this._internalRoot = a;
}
ml.prototype.unstable_scheduleHydration = function(a) {
  if (a) {
    var b = Hc();
    a = { blockedOn: null, target: a, priority: b };
    for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
    Qc.splice(c, 0, a);
    0 === c && Vc(a);
  }
};
function nl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function pl() {
}
function ql(a, b, c, d, e) {
  if (e) {
    if ("function" === typeof d) {
      var f2 = d;
      d = function() {
        var a2 = gl(g);
        f2.call(a2);
      };
    }
    var g = el(b, d, a, 0, null, false, false, "", pl);
    a._reactRootContainer = g;
    a[uf] = g.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk();
    return g;
  }
  for (; e = a.lastChild; ) a.removeChild(e);
  if ("function" === typeof d) {
    var h = d;
    d = function() {
      var a2 = gl(k2);
      h.call(a2);
    };
  }
  var k2 = bl(a, 0, false, null, null, false, false, "", pl);
  a._reactRootContainer = k2;
  a[uf] = k2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Rk(function() {
    fl(b, k2, c, d);
  });
  return k2;
}
function rl(a, b, c, d, e) {
  var f2 = c._reactRootContainer;
  if (f2) {
    var g = f2;
    if ("function" === typeof e) {
      var h = e;
      e = function() {
        var a2 = gl(g);
        h.call(a2);
      };
    }
    fl(b, g, a, e);
  } else g = ql(c, b, a, e, d);
  return gl(g);
}
Ec = function(a) {
  switch (a.tag) {
    case 3:
      var b = a.stateNode;
      if (b.current.memoizedState.isDehydrated) {
        var c = tc(b.pendingLanes);
        0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b2 = ih(a, 1);
        if (null !== b2) {
          var c2 = R();
          gi(b2, a, 1, c2);
        }
      }), il(a, 1);
  }
};
Fc = function(a) {
  if (13 === a.tag) {
    var b = ih(a, 134217728);
    if (null !== b) {
      var c = R();
      gi(b, a, 134217728, c);
    }
    il(a, 134217728);
  }
};
Gc = function(a) {
  if (13 === a.tag) {
    var b = yi(a), c = ih(a, b);
    if (null !== c) {
      var d = R();
      gi(c, a, b, d);
    }
    il(a, b);
  }
};
Hc = function() {
  return C;
};
Ic = function(a, b) {
  var c = C;
  try {
    return C = a, b();
  } finally {
    C = c;
  }
};
yb = function(a, b, c) {
  switch (b) {
    case "input":
      bb(a, c);
      b = c.name;
      if ("radio" === c.type && null != b) {
        for (c = a; c.parentNode; ) c = c.parentNode;
        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
        for (b = 0; b < c.length; b++) {
          var d = c[b];
          if (d !== a && d.form === a.form) {
            var e = Db(d);
            if (!e) throw Error(p(90));
            Wa(d);
            bb(d, e);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c);
      break;
    case "select":
      b = c.value, null != b && fb(a, !!c.multiple, b, false);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = Zb(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber) try {
    kc = vl.inject(ul), lc = vl;
  } catch (a) {
  }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b)) throw Error(p(200));
  return cl(a, b, null, c);
};
reactDom_production_min.createRoot = function(a, b) {
  if (!nl(a)) throw Error(p(299));
  var c = false, d = "", e = kl;
  null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
  b = bl(a, 1, false, null, null, c, false, d, e);
  a[uf] = b.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ll(b);
};
reactDom_production_min.findDOMNode = function(a) {
  if (null == a) return null;
  if (1 === a.nodeType) return a;
  var b = a._reactInternals;
  if (void 0 === b) {
    if ("function" === typeof a.render) throw Error(p(188));
    a = Object.keys(a).join(",");
    throw Error(p(268, a));
  }
  a = Zb(b);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a) {
  return Rk(a);
};
reactDom_production_min.hydrate = function(a, b, c) {
  if (!ol(b)) throw Error(p(200));
  return rl(null, a, b, true, c);
};
reactDom_production_min.hydrateRoot = function(a, b, c) {
  if (!nl(a)) throw Error(p(405));
  var d = null != c && c.hydratedSources || null, e = false, f2 = "", g = kl;
  null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f2 = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
  b = el(b, null, a, 1, null != c ? c : null, e, false, f2, g);
  a[uf] = b.current;
  sf(a);
  if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
    c,
    e
  );
  return new ml(b);
};
reactDom_production_min.render = function(a, b, c) {
  if (!ol(b)) throw Error(p(200));
  return rl(null, a, b, false, c);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!ol(a)) throw Error(p(40));
  return a._reactRootContainer ? (Rk(function() {
    rl(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
  if (!ol(c)) throw Error(p(200));
  if (null == a || void 0 === a._reactInternals) throw Error(p(38));
  return rl(a, b, c, false, d);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
var m = reactDomExports;
{
  client.createRoot = m.createRoot;
  client.hydrateRoot = m.hydrateRoot;
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e = new Event("vite:preloadError", {
      cancelable: true
    });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
const isDev$1 = typeof process !== "undefined" ? false : typeof window !== "undefined" && ((_a = window.location) == null ? void 0 : _a.hostname) === "localhost";
const SENSITIVE_PATTERNS = [
  /privateKey/i,
  /private_key/i,
  /secretKey/i,
  /secret_key/i,
  /mnemonic/i,
  /seed/i,
  /password/i,
  /token(?!s?\b)/i,
  // 'token' but not 'tokens'
  /apiKey/i,
  /api_key/i,
  /auth/i,
  /credential/i,
  /signature/i
];
const REDACTED_KEYS = /* @__PURE__ */ new Set([
  "privateKey",
  "private_key",
  "secretKey",
  "secret_key",
  "mnemonic",
  "seed",
  "password",
  "apiKey",
  "api_key",
  "auth",
  "authorization",
  "credentials",
  "secret"
]);
function sanitizeValue(value, key = "") {
  if (value === null || value === void 0) {
    return value;
  }
  if (value instanceof Error) {
    return {
      message: value.message,
      name: value.name,
      stack: value.stack
    };
  }
  const keyLower = key.toLowerCase();
  if (REDACTED_KEYS.has(keyLower) || SENSITIVE_PATTERNS.some((p2) => p2.test(key))) {
    return "[REDACTED]";
  }
  if (typeof value === "string") {
    if (/^[0-9a-fA-F]{64,}$/.test(value) || /^[1-9A-HJ-NP-Za-km-z]{87,}$/.test(value)) {
      return "[REDACTED_KEY]";
    }
    const words = value.split(/\s+/);
    if (words.length >= 12 && words.length <= 24) {
      const looksLikeMnemonic = words.every((w2) => /^[a-z]+$/.test(w2));
      if (looksLikeMnemonic) {
        return "[REDACTED_MNEMONIC]";
      }
    }
    return value;
  }
  if (Array.isArray(value)) {
    return value.map((item, index) => sanitizeValue(item, String(index)));
  }
  if (typeof value === "object") {
    const sanitized = {};
    for (const [k2, v2] of Object.entries(value)) {
      sanitized[k2] = sanitizeValue(v2, k2);
    }
    return sanitized;
  }
  return value;
}
function sanitizeArgs(args) {
  return args.map((arg, index) => {
    if (typeof arg === "string") {
      return sanitizeValue(arg);
    }
    return sanitizeValue(arg, String(index));
  });
}
const logger$1 = {
  log(...args) {
    if (isDev$1) {
      console.log(...sanitizeArgs(args));
    }
  },
  warn(...args) {
    if (isDev$1) {
      console.warn(...sanitizeArgs(args));
    }
  },
  error(...args) {
    console.error(...sanitizeArgs(args));
  },
  debug(...args) {
    if (isDev$1) {
      console.debug(...sanitizeArgs(args));
    }
  },
  info(...args) {
    if (isDev$1) {
      console.info(...sanitizeArgs(args));
    }
  },
  // Force log even in production (use sparingly)
  force(...args) {
    console.log(...sanitizeArgs(args));
  }
};
const WORDLIST = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
function getRandomBytes(length) {
  const bytes = new Uint8Array(length);
  crypto.getRandomValues(bytes);
  return bytes;
}
async function sha256(data) {
  const buffer2 = await crypto.subtle.digest("SHA-256", data);
  return new Uint8Array(buffer2);
}
function bytesToBinary(bytes) {
  return Array.from(bytes).map((b) => b.toString(2).padStart(8, "0")).join("");
}
async function entropyToMnemonic(entropy) {
  const hash = await sha256(entropy);
  const checksumBits = entropy.length / 4;
  const entropyBits = bytesToBinary(entropy);
  const hashBits = bytesToBinary(hash);
  const checksum = hashBits.slice(0, checksumBits);
  const allBits = entropyBits + checksum;
  const words = [];
  for (let i = 0; i < allBits.length; i += 11) {
    const index = parseInt(allBits.slice(i, i + 11), 2);
    words.push(WORDLIST[index]);
  }
  return words.join(" ");
}
async function generateMnemonic(strength = 128) {
  const entropy = getRandomBytes(strength / 8);
  return entropyToMnemonic(entropy);
}
async function validateMnemonic(mnemonic) {
  if (!mnemonic || typeof mnemonic !== "string") return false;
  const words = mnemonic.trim().toLowerCase().split(/\s+/);
  if (words.length !== 12 && words.length !== 24) return false;
  const indices = [];
  for (const word of words) {
    const index = WORDLIST.indexOf(word);
    if (index === -1) return false;
    indices.push(index);
  }
  let bits = "";
  for (const index of indices) {
    bits += index.toString(2).padStart(11, "0");
  }
  const entropyBits = bits.slice(0, -words.length / 3);
  const checksumBits = bits.slice(-words.length / 3);
  const entropyBytes = new Uint8Array(entropyBits.length / 8);
  for (let i = 0; i < entropyBytes.length; i++) {
    entropyBytes[i] = parseInt(entropyBits.slice(i * 8, (i + 1) * 8), 2);
  }
  const hash = await sha256(entropyBytes);
  const hashBits = bytesToBinary(hash);
  const expectedChecksum = hashBits.slice(0, words.length / 3);
  return checksumBits === expectedChecksum;
}
const ED25519_CURVE = "ed25519 seed";
const HARDENED_OFFSET = 2147483648;
async function hmacSha512(key, data) {
  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    key,
    { name: "HMAC", hash: "SHA-512" },
    false,
    ["sign"]
  );
  const signature = await crypto.subtle.sign("HMAC", cryptoKey, data);
  return new Uint8Array(signature);
}
function stringToBytes(str) {
  return new TextEncoder().encode(str);
}
function numberToBytes(num) {
  const arr = new Uint8Array(4);
  arr[0] = num >>> 24 & 255;
  arr[1] = num >>> 16 & 255;
  arr[2] = num >>> 8 & 255;
  arr[3] = num & 255;
  return arr;
}
function concat(...arrays) {
  const totalLength = arrays.reduce((acc, arr) => acc + arr.length, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const arr of arrays) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
async function mnemonicToSeed(mnemonic, passphrase = "") {
  const mnemonicBytes = stringToBytes(mnemonic.normalize("NFKD"));
  const saltBytes = stringToBytes("mnemonic" + passphrase.normalize("NFKD"));
  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    mnemonicBytes,
    "PBKDF2",
    false,
    ["deriveBits"]
  );
  const derivedBits = await crypto.subtle.deriveBits(
    {
      name: "PBKDF2",
      salt: saltBytes,
      iterations: 2048,
      hash: "SHA-512"
    },
    keyMaterial,
    512
  );
  return new Uint8Array(derivedBits);
}
async function getMasterKeyFromSeed(seed) {
  const I2 = await hmacSha512(stringToBytes(ED25519_CURVE), seed);
  const IL = I2.slice(0, 32);
  const IR = I2.slice(32);
  return { key: IL, chainCode: IR };
}
async function deriveHardened(parentKey, parentChainCode, index) {
  const indexBuffer = numberToBytes(HARDENED_OFFSET + index);
  const data = concat(new Uint8Array([0]), parentKey, indexBuffer);
  const I2 = await hmacSha512(parentChainCode, data);
  const IL = I2.slice(0, 32);
  const IR = I2.slice(32);
  return { key: IL, chainCode: IR };
}
function parsePath(path) {
  const parts = path.split("/");
  const result = [];
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    if (part === "m" || part === "") continue;
    const isHardened = part.endsWith("'") || part.endsWith("h");
    const index = parseInt(isHardened ? part.slice(0, -1) : part, 10);
    if (isNaN(index)) {
      throw new Error(`Invalid path component: ${part}`);
    }
    result.push({ index, hardened: isHardened });
  }
  return result;
}
async function derivePath(path, seed) {
  const { key, chainCode } = await getMasterKeyFromSeed(seed);
  const segments = parsePath(path);
  let currentKey = key;
  let currentChainCode = chainCode;
  for (const segment of segments) {
    if (!segment.hardened) {
      throw new Error("Ed25519 only supports hardened derivation");
    }
    const result = await deriveHardened(currentKey, currentChainCode, segment.index);
    currentKey = result.key;
    currentChainCode = result.chainCode;
  }
  return currentKey;
}
const gf$1 = (init) => {
  const r2 = new Float64Array(16);
  if (init) for (let i = 0; i < init.length; i++) r2[i] = init[i];
  return r2;
};
const gf0$1 = gf$1();
const gf1$1 = gf$1([1]);
gf$1([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]);
const D2$1 = gf$1([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]);
const X$1 = gf$1([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]);
const Y$1 = gf$1([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]);
function car25519$1(o) {
  let c;
  for (let i = 0; i < 16; i++) {
    o[i] += 65536;
    c = Math.floor(o[i] / 65536);
    o[(i + 1) * (i < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i === 15 ? 1 : 0);
    o[i] -= c * 65536;
  }
}
function sel25519$1(p2, q2, b) {
  let t2, c = ~(b - 1);
  for (let i = 0; i < 16; i++) {
    t2 = c & (p2[i] ^ q2[i]);
    p2[i] ^= t2;
    q2[i] ^= t2;
  }
}
function pack25519$1(o, n2) {
  let m2 = gf$1(), t2 = gf$1();
  for (let i = 0; i < 16; i++) t2[i] = n2[i];
  car25519$1(t2);
  car25519$1(t2);
  car25519$1(t2);
  for (let j = 0; j < 2; j++) {
    m2[0] = t2[0] - 65517;
    for (let i = 1; i < 15; i++) {
      m2[i] = t2[i] - 65535 - (m2[i - 1] >> 16 & 1);
      m2[i - 1] &= 65535;
    }
    m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
    let b = m2[15] >> 16 & 1;
    m2[14] &= 65535;
    sel25519$1(t2, m2, 1 - b);
  }
  for (let i = 0; i < 16; i++) {
    o[2 * i] = t2[i] & 255;
    o[2 * i + 1] = t2[i] >> 8;
  }
}
function par25519$1(a) {
  const d = new Uint8Array(32);
  pack25519$1(d, a);
  return d[0] & 1;
}
function A$1(o, a, b) {
  for (let i = 0; i < 16; i++) o[i] = a[i] + b[i];
}
function Z$1(o, a, b) {
  for (let i = 0; i < 16; i++) o[i] = a[i] - b[i];
}
function M$1(o, a, b) {
  let t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0;
  const b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  let v2 = a[0];
  t0 += v2 * b0;
  t1 += v2 * b1;
  t2 += v2 * b2;
  t3 += v2 * b3;
  t4 += v2 * b4;
  t5 += v2 * b5;
  t6 += v2 * b6;
  t7 += v2 * b7;
  t8 += v2 * b8;
  t9 += v2 * b9;
  t10 += v2 * b10;
  t11 += v2 * b11;
  t12 += v2 * b12;
  t13 += v2 * b13;
  t14 += v2 * b14;
  t15 += v2 * b15;
  v2 = a[1];
  t1 += v2 * b0;
  t2 += v2 * b1;
  t3 += v2 * b2;
  t4 += v2 * b3;
  t5 += v2 * b4;
  t6 += v2 * b5;
  t7 += v2 * b6;
  t8 += v2 * b7;
  t9 += v2 * b8;
  t10 += v2 * b9;
  t11 += v2 * b10;
  t12 += v2 * b11;
  t13 += v2 * b12;
  t14 += v2 * b13;
  t15 += v2 * b14;
  t16 += v2 * b15;
  v2 = a[2];
  t2 += v2 * b0;
  t3 += v2 * b1;
  t4 += v2 * b2;
  t5 += v2 * b3;
  t6 += v2 * b4;
  t7 += v2 * b5;
  t8 += v2 * b6;
  t9 += v2 * b7;
  t10 += v2 * b8;
  t11 += v2 * b9;
  t12 += v2 * b10;
  t13 += v2 * b11;
  t14 += v2 * b12;
  t15 += v2 * b13;
  t16 += v2 * b14;
  t17 += v2 * b15;
  v2 = a[3];
  t3 += v2 * b0;
  t4 += v2 * b1;
  t5 += v2 * b2;
  t6 += v2 * b3;
  t7 += v2 * b4;
  t8 += v2 * b5;
  t9 += v2 * b6;
  t10 += v2 * b7;
  t11 += v2 * b8;
  t12 += v2 * b9;
  t13 += v2 * b10;
  t14 += v2 * b11;
  t15 += v2 * b12;
  t16 += v2 * b13;
  t17 += v2 * b14;
  t18 += v2 * b15;
  v2 = a[4];
  t4 += v2 * b0;
  t5 += v2 * b1;
  t6 += v2 * b2;
  t7 += v2 * b3;
  t8 += v2 * b4;
  t9 += v2 * b5;
  t10 += v2 * b6;
  t11 += v2 * b7;
  t12 += v2 * b8;
  t13 += v2 * b9;
  t14 += v2 * b10;
  t15 += v2 * b11;
  t16 += v2 * b12;
  t17 += v2 * b13;
  t18 += v2 * b14;
  t19 += v2 * b15;
  v2 = a[5];
  t5 += v2 * b0;
  t6 += v2 * b1;
  t7 += v2 * b2;
  t8 += v2 * b3;
  t9 += v2 * b4;
  t10 += v2 * b5;
  t11 += v2 * b6;
  t12 += v2 * b7;
  t13 += v2 * b8;
  t14 += v2 * b9;
  t15 += v2 * b10;
  t16 += v2 * b11;
  t17 += v2 * b12;
  t18 += v2 * b13;
  t19 += v2 * b14;
  t20 += v2 * b15;
  v2 = a[6];
  t6 += v2 * b0;
  t7 += v2 * b1;
  t8 += v2 * b2;
  t9 += v2 * b3;
  t10 += v2 * b4;
  t11 += v2 * b5;
  t12 += v2 * b6;
  t13 += v2 * b7;
  t14 += v2 * b8;
  t15 += v2 * b9;
  t16 += v2 * b10;
  t17 += v2 * b11;
  t18 += v2 * b12;
  t19 += v2 * b13;
  t20 += v2 * b14;
  t21 += v2 * b15;
  v2 = a[7];
  t7 += v2 * b0;
  t8 += v2 * b1;
  t9 += v2 * b2;
  t10 += v2 * b3;
  t11 += v2 * b4;
  t12 += v2 * b5;
  t13 += v2 * b6;
  t14 += v2 * b7;
  t15 += v2 * b8;
  t16 += v2 * b9;
  t17 += v2 * b10;
  t18 += v2 * b11;
  t19 += v2 * b12;
  t20 += v2 * b13;
  t21 += v2 * b14;
  t22 += v2 * b15;
  v2 = a[8];
  t8 += v2 * b0;
  t9 += v2 * b1;
  t10 += v2 * b2;
  t11 += v2 * b3;
  t12 += v2 * b4;
  t13 += v2 * b5;
  t14 += v2 * b6;
  t15 += v2 * b7;
  t16 += v2 * b8;
  t17 += v2 * b9;
  t18 += v2 * b10;
  t19 += v2 * b11;
  t20 += v2 * b12;
  t21 += v2 * b13;
  t22 += v2 * b14;
  t23 += v2 * b15;
  v2 = a[9];
  t9 += v2 * b0;
  t10 += v2 * b1;
  t11 += v2 * b2;
  t12 += v2 * b3;
  t13 += v2 * b4;
  t14 += v2 * b5;
  t15 += v2 * b6;
  t16 += v2 * b7;
  t17 += v2 * b8;
  t18 += v2 * b9;
  t19 += v2 * b10;
  t20 += v2 * b11;
  t21 += v2 * b12;
  t22 += v2 * b13;
  t23 += v2 * b14;
  t24 += v2 * b15;
  v2 = a[10];
  t10 += v2 * b0;
  t11 += v2 * b1;
  t12 += v2 * b2;
  t13 += v2 * b3;
  t14 += v2 * b4;
  t15 += v2 * b5;
  t16 += v2 * b6;
  t17 += v2 * b7;
  t18 += v2 * b8;
  t19 += v2 * b9;
  t20 += v2 * b10;
  t21 += v2 * b11;
  t22 += v2 * b12;
  t23 += v2 * b13;
  t24 += v2 * b14;
  t25 += v2 * b15;
  v2 = a[11];
  t11 += v2 * b0;
  t12 += v2 * b1;
  t13 += v2 * b2;
  t14 += v2 * b3;
  t15 += v2 * b4;
  t16 += v2 * b5;
  t17 += v2 * b6;
  t18 += v2 * b7;
  t19 += v2 * b8;
  t20 += v2 * b9;
  t21 += v2 * b10;
  t22 += v2 * b11;
  t23 += v2 * b12;
  t24 += v2 * b13;
  t25 += v2 * b14;
  t26 += v2 * b15;
  v2 = a[12];
  t12 += v2 * b0;
  t13 += v2 * b1;
  t14 += v2 * b2;
  t15 += v2 * b3;
  t16 += v2 * b4;
  t17 += v2 * b5;
  t18 += v2 * b6;
  t19 += v2 * b7;
  t20 += v2 * b8;
  t21 += v2 * b9;
  t22 += v2 * b10;
  t23 += v2 * b11;
  t24 += v2 * b12;
  t25 += v2 * b13;
  t26 += v2 * b14;
  t27 += v2 * b15;
  v2 = a[13];
  t13 += v2 * b0;
  t14 += v2 * b1;
  t15 += v2 * b2;
  t16 += v2 * b3;
  t17 += v2 * b4;
  t18 += v2 * b5;
  t19 += v2 * b6;
  t20 += v2 * b7;
  t21 += v2 * b8;
  t22 += v2 * b9;
  t23 += v2 * b10;
  t24 += v2 * b11;
  t25 += v2 * b12;
  t26 += v2 * b13;
  t27 += v2 * b14;
  t28 += v2 * b15;
  v2 = a[14];
  t14 += v2 * b0;
  t15 += v2 * b1;
  t16 += v2 * b2;
  t17 += v2 * b3;
  t18 += v2 * b4;
  t19 += v2 * b5;
  t20 += v2 * b6;
  t21 += v2 * b7;
  t22 += v2 * b8;
  t23 += v2 * b9;
  t24 += v2 * b10;
  t25 += v2 * b11;
  t26 += v2 * b12;
  t27 += v2 * b13;
  t28 += v2 * b14;
  t29 += v2 * b15;
  v2 = a[15];
  t15 += v2 * b0;
  t16 += v2 * b1;
  t17 += v2 * b2;
  t18 += v2 * b3;
  t19 += v2 * b4;
  t20 += v2 * b5;
  t21 += v2 * b6;
  t22 += v2 * b7;
  t23 += v2 * b8;
  t24 += v2 * b9;
  t25 += v2 * b10;
  t26 += v2 * b11;
  t27 += v2 * b12;
  t28 += v2 * b13;
  t29 += v2 * b14;
  t30 += v2 * b15;
  t0 += 38 * t16;
  t1 += 38 * t17;
  t2 += 38 * t18;
  t3 += 38 * t19;
  t4 += 38 * t20;
  t5 += 38 * t21;
  t6 += 38 * t22;
  t7 += 38 * t23;
  t8 += 38 * t24;
  t9 += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  let c = 1;
  v2 = t0 + c + 65535;
  c = Math.floor(v2 / 65536);
  t0 = v2 - c * 65536;
  v2 = t1 + c + 65535;
  c = Math.floor(v2 / 65536);
  t1 = v2 - c * 65536;
  v2 = t2 + c + 65535;
  c = Math.floor(v2 / 65536);
  t2 = v2 - c * 65536;
  v2 = t3 + c + 65535;
  c = Math.floor(v2 / 65536);
  t3 = v2 - c * 65536;
  v2 = t4 + c + 65535;
  c = Math.floor(v2 / 65536);
  t4 = v2 - c * 65536;
  v2 = t5 + c + 65535;
  c = Math.floor(v2 / 65536);
  t5 = v2 - c * 65536;
  v2 = t6 + c + 65535;
  c = Math.floor(v2 / 65536);
  t6 = v2 - c * 65536;
  v2 = t7 + c + 65535;
  c = Math.floor(v2 / 65536);
  t7 = v2 - c * 65536;
  v2 = t8 + c + 65535;
  c = Math.floor(v2 / 65536);
  t8 = v2 - c * 65536;
  v2 = t9 + c + 65535;
  c = Math.floor(v2 / 65536);
  t9 = v2 - c * 65536;
  v2 = t10 + c + 65535;
  c = Math.floor(v2 / 65536);
  t10 = v2 - c * 65536;
  v2 = t11 + c + 65535;
  c = Math.floor(v2 / 65536);
  t11 = v2 - c * 65536;
  v2 = t12 + c + 65535;
  c = Math.floor(v2 / 65536);
  t12 = v2 - c * 65536;
  v2 = t13 + c + 65535;
  c = Math.floor(v2 / 65536);
  t13 = v2 - c * 65536;
  v2 = t14 + c + 65535;
  c = Math.floor(v2 / 65536);
  t14 = v2 - c * 65536;
  v2 = t15 + c + 65535;
  c = Math.floor(v2 / 65536);
  t15 = v2 - c * 65536;
  t0 += c - 1 + 37 * (c - 1);
  c = 1;
  v2 = t0 + c + 65535;
  c = Math.floor(v2 / 65536);
  t0 = v2 - c * 65536;
  v2 = t1 + c + 65535;
  c = Math.floor(v2 / 65536);
  t1 = v2 - c * 65536;
  v2 = t2 + c + 65535;
  c = Math.floor(v2 / 65536);
  t2 = v2 - c * 65536;
  v2 = t3 + c + 65535;
  c = Math.floor(v2 / 65536);
  t3 = v2 - c * 65536;
  v2 = t4 + c + 65535;
  c = Math.floor(v2 / 65536);
  t4 = v2 - c * 65536;
  v2 = t5 + c + 65535;
  c = Math.floor(v2 / 65536);
  t5 = v2 - c * 65536;
  v2 = t6 + c + 65535;
  c = Math.floor(v2 / 65536);
  t6 = v2 - c * 65536;
  v2 = t7 + c + 65535;
  c = Math.floor(v2 / 65536);
  t7 = v2 - c * 65536;
  v2 = t8 + c + 65535;
  c = Math.floor(v2 / 65536);
  t8 = v2 - c * 65536;
  v2 = t9 + c + 65535;
  c = Math.floor(v2 / 65536);
  t9 = v2 - c * 65536;
  v2 = t10 + c + 65535;
  c = Math.floor(v2 / 65536);
  t10 = v2 - c * 65536;
  v2 = t11 + c + 65535;
  c = Math.floor(v2 / 65536);
  t11 = v2 - c * 65536;
  v2 = t12 + c + 65535;
  c = Math.floor(v2 / 65536);
  t12 = v2 - c * 65536;
  v2 = t13 + c + 65535;
  c = Math.floor(v2 / 65536);
  t13 = v2 - c * 65536;
  v2 = t14 + c + 65535;
  c = Math.floor(v2 / 65536);
  t14 = v2 - c * 65536;
  v2 = t15 + c + 65535;
  c = Math.floor(v2 / 65536);
  t15 = v2 - c * 65536;
  t0 += c - 1 + 37 * (c - 1);
  o[0] = t0;
  o[1] = t1;
  o[2] = t2;
  o[3] = t3;
  o[4] = t4;
  o[5] = t5;
  o[6] = t6;
  o[7] = t7;
  o[8] = t8;
  o[9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}
function S$1(o, a) {
  M$1(o, a, a);
}
function inv25519$1(o, i) {
  const c = gf$1();
  for (let a = 0; a < 16; a++) c[a] = i[a];
  for (let a = 253; a >= 0; a--) {
    S$1(c, c);
    if (a !== 2 && a !== 4) M$1(c, c, i);
  }
  for (let a = 0; a < 16; a++) o[a] = c[a];
}
function set25519$1(r2, a) {
  for (let i = 0; i < 16; i++) r2[i] = a[i] | 0;
}
function scalarmult$1(p2, q2, s) {
  set25519$1(p2[0], gf0$1);
  set25519$1(p2[1], gf1$1);
  set25519$1(p2[2], gf1$1);
  set25519$1(p2[3], gf0$1);
  for (let i = 255; i >= 0; --i) {
    const b = s[i / 8 | 0] >> (i & 7) & 1;
    cswap$1(p2, q2, b);
    add$1(q2, p2);
    add$1(p2, p2);
    cswap$1(p2, q2, b);
  }
}
function scalarbase$1(p2, s) {
  const q2 = [gf$1(), gf$1(), gf$1(), gf$1()];
  set25519$1(q2[0], X$1);
  set25519$1(q2[1], Y$1);
  set25519$1(q2[2], gf1$1);
  M$1(q2[3], X$1, Y$1);
  scalarmult$1(p2, q2, s);
}
function cswap$1(p2, q2, b) {
  for (let i = 0; i < 4; i++) sel25519$1(p2[i], q2[i], b);
}
function add$1(p2, q2) {
  const a = gf$1(), b = gf$1(), c = gf$1(), d = gf$1(), e = gf$1(), f2 = gf$1(), g = gf$1(), h = gf$1(), t2 = gf$1();
  Z$1(a, p2[1], p2[0]);
  Z$1(t2, q2[1], q2[0]);
  M$1(a, a, t2);
  A$1(b, p2[0], p2[1]);
  A$1(t2, q2[0], q2[1]);
  M$1(b, b, t2);
  M$1(c, p2[3], q2[3]);
  M$1(c, c, D2$1);
  M$1(d, p2[2], q2[2]);
  A$1(d, d, d);
  Z$1(e, b, a);
  Z$1(f2, d, c);
  A$1(g, d, c);
  A$1(h, b, a);
  M$1(p2[0], e, f2);
  M$1(p2[1], h, g);
  M$1(p2[2], g, f2);
  M$1(p2[3], e, h);
}
function pack$1(r2, p2) {
  const tx = gf$1(), ty = gf$1(), zi2 = gf$1();
  inv25519$1(zi2, p2[2]);
  M$1(tx, p2[0], zi2);
  M$1(ty, p2[1], zi2);
  pack25519$1(r2, ty);
  r2[31] ^= par25519$1(tx) << 7;
}
async function getPublicKey(privateKey) {
  const d = new Uint8Array(await crypto.subtle.digest("SHA-512", privateKey));
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;
  const p2 = [gf$1(), gf$1(), gf$1(), gf$1()];
  const pk2 = new Uint8Array(32);
  scalarbase$1(p2, d);
  pack$1(pk2, p2);
  return pk2;
}
async function mnemonicToKeypair(mnemonic, pathOrIndex = 0) {
  let path;
  if (typeof pathOrIndex === "number") {
    path = `m/44'/501'/${pathOrIndex}'/0'`;
  } else if (typeof pathOrIndex === "string") {
    path = pathOrIndex;
  } else {
    path = "m/44'/501'/0'/0'";
  }
  const seed = await mnemonicToSeed(mnemonic);
  const privateKey = await derivePath(path, seed);
  const publicKey = await getPublicKey(privateKey);
  const secretKey = new Uint8Array(64);
  secretKey.set(privateKey);
  secretKey.set(publicKey, 32);
  return { publicKey, secretKey };
}
async function sign$1(message, secretKey) {
  const privateKey = secretKey.slice(0, 32);
  const publicKey = secretKey.slice(32);
  const d = new Uint8Array(await crypto.subtle.digest("SHA-512", privateKey));
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;
  const sm = new Uint8Array(64 + message.length);
  sm.set(message, 64);
  const tmp = new Uint8Array(64 + message.length);
  tmp.set(d.subarray(32), 0);
  tmp.set(message, 32);
  const r2 = new Uint8Array(await crypto.subtle.digest("SHA-512", tmp.subarray(0, 32 + message.length)));
  const x2 = new Float64Array(64);
  for (let i = 0; i < 64; i++) x2[i] = r2[i];
  for (let i = 0; i < 64; i++) r2[i] = 0;
  const L2 = [
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ];
  let carry;
  for (let i = 63; i >= 32; --i) {
    carry = 0;
    for (let j = i - 32, k2 = i - 12; j < k2; ++j) {
      x2[j] += carry - 16 * x2[i] * L2[j - (i - 32)];
      carry = Math.floor((x2[j] + 128) / 256);
      x2[j] -= carry * 256;
    }
    x2[i - 32 + (i - 12 - (i - 32))] += carry;
    x2[i] = 0;
  }
  carry = 0;
  for (let j = 0; j < 32; j++) {
    x2[j] += carry - (x2[31] >> 4) * L2[j];
    carry = x2[j] >> 8;
    x2[j] &= 255;
  }
  for (let j = 0; j < 32; j++) x2[j] -= carry * L2[j];
  for (let i = 0; i < 32; i++) {
    x2[i + 1] += x2[i] >> 8;
    r2[i] = x2[i] & 255;
  }
  const p2 = [gf$1(), gf$1(), gf$1(), gf$1()];
  scalarbase$1(p2, r2);
  pack$1(sm, p2);
  sm.set(publicKey, 32);
  const h = new Uint8Array(await crypto.subtle.digest("SHA-512", sm));
  for (let i = 0; i < 64; i++) x2[i] = h[i];
  for (let i = 0; i < 64; i++) h[i] = 0;
  for (let i = 63; i >= 32; --i) {
    carry = 0;
    for (let j = i - 32, k2 = i - 12; j < k2; ++j) {
      x2[j] += carry - 16 * x2[i] * L2[j - (i - 32)];
      carry = Math.floor((x2[j] + 128) / 256);
      x2[j] -= carry * 256;
    }
    x2[i - 32 + (i - 12 - (i - 32))] += carry;
    x2[i] = 0;
  }
  carry = 0;
  for (let j = 0; j < 32; j++) {
    x2[j] += carry - (x2[31] >> 4) * L2[j];
    carry = x2[j] >> 8;
    x2[j] &= 255;
  }
  for (let j = 0; j < 32; j++) x2[j] -= carry * L2[j];
  for (let i = 0; i < 32; i++) {
    x2[i + 1] += x2[i] >> 8;
    h[i] = x2[i] & 255;
  }
  for (let i = 0; i < 32; i++) x2[i] = r2[i];
  for (let i = 0; i < 32; i++) {
    for (let j = 0; j < 32; j++) {
      x2[i + j] += h[i] * d[j];
    }
  }
  for (let i = 63; i >= 32; --i) {
    carry = 0;
    for (let j = i - 32, k2 = i - 12; j < k2; ++j) {
      x2[j] += carry - 16 * x2[i] * L2[j - (i - 32)];
      carry = Math.floor((x2[j] + 128) / 256);
      x2[j] -= carry * 256;
    }
    x2[i - 32 + (i - 12 - (i - 32))] += carry;
    x2[i] = 0;
  }
  carry = 0;
  for (let j = 0; j < 32; j++) {
    x2[j] += carry - (x2[31] >> 4) * L2[j];
    carry = x2[j] >> 8;
    x2[j] &= 255;
  }
  for (let j = 0; j < 32; j++) x2[j] -= carry * L2[j];
  for (let i = 0; i < 32; i++) {
    x2[i + 1] += x2[i] >> 8;
    sm[32 + i] = x2[i] & 255;
  }
  return sm.subarray(0, 64);
}
const bip44 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  derivePath,
  mnemonicToKeypair,
  mnemonicToSeed,
  sign: sign$1
}, Symbol.toStringTag, { value: "Module" }));
const gf = (init) => {
  const r2 = new Float64Array(16);
  if (init) for (let i = 0; i < init.length; i++) r2[i] = init[i];
  return r2;
};
const gf0 = gf();
const gf1 = gf([1]);
gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]);
const D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]);
const X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]);
const Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]);
function car25519(o) {
  let c;
  for (let i = 0; i < 16; i++) {
    o[i] += 65536;
    c = Math.floor(o[i] / 65536);
    o[(i + 1) * (i < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i === 15 ? 1 : 0);
    o[i] -= c * 65536;
  }
}
function sel25519(p2, q2, b) {
  let t2, c = ~(b - 1);
  for (let i = 0; i < 16; i++) {
    t2 = c & (p2[i] ^ q2[i]);
    p2[i] ^= t2;
    q2[i] ^= t2;
  }
}
function pack25519(o, n2) {
  let m2 = gf(), t2 = gf();
  for (let i = 0; i < 16; i++) t2[i] = n2[i];
  car25519(t2);
  car25519(t2);
  car25519(t2);
  for (let j = 0; j < 2; j++) {
    m2[0] = t2[0] - 65517;
    for (let i = 1; i < 15; i++) {
      m2[i] = t2[i] - 65535 - (m2[i - 1] >> 16 & 1);
      m2[i - 1] &= 65535;
    }
    m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
    let b = m2[15] >> 16 & 1;
    m2[14] &= 65535;
    sel25519(t2, m2, 1 - b);
  }
  for (let i = 0; i < 16; i++) {
    o[2 * i] = t2[i] & 255;
    o[2 * i + 1] = t2[i] >> 8;
  }
}
function par25519(a) {
  const d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}
function A(o, a, b) {
  for (let i = 0; i < 16; i++) o[i] = a[i] + b[i];
}
function Z(o, a, b) {
  for (let i = 0; i < 16; i++) o[i] = a[i] - b[i];
}
function M(o, a, b) {
  let t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0;
  const b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  let v2 = a[0];
  t0 += v2 * b0;
  t1 += v2 * b1;
  t2 += v2 * b2;
  t3 += v2 * b3;
  t4 += v2 * b4;
  t5 += v2 * b5;
  t6 += v2 * b6;
  t7 += v2 * b7;
  t8 += v2 * b8;
  t9 += v2 * b9;
  t10 += v2 * b10;
  t11 += v2 * b11;
  t12 += v2 * b12;
  t13 += v2 * b13;
  t14 += v2 * b14;
  t15 += v2 * b15;
  v2 = a[1];
  t1 += v2 * b0;
  t2 += v2 * b1;
  t3 += v2 * b2;
  t4 += v2 * b3;
  t5 += v2 * b4;
  t6 += v2 * b5;
  t7 += v2 * b6;
  t8 += v2 * b7;
  t9 += v2 * b8;
  t10 += v2 * b9;
  t11 += v2 * b10;
  t12 += v2 * b11;
  t13 += v2 * b12;
  t14 += v2 * b13;
  t15 += v2 * b14;
  t16 += v2 * b15;
  v2 = a[2];
  t2 += v2 * b0;
  t3 += v2 * b1;
  t4 += v2 * b2;
  t5 += v2 * b3;
  t6 += v2 * b4;
  t7 += v2 * b5;
  t8 += v2 * b6;
  t9 += v2 * b7;
  t10 += v2 * b8;
  t11 += v2 * b9;
  t12 += v2 * b10;
  t13 += v2 * b11;
  t14 += v2 * b12;
  t15 += v2 * b13;
  t16 += v2 * b14;
  t17 += v2 * b15;
  v2 = a[3];
  t3 += v2 * b0;
  t4 += v2 * b1;
  t5 += v2 * b2;
  t6 += v2 * b3;
  t7 += v2 * b4;
  t8 += v2 * b5;
  t9 += v2 * b6;
  t10 += v2 * b7;
  t11 += v2 * b8;
  t12 += v2 * b9;
  t13 += v2 * b10;
  t14 += v2 * b11;
  t15 += v2 * b12;
  t16 += v2 * b13;
  t17 += v2 * b14;
  t18 += v2 * b15;
  v2 = a[4];
  t4 += v2 * b0;
  t5 += v2 * b1;
  t6 += v2 * b2;
  t7 += v2 * b3;
  t8 += v2 * b4;
  t9 += v2 * b5;
  t10 += v2 * b6;
  t11 += v2 * b7;
  t12 += v2 * b8;
  t13 += v2 * b9;
  t14 += v2 * b10;
  t15 += v2 * b11;
  t16 += v2 * b12;
  t17 += v2 * b13;
  t18 += v2 * b14;
  t19 += v2 * b15;
  v2 = a[5];
  t5 += v2 * b0;
  t6 += v2 * b1;
  t7 += v2 * b2;
  t8 += v2 * b3;
  t9 += v2 * b4;
  t10 += v2 * b5;
  t11 += v2 * b6;
  t12 += v2 * b7;
  t13 += v2 * b8;
  t14 += v2 * b9;
  t15 += v2 * b10;
  t16 += v2 * b11;
  t17 += v2 * b12;
  t18 += v2 * b13;
  t19 += v2 * b14;
  t20 += v2 * b15;
  v2 = a[6];
  t6 += v2 * b0;
  t7 += v2 * b1;
  t8 += v2 * b2;
  t9 += v2 * b3;
  t10 += v2 * b4;
  t11 += v2 * b5;
  t12 += v2 * b6;
  t13 += v2 * b7;
  t14 += v2 * b8;
  t15 += v2 * b9;
  t16 += v2 * b10;
  t17 += v2 * b11;
  t18 += v2 * b12;
  t19 += v2 * b13;
  t20 += v2 * b14;
  t21 += v2 * b15;
  v2 = a[7];
  t7 += v2 * b0;
  t8 += v2 * b1;
  t9 += v2 * b2;
  t10 += v2 * b3;
  t11 += v2 * b4;
  t12 += v2 * b5;
  t13 += v2 * b6;
  t14 += v2 * b7;
  t15 += v2 * b8;
  t16 += v2 * b9;
  t17 += v2 * b10;
  t18 += v2 * b11;
  t19 += v2 * b12;
  t20 += v2 * b13;
  t21 += v2 * b14;
  t22 += v2 * b15;
  v2 = a[8];
  t8 += v2 * b0;
  t9 += v2 * b1;
  t10 += v2 * b2;
  t11 += v2 * b3;
  t12 += v2 * b4;
  t13 += v2 * b5;
  t14 += v2 * b6;
  t15 += v2 * b7;
  t16 += v2 * b8;
  t17 += v2 * b9;
  t18 += v2 * b10;
  t19 += v2 * b11;
  t20 += v2 * b12;
  t21 += v2 * b13;
  t22 += v2 * b14;
  t23 += v2 * b15;
  v2 = a[9];
  t9 += v2 * b0;
  t10 += v2 * b1;
  t11 += v2 * b2;
  t12 += v2 * b3;
  t13 += v2 * b4;
  t14 += v2 * b5;
  t15 += v2 * b6;
  t16 += v2 * b7;
  t17 += v2 * b8;
  t18 += v2 * b9;
  t19 += v2 * b10;
  t20 += v2 * b11;
  t21 += v2 * b12;
  t22 += v2 * b13;
  t23 += v2 * b14;
  t24 += v2 * b15;
  v2 = a[10];
  t10 += v2 * b0;
  t11 += v2 * b1;
  t12 += v2 * b2;
  t13 += v2 * b3;
  t14 += v2 * b4;
  t15 += v2 * b5;
  t16 += v2 * b6;
  t17 += v2 * b7;
  t18 += v2 * b8;
  t19 += v2 * b9;
  t20 += v2 * b10;
  t21 += v2 * b11;
  t22 += v2 * b12;
  t23 += v2 * b13;
  t24 += v2 * b14;
  t25 += v2 * b15;
  v2 = a[11];
  t11 += v2 * b0;
  t12 += v2 * b1;
  t13 += v2 * b2;
  t14 += v2 * b3;
  t15 += v2 * b4;
  t16 += v2 * b5;
  t17 += v2 * b6;
  t18 += v2 * b7;
  t19 += v2 * b8;
  t20 += v2 * b9;
  t21 += v2 * b10;
  t22 += v2 * b11;
  t23 += v2 * b12;
  t24 += v2 * b13;
  t25 += v2 * b14;
  t26 += v2 * b15;
  v2 = a[12];
  t12 += v2 * b0;
  t13 += v2 * b1;
  t14 += v2 * b2;
  t15 += v2 * b3;
  t16 += v2 * b4;
  t17 += v2 * b5;
  t18 += v2 * b6;
  t19 += v2 * b7;
  t20 += v2 * b8;
  t21 += v2 * b9;
  t22 += v2 * b10;
  t23 += v2 * b11;
  t24 += v2 * b12;
  t25 += v2 * b13;
  t26 += v2 * b14;
  t27 += v2 * b15;
  v2 = a[13];
  t13 += v2 * b0;
  t14 += v2 * b1;
  t15 += v2 * b2;
  t16 += v2 * b3;
  t17 += v2 * b4;
  t18 += v2 * b5;
  t19 += v2 * b6;
  t20 += v2 * b7;
  t21 += v2 * b8;
  t22 += v2 * b9;
  t23 += v2 * b10;
  t24 += v2 * b11;
  t25 += v2 * b12;
  t26 += v2 * b13;
  t27 += v2 * b14;
  t28 += v2 * b15;
  v2 = a[14];
  t14 += v2 * b0;
  t15 += v2 * b1;
  t16 += v2 * b2;
  t17 += v2 * b3;
  t18 += v2 * b4;
  t19 += v2 * b5;
  t20 += v2 * b6;
  t21 += v2 * b7;
  t22 += v2 * b8;
  t23 += v2 * b9;
  t24 += v2 * b10;
  t25 += v2 * b11;
  t26 += v2 * b12;
  t27 += v2 * b13;
  t28 += v2 * b14;
  t29 += v2 * b15;
  v2 = a[15];
  t15 += v2 * b0;
  t16 += v2 * b1;
  t17 += v2 * b2;
  t18 += v2 * b3;
  t19 += v2 * b4;
  t20 += v2 * b5;
  t21 += v2 * b6;
  t22 += v2 * b7;
  t23 += v2 * b8;
  t24 += v2 * b9;
  t25 += v2 * b10;
  t26 += v2 * b11;
  t27 += v2 * b12;
  t28 += v2 * b13;
  t29 += v2 * b14;
  t30 += v2 * b15;
  t0 += 38 * t16;
  t1 += 38 * t17;
  t2 += 38 * t18;
  t3 += 38 * t19;
  t4 += 38 * t20;
  t5 += 38 * t21;
  t6 += 38 * t22;
  t7 += 38 * t23;
  t8 += 38 * t24;
  t9 += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  let c = 1;
  v2 = t0 + c + 65535;
  c = Math.floor(v2 / 65536);
  t0 = v2 - c * 65536;
  v2 = t1 + c + 65535;
  c = Math.floor(v2 / 65536);
  t1 = v2 - c * 65536;
  v2 = t2 + c + 65535;
  c = Math.floor(v2 / 65536);
  t2 = v2 - c * 65536;
  v2 = t3 + c + 65535;
  c = Math.floor(v2 / 65536);
  t3 = v2 - c * 65536;
  v2 = t4 + c + 65535;
  c = Math.floor(v2 / 65536);
  t4 = v2 - c * 65536;
  v2 = t5 + c + 65535;
  c = Math.floor(v2 / 65536);
  t5 = v2 - c * 65536;
  v2 = t6 + c + 65535;
  c = Math.floor(v2 / 65536);
  t6 = v2 - c * 65536;
  v2 = t7 + c + 65535;
  c = Math.floor(v2 / 65536);
  t7 = v2 - c * 65536;
  v2 = t8 + c + 65535;
  c = Math.floor(v2 / 65536);
  t8 = v2 - c * 65536;
  v2 = t9 + c + 65535;
  c = Math.floor(v2 / 65536);
  t9 = v2 - c * 65536;
  v2 = t10 + c + 65535;
  c = Math.floor(v2 / 65536);
  t10 = v2 - c * 65536;
  v2 = t11 + c + 65535;
  c = Math.floor(v2 / 65536);
  t11 = v2 - c * 65536;
  v2 = t12 + c + 65535;
  c = Math.floor(v2 / 65536);
  t12 = v2 - c * 65536;
  v2 = t13 + c + 65535;
  c = Math.floor(v2 / 65536);
  t13 = v2 - c * 65536;
  v2 = t14 + c + 65535;
  c = Math.floor(v2 / 65536);
  t14 = v2 - c * 65536;
  v2 = t15 + c + 65535;
  c = Math.floor(v2 / 65536);
  t15 = v2 - c * 65536;
  t0 += c - 1 + 37 * (c - 1);
  c = 1;
  v2 = t0 + c + 65535;
  c = Math.floor(v2 / 65536);
  t0 = v2 - c * 65536;
  v2 = t1 + c + 65535;
  c = Math.floor(v2 / 65536);
  t1 = v2 - c * 65536;
  v2 = t2 + c + 65535;
  c = Math.floor(v2 / 65536);
  t2 = v2 - c * 65536;
  v2 = t3 + c + 65535;
  c = Math.floor(v2 / 65536);
  t3 = v2 - c * 65536;
  v2 = t4 + c + 65535;
  c = Math.floor(v2 / 65536);
  t4 = v2 - c * 65536;
  v2 = t5 + c + 65535;
  c = Math.floor(v2 / 65536);
  t5 = v2 - c * 65536;
  v2 = t6 + c + 65535;
  c = Math.floor(v2 / 65536);
  t6 = v2 - c * 65536;
  v2 = t7 + c + 65535;
  c = Math.floor(v2 / 65536);
  t7 = v2 - c * 65536;
  v2 = t8 + c + 65535;
  c = Math.floor(v2 / 65536);
  t8 = v2 - c * 65536;
  v2 = t9 + c + 65535;
  c = Math.floor(v2 / 65536);
  t9 = v2 - c * 65536;
  v2 = t10 + c + 65535;
  c = Math.floor(v2 / 65536);
  t10 = v2 - c * 65536;
  v2 = t11 + c + 65535;
  c = Math.floor(v2 / 65536);
  t11 = v2 - c * 65536;
  v2 = t12 + c + 65535;
  c = Math.floor(v2 / 65536);
  t12 = v2 - c * 65536;
  v2 = t13 + c + 65535;
  c = Math.floor(v2 / 65536);
  t13 = v2 - c * 65536;
  v2 = t14 + c + 65535;
  c = Math.floor(v2 / 65536);
  t14 = v2 - c * 65536;
  v2 = t15 + c + 65535;
  c = Math.floor(v2 / 65536);
  t15 = v2 - c * 65536;
  t0 += c - 1 + 37 * (c - 1);
  o[0] = t0;
  o[1] = t1;
  o[2] = t2;
  o[3] = t3;
  o[4] = t4;
  o[5] = t5;
  o[6] = t6;
  o[7] = t7;
  o[8] = t8;
  o[9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}
function S(o, a) {
  M(o, a, a);
}
function inv25519(o, i) {
  const c = gf();
  for (let a = 0; a < 16; a++) c[a] = i[a];
  for (let a = 253; a >= 0; a--) {
    S(c, c);
    if (a !== 2 && a !== 4) M(c, c, i);
  }
  for (let a = 0; a < 16; a++) o[a] = c[a];
}
function set25519(r2, a) {
  for (let i = 0; i < 16; i++) r2[i] = a[i] | 0;
}
function scalarmult(p2, q2, s) {
  set25519(p2[0], gf0);
  set25519(p2[1], gf1);
  set25519(p2[2], gf1);
  set25519(p2[3], gf0);
  for (let i = 255; i >= 0; --i) {
    const b = s[i / 8 | 0] >> (i & 7) & 1;
    cswap(p2, q2, b);
    add(q2, p2);
    add(p2, p2);
    cswap(p2, q2, b);
  }
}
function scalarbase(p2, s) {
  const q2 = [gf(), gf(), gf(), gf()];
  set25519(q2[0], X);
  set25519(q2[1], Y);
  set25519(q2[2], gf1);
  M(q2[3], X, Y);
  scalarmult(p2, q2, s);
}
function cswap(p2, q2, b) {
  for (let i = 0; i < 4; i++) sel25519(p2[i], q2[i], b);
}
function add(p2, q2) {
  const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f2 = gf(), g = gf(), h = gf(), t2 = gf();
  Z(a, p2[1], p2[0]);
  Z(t2, q2[1], q2[0]);
  M(a, a, t2);
  A(b, p2[0], p2[1]);
  A(t2, q2[0], q2[1]);
  M(b, b, t2);
  M(c, p2[3], q2[3]);
  M(c, c, D2);
  M(d, p2[2], q2[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f2, d, c);
  A(g, d, c);
  A(h, b, a);
  M(p2[0], e, f2);
  M(p2[1], h, g);
  M(p2[2], g, f2);
  M(p2[3], e, h);
}
function pack(r2, p2) {
  const tx = gf(), ty = gf(), zi2 = gf();
  inv25519(zi2, p2[2]);
  M(tx, p2[0], zi2);
  M(ty, p2[1], zi2);
  pack25519(r2, ty);
  r2[31] ^= par25519(tx) << 7;
}
function modL(r2, x2) {
  const L2 = [
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ];
  let carry;
  for (let i = 63; i >= 32; --i) {
    carry = 0;
    for (let j = i - 32, k2 = i - 12; j < k2; ++j) {
      x2[j] += carry - 16 * x2[i] * L2[j - (i - 32)];
      carry = Math.floor((x2[j] + 128) / 256);
      x2[j] -= carry * 256;
    }
    x2[i - 32 + (i - 12 - (i - 32))] += carry;
    x2[i] = 0;
  }
  carry = 0;
  for (let j = 0; j < 32; j++) {
    x2[j] += carry - (x2[31] >> 4) * L2[j];
    carry = x2[j] >> 8;
    x2[j] &= 255;
  }
  for (let j = 0; j < 32; j++) x2[j] -= carry * L2[j];
  for (let i = 0; i < 32; i++) {
    x2[i + 1] += x2[i] >> 8;
    r2[i] = x2[i] & 255;
  }
}
function reduce(r2) {
  const x2 = new Float64Array(64);
  for (let i = 0; i < 64; i++) x2[i] = r2[i];
  for (let i = 0; i < 64; i++) r2[i] = 0;
  modL(r2, x2);
}
async function sign(message, secretKey) {
  const d = new Uint8Array(await crypto.subtle.digest("SHA-512", secretKey.subarray(0, 32)));
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;
  const sm = new Uint8Array(64 + message.length);
  sm.set(message, 64);
  const pk2 = secretKey.subarray(32);
  const tmp = new Uint8Array(64 + message.length);
  tmp.set(d.subarray(32), 0);
  tmp.set(message, 32);
  const r2 = new Uint8Array(await crypto.subtle.digest("SHA-512", tmp.subarray(0, 32 + message.length)));
  reduce(r2);
  const p2 = [gf(), gf(), gf(), gf()];
  scalarbase(p2, r2);
  pack(sm, p2);
  sm.set(pk2, 32);
  const h = new Uint8Array(await crypto.subtle.digest("SHA-512", sm));
  reduce(h);
  const x2 = new Float64Array(64);
  for (let i = 0; i < 32; i++) x2[i] = r2[i];
  for (let i = 0; i < 32; i++) {
    for (let j = 0; j < 32; j++) {
      x2[i + j] += h[i] * d[j];
    }
  }
  modL(sm.subarray(32, 64), x2);
  return sm.subarray(0, 64);
}
const ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function encode(bytes) {
  const digits = [0];
  for (let i = 0; i < bytes.length; i++) {
    let carry = bytes[i];
    for (let j = 0; j < digits.length; j++) {
      carry += digits[j] << 8;
      digits[j] = carry % 58;
      carry = carry / 58 | 0;
    }
    while (carry > 0) {
      digits.push(carry % 58);
      carry = carry / 58 | 0;
    }
  }
  let result = "";
  for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {
    result += ALPHABET[0];
  }
  for (let i = digits.length - 1; i >= 0; i--) {
    result += ALPHABET[digits[i]];
  }
  return result;
}
function decode(str) {
  const bytes = [0];
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    let value = ALPHABET.indexOf(char);
    if (value < 0) throw new Error("Invalid base58 character");
    for (let j = 0; j < bytes.length; j++) {
      value += bytes[j] * 58;
      bytes[j] = value & 255;
      value >>= 8;
    }
    while (value > 0) {
      bytes.push(value & 255);
      value >>= 8;
    }
  }
  for (let i = 0; i < str.length && str[i] === ALPHABET[0]; i++) {
    bytes.push(0);
  }
  return new Uint8Array(bytes.reverse());
}
function validateAddress(str) {
  if (!str) {
    return { valid: false, error: "Address is required" };
  }
  if (typeof str !== "string") {
    return { valid: false, error: "Address must be a string" };
  }
  str = str.trim();
  if (str.length < 32) {
    return { valid: false, error: "Address is too short" };
  }
  if (str.length > 44) {
    return { valid: false, error: "Address is too long" };
  }
  for (let i = 0; i < str.length; i++) {
    if (ALPHABET.indexOf(str[i]) < 0) {
      return { valid: false, error: `Invalid character '${str[i]}' at position ${i + 1}` };
    }
  }
  try {
    const decoded = decode(str);
    if (decoded.length !== 32) {
      return { valid: false, error: "Invalid address length after decoding" };
    }
    const reencoded = encode(decoded);
    if (reencoded !== str) {
      return { valid: false, error: "Address is not in canonical form" };
    }
    return { valid: true, decoded };
  } catch (e) {
    return { valid: false, error: "Invalid base58 encoding" };
  }
}
const encodeBase58 = encode;
const decodeBase58 = decode;
const base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode,
  decodeBase58,
  encode,
  encodeBase58,
  validateAddress
}, Symbol.toStringTag, { value: "Module" }));
const SYSTEM_PROGRAM_ID$1 = "11111111111111111111111111111111";
const TOKEN_PROGRAM_ID$3 = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
const ASSOCIATED_TOKEN_PROGRAM_ID$1 = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
const COMPUTE_BUDGET_PROGRAM_ID = "ComputeBudget111111111111111111111111111111";
const BUBBLEGUM_PROGRAM_ID = "BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY";
const SPL_NOOP_PROGRAM_ID = "noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV";
const SPL_ACCOUNT_COMPRESSION_PROGRAM_ID = "cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK";
function decodeToFixedSize$1(base58Str, size) {
  const decoded = decodeBase58(base58Str);
  if (decoded.length === size) {
    return decoded;
  }
  if (decoded.length < size) {
    const padded = new Uint8Array(size);
    padded.set(decoded, size - decoded.length);
    return padded;
  }
  return decoded.slice(0, size);
}
async function createTransferTransaction({ fromPubkey, toPubkey, lamports, recentBlockhash, privateKey, priorityFee = 0 }) {
  try {
    let secretKey;
    if (typeof privateKey === "string") {
      secretKey = decodeBase58(privateKey);
    } else {
      secretKey = privateKey;
    }
    if (secretKey.length !== 64) {
      throw new Error(`Invalid secret key length: ${secretKey.length}, expected 64`);
    }
    const message = buildTransferMessage(fromPubkey, toPubkey, lamports, recentBlockhash, priorityFee);
    const signature = await sign$1(message, secretKey);
    const serializedTx = serializeTransaction(signature, message);
    return btoa(String.fromCharCode(...serializedTx));
  } catch (error) {
    logger$1.error("Transaction creation error:", error);
    throw error;
  }
}
async function createTokenTransferTransaction({
  fromPubkey,
  toPubkey,
  mint,
  amount,
  decimals,
  fromTokenAccount,
  toTokenAccount: providedToTokenAccount,
  // Optional: direct token account address
  recentBlockhash,
  privateKey,
  programId,
  rpcUrl
}) {
  try {
    logger$1.log("=== TOKEN TRANSFER START ===");
    logger$1.log("From wallet:", fromPubkey);
    logger$1.log("To wallet:", toPubkey);
    logger$1.log("Mint:", mint);
    logger$1.log("Amount:", amount);
    logger$1.log("From token account:", fromTokenAccount);
    logger$1.log("Provided to token account:", providedToTokenAccount);
    logger$1.log("Token program:", programId);
    if (!fromPubkey) throw new Error("From wallet address is required");
    if (!toPubkey) throw new Error("To wallet address is required");
    if (!mint) throw new Error("Token mint address is required");
    if (!fromTokenAccount) throw new Error("Source token account address is required");
    if (!privateKey) throw new Error("Wallet is locked. Please unlock your wallet to sign transactions.");
    if (fromPubkey === toPubkey) {
      logger$1.log("[Transaction] Self-transfer detected - returning no-op success (balance unchanged)");
      return {
        signature: "self-transfer-no-op",
        success: true,
        message: "Self-transfer completed (no blockchain transaction needed - balance unchanged)"
      };
    }
    let secretKey;
    if (typeof privateKey === "string") {
      secretKey = decodeBase58(privateKey);
    } else {
      secretKey = privateKey;
    }
    if (!secretKey || secretKey.length !== 64) {
      throw new Error(`Invalid secret key length: ${(secretKey == null ? void 0 : secretKey.length) || 0}, expected 64`);
    }
    const tokenProgramId = programId || TOKEN_PROGRAM_ID$3;
    let toTokenAccount = providedToTokenAccount;
    let needsCreateATA = false;
    if (!toTokenAccount && rpcUrl) {
      const existingATA = await findExistingATA(rpcUrl, toPubkey, mint);
      if (existingATA) {
        logger$1.log("Found existing ATA for recipient:", existingATA);
        toTokenAccount = existingATA;
        needsCreateATA = false;
      } else {
        logger$1.log("No existing ATA - deriving with RPC validation");
        try {
          toTokenAccount = await deriveATAAddressStandard(toPubkey, mint, tokenProgramId, rpcUrl, fromPubkey);
          logger$1.log("Derived ATA with RPC validation:", toTokenAccount);
          needsCreateATA = true;
        } catch (deriveErr) {
          logger$1.warn("RPC validation failed, using simple derivation:", deriveErr.message);
          const result = await findATAAddress(toPubkey, mint, tokenProgramId);
          toTokenAccount = result.address;
          needsCreateATA = true;
        }
      }
    } else if (!toTokenAccount) {
      const result = await findATAAddress(toPubkey, mint, tokenProgramId);
      toTokenAccount = result.address;
      needsCreateATA = true;
      logger$1.log("Derived ATA (no RPC):", toTokenAccount);
    } else {
      logger$1.log("Using provided token account:", toTokenAccount);
    }
    logger$1.log("Final destination token account:", toTokenAccount);
    logger$1.log("Needs ATA creation:", needsCreateATA);
    logger$1.log("[TOKEN TRANSFER] Validating account addresses:");
    logger$1.log("  fromPubkey:", fromPubkey);
    logger$1.log("  toPubkey:", toPubkey);
    logger$1.log("  fromTokenAccount:", fromTokenAccount);
    logger$1.log("  toTokenAccount:", toTokenAccount);
    logger$1.log("  mint:", mint);
    if (toTokenAccount === fromPubkey) {
      throw new Error("Derived ATA matches sender wallet - invalid derivation");
    }
    if (toTokenAccount === toPubkey) {
      throw new Error("Derived ATA matches recipient wallet - invalid derivation");
    }
    if (toTokenAccount === fromTokenAccount) {
      throw new Error("Derived ATA matches source token account - cannot send to same account. This may happen if sending to your own wallet.");
    }
    if (toTokenAccount === mint) {
      throw new Error("Derived ATA matches mint address - invalid derivation");
    }
    let message;
    if (needsCreateATA) {
      message = buildTokenTransferWithCreateATAMessage({
        fromPubkey,
        toPubkey,
        fromTokenAccount,
        toTokenAccount,
        mint,
        amount,
        recentBlockhash,
        tokenProgramId
      });
      logger$1.log("Built transfer WITH ATA creation (2 instructions)");
    } else {
      message = buildTokenTransferMessage({
        fromPubkey,
        fromTokenAccount,
        toTokenAccount,
        amount,
        recentBlockhash,
        tokenProgramId
      });
      logger$1.log("Built simple transfer (1 instruction)");
    }
    const signature = await sign$1(message, secretKey);
    const serializedTx = serializeTransaction(signature, message);
    logger$1.log("=== TOKEN TRANSFER READY ===");
    return btoa(String.fromCharCode(...serializedTx));
  } catch (error) {
    logger$1.error("Token transfer error:", error);
    throw error;
  }
}
async function createCompressedNftTransfer({
  assetId,
  owner,
  newOwner,
  proof,
  asset,
  recentBlockhash,
  privateKey
}) {
  try {
    logger$1.log("[cNFT Transfer] Starting transfer:", assetId == null ? void 0 : assetId.slice(0, 8));
    let secretKey;
    if (typeof privateKey === "string") {
      secretKey = decodeBase58(privateKey);
    } else {
      secretKey = privateKey;
    }
    if (!secretKey || secretKey.length !== 64) {
      throw new Error("Invalid private key");
    }
    const pubkeyFromSecret = secretKey.slice(32);
    const expectedPubkey = encodeBase58(pubkeyFromSecret);
    if (expectedPubkey !== owner) {
      throw new Error("Private key does not match owner address");
    }
    const compression = asset.compression;
    if (!compression) {
      throw new Error("Asset is not compressed");
    }
    const treeId = proof.tree_id;
    const root = proof.root;
    const dataHash = compression.data_hash;
    const creatorHash = compression.creator_hash;
    const leafIndex = compression.leaf_id;
    const proofPath = proof.proof || [];
    const treeAuthority = await deriveTreeAuthority(treeId);
    const message = buildCompressedNftTransferMessage({
      treeAuthority,
      leafOwner: owner,
      leafDelegate: owner,
      newLeafOwner: newOwner,
      merkleTree: treeId,
      root,
      dataHash,
      creatorHash,
      nonce: leafIndex,
      index: leafIndex,
      proofPath,
      recentBlockhash
    });
    const signature = await sign$1(message, secretKey);
    const serializedTx = serializeTransaction(signature, message);
    logger$1.log("[cNFT Transfer] Transaction built successfully");
    return btoa(String.fromCharCode(...serializedTx));
  } catch (error) {
    logger$1.error("[cNFT Transfer] Error:", error.message);
    throw error;
  }
}
async function deriveTreeAuthority(treeId) {
  const treeBytes = decodeToFixedSize$1(treeId, 32);
  const bubblegumBytes = decodeToFixedSize$1(BUBBLEGUM_PROGRAM_ID, 32);
  const marker = new TextEncoder().encode("ProgramDerivedAddress");
  for (let bump = 255; bump >= 0; bump--) {
    const bumpSeed = new Uint8Array([bump]);
    const buffer2 = new Uint8Array(32 + 1 + 32 + marker.length);
    let offset = 0;
    buffer2.set(treeBytes, offset);
    offset += 32;
    buffer2.set(bumpSeed, offset);
    offset += 1;
    buffer2.set(bubblegumBytes, offset);
    offset += 32;
    buffer2.set(marker, offset);
    const hash = await crypto.subtle.digest("SHA-256", buffer2);
    const hashBytes = new Uint8Array(hash);
    if (!isOnCurve(hashBytes)) {
      return encodeBase58(hashBytes);
    }
  }
  throw new Error("Failed to derive tree authority");
}
function buildCompressedNftTransferMessage({
  treeAuthority,
  leafOwner,
  leafDelegate,
  newLeafOwner,
  merkleTree,
  root,
  dataHash,
  creatorHash,
  nonce,
  index,
  proofPath,
  recentBlockhash
}) {
  const isDelegateSameAsOwner = leafDelegate === leafOwner;
  const treeAuthorityBytes = decodeToFixedSize$1(treeAuthority, 32);
  const leafOwnerBytes = decodeToFixedSize$1(leafOwner, 32);
  const leafDelegateBytes = isDelegateSameAsOwner ? leafOwnerBytes : decodeToFixedSize$1(leafDelegate, 32);
  const newLeafOwnerBytes = decodeToFixedSize$1(newLeafOwner, 32);
  const merkleTreeBytes = decodeToFixedSize$1(merkleTree, 32);
  const bubblegumBytes = decodeToFixedSize$1(BUBBLEGUM_PROGRAM_ID, 32);
  const noopBytes = decodeToFixedSize$1(SPL_NOOP_PROGRAM_ID, 32);
  const compressionBytes = decodeToFixedSize$1(SPL_ACCOUNT_COMPRESSION_PROGRAM_ID, 32);
  const systemBytes = decodeToFixedSize$1(SYSTEM_PROGRAM_ID$1, 32);
  const blockhashBytes = decodeToFixedSize$1(recentBlockhash, 32);
  const rootBytes = decodeToFixedSize$1(root, 32);
  const dataHashBytes = decodeToFixedSize$1(dataHash, 32);
  const creatorHashBytes = decodeToFixedSize$1(creatorHash, 32);
  const proofBytes = proofPath.map((p2) => decodeToFixedSize$1(p2, 32));
  const numProofAccounts = proofBytes.length;
  let accountList = [];
  accountList.push({ bytes: leafOwnerBytes, name: "leafOwner" });
  accountList.push({ bytes: merkleTreeBytes, name: "merkleTree" });
  accountList.push({ bytes: treeAuthorityBytes, name: "treeAuthority" });
  let leafDelegateIdx = 0;
  if (!isDelegateSameAsOwner) {
    leafDelegateIdx = accountList.length;
    accountList.push({ bytes: leafDelegateBytes, name: "leafDelegate" });
  }
  const newLeafOwnerIdx = accountList.length;
  accountList.push({ bytes: newLeafOwnerBytes, name: "newLeafOwner" });
  const noopIdx = accountList.length;
  accountList.push({ bytes: noopBytes, name: "noop" });
  const compressionIdx = accountList.length;
  accountList.push({ bytes: compressionBytes, name: "compression" });
  const systemIdx = accountList.length;
  accountList.push({ bytes: systemBytes, name: "system" });
  const proofStartIdx = accountList.length;
  for (const proofAcc of proofBytes) {
    accountList.push({ bytes: proofAcc, name: "proof" });
  }
  const bubblegumIdx = accountList.length;
  accountList.push({ bytes: bubblegumBytes, name: "bubblegum" });
  const numAccounts = accountList.length;
  const accountKeys = new Uint8Array(32 * numAccounts);
  for (let i = 0; i < numAccounts; i++) {
    accountKeys.set(accountList[i].bytes, i * 32);
  }
  const numReadonlyUnsigned = numAccounts - 2;
  const header = new Uint8Array([1, 0, numReadonlyUnsigned]);
  const discriminator = new Uint8Array([163, 52, 200, 231, 140, 3, 69, 186]);
  const instructionData = new Uint8Array(8 + 32 + 32 + 32 + 8 + 4);
  let dataOffset = 0;
  instructionData.set(discriminator, dataOffset);
  dataOffset += 8;
  instructionData.set(rootBytes, dataOffset);
  dataOffset += 32;
  instructionData.set(dataHashBytes, dataOffset);
  dataOffset += 32;
  instructionData.set(creatorHashBytes, dataOffset);
  dataOffset += 32;
  const nonceBI = BigInt(nonce);
  for (let i = 0; i < 8; i++) {
    instructionData[dataOffset + i] = Number(nonceBI >> BigInt(i * 8) & BigInt(255));
  }
  dataOffset += 8;
  instructionData[dataOffset] = index & 255;
  instructionData[dataOffset + 1] = index >> 8 & 255;
  instructionData[dataOffset + 2] = index >> 16 & 255;
  instructionData[dataOffset + 3] = index >> 24 & 255;
  const accountIndices = [
    2,
    // tree_authority -> our idx 2
    0,
    // leaf_owner -> our idx 0
    leafDelegateIdx,
    // leaf_delegate -> our idx 0 or 3
    newLeafOwnerIdx,
    // new_leaf_owner
    1,
    // merkle_tree -> our idx 1
    noopIdx,
    // log_wrapper
    compressionIdx,
    // compression_program
    systemIdx
    // system_program
  ];
  for (let i = 0; i < numProofAccounts; i++) {
    accountIndices.push(proofStartIdx + i);
  }
  const numInstrAccounts = accountIndices.length;
  let instrSize = 1;
  instrSize += 1;
  instrSize += numInstrAccounts;
  instrSize += instructionData.length < 128 ? 1 : 2;
  instrSize += instructionData.length;
  const instruction = new Uint8Array(instrSize);
  let instrOffset = 0;
  instruction[instrOffset++] = bubblegumIdx;
  instruction[instrOffset++] = numInstrAccounts;
  for (const idx of accountIndices) {
    instruction[instrOffset++] = idx;
  }
  if (instructionData.length < 128) {
    instruction[instrOffset++] = instructionData.length;
  } else {
    instruction[instrOffset++] = instructionData.length & 127 | 128;
    instruction[instrOffset++] = instructionData.length >> 7;
  }
  instruction.set(instructionData, instrOffset);
  const messageLength = 3 + 1 + 32 * numAccounts + 32 + 1 + instruction.length;
  const message = new Uint8Array(messageLength);
  let msgOffset = 0;
  message.set(header, msgOffset);
  msgOffset += 3;
  message[msgOffset] = numAccounts;
  msgOffset += 1;
  message.set(accountKeys, msgOffset);
  msgOffset += 32 * numAccounts;
  message.set(blockhashBytes, msgOffset);
  msgOffset += 32;
  message[msgOffset] = 1;
  msgOffset += 1;
  message.set(instruction, msgOffset);
  return message;
}
async function findExistingATA(rpcUrl, owner, mint, tokenProgramId = null) {
  var _a2, _b2, _c, _d, _e, _f, _g;
  try {
    logger$1.log("[findExistingATA] Looking for mint:", mint == null ? void 0 : mint.slice(0, 8), "owner:", owner == null ? void 0 : owner.slice(0, 8));
    const [response1, response2] = await Promise.all([
      fetchRpcRetry(rpcUrl, {
        jsonrpc: "2.0",
        id: 1,
        method: "getTokenAccountsByOwner",
        params: [
          owner,
          { programId: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" },
          { encoding: "jsonParsed" }
        ]
      }),
      fetchRpcRetry(rpcUrl, {
        jsonrpc: "2.0",
        id: 2,
        method: "getTokenAccountsByOwner",
        params: [
          owner,
          { programId: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb" },
          { encoding: "jsonParsed" }
        ]
      })
    ]);
    const [data1, data2] = await Promise.all([
      response1.json(),
      response2.json()
    ]);
    const allAccounts = [
      ...((_a2 = data1.result) == null ? void 0 : _a2.value) || [],
      ...((_b2 = data2.result) == null ? void 0 : _b2.value) || []
    ];
    logger$1.log("[findExistingATA] Found", allAccounts.length, "total token accounts");
    for (const acc of allAccounts) {
      const accMint = (_f = (_e = (_d = (_c = acc.account) == null ? void 0 : _c.data) == null ? void 0 : _d.parsed) == null ? void 0 : _e.info) == null ? void 0 : _f.mint;
      if (accMint === mint) {
        logger$1.log("[findExistingATA] Found matching account:", (_g = acc.pubkey) == null ? void 0 : _g.slice(0, 8));
        return acc.pubkey;
      }
    }
    logger$1.warn("[findExistingATA] No token account found for mint:", mint == null ? void 0 : mint.slice(0, 8));
    return null;
  } catch (error) {
    logger$1.warn("[findExistingATA] Failed:", error.message);
    return null;
  }
}
async function deriveATAAddressWithValidation(rpcUrl, owner, mint, tokenProgramId, payer) {
  logger$1.log("[ATA-RPC] Deriving ATA for owner:", owner);
  logger$1.log("[ATA-RPC] Mint:", mint);
  logger$1.log("[ATA-RPC] Token program:", tokenProgramId);
  const address255 = await computeATAAddress(owner, mint, tokenProgramId, 255);
  logger$1.log("[ATA-RPC] Testing bump 255:", address255);
  const isValid255 = await validateATAWithRPC(rpcUrl, owner, mint, address255, tokenProgramId, 255, payer);
  if (isValid255) {
    logger$1.log("[ATA-RPC]  Found valid ATA with bump 255:", address255);
    return address255;
  }
  const bumpsToTry = [254, 253, 252, 251, 250];
  for (const bump of bumpsToTry) {
    await new Promise((r2) => setTimeout(r2, 200));
    const address = await computeATAAddress(owner, mint, tokenProgramId, bump);
    logger$1.log(`[ATA-RPC] Testing bump ${bump}: ${address}`);
    const isValid = await validateATAWithRPC(rpcUrl, owner, mint, address, tokenProgramId, bump, payer);
    if (isValid) {
      logger$1.log(`[ATA-RPC]  Found valid ATA with bump ${bump}: ${address}`);
      return address;
    }
    logger$1.log(`[ATA-RPC]  Bump ${bump} invalid`);
  }
  logger$1.warn("[ATA-RPC] No valid bump found, using 255 as fallback");
  return address255;
}
async function computeATAAddress(owner, mint, tokenProgramId, bump) {
  const ownerBytes = decodeToFixedSize$1(owner, 32);
  const mintBytes = decodeToFixedSize$1(mint, 32);
  const tokenProgramBytes = decodeToFixedSize$1(tokenProgramId, 32);
  const ataProgramBytes = decodeToFixedSize$1(ASSOCIATED_TOKEN_PROGRAM_ID$1, 32);
  const bumpSeed = new Uint8Array([bump]);
  const marker = new TextEncoder().encode("ProgramDerivedAddress");
  const totalLength = 32 + 32 + 32 + 1 + 32 + marker.length;
  const buffer2 = new Uint8Array(totalLength);
  let offset = 0;
  buffer2.set(ownerBytes, offset);
  offset += 32;
  buffer2.set(tokenProgramBytes, offset);
  offset += 32;
  buffer2.set(mintBytes, offset);
  offset += 32;
  buffer2.set(bumpSeed, offset);
  offset += 1;
  buffer2.set(ataProgramBytes, offset);
  offset += 32;
  buffer2.set(marker, offset);
  const hash = await crypto.subtle.digest("SHA-256", buffer2);
  return encodeBase58(new Uint8Array(hash));
}
async function findATAAddress(owner, mint, tokenProgramId) {
  logger$1.log("[findATAAddress] Deriving ATA for:");
  logger$1.log("  owner:", owner);
  logger$1.log("  mint:", mint);
  logger$1.log("  tokenProgramId:", tokenProgramId);
  const ownerBytes = decodeToFixedSize$1(owner, 32);
  const mintBytes = decodeToFixedSize$1(mint, 32);
  const tokenProgramBytes = decodeToFixedSize$1(tokenProgramId, 32);
  const ataProgramBytes = decodeToFixedSize$1(ASSOCIATED_TOKEN_PROGRAM_ID$1, 32);
  const marker = new TextEncoder().encode("ProgramDerivedAddress");
  for (let bump = 255; bump >= 0; bump--) {
    const bumpSeed = new Uint8Array([bump]);
    const totalLength = 32 + 32 + 32 + 1 + 32 + marker.length;
    const buffer2 = new Uint8Array(totalLength);
    let offset = 0;
    buffer2.set(ownerBytes, offset);
    offset += 32;
    buffer2.set(tokenProgramBytes, offset);
    offset += 32;
    buffer2.set(mintBytes, offset);
    offset += 32;
    buffer2.set(bumpSeed, offset);
    offset += 1;
    buffer2.set(ataProgramBytes, offset);
    offset += 32;
    buffer2.set(marker, offset);
    const hash = await crypto.subtle.digest("SHA-256", buffer2);
    const hashBytes = new Uint8Array(hash);
    if (!isOnCurve(hashBytes)) {
      console.log("[ATA] Found valid PDA at bump:", bump, "address:", encodeBase58(hashBytes));
      return { address: encodeBase58(hashBytes), bump };
    }
  }
  throw new Error("Could not find valid PDA for ATA");
}
function isOnCurve(bytes) {
  let allZero = true;
  let allOne = true;
  for (let i = 0; i < 32; i++) {
    if (bytes[i] !== 0) allZero = false;
    if (bytes[i] !== 255) allOne = false;
  }
  if (allZero || allOne) return true;
  return false;
}
async function fetchRpcRetry(rpcUrl, body, maxRetries = 5) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(rpcUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: typeof body === "string" ? body : JSON.stringify(body)
      });
      if (response.status === 429) {
        const baseDelay = 1e3 * Math.pow(2, attempt - 1);
        const jitter = Math.random() * 500;
        const delay = Math.min(baseDelay + jitter, 8e3);
        logger$1.warn(`[RPC] Rate limited (429), waiting ${Math.round(delay)}ms (attempt ${attempt}/${maxRetries})`);
        await new Promise((r2) => setTimeout(r2, delay));
        continue;
      }
      return response;
    } catch (err) {
      if (attempt === maxRetries) throw err;
      await new Promise((r2) => setTimeout(r2, 1e3));
    }
  }
  throw new Error("RPC request failed after max retries");
}
async function validateATAWithRPC(rpcUrl, owner, mint, ataAddress, tokenProgramId, bump, payer) {
  var _a2, _b2, _c, _d;
  try {
    const bhResponse = await fetchRpcRetry(rpcUrl, {
      jsonrpc: "2.0",
      id: 1,
      method: "getLatestBlockhash",
      params: [{ commitment: "finalized" }]
    });
    const bhData = await bhResponse.json();
    const blockhash = (_b2 = (_a2 = bhData.result) == null ? void 0 : _a2.value) == null ? void 0 : _b2.blockhash;
    if (!blockhash) {
      logger$1.warn("[ATA-RPC] Failed to get blockhash");
      return false;
    }
    const message = buildCreateATAMessage(payer, owner, ataAddress, mint, tokenProgramId, blockhash);
    const dummySignature = new Uint8Array(64);
    const tx = new Uint8Array(1 + 64 + message.length);
    tx[0] = 1;
    tx.set(dummySignature, 1);
    tx.set(message, 65);
    const txBase64 = btoa(String.fromCharCode(...tx));
    const response = await fetchRpcRetry(rpcUrl, {
      jsonrpc: "2.0",
      id: 1,
      method: "simulateTransaction",
      params: [txBase64, {
        encoding: "base64",
        sigVerify: false,
        replaceRecentBlockhash: true
      }]
    });
    const data = await response.json();
    const err = (_d = (_c = data.result) == null ? void 0 : _c.value) == null ? void 0 : _d.err;
    logger$1.log(`[ATA-RPC] Bump ${bump} simulation result:`, err ? JSON.stringify(err) : "OK");
    if (!err) {
      return true;
    }
    if (err.InstructionError) {
      const [instrIndex, errType] = err.InstructionError;
      if (typeof errType === "object" && "Custom" in errType) {
        return false;
      }
      if (errType === "InvalidSeeds") {
        return false;
      }
      if (errType === "IncorrectProgramId") {
        return false;
      }
      if (errType === "InvalidAccountData") {
        return false;
      }
      if (errType === "AccountNotFound") {
        logger$1.warn("AccountNotFound with real payer - checking mint");
        return true;
      }
      if (errType === "InsufficientFunds") {
        return true;
      }
      if (errType === "AccountLoadedTwice") {
        logger$1.warn("AccountLoadedTwice error - check message construction");
        return false;
      }
    }
    const errStr = JSON.stringify(err);
    if (errStr.includes("InvalidSeeds") || errStr.includes("seeds")) {
      return false;
    }
    return true;
  } catch (error) {
    logger$1.warn("Validation error for bump", bump, ":", error);
    return false;
  }
}
function buildCreateATAMessage(payer, owner, ataAddress, mint, tokenProgramId, blockhash) {
  const payerBytes = decodeToFixedSize$1(payer, 32);
  const ownerBytes = decodeToFixedSize$1(owner, 32);
  const ataBytes = decodeToFixedSize$1(ataAddress, 32);
  const mintBytes = decodeToFixedSize$1(mint, 32);
  const tokenProgramBytes = decodeToFixedSize$1(tokenProgramId, 32);
  const ataProgramBytes = decodeToFixedSize$1(ASSOCIATED_TOKEN_PROGRAM_ID$1, 32);
  const systemProgramBytes = decodeToFixedSize$1(SYSTEM_PROGRAM_ID$1, 32);
  const blockhashBytes = decodeToFixedSize$1(blockhash, 32);
  const header = new Uint8Array([1, 0, 3]);
  const numAccounts = 7;
  const accountKeys = new Uint8Array(32 * numAccounts);
  accountKeys.set(payerBytes, 0);
  accountKeys.set(ataBytes, 32);
  accountKeys.set(ownerBytes, 64);
  accountKeys.set(mintBytes, 96);
  accountKeys.set(systemProgramBytes, 128);
  accountKeys.set(tokenProgramBytes, 160);
  accountKeys.set(ataProgramBytes, 192);
  const createATAInstruction = new Uint8Array([
    6,
    // program id index
    6,
    // number of accounts
    0,
    1,
    2,
    3,
    4,
    5,
    // account indices
    1,
    // data length
    1
    // instruction type 1 = CreateIdempotent
  ]);
  const messageLength = 3 + 1 + 32 * numAccounts + 32 + 1 + createATAInstruction.length;
  const message = new Uint8Array(messageLength);
  let offset = 0;
  message.set(header, offset);
  offset += 3;
  message[offset] = numAccounts;
  offset += 1;
  message.set(accountKeys, offset);
  offset += 32 * numAccounts;
  message.set(blockhashBytes, offset);
  offset += 32;
  message[offset] = 1;
  offset += 1;
  message.set(createATAInstruction, offset);
  return message;
}
async function deriveATAAddressStandard(owner, mint, tokenProgramId, rpcUrl = null, payer = null) {
  if (rpcUrl && payer) {
    try {
      logger$1.log("[ATA] Using RPC validation for ATA derivation");
      const address = await deriveATAAddressWithValidation(rpcUrl, owner, mint, tokenProgramId, payer);
      logger$1.log("[ATA] RPC validated address:", address);
      return address;
    } catch (e) {
      logger$1.error("[ATA] RPC validation failed:", e.message);
      throw new Error(`Failed to derive ATA address: ${e.message}`);
    }
  }
  logger$1.warn("[ATA] No RPC validation - using bump 255 (may be incorrect)");
  const result = await findATAAddress(owner, mint, tokenProgramId);
  return result.address;
}
function buildTokenTransferMessage({
  fromPubkey,
  fromTokenAccount,
  toTokenAccount,
  amount,
  recentBlockhash,
  tokenProgramId
}) {
  logger$1.log("[BUILD TX Simple] Checking accounts:");
  logger$1.log("  owner:", fromPubkey);
  logger$1.log("  source:", fromTokenAccount);
  logger$1.log("  dest:", toTokenAccount);
  logger$1.log("  program:", tokenProgramId);
  if (fromPubkey === fromTokenAccount) {
    throw new Error("Owner cannot be the same as source token account");
  }
  if (fromPubkey === toTokenAccount) {
    throw new Error("Owner cannot be the same as destination token account");
  }
  if (fromTokenAccount === toTokenAccount) {
    logger$1.log("[BUILD TX Simple] Self-transfer detected (same ATA), returning null for no-op");
    return null;
  }
  const ownerBytes = decodeToFixedSize$1(fromPubkey, 32);
  const sourceBytes = decodeToFixedSize$1(fromTokenAccount, 32);
  const destBytes = decodeToFixedSize$1(toTokenAccount, 32);
  const programBytes = decodeToFixedSize$1(tokenProgramId, 32);
  const blockhashBytes = decodeToFixedSize$1(recentBlockhash, 32);
  const header = new Uint8Array([1, 0, 1]);
  const accountKeys = new Uint8Array(32 * 4);
  accountKeys.set(ownerBytes, 0);
  accountKeys.set(sourceBytes, 32);
  accountKeys.set(destBytes, 64);
  accountKeys.set(programBytes, 96);
  const instructionData = new Uint8Array(9);
  instructionData[0] = 3;
  const amountBI = BigInt(amount);
  for (let i = 0; i < 8; i++) {
    instructionData[1 + i] = Number(amountBI >> BigInt(i * 8) & BigInt(255));
  }
  const instruction = new Uint8Array([
    3,
    3,
    1,
    2,
    0,
    9,
    ...instructionData
  ]);
  const messageLength = 3 + 1 + 128 + 32 + 1 + instruction.length;
  const message = new Uint8Array(messageLength);
  let offset = 0;
  message.set(header, offset);
  offset += 3;
  message[offset] = 4;
  offset += 1;
  message.set(accountKeys, offset);
  offset += 128;
  message.set(blockhashBytes, offset);
  offset += 32;
  message[offset] = 1;
  offset += 1;
  message.set(instruction, offset);
  return message;
}
function buildTokenTransferWithCreateATAMessage({
  fromPubkey,
  toPubkey,
  fromTokenAccount,
  toTokenAccount,
  mint,
  amount,
  recentBlockhash,
  tokenProgramId
}) {
  const payerBytes = decodeToFixedSize$1(fromPubkey, 32);
  const destOwnerBytes = decodeToFixedSize$1(toPubkey, 32);
  const sourceBytes = decodeToFixedSize$1(fromTokenAccount, 32);
  const destATABytes = decodeToFixedSize$1(toTokenAccount, 32);
  const mintBytes = decodeToFixedSize$1(mint, 32);
  const tokenProgramBytes = decodeToFixedSize$1(tokenProgramId, 32);
  const ataProgramBytes = decodeToFixedSize$1(ASSOCIATED_TOKEN_PROGRAM_ID$1, 32);
  const systemProgramBytes = decodeToFixedSize$1(SYSTEM_PROGRAM_ID$1, 32);
  const blockhashBytes = decodeToFixedSize$1(recentBlockhash, 32);
  const accounts = [
    { name: "payer", bytes: payerBytes, address: fromPubkey },
    { name: "destATA", bytes: destATABytes, address: toTokenAccount },
    { name: "source", bytes: sourceBytes, address: fromTokenAccount },
    { name: "destOwner", bytes: destOwnerBytes, address: toPubkey },
    { name: "mint", bytes: mintBytes, address: mint },
    { name: "system", bytes: systemProgramBytes, address: SYSTEM_PROGRAM_ID$1 },
    { name: "tokenProgram", bytes: tokenProgramBytes, address: tokenProgramId },
    { name: "ataProgram", bytes: ataProgramBytes, address: ASSOCIATED_TOKEN_PROGRAM_ID$1 }
  ];
  logger$1.log("[BUILD TX] Checking for duplicate accounts...");
  for (let i = 0; i < accounts.length; i++) {
    for (let j = i + 1; j < accounts.length; j++) {
      if (accounts[i].address === accounts[j].address) {
        logger$1.error(`[BUILD TX] DUPLICATE DETECTED: ${accounts[i].name} === ${accounts[j].name} === ${accounts[i].address}`);
        throw new Error(`Duplicate account detected: ${accounts[i].name} and ${accounts[j].name} are the same (${accounts[i].address})`);
      }
    }
  }
  logger$1.log("[BUILD TX] No duplicates found, building transaction...");
  const header = new Uint8Array([1, 0, 5]);
  const numAccounts = 8;
  const accountKeys = new Uint8Array(32 * numAccounts);
  accountKeys.set(payerBytes, 0);
  accountKeys.set(destATABytes, 32);
  accountKeys.set(sourceBytes, 64);
  accountKeys.set(destOwnerBytes, 96);
  accountKeys.set(mintBytes, 128);
  accountKeys.set(systemProgramBytes, 160);
  accountKeys.set(tokenProgramBytes, 192);
  accountKeys.set(ataProgramBytes, 224);
  const createATAInstruction = new Uint8Array([
    7,
    // program id index (ATA program)
    6,
    // number of accounts
    0,
    1,
    3,
    4,
    5,
    6,
    // account indices
    1,
    // data length
    1
    // instruction type 1 = CreateIdempotent
  ]);
  const transferData = new Uint8Array(9);
  transferData[0] = 3;
  const amountBI = BigInt(amount);
  for (let i = 0; i < 8; i++) {
    transferData[1 + i] = Number(amountBI >> BigInt(i * 8) & BigInt(255));
  }
  const transferInstruction = new Uint8Array([
    6,
    // program id index (token program)
    3,
    // number of accounts
    2,
    1,
    0,
    // source, dest, authority
    9,
    // data length
    ...transferData
  ]);
  const messageLength = 3 + 1 + 32 * numAccounts + 32 + 1 + createATAInstruction.length + transferInstruction.length;
  const message = new Uint8Array(messageLength);
  let offset = 0;
  message.set(header, offset);
  offset += 3;
  message[offset] = numAccounts;
  offset += 1;
  message.set(accountKeys, offset);
  offset += 32 * numAccounts;
  message.set(blockhashBytes, offset);
  offset += 32;
  message[offset] = 2;
  offset += 1;
  message.set(createATAInstruction, offset);
  offset += createATAInstruction.length;
  message.set(transferInstruction, offset);
  return message;
}
function buildTransferMessage(fromPubkey, toPubkey, lamports, recentBlockhash, priorityFee = 0) {
  const fromPubkeyBytes = decodeToFixedSize$1(fromPubkey, 32);
  const toPubkeyBytes = decodeToFixedSize$1(toPubkey, 32);
  const systemProgramBytes = decodeToFixedSize$1(SYSTEM_PROGRAM_ID$1, 32);
  const blockhashBytes = decodeToFixedSize$1(recentBlockhash, 32);
  if (!priorityFee || priorityFee <= 0) {
    const header2 = new Uint8Array([1, 0, 1]);
    const accountKeys2 = new Uint8Array(32 * 3);
    accountKeys2.set(fromPubkeyBytes, 0);
    accountKeys2.set(toPubkeyBytes, 32);
    accountKeys2.set(systemProgramBytes, 64);
    const instructionData = new Uint8Array(12);
    instructionData[0] = 2;
    const lamportsBI2 = BigInt(lamports);
    for (let i = 0; i < 8; i++) {
      instructionData[4 + i] = Number(lamportsBI2 >> BigInt(i * 8) & BigInt(255));
    }
    const instruction = new Uint8Array([
      2,
      2,
      0,
      1,
      12,
      ...instructionData
    ]);
    const messageLength2 = 3 + 1 + 96 + 32 + 1 + instruction.length;
    const message2 = new Uint8Array(messageLength2);
    let offset2 = 0;
    message2.set(header2, offset2);
    offset2 += 3;
    message2[offset2] = 3;
    offset2 += 1;
    message2.set(accountKeys2, offset2);
    offset2 += 96;
    message2.set(blockhashBytes, offset2);
    offset2 += 32;
    message2[offset2] = 1;
    offset2 += 1;
    message2.set(instruction, offset2);
    return message2;
  }
  const computeBudgetProgramBytes = decodeToFixedSize$1(COMPUTE_BUDGET_PROGRAM_ID, 32);
  const header = new Uint8Array([1, 0, 2]);
  const accountKeys = new Uint8Array(32 * 4);
  accountKeys.set(fromPubkeyBytes, 0);
  accountKeys.set(toPubkeyBytes, 32);
  accountKeys.set(computeBudgetProgramBytes, 64);
  accountKeys.set(systemProgramBytes, 96);
  const priorityInstData = new Uint8Array(9);
  priorityInstData[0] = 3;
  const priorityBI = BigInt(priorityFee);
  for (let i = 0; i < 8; i++) {
    priorityInstData[1 + i] = Number(priorityBI >> BigInt(i * 8) & BigInt(255));
  }
  const priorityInst = new Uint8Array([
    2,
    // program_id_index (ComputeBudget at index 2)
    0,
    // accounts length
    9,
    // data length
    ...priorityInstData
  ]);
  const transferInstData = new Uint8Array(12);
  transferInstData[0] = 2;
  const lamportsBI = BigInt(lamports);
  for (let i = 0; i < 8; i++) {
    transferInstData[4 + i] = Number(lamportsBI >> BigInt(i * 8) & BigInt(255));
  }
  const transferInst = new Uint8Array([
    3,
    // program_id_index (System at index 3)
    2,
    // accounts length
    0,
    // account index 0 (from)
    1,
    // account index 1 (to)
    12,
    // data length
    ...transferInstData
  ]);
  const messageLength = 3 + 1 + 128 + 32 + 1 + priorityInst.length + transferInst.length;
  const message = new Uint8Array(messageLength);
  let offset = 0;
  message.set(header, offset);
  offset += 3;
  message[offset] = 4;
  offset += 1;
  message.set(accountKeys, offset);
  offset += 128;
  message.set(blockhashBytes, offset);
  offset += 32;
  message[offset] = 2;
  offset += 1;
  message.set(priorityInst, offset);
  offset += priorityInst.length;
  message.set(transferInst, offset);
  return message;
}
function buildTokenTransferMessageForHardware({
  fromPubkey,
  toPubkey,
  fromTokenAccount,
  toTokenAccount,
  mint,
  amount,
  recentBlockhash,
  tokenProgramId,
  needsCreateATA = false
}) {
  if (needsCreateATA) {
    return buildTokenTransferWithCreateATAMessage({
      fromPubkey,
      toPubkey,
      fromTokenAccount,
      toTokenAccount,
      mint,
      amount,
      recentBlockhash,
      tokenProgramId: tokenProgramId || TOKEN_PROGRAM_ID$3
    });
  } else {
    return buildTokenTransferMessage({
      fromPubkey,
      fromTokenAccount,
      toTokenAccount,
      amount,
      recentBlockhash,
      tokenProgramId: tokenProgramId || TOKEN_PROGRAM_ID$3
    });
  }
}
function serializeTransaction(signature, message) {
  const tx = new Uint8Array(1 + 64 + message.length);
  tx[0] = 1;
  tx.set(signature, 1);
  tx.set(message, 65);
  return tx;
}
function getTransactionHistory(walletAddress, network, sortOrder = "desc") {
  try {
    const all = JSON.parse(localStorage.getItem("x1wallet_transactions") || "[]");
    const filtered = all.filter((tx) => {
      const matchesWallet = tx.walletAddress === walletAddress || tx.from === walletAddress || tx.to === walletAddress;
      const matchesNetwork = !network || tx.network === network;
      return matchesWallet && matchesNetwork;
    });
    if (sortOrder === "asc") {
      return filtered.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
    }
    return filtered.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
  } catch {
    return [];
  }
}
function addTransaction(tx) {
  try {
    if (!tx.walletAddress && tx.from) {
      tx.walletAddress = tx.from;
    }
    const history = JSON.parse(localStorage.getItem("x1wallet_transactions") || "[]");
    history.unshift(tx);
    localStorage.setItem("x1wallet_transactions", JSON.stringify(history.slice(0, 100)));
  } catch (e) {
    logger$1.error("Failed to save transaction:", e);
  }
}
function formatTransaction(tx) {
  let ts = tx.rawTimestamp || tx.timestamp || 0;
  if (ts > 0 && ts < 4102444800) {
    ts = ts * 1e3;
  }
  const date = new Date(ts);
  const now = /* @__PURE__ */ new Date();
  let dateStr;
  if (ts === 0 || isNaN(date.getTime())) {
    dateStr = "";
  } else {
    const timeStr = date.toLocaleTimeString("en-US", {
      hour: "numeric",
      minute: "2-digit",
      hour12: true
    });
    const isToday = date.toDateString() === now.toDateString();
    const isYesterday = date.toDateString() === new Date(now - 864e5).toDateString();
    if (isToday) {
      dateStr = `Today  ${timeStr}`;
    } else if (isYesterday) {
      dateStr = `Yesterday  ${timeStr}`;
    } else {
      const dateOnlyStr = date.toLocaleDateString("en-US", {
        month: "short",
        day: "numeric",
        year: date.getFullYear() !== now.getFullYear() ? "numeric" : void 0
      });
      dateStr = `${dateOnlyStr}  ${timeStr}`;
    }
  }
  return {
    ...tx,
    timestamp: ts,
    rawTimestamp: ts,
    dateStr,
    timeStr: date.toLocaleTimeString(),
    shortSignature: tx.signature ? `${tx.signature.slice(0, 8)}...${tx.signature.slice(-8)}` : "",
    shortFrom: tx.from ? `${tx.from.slice(0, 6)}...${tx.from.slice(-4)}` : "",
    shortTo: tx.to ? `${tx.to.slice(0, 6)}...${tx.to.slice(-4)}` : ""
  };
}
async function fetchBlockchainTransactions(rpcUrl, walletAddress, limit = 20, network = "") {
  var _a2;
  try {
    const sigResponse = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "getSignaturesForAddress",
        params: [walletAddress, { limit }]
      })
    });
    const sigData = await sigResponse.json();
    if (sigData.error || !((_a2 = sigData.result) == null ? void 0 : _a2.length)) return [];
    const signatures = sigData.result.slice(0, 10);
    const txPromises = signatures.map(
      (sig) => fetch(rpcUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "getTransaction",
          params: [sig.signature, { encoding: "jsonParsed", maxSupportedTransactionVersion: 0 }]
        })
      }).then((r2) => r2.json()).catch(() => null)
    );
    const txResults = await Promise.all(txPromises);
    const transactions = [];
    const mintsToLookup = /* @__PURE__ */ new Set();
    for (let i = 0; i < txResults.length; i++) {
      const txData = txResults[i];
      if (txData == null ? void 0 : txData.result) {
        const parsedTx = parseTransaction(txData.result, walletAddress, signatures[i].signature, network);
        if (parsedTx) {
          transactions.push(parsedTx);
          if (parsedTx.tokenMint && parsedTx.symbol === "Token") {
            mintsToLookup.add(parsedTx.tokenMint);
          }
          if (parsedTx.toTokenMint && parsedTx.toSymbol === "Token") {
            mintsToLookup.add(parsedTx.toTokenMint);
          }
        }
      }
    }
    if (mintsToLookup.size > 0) {
      try {
        const { fetchTokenMetadataFromAPI: fetchTokenMetadataFromAPI2, fetchToken2022Metadata: fetchToken2022Metadata2 } = await __vitePreload(async () => {
          const { fetchTokenMetadataFromAPI: fetchTokenMetadataFromAPI3, fetchToken2022Metadata: fetchToken2022Metadata3 } = await Promise.resolve().then(() => tokens);
          return { fetchTokenMetadataFromAPI: fetchTokenMetadataFromAPI3, fetchToken2022Metadata: fetchToken2022Metadata3 };
        }, true ? void 0 : void 0);
        const mintArray = Array.from(mintsToLookup);
        logger$1.log("[fetchBlockchainTransactions] Looking up symbols for", mintArray.length, "mints");
        const mintSymbols = {};
        for (const mint of mintArray) {
          let symbol = null;
          try {
            const apiResult = await fetchTokenMetadataFromAPI2(mint);
            if (apiResult == null ? void 0 : apiResult.symbol) {
              symbol = apiResult.symbol;
              logger$1.log("[fetchBlockchainTransactions] API found:", mint.slice(0, 8), "->", symbol);
            }
          } catch (e) {
          }
          if (!symbol) {
            try {
              const t22Metadata = await fetchToken2022Metadata2(rpcUrl, mint);
              if (t22Metadata == null ? void 0 : t22Metadata.symbol) {
                symbol = t22Metadata.symbol;
                logger$1.log("[fetchBlockchainTransactions] Token2022 found:", mint.slice(0, 8), "->", symbol);
              }
            } catch (e) {
            }
          }
          if (!symbol) {
            symbol = mint.slice(0, 4) + ".." + mint.slice(-3);
            logger$1.log("[fetchBlockchainTransactions] Using fallback for:", mint.slice(0, 8));
          }
          mintSymbols[mint] = symbol;
        }
        for (const tx of transactions) {
          if (tx.tokenMint && mintSymbols[tx.tokenMint]) {
            tx.symbol = mintSymbols[tx.tokenMint];
          }
          if (tx.toTokenMint && mintSymbols[tx.toTokenMint]) {
            tx.toSymbol = mintSymbols[tx.toTokenMint];
          }
        }
      } catch (e) {
        logger$1.warn("[fetchBlockchainTransactions] Failed to fetch token metadata:", e.message);
        for (const tx of transactions) {
          if (tx.tokenMint && tx.symbol === "Token") {
            tx.symbol = tx.tokenMint.slice(0, 4) + ".." + tx.tokenMint.slice(-3);
          }
          if (tx.toTokenMint && tx.toSymbol === "Token") {
            tx.toSymbol = tx.toTokenMint.slice(0, 4) + ".." + tx.toTokenMint.slice(-3);
          }
        }
      }
    }
    return transactions.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
  } catch (e) {
    logger$1.error("Failed to fetch transactions:", e);
    return [];
  }
}
function getNativeSymbol(network) {
  if (!network) return "XNT";
  const networkLower = network.toLowerCase();
  if (networkLower.includes("x1")) return "XNT";
  if (networkLower.includes("solana")) return "SOL";
  return "XNT";
}
function parseTransaction(txData, walletAddress, signature, network = "") {
  var _a2, _b2, _c, _d, _e, _f, _g;
  try {
    const meta = txData.meta;
    const message = (_a2 = txData.transaction) == null ? void 0 : _a2.message;
    if (!meta || !message) return null;
    const preBalances = meta.preBalances || [];
    const postBalances = meta.postBalances || [];
    const accountKeys = message.accountKeys || [];
    const nativeSymbol = getNativeSymbol(network);
    let walletIndex = -1;
    for (let i = 0; i < accountKeys.length; i++) {
      const key = typeof accountKeys[i] === "string" ? accountKeys[i] : accountKeys[i].pubkey;
      if (key === walletAddress) {
        walletIndex = i;
        break;
      }
    }
    const preTokenBalances = meta.preTokenBalances || [];
    const postTokenBalances = meta.postTokenBalances || [];
    const tokenChanges = [];
    for (const post of postTokenBalances) {
      const isOurToken = post.owner === walletAddress;
      if (!isOurToken) continue;
      const pre = preTokenBalances.find(
        (p2) => p2.mint === post.mint && (p2.owner === walletAddress || p2.accountIndex === post.accountIndex)
      );
      const preAmount = parseFloat((_b2 = pre == null ? void 0 : pre.uiTokenAmount) == null ? void 0 : _b2.uiAmount) || 0;
      const postAmount = parseFloat((_c = post.uiTokenAmount) == null ? void 0 : _c.uiAmount) || 0;
      const change = postAmount - preAmount;
      if (Math.abs(change) > 1e-7) {
        tokenChanges.push({
          mint: post.mint,
          change,
          amount: Math.abs(change),
          decimals: ((_d = post.uiTokenAmount) == null ? void 0 : _d.decimals) || 9,
          symbol: null,
          isNative: false
        });
      }
    }
    for (const pre of preTokenBalances) {
      if (pre.owner !== walletAddress) continue;
      const existsInPost = postTokenBalances.some((p2) => p2.mint === pre.mint && p2.owner === walletAddress);
      if (!existsInPost) {
        const preAmount = parseFloat((_e = pre.uiTokenAmount) == null ? void 0 : _e.uiAmount) || 0;
        if (preAmount > 1e-7) {
          tokenChanges.push({
            mint: pre.mint,
            change: -preAmount,
            amount: preAmount,
            decimals: ((_f = pre.uiTokenAmount) == null ? void 0 : _f.decimals) || 9,
            symbol: null,
            isNative: false
          });
        }
      }
    }
    if (walletIndex >= 0 && preBalances.length > walletIndex && postBalances.length > walletIndex) {
      const preNative = (preBalances[walletIndex] || 0) / 1e9;
      const postNative = (postBalances[walletIndex] || 0) / 1e9;
      const fee = (meta.fee || 0) / 1e9;
      const nativeChange = postNative - preNative + fee;
      if (Math.abs(nativeChange) > 1e-4) {
        tokenChanges.push({
          mint: "native",
          change: nativeChange,
          amount: Math.abs(nativeChange),
          decimals: 9,
          symbol: nativeSymbol,
          isNative: true
        });
      }
    }
    const sentTokens = tokenChanges.filter((t2) => t2.change < 0).sort((a, b) => b.amount - a.amount);
    const receivedTokens = tokenChanges.filter((t2) => t2.change > 0).sort((a, b) => b.amount - a.amount);
    const sent = sentTokens[0];
    const received = receivedTokens[0];
    const isSameTokenInOut = sent && received && (sent.isNative && received.isNative || sent.mint === received.mint);
    const netGain = received && sent ? received.amount - sent.amount : 0;
    const isLikelyReward = isSameTokenInOut && netGain > 0;
    const isSwap = sentTokens.length > 0 && receivedTokens.length > 0 && !isLikelyReward;
    const instructions = message.instructions || [];
    const innerInstructions = meta.innerInstructions || [];
    const simplePrograms = [
      "11111111111111111111111111111111",
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
      "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
      "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
      "ComputeBudget111111111111111111111111111111"
    ];
    let dappProgram = null;
    if (instructions.length > 2 || innerInstructions.length > 0) {
      for (const inst of instructions) {
        const programId = inst.programId || (typeof inst.program === "string" ? inst.program : (_g = inst.program) == null ? void 0 : _g.pubkey);
        if (programId && !simplePrograms.includes(programId)) {
          dappProgram = programId;
          break;
        }
      }
    }
    const baseTx = {
      signature,
      timestamp: txData.blockTime ? txData.blockTime * 1e3 : Date.now(),
      rawTimestamp: txData.blockTime ? txData.blockTime * 1e3 : Date.now(),
      status: meta.err ? "failed" : "confirmed",
      fee: (meta.fee || 0) / 1e9,
      source: "blockchain",
      dappProgram
    };
    if (isLikelyReward) {
      let symbol = received.isNative ? nativeSymbol : null;
      if (!symbol && received.decimals === 6) symbol = "USDC";
      if (!symbol) symbol = "Token";
      return {
        ...baseTx,
        type: "reward",
        isReward: true,
        amount: netGain,
        // Show NET gain, not gross amounts
        symbol,
        tokenMint: received.mint !== "native" ? received.mint : null,
        from: "",
        to: walletAddress,
        description: `Reward: +${netGain.toFixed(4)} ${symbol} (received ${received.amount.toFixed(4)}, fee ${sent.amount.toFixed(4)})`
      };
    }
    if (isSwap) {
      let sentSymbol = sent.isNative ? nativeSymbol : null;
      if (!sentSymbol && sent.decimals === 6) sentSymbol = "USDC";
      if (!sentSymbol && sent.decimals === 9) sentSymbol = "Token";
      if (!sentSymbol) sentSymbol = "Token";
      let receivedSymbol = received.isNative ? nativeSymbol : null;
      if (!receivedSymbol && received.decimals === 6) receivedSymbol = "USDC";
      if (!receivedSymbol && received.decimals === 9) receivedSymbol = "Token";
      if (!receivedSymbol) receivedSymbol = "Token";
      return {
        ...baseTx,
        type: "swap",
        isSwap: true,
        amount: sent.amount,
        symbol: sentSymbol,
        tokenMint: sent.mint !== "native" ? sent.mint : null,
        toAmount: received.amount,
        toSymbol: receivedSymbol,
        toTokenMint: received.mint !== "native" ? received.mint : null,
        from: walletAddress,
        to: walletAddress
      };
    }
    if (sent && !received) {
      let symbol = sent.isNative ? nativeSymbol : null;
      if (!symbol && sent.decimals === 6) symbol = "USDC";
      if (!symbol) symbol = "Token";
      return {
        ...baseTx,
        type: dappProgram ? "dapp" : "send",
        isDappInteraction: !!dappProgram,
        amount: sent.amount,
        symbol,
        tokenMint: sent.mint !== "native" ? sent.mint : null,
        from: walletAddress,
        to: ""
      };
    }
    if (received && !sent) {
      let symbol = received.isNative ? nativeSymbol : null;
      if (!symbol && received.decimals === 6) symbol = "USDC";
      if (!symbol) symbol = "Token";
      return {
        ...baseTx,
        type: dappProgram ? "dapp" : "receive",
        isDappInteraction: !!dappProgram,
        amount: received.amount,
        symbol,
        tokenMint: received.mint !== "native" ? received.mint : null,
        from: "",
        to: walletAddress
      };
    }
    if (walletIndex >= 0) {
      const balanceChange = (postBalances[walletIndex] || 0) - (preBalances[walletIndex] || 0);
      if (Math.abs(balanceChange) > 0) {
        const isSend = balanceChange < 0;
        return {
          ...baseTx,
          type: dappProgram ? "dapp" : isSend ? "send" : "receive",
          isDappInteraction: !!dappProgram,
          amount: Math.abs(balanceChange) / 1e9,
          symbol: nativeSymbol,
          from: isSend ? walletAddress : "",
          to: isSend ? "" : walletAddress
        };
      }
    }
    return null;
  } catch (e) {
    logger$1.warn("[ParseTx] Error parsing transaction:", e);
    return null;
  }
}
async function modifyTransactionPriorityFee(messageBytes, priorityMicroLamports, rpcUrl) {
  var _a2, _b2;
  try {
    const isVersioned = messageBytes[0] === 128;
    let offset = isVersioned ? 1 : 0;
    const numRequiredSigs = messageBytes[offset];
    const numReadonlySigned = messageBytes[offset + 1];
    const numReadonlyUnsigned = messageBytes[offset + 2];
    offset += 3;
    const numAccountKeys = messageBytes[offset];
    offset += 1;
    let computeBudgetIndex = -1;
    const computeBudgetPubkey = decodeBase58(COMPUTE_BUDGET_PROGRAM_ID);
    for (let i = 0; i < numAccountKeys; i++) {
      const keyStart = offset + i * 32;
      const key = messageBytes.slice(keyStart, keyStart + 32);
      let match = true;
      for (let j = 0; j < 32; j++) {
        if (key[j] !== computeBudgetPubkey[j]) {
          match = false;
          break;
        }
      }
      if (match) {
        computeBudgetIndex = i;
        break;
      }
    }
    if (computeBudgetIndex === -1) {
      logger$1.log("[Priority Fee] ComputeBudget program not found in transaction");
      return messageBytes;
    }
    offset += numAccountKeys * 32;
    const blockhashOffset = offset;
    offset += 32;
    const numInstructions = messageBytes[offset];
    offset += 1;
    for (let i = 0; i < numInstructions; i++) {
      const programIndex = messageBytes[offset];
      offset += 1;
      const numAccounts = messageBytes[offset];
      offset += 1;
      offset += numAccounts;
      const dataLen = messageBytes[offset];
      offset += 1;
      if (programIndex === computeBudgetIndex && dataLen === 9 && messageBytes[offset] === 3) {
        logger$1.log("[Priority Fee] Found SetComputeUnitPrice at offset", offset);
        const modifiedMessage = new Uint8Array(messageBytes);
        const feeBytes = new BigUint64Array([BigInt(priorityMicroLamports)]);
        const feeView = new Uint8Array(feeBytes.buffer);
        for (let j = 0; j < 8; j++) {
          modifiedMessage[offset + 1 + j] = feeView[j];
        }
        logger$1.log("[Priority Fee] Updated priority fee to", priorityMicroLamports, "microlamports");
        const blockhashResponse = await fetch(rpcUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            jsonrpc: "2.0",
            id: 1,
            method: "getLatestBlockhash",
            params: [{ commitment: "finalized" }]
          })
        });
        const blockhashResult = await blockhashResponse.json();
        if ((_b2 = (_a2 = blockhashResult.result) == null ? void 0 : _a2.value) == null ? void 0 : _b2.blockhash) {
          const newBlockhash = decodeBase58(blockhashResult.result.value.blockhash);
          for (let j = 0; j < 32; j++) {
            modifiedMessage[blockhashOffset + j] = newBlockhash[j];
          }
          logger$1.log("[Priority Fee] Updated blockhash");
        }
        return modifiedMessage;
      }
      offset += dataLen;
    }
    logger$1.log("[Priority Fee] SetComputeUnitPrice instruction not found");
    return messageBytes;
  } catch (error) {
    logger$1.error("[Priority Fee] Error modifying priority fee:", error);
    return messageBytes;
  }
}
async function signAndSendExternalTransaction(transactionBase64, privateKey, rpcUrl, priorityMicroLamports = 0) {
  try {
    logger$1.log("[Swap TX] Starting to sign external transaction");
    if (typeof privateKey === "string" && privateKey.includes(" ")) {
      throw new Error("Invalid private key format - expected base58 encoded key");
    }
    let secretKey;
    if (typeof privateKey === "string") {
      secretKey = decodeBase58(privateKey);
    } else {
      secretKey = privateKey;
    }
    if (secretKey.length !== 64) {
      throw new Error(`Invalid secret key length: ${secretKey.length}, expected 64`);
    }
    if (!transactionBase64 || typeof transactionBase64 !== "string") {
      throw new Error("Transaction data is missing or invalid");
    }
    logger$1.log("[Swap TX] Transaction base64 length:", transactionBase64.length);
    logger$1.log("[Swap TX] Transaction base64 preview:", transactionBase64.substring(0, 50) + "...");
    let cleanedBase64 = transactionBase64.replace(/-/g, "+").replace(/_/g, "/");
    cleanedBase64 = cleanedBase64.replace(/\s/g, "");
    const paddingNeeded = (4 - cleanedBase64.length % 4) % 4;
    cleanedBase64 += "=".repeat(paddingNeeded);
    const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
    if (!base64Regex.test(cleanedBase64)) {
      logger$1.error("[Swap TX] Invalid base64 characters detected");
      const invalidChars = cleanedBase64.match(/[^A-Za-z0-9+/=]/g);
      if (invalidChars) {
        logger$1.error("[Swap TX] Invalid characters:", [...new Set(invalidChars)].join(", "));
      }
      throw new Error("Transaction contains invalid base64 encoding");
    }
    let txBytes;
    try {
      txBytes = Uint8Array.from(atob(cleanedBase64), (c) => c.charCodeAt(0));
    } catch (atobError) {
      logger$1.error("[Swap TX] atob failed:", atobError.message);
      throw new Error("Failed to decode transaction: Invalid base64 encoding");
    }
    logger$1.log("[Swap TX] Decoded transaction:", txBytes.length, "bytes");
    const numSignatures = txBytes[0];
    logger$1.log("[Swap TX] Number of signatures:", numSignatures);
    const messageOffset = 1 + numSignatures * 64;
    let message = txBytes.slice(messageOffset);
    logger$1.log("[Swap TX] Message length:", message.length, "bytes");
    if (priorityMicroLamports > 0) {
      logger$1.log("[Swap TX] Modifying priority fee to", priorityMicroLamports, "microlamports");
      message = await modifyTransactionPriorityFee(message, priorityMicroLamports, rpcUrl);
    }
    const signature = await sign$1(message, secretKey);
    logger$1.log("[Swap TX] Signature generated");
    const signedTx = new Uint8Array(1 + 64 + message.length);
    signedTx[0] = 1;
    signedTx.set(signature, 1);
    signedTx.set(message, 65);
    const signedTxBase64 = btoa(String.fromCharCode(...signedTx));
    logger$1.log("[Swap TX] Signed transaction ready");
    const response = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "sendTransaction",
        params: [
          signedTxBase64,
          {
            encoding: "base64",
            skipPreflight: false,
            preflightCommitment: "confirmed"
          }
        ]
      })
    });
    const result = await response.json();
    logger$1.log("[Swap TX] Send result:", result);
    if (result.error) {
      throw new Error(result.error.message || JSON.stringify(result.error));
    }
    return result.result;
  } catch (error) {
    logger$1.error("[Swap TX] Error:", error);
    throw error;
  }
}
async function signAndSendExternalTransactionHardware(transactionBase64, hardwareWallet2, rpcUrl, derivationPath = null, priorityMicroLamports = 0) {
  try {
    logger$1.log("[Swap TX HW] Starting to sign external transaction with hardware wallet");
    logger$1.log("[Swap TX HW] Using derivation path:", derivationPath);
    if (!transactionBase64 || typeof transactionBase64 !== "string") {
      throw new Error("Transaction data is missing or invalid");
    }
    logger$1.log("[Swap TX HW] Transaction base64 length:", transactionBase64.length);
    let cleanedBase64 = transactionBase64.replace(/-/g, "+").replace(/_/g, "/");
    cleanedBase64 = cleanedBase64.replace(/\s/g, "");
    const paddingNeeded = (4 - cleanedBase64.length % 4) % 4;
    cleanedBase64 += "=".repeat(paddingNeeded);
    const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
    if (!base64Regex.test(cleanedBase64)) {
      throw new Error("Transaction contains invalid base64 encoding");
    }
    let txBytes;
    try {
      txBytes = Uint8Array.from(atob(cleanedBase64), (c) => c.charCodeAt(0));
    } catch (atobError) {
      throw new Error("Failed to decode transaction: Invalid base64 encoding");
    }
    logger$1.log("[Swap TX HW] Decoded transaction:", txBytes.length, "bytes");
    const numSignatures = txBytes[0];
    logger$1.log("[Swap TX HW] Number of signatures:", numSignatures);
    const messageOffset = 1 + numSignatures * 64;
    let message = txBytes.slice(messageOffset);
    logger$1.log("[Swap TX HW] Message length:", message.length, "bytes");
    if (priorityMicroLamports > 0) {
      logger$1.log("[Swap TX HW] Modifying priority fee to", priorityMicroLamports, "microlamports");
      message = await modifyTransactionPriorityFee(message, priorityMicroLamports, rpcUrl);
    }
    const signature = await hardwareWallet2.signTransaction(message, derivationPath);
    logger$1.log("[Swap TX HW] Signature generated via hardware wallet");
    const signedTx = new Uint8Array(1 + 64 + message.length);
    signedTx[0] = 1;
    signedTx.set(signature, 1);
    signedTx.set(message, 65);
    const signedTxBase64 = btoa(String.fromCharCode(...signedTx));
    logger$1.log("[Swap TX HW] Signed transaction ready");
    const response = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "sendTransaction",
        params: [
          signedTxBase64,
          {
            encoding: "base64",
            skipPreflight: false,
            preflightCommitment: "confirmed"
          }
        ]
      })
    });
    const result = await response.json();
    logger$1.log("[Swap TX HW] Send result:", result);
    if (result.error) {
      throw new Error(result.error.message || JSON.stringify(result.error));
    }
    return result.result;
  } catch (error) {
    logger$1.error("[Swap TX HW] Error:", error);
    throw error;
  }
}
function buildTransaction({ feePayer, recentBlockhash, instructions }) {
  logger$1.log("[BuildTx] Params received - feePayer:", feePayer);
  logger$1.log("[BuildTx] Params received - recentBlockhash:", recentBlockhash);
  logger$1.log("[BuildTx] Params received - instructions:", instructions);
  if (!instructions || !Array.isArray(instructions)) {
    throw new Error("Instructions must be an array");
  }
  if (!feePayer) {
    throw new Error("Fee payer is required");
  }
  if (!recentBlockhash) {
    throw new Error("Recent blockhash is required");
  }
  logger$1.log("[BuildTx] Building transaction with", instructions.length, "instructions");
  const accountMap = /* @__PURE__ */ new Map();
  accountMap.set(feePayer, { isSigner: true, isWritable: true });
  for (const instruction of instructions) {
    for (const key of instruction.keys) {
      const pubkey = key.pubkey;
      const existing = accountMap.get(pubkey);
      if (existing) {
        existing.isSigner = existing.isSigner || key.isSigner;
        existing.isWritable = existing.isWritable || key.isWritable;
      } else {
        accountMap.set(pubkey, { isSigner: key.isSigner, isWritable: key.isWritable });
      }
    }
    if (!accountMap.has(instruction.programId)) {
      accountMap.set(instruction.programId, { isSigner: false, isWritable: false });
    }
  }
  const accounts = Array.from(accountMap.entries()).map(([pubkey, flags]) => ({
    pubkey,
    ...flags
  }));
  accounts.sort((a, b) => {
    if (a.isSigner !== b.isSigner) return a.isSigner ? -1 : 1;
    if (a.isWritable !== b.isWritable) return a.isWritable ? -1 : 1;
    return 0;
  });
  const feePayerIndex = accounts.findIndex((a) => a.pubkey === feePayer);
  if (feePayerIndex > 0) {
    const [fp] = accounts.splice(feePayerIndex, 1);
    accounts.unshift(fp);
  }
  logger$1.log("[BuildTx] Account count:", accounts.length);
  const numSigners = accounts.filter((a) => a.isSigner).length;
  const numReadOnlySigners = accounts.filter((a) => a.isSigner && !a.isWritable).length;
  const numReadOnlyNonSigners = accounts.filter((a) => !a.isSigner && !a.isWritable).length;
  const accountKeyBytes = [];
  for (const account of accounts) {
    accountKeyBytes.push(decodeToFixedSize$1(account.pubkey, 32));
  }
  const compiledInstructions = [];
  for (const instruction of instructions) {
    const programIdIndex = accounts.findIndex((a) => a.pubkey === instruction.programId);
    const accountIndexes = instruction.keys.map((k2) => accounts.findIndex((a) => a.pubkey === k2.pubkey));
    compiledInstructions.push({
      programIdIndex,
      accountIndexes,
      data: instruction.data
    });
  }
  const header = new Uint8Array([numSigners, numReadOnlySigners, numReadOnlyNonSigners]);
  const accountKeysBuffer = new Uint8Array(accounts.length * 32);
  for (let i = 0; i < accounts.length; i++) {
    accountKeysBuffer.set(accountKeyBytes[i], i * 32);
  }
  const blockhashBytes = decodeToFixedSize$1(recentBlockhash, 32);
  const instructionBuffers = [];
  for (const ci2 of compiledInstructions) {
    const progIndex = new Uint8Array([ci2.programIdIndex]);
    const accountsLen = encodeCompactU16(ci2.accountIndexes.length);
    const accountIndexBytes = new Uint8Array(ci2.accountIndexes);
    const dataLen = encodeCompactU16(ci2.data.length);
    const dataBytes = ci2.data;
    instructionBuffers.push(progIndex, accountsLen, accountIndexBytes, dataLen, dataBytes);
  }
  const numAccountsCompact = encodeCompactU16(accounts.length);
  const numInstructionsCompact = encodeCompactU16(compiledInstructions.length);
  const totalLength = header.length + numAccountsCompact.length + accountKeysBuffer.length + blockhashBytes.length + numInstructionsCompact.length + instructionBuffers.reduce((sum, b) => sum + b.length, 0);
  const message = new Uint8Array(totalLength);
  let offset = 0;
  message.set(header, offset);
  offset += header.length;
  message.set(numAccountsCompact, offset);
  offset += numAccountsCompact.length;
  message.set(accountKeysBuffer, offset);
  offset += accountKeysBuffer.length;
  message.set(blockhashBytes, offset);
  offset += blockhashBytes.length;
  message.set(numInstructionsCompact, offset);
  offset += numInstructionsCompact.length;
  for (const buf of instructionBuffers) {
    message.set(buf, offset);
    offset += buf.length;
  }
  logger$1.log("[BuildTx] Message built, length:", message.length);
  return message;
}
async function signTransaction(message, privateKey) {
  logger$1.log("[SignTx] Signing transaction");
  let secretKey;
  if (typeof privateKey === "string") {
    secretKey = decodeBase58(privateKey);
  } else {
    secretKey = privateKey;
  }
  if (secretKey.length !== 64) {
    throw new Error(`Invalid secret key length: ${secretKey.length}, expected 64`);
  }
  const signature = await sign$1(message, secretKey);
  const signedTx = new Uint8Array(1 + 64 + message.length);
  signedTx[0] = 1;
  signedTx.set(signature, 1);
  signedTx.set(message, 65);
  logger$1.log("[SignTx] Signed transaction ready, length:", signedTx.length);
  return signedTx;
}
async function sendTransaction(signedTx, rpcUrl) {
  logger$1.log("[SendTx] Sending transaction to", rpcUrl);
  const txBase64 = btoa(String.fromCharCode(...signedTx));
  const response = await fetch(rpcUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: 1,
      method: "sendTransaction",
      params: [
        txBase64,
        {
          encoding: "base64",
          skipPreflight: false,
          preflightCommitment: "confirmed"
        }
      ]
    })
  });
  const result = await response.json();
  logger$1.log("[SendTx] Result:", result);
  if (result.error) {
    throw new Error(result.error.message || JSON.stringify(result.error));
  }
  return result.result;
}
const NATIVE_MINT = "So11111111111111111111111111111111111111112";
async function createWrapTransaction({ owner, amount, rpcUrl, privateKey }) {
  var _a2, _b2, _c;
  logger$1.log("[Wrap] Creating wrap transaction for", amount, "native tokens");
  try {
    const lamports = Math.floor(amount * 1e9);
    const blockhashResponse = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "getLatestBlockhash",
        params: [{ commitment: "confirmed" }]
      })
    });
    const blockhashResult = await blockhashResponse.json();
    if (blockhashResult.error) {
      throw new Error("Blockhash error: " + (blockhashResult.error.message || JSON.stringify(blockhashResult.error)));
    }
    const recentBlockhash = blockhashResult.result.value.blockhash;
    logger$1.log("[Wrap] Got blockhash:", recentBlockhash);
    let ataAddress;
    try {
      const tokenAccountsResponse = await fetch(rpcUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "getTokenAccountsByOwner",
          params: [
            owner,
            { mint: NATIVE_MINT },
            { encoding: "jsonParsed" }
          ]
        })
      });
      const tokenAccountsResult = await tokenAccountsResponse.json();
      if (((_b2 = (_a2 = tokenAccountsResult.result) == null ? void 0 : _a2.value) == null ? void 0 : _b2.length) > 0) {
        ataAddress = tokenAccountsResult.result.value[0].pubkey;
        logger$1.log("[Wrap] Found existing ATA:", ataAddress);
      }
    } catch (e) {
      logger$1.log("[Wrap] Could not query token accounts:", e == null ? void 0 : e.message);
    }
    if (!ataAddress) {
      ataAddress = await deriveATAAddressStandard(owner, NATIVE_MINT, TOKEN_PROGRAM_ID$3);
      logger$1.log("[Wrap] Derived ATA address:", ataAddress);
    }
    const ataInfoResponse = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "getAccountInfo",
        params: [ataAddress, { encoding: "base64" }]
      })
    });
    const ataInfoResult = await ataInfoResponse.json();
    const ataExists = ((_c = ataInfoResult.result) == null ? void 0 : _c.value) !== null;
    logger$1.log("[Wrap] ATA exists:", ataExists);
    const ownerKey = decodeToFixedSize$1(owner, 32);
    const nativeMintKey = decodeToFixedSize$1(NATIVE_MINT, 32);
    const ataKey = decodeToFixedSize$1(ataAddress, 32);
    const tokenProgramKey = decodeToFixedSize$1(TOKEN_PROGRAM_ID$3, 32);
    const systemProgramKey = decodeToFixedSize$1(SYSTEM_PROGRAM_ID$1, 32);
    const ataProgramKey = decodeToFixedSize$1(ASSOCIATED_TOKEN_PROGRAM_ID$1, 32);
    const blockhashBytes = decodeBase58(recentBlockhash);
    const accountKeys = [];
    const addKey = (key) => {
      const keyBase58 = encodeBase58(key);
      if (!accountKeys.find((k2) => encodeBase58(k2) === keyBase58)) {
        accountKeys.push(key);
      }
      return accountKeys.findIndex((k2) => encodeBase58(k2) === keyBase58);
    };
    const ownerIdx = addKey(ownerKey);
    const ataIdx = addKey(ataKey);
    const nativeMintIdx = addKey(nativeMintKey);
    const systemIdx = addKey(systemProgramKey);
    const tokenIdx = addKey(tokenProgramKey);
    const ataProgIdx = addKey(ataProgramKey);
    const instructions = [];
    instructions.push({
      programIdIndex: ataProgIdx,
      accountIndices: [ownerIdx, ataIdx, ownerIdx, nativeMintIdx, systemIdx, tokenIdx],
      data: new Uint8Array([1])
      // CreateIdempotent instruction
    });
    const transferData = new Uint8Array(12);
    transferData[0] = 2;
    const lamportsView = new DataView(transferData.buffer);
    lamportsView.setBigUint64(4, BigInt(lamports), true);
    instructions.push({
      programIdIndex: systemIdx,
      accountIndices: [ownerIdx, ataIdx],
      data: transferData
    });
    instructions.push({
      programIdIndex: tokenIdx,
      accountIndices: [ataIdx],
      data: new Uint8Array([17])
      // SyncNative instruction
    });
    const numSigners = 1;
    const numReadonlySigners = 0;
    const readonlyNonSigners = [nativeMintIdx, systemIdx, tokenIdx, ataProgIdx].filter((v2, i, a) => a.indexOf(v2) === i).length;
    const messageHeader = new Uint8Array([numSigners, numReadonlySigners, readonlyNonSigners]);
    const numKeys = encodeCompactU16(accountKeys.length);
    const flatKeys = new Uint8Array(accountKeys.length * 32);
    accountKeys.forEach((key, i) => flatKeys.set(key, i * 32));
    const numInstructions = encodeCompactU16(instructions.length);
    const serializedInstructions = [];
    for (const ix of instructions) {
      const accountsLen = encodeCompactU16(ix.accountIndices.length);
      const dataLen = encodeCompactU16(ix.data.length);
      serializedInstructions.push(
        new Uint8Array([ix.programIdIndex]),
        accountsLen,
        new Uint8Array(ix.accountIndices),
        dataLen,
        ix.data
      );
    }
    const messageParts = [
      messageHeader,
      numKeys,
      flatKeys,
      blockhashBytes,
      numInstructions,
      ...serializedInstructions
    ];
    const totalLen = messageParts.reduce((sum, part) => sum + part.length, 0);
    const message = new Uint8Array(totalLen);
    let offset = 0;
    for (const part of messageParts) {
      message.set(part, offset);
      offset += part.length;
    }
    logger$1.log("[Wrap] Message built, length:", message.length);
    const signature = await sign$1(message, privateKey);
    logger$1.log("[Wrap] Signature created");
    const signedTx = new Uint8Array(1 + 64 + message.length);
    signedTx[0] = 1;
    signedTx.set(signature, 1);
    signedTx.set(message, 65);
    const txSignature = await sendTransaction(signedTx, rpcUrl);
    logger$1.log("[Wrap] Transaction sent:", txSignature);
    return txSignature;
  } catch (err) {
    logger$1.error("[Wrap] Error:", (err == null ? void 0 : err.message) || err);
    throw err;
  }
}
async function createUnwrapTransaction({ owner, amount, rpcUrl, privateKey }) {
  var _a2, _b2, _c;
  console.log("[Unwrap] Creating unwrap transaction");
  console.log("[Unwrap] Owner:", owner);
  console.log("[Unwrap] RPC URL:", rpcUrl);
  try {
    const blockhashResponse = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "getLatestBlockhash",
        params: [{ commitment: "confirmed" }]
      })
    });
    const blockhashResult = await blockhashResponse.json();
    if (blockhashResult.error) {
      throw new Error(blockhashResult.error.message);
    }
    const recentBlockhash = blockhashResult.result.value.blockhash;
    console.log("[Unwrap] Got blockhash:", recentBlockhash);
    let ataAddress;
    try {
      const tokenAccountsResponse = await fetch(rpcUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "getTokenAccountsByOwner",
          params: [
            owner,
            { mint: NATIVE_MINT },
            { encoding: "jsonParsed" }
          ]
        })
      });
      const tokenAccountsResult = await tokenAccountsResponse.json();
      console.log("[Unwrap] Token accounts result:", tokenAccountsResult);
      if (((_b2 = (_a2 = tokenAccountsResult.result) == null ? void 0 : _a2.value) == null ? void 0 : _b2.length) > 0) {
        ataAddress = tokenAccountsResult.result.value[0].pubkey;
        console.log("[Unwrap] Found existing ATA from RPC:", ataAddress);
      } else {
        throw new Error("No wrapped token account found to unwrap");
      }
    } catch (e) {
      if (e.message.includes("No wrapped token")) {
        throw e;
      }
      console.log("[Unwrap] Could not query token accounts:", e == null ? void 0 : e.message);
      ataAddress = await deriveATAAddressStandard(owner, NATIVE_MINT, TOKEN_PROGRAM_ID$3);
      console.log("[Unwrap] Derived ATA address:", ataAddress);
    }
    const ataInfoResponse = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "getAccountInfo",
        params: [ataAddress, { encoding: "jsonParsed" }]
      })
    });
    const ataInfoResult = await ataInfoResponse.json();
    console.log("[Unwrap] ATA info:", ataInfoResult);
    if (!((_c = ataInfoResult.result) == null ? void 0 : _c.value)) {
      throw new Error("Wrapped token account does not exist");
    }
    const ownerKey = decodeToFixedSize$1(owner, 32);
    const ataKey = decodeToFixedSize$1(ataAddress, 32);
    const tokenProgramKey = decodeToFixedSize$1(TOKEN_PROGRAM_ID$3, 32);
    const blockhashBytes = decodeBase58(recentBlockhash);
    const accountKeys = [ownerKey, ataKey, tokenProgramKey];
    const closeInstruction = {
      programIdIndex: 2,
      // token program
      accountIndices: [1, 0, 0],
      // [ATA, owner (destination), owner (authority)]
      data: new Uint8Array([9])
      // CloseAccount instruction
    };
    const messageHeader = new Uint8Array([1, 0, 1]);
    const numKeys = encodeCompactU16(accountKeys.length);
    const flatKeys = new Uint8Array(accountKeys.length * 32);
    accountKeys.forEach((key, i) => flatKeys.set(key, i * 32));
    const accountsLen = encodeCompactU16(closeInstruction.accountIndices.length);
    const dataLen = encodeCompactU16(closeInstruction.data.length);
    const messageParts = [
      messageHeader,
      numKeys,
      flatKeys,
      blockhashBytes,
      encodeCompactU16(1),
      // 1 instruction
      new Uint8Array([closeInstruction.programIdIndex]),
      accountsLen,
      new Uint8Array(closeInstruction.accountIndices),
      dataLen,
      closeInstruction.data
    ];
    const totalLen = messageParts.reduce((sum, part) => sum + part.length, 0);
    const message = new Uint8Array(totalLen);
    let offset = 0;
    for (const part of messageParts) {
      message.set(part, offset);
      offset += part.length;
    }
    console.log("[Unwrap] Message built, length:", message.length);
    const signature = await sign$1(message, privateKey);
    console.log("[Unwrap] Signature created");
    const signedTx = new Uint8Array(1 + 64 + message.length);
    signedTx[0] = 1;
    signedTx.set(signature, 1);
    signedTx.set(message, 65);
    const txSignature = await sendTransaction(signedTx, rpcUrl);
    console.log("[Unwrap] Transaction sent:", txSignature);
    return txSignature;
  } catch (err) {
    console.error("[Unwrap] Error:", (err == null ? void 0 : err.message) || err);
    throw err;
  }
}
async function createWrapTransactionHardware({ owner, amount, rpcUrl, hardwareWallet: hardwareWallet2, derivationPath = null }) {
  var _a2, _b2;
  logger$1.log("[Wrap HW] Creating wrap transaction for", amount, "native tokens");
  logger$1.log("[Wrap HW] Using derivation path:", derivationPath);
  try {
    const lamports = Math.floor(amount * 1e9);
    const blockhashResponse = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "getLatestBlockhash",
        params: [{ commitment: "confirmed" }]
      })
    });
    const blockhashResult = await blockhashResponse.json();
    if (blockhashResult.error) {
      throw new Error("Blockhash error: " + (blockhashResult.error.message || JSON.stringify(blockhashResult.error)));
    }
    const recentBlockhash = blockhashResult.result.value.blockhash;
    logger$1.log("[Wrap HW] Got blockhash:", recentBlockhash);
    let ataAddress;
    try {
      const tokenAccountsResponse = await fetch(rpcUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "getTokenAccountsByOwner",
          params: [owner, { mint: NATIVE_MINT }, { encoding: "jsonParsed" }]
        })
      });
      const tokenAccountsResult = await tokenAccountsResponse.json();
      if (((_b2 = (_a2 = tokenAccountsResult.result) == null ? void 0 : _a2.value) == null ? void 0 : _b2.length) > 0) {
        ataAddress = tokenAccountsResult.result.value[0].pubkey;
        logger$1.log("[Wrap HW] Found existing ATA:", ataAddress);
      }
    } catch (e) {
      logger$1.log("[Wrap HW] Could not query token accounts:", e == null ? void 0 : e.message);
    }
    if (!ataAddress) {
      ataAddress = await deriveATAAddressStandard(owner, NATIVE_MINT, TOKEN_PROGRAM_ID$3);
      logger$1.log("[Wrap HW] Derived ATA address:", ataAddress);
    }
    const ownerKey = decodeToFixedSize$1(owner, 32);
    const nativeMintKey = decodeToFixedSize$1(NATIVE_MINT, 32);
    const ataKey = decodeToFixedSize$1(ataAddress, 32);
    const tokenProgramKey = decodeToFixedSize$1(TOKEN_PROGRAM_ID$3, 32);
    const systemProgramKey = decodeToFixedSize$1(SYSTEM_PROGRAM_ID$1, 32);
    const ataProgramKey = decodeToFixedSize$1(ASSOCIATED_TOKEN_PROGRAM_ID$1, 32);
    const blockhashBytes = decodeBase58(recentBlockhash);
    const accountKeys = [];
    const addKey = (key) => {
      const keyBase58 = encodeBase58(key);
      if (!accountKeys.find((k2) => encodeBase58(k2) === keyBase58)) {
        accountKeys.push(key);
      }
      return accountKeys.findIndex((k2) => encodeBase58(k2) === keyBase58);
    };
    const ownerIdx = addKey(ownerKey);
    const ataIdx = addKey(ataKey);
    const nativeMintIdx = addKey(nativeMintKey);
    const systemIdx = addKey(systemProgramKey);
    const tokenIdx = addKey(tokenProgramKey);
    const ataProgIdx = addKey(ataProgramKey);
    const instructions = [];
    instructions.push({
      programIdIndex: ataProgIdx,
      accountIndices: [ownerIdx, ataIdx, ownerIdx, nativeMintIdx, systemIdx, tokenIdx],
      data: new Uint8Array([1])
    });
    const transferData = new Uint8Array(12);
    transferData[0] = 2;
    const lamportsView = new DataView(transferData.buffer);
    lamportsView.setBigUint64(4, BigInt(lamports), true);
    instructions.push({
      programIdIndex: systemIdx,
      accountIndices: [ownerIdx, ataIdx],
      data: transferData
    });
    instructions.push({
      programIdIndex: tokenIdx,
      accountIndices: [ataIdx],
      data: new Uint8Array([17])
    });
    const numSigners = 1;
    const numReadonlySigners = 0;
    const readonlyNonSigners = [nativeMintIdx, systemIdx, tokenIdx, ataProgIdx].filter((v2, i, a) => a.indexOf(v2) === i).length;
    const messageHeader = new Uint8Array([numSigners, numReadonlySigners, readonlyNonSigners]);
    const numKeys = encodeCompactU16(accountKeys.length);
    const flatKeys = new Uint8Array(accountKeys.length * 32);
    accountKeys.forEach((key, i) => flatKeys.set(key, i * 32));
    const numInstructions = encodeCompactU16(instructions.length);
    const serializedInstructions = [];
    for (const ix of instructions) {
      const accountsLen = encodeCompactU16(ix.accountIndices.length);
      const dataLen = encodeCompactU16(ix.data.length);
      serializedInstructions.push(
        new Uint8Array([ix.programIdIndex]),
        accountsLen,
        new Uint8Array(ix.accountIndices),
        dataLen,
        ix.data
      );
    }
    const messageParts = [
      messageHeader,
      numKeys,
      flatKeys,
      blockhashBytes,
      numInstructions,
      ...serializedInstructions
    ];
    const totalLen = messageParts.reduce((sum, part) => sum + part.length, 0);
    const message = new Uint8Array(totalLen);
    let offset = 0;
    for (const part of messageParts) {
      message.set(part, offset);
      offset += part.length;
    }
    logger$1.log("[Wrap HW] Message built, length:", message.length);
    const signature = await hardwareWallet2.signTransaction(message, derivationPath);
    logger$1.log("[Wrap HW] Signature created via hardware wallet");
    const signedTx = new Uint8Array(1 + 64 + message.length);
    signedTx[0] = 1;
    signedTx.set(signature, 1);
    signedTx.set(message, 65);
    const txSignature = await sendTransaction(signedTx, rpcUrl);
    logger$1.log("[Wrap HW] Transaction sent:", txSignature);
    return txSignature;
  } catch (err) {
    logger$1.error("[Wrap HW] Error:", (err == null ? void 0 : err.message) || err);
    throw err;
  }
}
async function createUnwrapTransactionHardware({ owner, amount, rpcUrl, hardwareWallet: hardwareWallet2, derivationPath = null }) {
  var _a2, _b2;
  console.log("[Unwrap HW] Creating unwrap transaction");
  console.log("[Unwrap HW] Using derivation path:", derivationPath);
  try {
    const blockhashResponse = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "getLatestBlockhash",
        params: [{ commitment: "confirmed" }]
      })
    });
    const blockhashResult = await blockhashResponse.json();
    if (blockhashResult.error) {
      throw new Error("Blockhash error: " + blockhashResult.error.message);
    }
    const recentBlockhash = blockhashResult.result.value.blockhash;
    const tokenAccountsResponse = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "getTokenAccountsByOwner",
        params: [owner, { mint: NATIVE_MINT }, { encoding: "jsonParsed" }]
      })
    });
    const tokenAccountsResult = await tokenAccountsResponse.json();
    if (!((_b2 = (_a2 = tokenAccountsResult.result) == null ? void 0 : _a2.value) == null ? void 0 : _b2.length)) {
      throw new Error("No wrapped token account found");
    }
    const ataAddress = tokenAccountsResult.result.value[0].pubkey;
    console.log("[Unwrap HW] Found ATA:", ataAddress);
    const ownerKey = decodeToFixedSize$1(owner, 32);
    const ataKey = decodeToFixedSize$1(ataAddress, 32);
    const tokenProgramKey = decodeToFixedSize$1(TOKEN_PROGRAM_ID$3, 32);
    const blockhashBytes = decodeBase58(recentBlockhash);
    const accountKeys = [];
    const addKey = (key) => {
      const keyBase58 = encodeBase58(key);
      if (!accountKeys.find((k2) => encodeBase58(k2) === keyBase58)) {
        accountKeys.push(key);
      }
      return accountKeys.findIndex((k2) => encodeBase58(k2) === keyBase58);
    };
    const ownerIdx = addKey(ownerKey);
    const ataIdx = addKey(ataKey);
    const tokenIdx = addKey(tokenProgramKey);
    const closeInstruction = {
      programIdIndex: tokenIdx,
      accountIndices: [ataIdx, ownerIdx, ownerIdx],
      data: new Uint8Array([9])
      // CloseAccount instruction
    };
    const numSigners = 1;
    const numReadonlySigners = 0;
    const readonlyNonSigners = 1;
    const messageHeader = new Uint8Array([numSigners, numReadonlySigners, readonlyNonSigners]);
    const numKeys = encodeCompactU16(accountKeys.length);
    const flatKeys = new Uint8Array(accountKeys.length * 32);
    accountKeys.forEach((key, i) => flatKeys.set(key, i * 32));
    const accountsLen = encodeCompactU16(closeInstruction.accountIndices.length);
    const dataLen = encodeCompactU16(closeInstruction.data.length);
    const messageParts = [
      messageHeader,
      numKeys,
      flatKeys,
      blockhashBytes,
      encodeCompactU16(1),
      new Uint8Array([closeInstruction.programIdIndex]),
      accountsLen,
      new Uint8Array(closeInstruction.accountIndices),
      dataLen,
      closeInstruction.data
    ];
    const totalLen = messageParts.reduce((sum, part) => sum + part.length, 0);
    const message = new Uint8Array(totalLen);
    let offset = 0;
    for (const part of messageParts) {
      message.set(part, offset);
      offset += part.length;
    }
    console.log("[Unwrap HW] Message built, length:", message.length);
    const signature = await hardwareWallet2.signTransaction(message, derivationPath);
    console.log("[Unwrap HW] Signature created via hardware wallet");
    const signedTx = new Uint8Array(1 + 64 + message.length);
    signedTx[0] = 1;
    signedTx.set(signature, 1);
    signedTx.set(message, 65);
    const txSignature = await sendTransaction(signedTx, rpcUrl);
    console.log("[Unwrap HW] Transaction sent:", txSignature);
    return txSignature;
  } catch (err) {
    console.error("[Unwrap HW] Error:", (err == null ? void 0 : err.message) || err);
    throw err;
  }
}
function encodeCompactU16(value) {
  if (value < 128) {
    return new Uint8Array([value]);
  } else if (value < 16384) {
    return new Uint8Array([
      value & 127 | 128,
      value >> 7
    ]);
  } else {
    return new Uint8Array([
      value & 127 | 128,
      value >> 7 & 127 | 128,
      value >> 14
    ]);
  }
}
const transaction = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addTransaction,
  buildTokenTransferMessageForHardware,
  buildTransaction,
  buildTransferMessage,
  createCompressedNftTransfer,
  createTokenTransferTransaction,
  createTransferTransaction,
  createUnwrapTransaction,
  createUnwrapTransactionHardware,
  createWrapTransaction,
  createWrapTransactionHardware,
  deriveATAAddressStandard,
  fetchBlockchainTransactions,
  findExistingATA,
  formatTransaction,
  getTransactionHistory,
  sendTransaction,
  serializeTransaction,
  signAndSendExternalTransaction,
  signAndSendExternalTransactionHardware,
  signTransaction
}, Symbol.toStringTag, { value: "Module" }));
const ERROR_MAPPINGS = [
  // Network errors
  { pattern: /fetch failed|network error|net::ERR/i, message: "Network connection failed. Please check your internet connection." },
  { pattern: /timeout|timed out/i, message: "Request timed out. Please try again." },
  { pattern: /CORS|cross-origin/i, message: "Unable to connect to the service. Please try again later." },
  { pattern: /dns|ENOTFOUND/i, message: "Unable to reach the server. Please check your connection." },
  // RPC errors
  { pattern: /rpc.*error|jsonrpc/i, message: "Blockchain network error. Please try again." },
  { pattern: /rate limit|429|too many requests/i, message: "Too many requests. Please wait a moment and try again." },
  { pattern: /blockhash not found|expired/i, message: "Transaction expired. Please try again." },
  // Transaction errors  
  { pattern: /insufficient.*balance|insufficient.*funds/i, message: "Insufficient balance for this transaction." },
  { pattern: /invalid.*signature/i, message: "Transaction signing failed. Please try again." },
  { pattern: /simulation failed/i, message: "Transaction simulation failed. Please check the details and try again." },
  { pattern: /account.*not found|account does not exist/i, message: "Account not found. Please verify the address." },
  // Wallet errors
  { pattern: /invalid.*address|invalid.*public.*key/i, message: "Invalid wallet address format." },
  { pattern: /invalid.*mnemonic|invalid.*seed/i, message: "Invalid recovery phrase." },
  { pattern: /wallet.*locked|unlock.*required/i, message: "Please unlock your wallet first." },
  // Hardware wallet errors
  { pattern: /ledger.*not.*connected|device.*not.*found/i, message: "Hardware wallet not connected. Please connect and try again." },
  { pattern: /user.*rejected|user.*denied|cancelled by user/i, message: "Action cancelled." },
  { pattern: /wrong.*app|open.*app/i, message: "Please open the correct app on your hardware wallet." },
  { pattern: /locked.*device/i, message: "Please unlock your hardware wallet." },
  // Swap errors
  { pattern: /slippage|price.*impact/i, message: "Price changed significantly. Please adjust slippage or try again." },
  { pattern: /no.*route|route.*not.*found/i, message: "No swap route available for this pair." },
  { pattern: /liquidity/i, message: "Insufficient liquidity for this swap." },
  // Generic errors
  { pattern: /unauthorized|401/i, message: "Authentication required. Please reconnect." },
  { pattern: /forbidden|403/i, message: "Access denied." },
  { pattern: /not found|404/i, message: "Resource not found." },
  { pattern: /internal.*error|500|502|503|504/i, message: "Service temporarily unavailable. Please try again later." }
];
function getUserFriendlyError(error, fallback = "An unexpected error occurred. Please try again.") {
  if (!error) {
    return fallback;
  }
  let errorMessage = "";
  if (typeof error === "string") {
    errorMessage = error;
  } else if (error instanceof Error) {
    errorMessage = error.message || "";
  } else if (typeof error === "object") {
    errorMessage = error.message || error.error || error.msg || JSON.stringify(error);
  }
  for (const { pattern, message } of ERROR_MAPPINGS) {
    if (pattern.test(errorMessage)) {
      return message;
    }
  }
  return fallback;
}
const ErrorMessages = {
  // Transaction errors
  transaction: {
    failed: "Transaction failed. Please try again.",
    signFailed: "Failed to sign transaction. Please try again."
  },
  // Wallet errors
  wallet: {
    loadFailed: "Failed to load wallet. Please try again."
  },
  // Swap errors  
  swap: {
    failed: "Swap failed. Please try again.",
    quoteFailed: "Failed to get quote. Please try again."
  }
};
const PBKDF2_ITERATIONS_V2 = 1e5;
const PBKDF2_ITERATIONS_V3 = 6e5;
const CURRENT_VERSION = 3;
const SALT_LENGTH = 16;
const IV_LENGTH = 12;
const VERSION_BYTE_LENGTH = 1;
async function deriveKey(password, salt, iterations = PBKDF2_ITERATIONS_V3) {
  const encoder = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    encoder.encode(password),
    "PBKDF2",
    false,
    ["deriveBits", "deriveKey"]
  );
  return crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt,
      iterations,
      hash: "SHA-256"
    },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
}
async function encryptData(plaintext, password) {
  if (!password || password.length < 1) {
    throw new Error("Password is required for encryption");
  }
  const encoder = new TextEncoder();
  const data = encoder.encode(plaintext);
  const salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
  const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH));
  const key = await deriveKey(password, salt, PBKDF2_ITERATIONS_V3);
  const encryptedBuffer = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    key,
    data
  );
  const encrypted = new Uint8Array(encryptedBuffer);
  const combined = new Uint8Array(VERSION_BYTE_LENGTH + SALT_LENGTH + IV_LENGTH + encrypted.length);
  combined[0] = CURRENT_VERSION;
  combined.set(salt, VERSION_BYTE_LENGTH);
  combined.set(iv, VERSION_BYTE_LENGTH + SALT_LENGTH);
  combined.set(encrypted, VERSION_BYTE_LENGTH + SALT_LENGTH + IV_LENGTH);
  let binary = "";
  const chunkSize = 8192;
  for (let i = 0; i < combined.length; i += chunkSize) {
    const chunk = combined.subarray(i, Math.min(i + chunkSize, combined.length));
    binary += String.fromCharCode.apply(null, chunk);
  }
  return btoa(binary);
}
async function decryptData(encryptedBase64, password) {
  if (!password) throw new Error("Password is required for decryption");
  if (!encryptedBase64) throw new Error("No encrypted data provided");
  try {
    const combined = Uint8Array.from(atob(encryptedBase64), (c) => c.charCodeAt(0));
    let salt, iv, encrypted, iterations;
    if (combined[0] === 3) {
      salt = combined.slice(VERSION_BYTE_LENGTH, VERSION_BYTE_LENGTH + SALT_LENGTH);
      iv = combined.slice(VERSION_BYTE_LENGTH + SALT_LENGTH, VERSION_BYTE_LENGTH + SALT_LENGTH + IV_LENGTH);
      encrypted = combined.slice(VERSION_BYTE_LENGTH + SALT_LENGTH + IV_LENGTH);
      iterations = PBKDF2_ITERATIONS_V3;
    } else {
      salt = combined.slice(0, SALT_LENGTH);
      iv = combined.slice(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);
      encrypted = combined.slice(SALT_LENGTH + IV_LENGTH);
      iterations = PBKDF2_ITERATIONS_V2;
    }
    const key = await deriveKey(password, salt, iterations);
    const decryptedBuffer = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
    );
    return new TextDecoder().decode(decryptedBuffer);
  } catch (error) {
    throw new Error("Decryption failed - incorrect password or corrupted data");
  }
}
async function hashPassword(password, existingSalt = null) {
  const encoder = new TextEncoder();
  const salt = existingSalt || crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    encoder.encode(password),
    "PBKDF2",
    false,
    ["deriveBits"]
  );
  const hashBuffer = await crypto.subtle.deriveBits(
    {
      name: "PBKDF2",
      salt,
      iterations: PBKDF2_ITERATIONS_V3,
      // Use modern iteration count
      hash: "SHA-256"
    },
    keyMaterial,
    256
  );
  const hashArray = new Uint8Array(hashBuffer);
  let hashBinary = "";
  for (let i = 0; i < hashArray.length; i++) {
    hashBinary += String.fromCharCode(hashArray[i]);
  }
  let saltBinary = "";
  for (let i = 0; i < salt.length; i++) {
    saltBinary += String.fromCharCode(salt[i]);
  }
  return {
    hash: btoa(hashBinary),
    salt: btoa(saltBinary)
  };
}
async function verifyPassword(password, storedHash, storedSalt) {
  try {
    const salt = Uint8Array.from(atob(storedSalt), (c) => c.charCodeAt(0));
    const { hash } = await hashPassword(password, salt);
    return hash === storedHash;
  } catch {
    return false;
  }
}
function isEncrypted(data) {
  if (!data || typeof data !== "string") return false;
  try {
    const decoded = atob(data);
    return decoded.length >= SALT_LENGTH + IV_LENGTH + 16;
  } catch {
    return false;
  }
}
const RPC_OVERRIDES_KEY = "x1wallet_rpcOverrides";
const CUSTOM_NETWORKS_KEY$1 = "x1wallet_customRpcs";
const NETWORKS = {
  "X1 Mainnet": {
    name: "X1 Mainnet",
    providerId: "X1-mainnet",
    rpcUrl: "https://rpc.mainnet.x1.xyz",
    symbol: "XNT",
    explorer: "https://explorer.mainnet.x1.xyz",
    explorerTx: "https://explorer.mainnet.x1.xyz/tx",
    explorerToken: "https://explorer.mainnet.x1.xyz/address",
    decimals: 9,
    isSVM: true,
    isX1: true
  },
  "X1 Testnet": {
    name: "X1 Testnet",
    providerId: "X1-testnet",
    rpcUrl: "https://rpc.testnet.x1.xyz",
    symbol: "XNT",
    explorer: "https://explorer.testnet.x1.xyz",
    explorerTx: "https://explorer.testnet.x1.xyz/tx",
    explorerToken: "https://explorer.testnet.x1.xyz/token",
    decimals: 9,
    isSVM: true,
    isX1: true
  },
  "Solana Mainnet": {
    name: "Solana Mainnet",
    providerId: "SOLANA-mainnet",
    rpcUrl: "https://jessamine-463apc-fast-mainnet.helius-rpc.com",
    symbol: "SOL",
    explorer: "https://solscan.io",
    explorerTx: "https://solscan.io/tx",
    explorerToken: "https://solscan.io/token",
    decimals: 9,
    isSVM: true,
    isSolana: true
  },
  "Solana Devnet": {
    name: "Solana Devnet",
    providerId: "SOLANA-devnet",
    rpcUrl: "https://rose-l3rk46-fast-devnet.helius-rpc.com",
    symbol: "SOL",
    explorer: "https://solscan.io",
    explorerTx: "https://solscan.io/tx",
    explorerToken: "https://solscan.io/token",
    explorerSuffix: "?cluster=devnet",
    decimals: 9,
    isSVM: true,
    isSolana: true
  }
};
const DEFAULT_NETWORK = "X1 Mainnet";
function getRpcOverrides() {
  try {
    return JSON.parse(localStorage.getItem(RPC_OVERRIDES_KEY)) || {};
  } catch (e) {
    logger$1.warn("Failed to load RPC overrides:", e);
    return {};
  }
}
function getNetwork(name) {
  if (NETWORKS[name]) {
    const config = { ...NETWORKS[name] };
    try {
      const overrides = getRpcOverrides();
      if (overrides[name]) {
        config.rpcUrl = overrides[name];
        config.hasCustomRpc = true;
      }
    } catch (e) {
      logger$1.warn("Failed to load RPC overrides:", e);
    }
    return config;
  }
  try {
    const customNetworks = JSON.parse(localStorage.getItem(CUSTOM_NETWORKS_KEY$1) || "[]");
    const customNet = customNetworks.find((n2) => n2.name === name);
    if (customNet) {
      return {
        name: customNet.name,
        providerId: `custom-${customNet.id || Date.now()}`,
        rpcUrl: customNet.url,
        symbol: customNet.symbol || "TOKEN",
        decimals: parseInt(customNet.decimals) || 9,
        explorer: customNet.explorer || "",
        explorerTx: customNet.explorer ? `${customNet.explorer.replace(/\/$/, "")}/tx` : "",
        explorerToken: customNet.explorer ? `${customNet.explorer.replace(/\/$/, "")}/token` : "",
        isCustom: true,
        isSVM: true
      };
    }
  } catch (e) {
    logger$1.warn("Failed to load custom networks:", e);
  }
  return NETWORKS[DEFAULT_NETWORK];
}
function getExplorerUrl(network, txSignature, customExplorer = null) {
  if (customExplorer) {
    const baseUrl = customExplorer.replace(/\/$/, "");
    return `${baseUrl}/tx/${txSignature}`;
  }
  const config = getNetwork(network);
  const suffix = config.explorerSuffix || "";
  return `${config.explorerTx}/${txSignature}${suffix}`;
}
function getCustomExplorer(network) {
  try {
    let key;
    if (network == null ? void 0 : network.includes("Solana")) {
      key = (network == null ? void 0 : network.includes("Devnet")) ? "x1wallet_solanaDevnetExplorer" : "x1wallet_solanaExplorer";
    } else {
      key = (network == null ? void 0 : network.includes("Testnet")) ? "x1wallet_x1TestnetExplorer" : "x1wallet_x1Explorer";
    }
    const stored = localStorage.getItem(key);
    if (stored) {
      return JSON.parse(stored);
    }
  } catch (e) {
    logger$1.warn("Failed to get custom explorer:", e);
  }
  return null;
}
function getTxExplorerUrl(network, txSignature) {
  const custom = getCustomExplorer(network);
  return getExplorerUrl(network, txSignature, custom);
}
const XDEX_API$1 = "https://api.xdex.xyz/api/xendex";
const JUPITER_TOKEN_API = "https://lite-api.jup.ag/tokens/v2";
const tokenMetadataCache = /* @__PURE__ */ new Map();
const CACHE_TTL_SUCCESS = 30 * 60 * 1e3;
const CACHE_TTL_FAILED = 5 * 60 * 1e3;
function getCachedMetadata(mintAddress) {
  const cached = tokenMetadataCache.get(mintAddress);
  if (!cached) return null;
  const age = Date.now() - cached.timestamp;
  const ttl = cached.failed ? CACHE_TTL_FAILED : CACHE_TTL_SUCCESS;
  if (age > ttl) {
    tokenMetadataCache.delete(mintAddress);
    return null;
  }
  return cached;
}
function setCachedMetadata(mintAddress, data, failed = false) {
  tokenMetadataCache.set(mintAddress, {
    data,
    failed,
    timestamp: Date.now()
  });
}
const XDEX_LOGOS = {
  X1: "/icons/48-x1.png",
  WXNT: "/icons/48-x1.png",
  SOL: "/icons/48-sol.png",
  USDC: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v/logo.png",
  USDC_X: "/icons/48-usdcx.png"
};
const KNOWN_TOKENS$1 = {
  "X1 Mainnet": {
    "B69chRzqzDCmdB5WYB8NRu5Yv5ZA95ABiZcdzCgGm9Tq": {
      symbol: "USDC.X",
      name: "USD Coin (X1)",
      decimals: 6,
      logoURI: XDEX_LOGOS.USDC_X,
      isToken2022: true,
      price: 1
    },
    "AvNDf423kEmWNP6AZHFV7DkNG4YRgt6qbdyyryjaa4PQ": {
      symbol: "XNM",
      name: "Xenium",
      decimals: 9,
      logoURI: "https://mint.xdex.xyz/ipfs/bafkreidzj5vsbzgojfultyykflh322ypmbzpl7wngq7qxfjxzl3hql47ge?pinataGatewayToken=yMPvcPv-nyFCJ0GGUmoHxYkuVS6bZxS_ucWqpMpVMedA3_nOdJO5uUqA8dibii5a",
      isToken2022: true
    }
    // Add more X1 Mainnet tokens here
  },
  "X1 Testnet": {
    "B69chRzqzDCmdB5WYB8NRu5Yv5ZA95ABiZcdzCgGm9Tq": {
      symbol: "USDC.X",
      name: "USD Coin (X1)",
      decimals: 6,
      logoURI: XDEX_LOGOS.USDC_X,
      isToken2022: true,
      price: 1
    },
    "AvNDf423kEmWNP6AZHFV7DkNG4YRgt6qbdyyryjaa4PQ": {
      symbol: "XNM",
      name: "Xenium",
      decimals: 9,
      logoURI: "https://mint.xdex.xyz/ipfs/bafkreidzj5vsbzgojfultyykflh322ypmbzpl7wngq7qxfjxzl3hql47ge?pinataGatewayToken=yMPvcPv-nyFCJ0GGUmoHxYkuVS6bZxS_ucWqpMpVMedA3_nOdJO5uUqA8dibii5a",
      isToken2022: true
    }
    // Add more X1 Testnet tokens here
  },
  "Solana Mainnet": {
    "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v": {
      symbol: "USDC",
      name: "USD Coin",
      decimals: 6,
      logoURI: XDEX_LOGOS.USDC,
      isToken2022: false
    },
    "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB": {
      symbol: "USDT",
      name: "Tether USD",
      decimals: 6,
      logoURI: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB/logo.svg",
      isToken2022: false
    }
    // Add more Solana Mainnet tokens here
  },
  "Solana Devnet": {
    // Devnet has different token addresses
  }
};
const SOLANA_TOKENS = {
  "SOL": "So11111111111111111111111111111111111111112"
};
function isSolanaNetwork(network) {
  return network === "Solana Mainnet" || network === "Solana Devnet";
}
function isX1Network$1(network) {
  var _a2, _b2;
  if (network === "X1 Mainnet" || network === "X1 Testnet") return true;
  const lowerName = network.toLowerCase();
  if (lowerName.includes("x1") || lowerName.includes("xnt")) return true;
  try {
    const customNetworks = JSON.parse(localStorage.getItem("x1wallet_customRpcs") || "[]");
    const customNet = customNetworks.find((n2) => n2.name === network);
    if (customNet) {
      const url = ((_a2 = customNet.url) == null ? void 0 : _a2.toLowerCase()) || "";
      if (url.includes("x1.xyz") || url.includes("x1.") || url.includes("/x1")) return true;
      if (((_b2 = customNet.symbol) == null ? void 0 : _b2.toUpperCase()) === "XNT") return true;
    }
  } catch (e) {
  }
  return false;
}
function getKnownToken(network, mintAddress) {
  const networkTokens = KNOWN_TOKENS$1[network] || {};
  return networkTokens[mintAddress] || null;
}
function getNetworkName(network) {
  switch (network) {
    case "X1 Mainnet":
      return "X1 Mainnet";
    case "X1 Testnet":
      return "X1 Testnet";
    case "Solana Mainnet":
      return "Solana Mainnet";
    case "Solana Devnet":
      return "Solana Devnet";
    default:
      return network || "X1 Mainnet";
  }
}
const NATIVE_TOKEN_ADDRESS = "So11111111111111111111111111111111111111112";
async function getQuote(tokenIn, tokenOut, amountIn, network, tokenInData = null, tokenOutData = null) {
  const parsedAmount = parseFloat(amountIn);
  if (!amountIn || isNaN(parsedAmount) || parsedAmount <= 0) {
    throw new Error("Invalid amount");
  }
  if (!tokenIn && !(tokenInData == null ? void 0 : tokenInData.mint)) {
    throw new Error("Invalid input token");
  }
  if (!tokenOut && !(tokenOutData == null ? void 0 : tokenOutData.mint)) {
    throw new Error("Invalid output token");
  }
  const networkName = getNetworkName(network);
  let tokenInParam = tokenIn;
  let tokenOutParam = tokenOut;
  if (tokenInData) {
    if (tokenInData.mint === "native" || tokenInData.isNative || !tokenInData.mint || tokenInData.mint.startsWith("native_")) {
      tokenInParam = NATIVE_TOKEN_ADDRESS;
    } else {
      tokenInParam = tokenInData.mint;
    }
  } else if (tokenIn === "XNT" || tokenIn === "SOL") {
    tokenInParam = NATIVE_TOKEN_ADDRESS;
  }
  if (tokenOutData) {
    if (tokenOutData.mint === "native" || tokenOutData.isNative || !tokenOutData.mint || tokenOutData.mint.startsWith("native_")) {
      tokenOutParam = NATIVE_TOKEN_ADDRESS;
    } else {
      tokenOutParam = tokenOutData.mint;
    }
  } else if (tokenOut === "XNT" || tokenOut === "SOL") {
    tokenOutParam = NATIVE_TOKEN_ADDRESS;
  }
  const decimals = (tokenInData == null ? void 0 : tokenInData.decimals) || 9;
  const amountInSmallest = Math.floor(parseFloat(amountIn) * Math.pow(10, decimals));
  const params = new URLSearchParams({
    network: networkName,
    token_in: tokenInParam,
    token_out: tokenOutParam,
    token_in_amount: amountIn.toString(),
    is_exact_amount_in: "true"
  });
  logger$1.log("[XDEX] Getting quote:", {
    url: `${XDEX_API$1}/swap/quote`,
    params: Object.fromEntries(params),
    tokenIn: tokenInParam,
    tokenOut: tokenOutParam,
    amount: amountIn,
    amountSmallest: amountInSmallest,
    decimals,
    network: networkName
  });
  try {
    const response = await fetch(`${XDEX_API$1}/swap/quote?${params}`, {
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    });
    const data = await response.json();
    if (!response.ok) {
      logger$1.error("[XDEX] Quote error response:", {
        status: response.status,
        data,
        requestParams: Object.fromEntries(params)
      });
      let errorMsg = data.error || data.message || "";
      errorMsg = errorMsg.replace(/<[^>]*>/g, "").trim();
      if (response.status === 429 || errorMsg.includes("429") || errorMsg.includes("Too Many Requests")) {
        throw new Error("Too many requests. Please wait a moment and try again.");
      }
      if (errorMsg.includes("Pool not found") || errorMsg.includes("No pool")) {
        throw new Error("No liquidity pool exists for this pair");
      }
      if (errorMsg.includes("Invalid token") || errorMsg.includes("address format")) {
        throw new Error("Invalid token address");
      }
      if (response.status === 404 || errorMsg.includes("No route") || errorMsg.includes("Route not found")) {
        throw new Error("No swap route available");
      }
      if (response.status === 400) {
        throw new Error(errorMsg || "Invalid request");
      }
      throw new Error(errorMsg || `Quote failed: ${response.status}`);
    }
    logger$1.log("[XDEX] Quote response:", data);
    return { ...data, provider: "xdex" };
  } catch (error) {
    logger$1.error("[XDEX] Quote fetch error:", error);
    throw error;
  }
}
async function prepareSwap(walletAddress, tokenIn, tokenOut, amountIn, network, slippageBps = 50) {
  var _a2;
  if (!walletAddress || typeof walletAddress !== "string") {
    throw new Error("Invalid wallet address");
  }
  if (!tokenIn || typeof tokenIn !== "string") {
    throw new Error("Invalid input token");
  }
  if (!tokenOut || typeof tokenOut !== "string") {
    throw new Error("Invalid output token");
  }
  const parsedAmount = parseFloat(amountIn);
  if (isNaN(parsedAmount) || parsedAmount <= 0) {
    throw new Error("Invalid swap amount");
  }
  const networkName = getNetworkName(network);
  const payload = {
    network: networkName,
    wallet: walletAddress,
    token_in: tokenIn,
    token_out: tokenOut,
    token_in_amount: parsedAmount,
    is_exact_amount_in: true,
    slippage_bps: slippageBps,
    slippage: slippageBps / 100,
    // Also send as percentage for compatibility
    wrap_unwrap_sol: true,
    // Explicitly request SOL wrapping/unwrapping
    use_shared_accounts: true
    // Use shared accounts for better success rate
  };
  logger$1.log("[XDEX] Preparing swap:", JSON.stringify(payload));
  const response = await fetch(`${XDEX_API$1}/swap/prepare`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  });
  const data = await response.json();
  if (!response.ok) {
    logger$1.error("[XDEX] Prepare failed:", response.status);
    logger$1.error("[XDEX] Error response:", JSON.stringify(data));
    let errorMsg = data.error || data.message || data.detail || `Swap prepare failed: ${response.status}`;
    errorMsg = errorMsg.replace(/<[^>]*>/g, "").trim();
    if (errorMsg.includes("429") || errorMsg.includes("Too Many Requests")) {
      throw new Error("Too many requests. Please wait 30 seconds and try again.");
    }
    throw new Error(errorMsg);
  }
  logger$1.log("[XDEX] Prepare response received");
  logger$1.log("[XDEX] Response keys:", Object.keys(data));
  if (data.data) {
    logger$1.log("[XDEX] data.data keys:", Object.keys(data.data));
  }
  if (data.transaction) {
    logger$1.log("[XDEX] transaction type:", typeof data.transaction);
    if (typeof data.transaction === "object") {
      logger$1.log("[XDEX] transaction keys:", Object.keys(data.transaction));
    }
  }
  if ((_a2 = data.data) == null ? void 0 : _a2.transaction) {
    logger$1.log("[XDEX] data.transaction type:", typeof data.data.transaction);
    if (typeof data.data.transaction === "object") {
      logger$1.log("[XDEX] data.transaction keys:", Object.keys(data.data.transaction));
    }
  }
  return { ...data, provider: "xdex" };
}
let jupiterTokensCache = null;
let jupiterTokensCacheTime = 0;
const CACHE_DURATION = 5 * 60 * 1e3;
const SOLANA_TOKEN_LIST = [
  { symbol: "SOL", name: "Solana", address: "So11111111111111111111111111111111111111112", decimals: 9, logoURI: "/icons/48-sol.png" },
  { symbol: "USDC", name: "USD Coin", address: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", decimals: 6, logoURI: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v/logo.png" },
  { symbol: "USDT", name: "Tether USD", address: "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB", decimals: 6, logoURI: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB/logo.svg" },
  { symbol: "JUP", name: "Jupiter", address: "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN", decimals: 6, logoURI: "https://static.jup.ag/jup/icon.png" },
  { symbol: "BONK", name: "Bonk", address: "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263", decimals: 5, logoURI: "https://arweave.net/hQiPZOsRZXGXBJd_82PhVdlM_hACsT_q6wqwf5cSY7I" },
  { symbol: "RAY", name: "Raydium", address: "4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R", decimals: 6, logoURI: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R/logo.png" },
  { symbol: "PYTH", name: "Pyth Network", address: "HZ1JovNiVvGrGNiiYvEozEVgZ58xaU3RKwX8eACQBCt3", decimals: 6, logoURI: "https://pyth.network/token.svg" },
  { symbol: "WIF", name: "dogwifhat", address: "EKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm", decimals: 6, logoURI: "https://assets.coingecko.com/coins/images/33566/standard/dogwifhat.jpg" },
  { symbol: "ORCA", name: "Orca", address: "orcaEKTdK7LKz57vaAYr9QeNsVEPfiu6QeMU1kektZE", decimals: 6, logoURI: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/orcaEKTdK7LKz57vaAYr9QeNsVEPfiu6QeMU1kektZE/logo.png" },
  { symbol: "MSOL", name: "Marinade SOL", address: "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So", decimals: 9, logoURI: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So/logo.png" }
];
async function fetchJupiterTokens() {
  if (jupiterTokensCache && Date.now() - jupiterTokensCacheTime < CACHE_DURATION) {
    return jupiterTokensCache;
  }
  try {
    logger$1.log("[Jupiter] Fetching token list...");
    const response = await fetch("https://lite-api.jup.ag/tokens/v2/tag?query=verified", {
      headers: {
        "Accept": "application/json"
      }
    });
    if (!response.ok) {
      logger$1.warn("[Jupiter] API returned", response.status);
      return SOLANA_TOKEN_LIST;
    }
    const tokens2 = await response.json();
    if (Array.isArray(tokens2) && tokens2.length > 0) {
      const normalizedTokens = tokens2.map((t2) => ({
        address: t2.id || t2.address,
        symbol: t2.symbol,
        name: t2.name,
        decimals: t2.decimals,
        logoURI: t2.icon || t2.logoURI
      }));
      jupiterTokensCache = normalizedTokens;
      jupiterTokensCacheTime = Date.now();
      logger$1.log("[Jupiter] Loaded", normalizedTokens.length, "verified tokens");
      return normalizedTokens;
    }
    return SOLANA_TOKEN_LIST;
  } catch (err) {
    logger$1.error("[Jupiter] Token fetch error:", err);
    return SOLANA_TOKEN_LIST;
  }
}
const POPULAR_SOLANA_MINTS = [
  "So11111111111111111111111111111111111111112",
  // SOL
  "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  // USDC
  "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
  // USDT
  "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN",
  // JUP
  "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263",
  // BONK
  "4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R",
  // RAY
  "HZ1JovNiVvGrGNiiYvEozEVgZ58xaU3RKwX8eACQBCt3",
  // PYTH
  "EKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm",
  // WIF
  "orcaEKTdK7LKz57vaAYr9QeNsVEPfiu6QeMU1kektZE",
  // ORCA
  "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"
  // mSOL
];
async function getSwapTokens(network) {
  if (isX1Network$1(network)) {
    return [
      { symbol: "XNT", name: "X1 Native Token", mint: "native", logoURI: XDEX_LOGOS.X1, decimals: 9, isNative: true },
      {
        symbol: "WXNT",
        name: "Wrapped XNT",
        mint: "So11111111111111111111111111111111111111112",
        logoURI: XDEX_LOGOS.WXNT,
        decimals: 9,
        isWrappedNative: true
      },
      {
        symbol: "USDC.X",
        name: "USD Coin (X1)",
        mint: "B69chRzqzDCmdB5WYB8NRu5Yv5ZA95ABiZcdzCgGm9Tq",
        logoURI: XDEX_LOGOS.USDC_X,
        decimals: 6,
        isToken2022: true
      }
    ];
  }
  if (network === "Solana Devnet") {
    return [
      { symbol: "SOL", name: "Solana", mint: SOLANA_TOKENS.SOL, logoURI: XDEX_LOGOS.SOL, decimals: 9, isNative: true },
      { symbol: "USDC", name: "USD Coin", mint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", decimals: 6, logoURI: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v/logo.png" }
    ];
  }
  logger$1.log("[Swap] Loading Solana Mainnet tokens from Jupiter");
  const jupiterTokens = await fetchJupiterTokens();
  if (jupiterTokens && jupiterTokens.length > 0 && jupiterTokens !== SOLANA_TOKEN_LIST) {
    const popularSet = new Set(POPULAR_SOLANA_MINTS);
    const logoOverrides = {};
    SOLANA_TOKEN_LIST.forEach((t2) => {
      logoOverrides[t2.address] = t2.logoURI;
    });
    const allTokens = jupiterTokens.map((t2) => ({
      symbol: t2.symbol,
      name: t2.name,
      mint: t2.address,
      // Use our reliable logos for popular tokens, fallback to Jupiter's logo
      logoURI: logoOverrides[t2.address] || t2.logoURI,
      decimals: t2.decimals,
      isPopular: popularSet.has(t2.address),
      // Mark SOL as native
      isNative: t2.symbol === "SOL" || t2.address === SOLANA_TOKENS.SOL
    })).sort((a, b) => {
      if (a.isNative && !b.isNative) return -1;
      if (!a.isNative && b.isNative) return 1;
      if (a.isPopular && !b.isPopular) return -1;
      if (!a.isPopular && b.isPopular) return 1;
      return a.symbol.localeCompare(b.symbol);
    });
    logger$1.log("[Swap] Loaded", allTokens.length, "tokens from Jupiter");
    return allTokens;
  }
  logger$1.log("[Swap] Using hardcoded Solana token list");
  return SOLANA_TOKEN_LIST.map((t2) => ({
    symbol: t2.symbol,
    name: t2.name,
    mint: t2.address,
    logoURI: t2.logoURI,
    decimals: t2.decimals,
    isNative: t2.symbol === "SOL"
  }));
}
async function searchTokens(query, network) {
  if (!isSolanaNetwork(network) || !query || query.length < 2) {
    return [];
  }
  const jupiterTokens = await fetchJupiterTokens();
  if (!jupiterTokens) return [];
  const lowerQuery = query.toLowerCase();
  return jupiterTokens.filter(
    (t2) => t2.symbol.toLowerCase().includes(lowerQuery) || t2.name.toLowerCase().includes(lowerQuery)
  ).slice(0, 20).map((t2) => ({
    symbol: t2.symbol,
    name: t2.name,
    mint: t2.address,
    logoURI: t2.logoURI,
    decimals: t2.decimals
  }));
}
async function fetchTokenMetadata(rpcUrl, mintAddress, network = null) {
  var _a2, _b2, _c, _d, _e, _f, _g;
  try {
    logger$1.log("[XDEX] Fetching token metadata for:", mintAddress, "on", network || "unknown network");
    const cached = getCachedMetadata(mintAddress);
    if (cached) {
      if (cached.failed) {
        logger$1.log("[XDEX] Cache hit (failed):", mintAddress, "- skipping API call");
        return null;
      }
      logger$1.log("[XDEX] Cache hit:", mintAddress, (_a2 = cached.data) == null ? void 0 : _a2.symbol);
      return cached.data;
    }
    if (network) {
      const knownToken = getKnownToken(network, mintAddress);
      if (knownToken) {
        logger$1.log("[XDEX] Found in known tokens:", knownToken.symbol);
        const result2 = {
          mint: mintAddress,
          symbol: knownToken.symbol,
          name: knownToken.name,
          decimals: knownToken.decimals,
          logoURI: knownToken.logoURI,
          isToken2022: knownToken.isToken2022 || false,
          isCustom: true
        };
        setCachedMetadata(mintAddress, result2);
        return result2;
      }
    }
    if (network && isSolanaNetwork(network)) {
      try {
        logger$1.log("[XDEX] Trying Jupiter API for Solana token...");
        const jupResponse = await fetch(`${JUPITER_TOKEN_API}/tag?query=verified`);
        if (jupResponse.ok) {
          const tokens2 = await jupResponse.json();
          const token = tokens2.find((t2) => (t2.id || t2.address) === mintAddress);
          if (token) {
            logger$1.log("[XDEX] Found token in Jupiter:", token.symbol);
            const result2 = {
              mint: mintAddress,
              symbol: token.symbol,
              name: token.name,
              decimals: token.decimals,
              logoURI: token.icon || token.logoURI,
              isToken2022: false,
              isCustom: true
            };
            setCachedMetadata(mintAddress, result2);
            return result2;
          }
        }
      } catch (e) {
        logger$1.log("[XDEX] Jupiter lookup failed:", e.message);
      }
    }
    logger$1.log("[XDEX] Fetching from RPC:", rpcUrl);
    const accountResponse = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "getAccountInfo",
        params: [mintAddress, { encoding: "jsonParsed" }]
      })
    });
    const accountData = await accountResponse.json();
    logger$1.log("[XDEX] RPC response:", accountData.result ? "found" : "not found", ((_b2 = accountData.error) == null ? void 0 : _b2.message) || "");
    if (!((_c = accountData.result) == null ? void 0 : _c.value)) {
      throw new Error(((_d = accountData.error) == null ? void 0 : _d.message) || "Token not found on this network");
    }
    const parsedData = (_e = accountData.result.value.data) == null ? void 0 : _e.parsed;
    if (!parsedData || parsedData.type !== "mint") {
      throw new Error("Not a valid token mint");
    }
    const mintInfo = parsedData.info;
    const owner = accountData.result.value.owner;
    const isToken2022 = owner === "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
    let symbol = mintAddress.slice(0, 4).toUpperCase();
    let name = isToken2022 ? "Token-2022" : "SPL Token";
    let logoURI = null;
    if (isToken2022 && mintInfo.extensions) {
      logger$1.log("[XDEX] Token-2022 extensions:", JSON.stringify(mintInfo.extensions, null, 2));
      const metadataExt = mintInfo.extensions.find(
        (ext) => ext.extension === "tokenMetadata" || ext.extension === "metadata" || ext.extension === "TokenMetadata"
      );
      logger$1.log("[XDEX] Metadata extension found:", metadataExt);
      if (metadataExt == null ? void 0 : metadataExt.state) {
        symbol = metadataExt.state.symbol || symbol;
        name = metadataExt.state.name || name;
        logger$1.log("[XDEX] Token-2022 metadata from extension:", { symbol, name });
        const uri = metadataExt.state.uri || metadataExt.state.URI || metadataExt.state.url;
        if (uri) {
          try {
            logger$1.log("[XDEX] Fetching metadata from URI:", uri);
            const metaResponse = await fetch(uri);
            if (metaResponse.ok) {
              const metaJson = await metaResponse.json();
              logger$1.log("[XDEX] URI metadata:", metaJson);
              logoURI = metaJson.image || metaJson.logo || metaJson.icon || metaJson.logoURI || null;
              if (metaJson.name && metaJson.name !== "Unknown") name = metaJson.name;
              if (metaJson.symbol && metaJson.symbol !== "UNKN") symbol = metaJson.symbol;
            }
          } catch (e) {
            logger$1.log("[XDEX] Could not fetch URI metadata:", e.message);
          }
        }
      }
    }
    if (!isToken2022 && parsedData.info) {
      if (parsedData.info.name) name = parsedData.info.name;
      if (parsedData.info.symbol) symbol = parsedData.info.symbol;
    }
    if (name === "Token-2022" || name === "SPL Token") {
      try {
        const METADATA_PROGRAM = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";
        const metaAccountResponse = await fetch(rpcUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            jsonrpc: "2.0",
            id: 1,
            method: "getProgramAccounts",
            params: [
              METADATA_PROGRAM,
              {
                encoding: "jsonParsed",
                filters: [
                  { memcmp: { offset: 33, bytes: mintAddress } }
                ]
              }
            ]
          })
        });
        const metaAccounts = await metaAccountResponse.json();
        logger$1.log("[XDEX] Metaplex accounts:", metaAccounts);
        if (((_f = metaAccounts.result) == null ? void 0 : _f.length) > 0) {
          const metaAccount = metaAccounts.result[0];
          const metaData = (_g = metaAccount.account) == null ? void 0 : _g.data;
          if (metaData) {
            logger$1.log("[XDEX] Found Metaplex metadata account");
          }
        }
      } catch (e) {
        logger$1.log("[XDEX] Metaplex lookup failed:", e.message);
      }
    }
    try {
      logger$1.log("[XDEX] Trying explorer API...");
      const explorerResponse = await fetch(`https://explorer.mainnet.x1.xyz/api/v2/tokens/${mintAddress}`);
      if (explorerResponse.ok) {
        const explorerData = await explorerResponse.json();
        logger$1.log("[XDEX] Explorer API response:", explorerData);
        if (explorerData.name) name = explorerData.name;
        if (explorerData.symbol) symbol = explorerData.symbol;
        if (explorerData.image || explorerData.logo || explorerData.logoURI) {
          logoURI = explorerData.image || explorerData.logo || explorerData.logoURI;
        }
      }
    } catch (e) {
      logger$1.log("[XDEX] Explorer API not available:", e.message);
    }
    if (name === "Token-2022" || name === "SPL Token" || !logoURI) {
      try {
        logger$1.log("[XDEX] Trying XDEX tokens API...");
        const xdexResponse = await fetch(`${XDEX_API$1}/tokens/${mintAddress}`);
        if (xdexResponse.ok) {
          const xdexData = await xdexResponse.json();
          logger$1.log("[XDEX] XDEX API response:", xdexData);
          if (xdexData.name) name = xdexData.name;
          if (xdexData.symbol) symbol = xdexData.symbol;
          if (xdexData.image || xdexData.logo || xdexData.logoURI || xdexData.icon) {
            logoURI = xdexData.image || xdexData.logo || xdexData.logoURI || xdexData.icon;
          }
        }
      } catch (e) {
        logger$1.log("[XDEX] XDEX API not available:", e.message);
      }
    }
    if (name === "Token-2022" || name === "SPL Token" || !logoURI) {
      try {
        logger$1.log("[XDEX] Trying X1 mobile API...");
        const mobileApiResponse = await fetch(`https://mobile-api.x1.xyz/tokens?mint=${encodeURIComponent(mintAddress)}&verified=true`);
        if (mobileApiResponse.ok) {
          const mobileData = await mobileApiResponse.json();
          logger$1.log("[XDEX] X1 mobile API response:", mobileData);
          if (mobileData.tokens && mobileData.tokens.length > 0) {
            const tokenData = mobileData.tokens[0];
            if (tokenData.name) name = tokenData.name;
            if (tokenData.symbol) symbol = tokenData.symbol;
            if (tokenData.image || tokenData.logo || tokenData.logoURI) {
              logoURI = tokenData.image || tokenData.logo || tokenData.logoURI;
            }
            logger$1.log("[XDEX] Found token in X1 mobile API:", symbol);
          }
        }
      } catch (e) {
        logger$1.log("[XDEX] X1 mobile API not available:", e.message);
      }
    }
    if (network && isSolanaNetwork(network) && (name === "SPL Token" || !logoURI)) {
      try {
        logger$1.log("[XDEX] Trying Solscan API...");
        const solscanResponse = await fetch(`https://api.solscan.io/token/meta?token=${mintAddress}`);
        if (solscanResponse.ok) {
          const solscanData = await solscanResponse.json();
          logger$1.log("[XDEX] Solscan API response:", solscanData);
          if (solscanData.data) {
            if (solscanData.data.name) name = solscanData.data.name;
            if (solscanData.data.symbol) symbol = solscanData.data.symbol;
            if (solscanData.data.icon) logoURI = solscanData.data.icon;
          }
        }
      } catch (e) {
        logger$1.log("[XDEX] Solscan API not available:", e.message);
      }
    }
    logger$1.log("[XDEX] Token metadata result:", { symbol, name, decimals: mintInfo.decimals, isToken2022, logoURI });
    const result = {
      mint: mintAddress,
      symbol,
      name,
      decimals: mintInfo.decimals,
      supply: mintInfo.supply,
      isToken2022,
      logoURI,
      isCustom: true
    };
    setCachedMetadata(mintAddress, result);
    return result;
  } catch (error) {
    logger$1.error("[XDEX] Failed to fetch token metadata:", error);
    setCachedMetadata(mintAddress, null, true);
    throw error;
  }
}
async function searchXDEXTokens(query, network) {
  try {
    const networkName = getNetworkName(network);
    const response = await fetch(`${XDEX_API$1}/tokens?network=${encodeURIComponent(networkName)}&search=${encodeURIComponent(query)}`, {
      method: "GET",
      headers: { "Content-Type": "application/json" }
    });
    if (!response.ok) {
      logger$1.log("[XDEX] Token search endpoint not available, using fallback");
      return null;
    }
    const data = await response.json();
    logger$1.log("[XDEX] Token search results:", data);
    if (data.tokens && Array.isArray(data.tokens)) {
      return data.tokens.map((t2) => ({
        symbol: t2.symbol,
        name: t2.name,
        mint: t2.address || t2.mint,
        logoURI: t2.logoURI || t2.logo,
        decimals: t2.decimals,
        isToken2022: t2.isToken2022 || false
      }));
    }
    return null;
  } catch (error) {
    logger$1.log("[XDEX] Token search failed:", error.message);
    return null;
  }
}
const xdex = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  KNOWN_TOKENS: KNOWN_TOKENS$1,
  SOLANA_TOKENS,
  XDEX_LOGOS,
  fetchTokenMetadata,
  getKnownToken,
  getNetworkName,
  getQuote,
  getSwapTokens,
  isSolanaNetwork,
  isX1Network: isX1Network$1,
  prepareSwap,
  searchTokens,
  searchXDEXTokens
}, Symbol.toStringTag, { value: "Module" }));
const ICONS = {
  X1: "/icons/48-x1.png",
  PXNT: "/icons/48-pxnt.png",
  USDCX: "/icons/48-usdcx.png",
  XLP: "/icons/48-xlp.png",
  // External icons (third-party tokens)
  SOL: "/icons/48-sol.png",
  USDC: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v/logo.png",
  USDT: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB/logo.png",
  MSOL: "https://raw.githubusercontent.com/marinade-finance/msol-logo/main/msol-logo.png",
  BONK: "https://arweave.net/hQiPZOsRZXGXBJd_82PhVdlM_hACsT_q6wqwf5cSY7I",
  JUP: "https://static.jup.ag/jup/icon.png",
  ETH: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs/logo.png",
  MIND: "https://xdex.s3.us-east-2.amazonaws.com/tokens/mind-48.png"
};
const XDEX_LP_MINT_AUTHORITY = "9Dpjw2pB5kXJr6ZTHiqzEMfJPic3om9jgNacnwpLCoaU";
const XLP_LOGO_URL = ICONS.XLP;
const KNOWN_TOKENS = {
  // === Native/Wrapped Tokens ===
  "So11111111111111111111111111111111111111112": {
    symbol: "SOL",
    name: "Wrapped SOL",
    decimals: 9,
    logoURI: ICONS.SOL
  },
  // === Stablecoins ===
  "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v": {
    symbol: "USDC",
    name: "USD Coin",
    decimals: 6,
    logoURI: ICONS.USDC
  },
  "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB": {
    symbol: "USDT",
    name: "Tether USD",
    decimals: 6,
    logoURI: ICONS.USDT
  },
  "B69chRzqzDCmdB5WYB8NRu5Yv5ZA95ABiZcdzCgGm9Tq": {
    symbol: "USDC.X",
    name: "USDC X1",
    decimals: 6,
    logoURI: ICONS.USDCX,
    isToken2022: true,
    price: 1
  },
  // === Liquid Staking Tokens ===
  "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So": {
    symbol: "mSOL",
    name: "Marinade staked SOL",
    decimals: 9,
    logoURI: ICONS.MSOL
  },
  "pXNTyoqQsskHdZ7Q1rnP25FEyHHjissbs7n6RRN2nP5": {
    symbol: "pXNT",
    name: "Staked XNT",
    decimals: 9,
    logoURI: ICONS.PXNT,
    isToken2022: false,
    isStakePoolToken: true,
    price: 1
  },
  // === Popular Tokens ===
  "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263": {
    symbol: "BONK",
    name: "Bonk",
    decimals: 5,
    logoURI: ICONS.BONK
  },
  "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN": {
    symbol: "JUP",
    name: "Jupiter",
    decimals: 6,
    logoURI: ICONS.JUP
  },
  "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs": {
    symbol: "ETH",
    name: "Ether (Wormhole)",
    decimals: 8,
    logoURI: ICONS.ETH
  },
  // === X1 Ecosystem Tokens ===
  "DohWBfvXER6qs8zFGtdZRDpgbHmm97ZZwgCUTCdtHQNT": {
    symbol: "MIND",
    name: "Mind",
    decimals: 9,
    logoURI: ICONS.MIND
  }
};
const NETWORK_TOKEN_OVERRIDES = {
  "X1 Mainnet": {
    "So11111111111111111111111111111111111111112": {
      symbol: "WXNT",
      name: "Wrapped XNT",
      decimals: 9,
      logoURI: ICONS.X1
    }
  },
  "X1 Testnet": {
    "So11111111111111111111111111111111111111112": {
      symbol: "WXNT",
      name: "Wrapped XNT",
      decimals: 9,
      logoURI: ICONS.X1
    }
  },
  "Solana Mainnet": {
    "So11111111111111111111111111111111111111112": {
      symbol: "SOL",
      name: "Solana",
      decimals: 9,
      logoURI: ICONS.SOL
    },
    "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v": {
      symbol: "USDC",
      name: "USD Coin",
      decimals: 6,
      logoURI: ICONS.USDC
    },
    "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB": {
      symbol: "USDT",
      name: "Tether USD",
      decimals: 6,
      logoURI: ICONS.USDT
    }
  },
  "Solana Devnet": {
    "So11111111111111111111111111111111111111112": {
      symbol: "SOL",
      name: "Solana",
      decimals: 9,
      logoURI: ICONS.SOL
    }
  }
};
const X1_TOKEN_OVERRIDES = {
  "So11111111111111111111111111111111111111112": {
    symbol: "WXNT",
    name: "Wrapped XNT",
    decimals: 9,
    logoURI: ICONS.X1
  }
};
function isX1Network(network) {
  var _a2, _b2;
  if (!network) return false;
  if (network === "X1 Mainnet" || network === "X1 Testnet") return true;
  const lowerName = network.toLowerCase();
  if (lowerName.includes("x1") || lowerName.includes("xnt")) return true;
  try {
    const customNetworks = JSON.parse(localStorage.getItem("x1wallet_customRpcs") || "[]");
    const customNet = customNetworks.find((n2) => n2.name === network);
    if (customNet) {
      const url = ((_a2 = customNet.url) == null ? void 0 : _a2.toLowerCase()) || "";
      if (url.includes("x1.xyz") || url.includes("x1.") || url.includes("/x1") || ((_b2 = customNet.symbol) == null ? void 0 : _b2.toUpperCase()) === "XNT") {
        return true;
      }
    }
  } catch {
  }
  return false;
}
function getKnownTokenMetadata(mint, network) {
  const networkOverrides = NETWORK_TOKEN_OVERRIDES[network];
  if (networkOverrides && networkOverrides[mint]) {
    return networkOverrides[mint];
  }
  if (isX1Network(network) && X1_TOKEN_OVERRIDES[mint]) {
    return X1_TOKEN_OVERRIDES[mint];
  }
  return KNOWN_TOKENS[mint] || null;
}
const API_SERVER$1 = "https://mobile-api.x1.xyz";
const TOKEN_PROGRAM_ID$2 = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
const TOKEN_2022_PROGRAM_ID = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
const METADATA_PROGRAM_ID = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";
class RateLimiter {
  constructor(maxRequests = 5, windowMs = 1e3) {
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
    this.requests = [];
  }
  async acquire() {
    const now = Date.now();
    this.requests = this.requests.filter((time) => now - time < this.windowMs);
    if (this.requests.length >= this.maxRequests) {
      const waitTime = this.windowMs - (now - this.requests[0]) + 10;
      await new Promise((resolve) => setTimeout(resolve, waitTime));
      return this.acquire();
    }
    this.requests.push(now);
    return true;
  }
}
const xdexRateLimiter = new RateLimiter(5, 1e3);
const rpcTokenAccountsCache = /* @__PURE__ */ new Map();
const RPC_CACHE_TTL = 15 * 1e3;
const walletTokensCache = /* @__PURE__ */ new Map();
const WALLET_TOKENS_CACHE_TTL = 60 * 1e3;
function getCachedRPCTokenAccounts(ownerAddress, rpcUrl) {
  const cacheKey = `${ownerAddress}:${rpcUrl}`;
  const cached = rpcTokenAccountsCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < RPC_CACHE_TTL) {
    logger$1.log("[RPC Cache] Hit - using cached token accounts, age:", Math.round((Date.now() - cached.timestamp) / 1e3), "s");
    return cached.data;
  }
  return null;
}
function setCachedRPCTokenAccounts(ownerAddress, rpcUrl, splTokens, token2022) {
  const cacheKey = `${ownerAddress}:${rpcUrl}`;
  rpcTokenAccountsCache.set(cacheKey, {
    data: { splTokens, token2022 },
    timestamp: Date.now()
  });
  if (rpcTokenAccountsCache.size > 5) {
    const oldestKey = rpcTokenAccountsCache.keys().next().value;
    rpcTokenAccountsCache.delete(oldestKey);
  }
  logger$1.log("[RPC Cache] Stored token accounts for", ownerAddress.slice(0, 8));
}
function invalidateRPCCache(ownerAddress = null) {
  if (ownerAddress) {
    for (const key of rpcTokenAccountsCache.keys()) {
      if (key.startsWith(ownerAddress)) {
        rpcTokenAccountsCache.delete(key);
      }
    }
    for (const key of walletTokensCache.keys()) {
      if (key.startsWith(ownerAddress)) {
        walletTokensCache.delete(key);
      }
    }
    logger$1.log("[Cache] Invalidated for wallet:", ownerAddress.slice(0, 8));
  } else {
    rpcTokenAccountsCache.clear();
    walletTokensCache.clear();
    logger$1.log("[Cache] Invalidated all");
  }
}
const FAILED_CACHE_KEY = "x1wallet_failed_token_lookups";
const FAILED_CACHE_TTL = 10 * 60 * 1e3;
function getFailedCache() {
  try {
    const cached = localStorage.getItem(FAILED_CACHE_KEY);
    return cached ? JSON.parse(cached) : {};
  } catch {
    return {};
  }
}
function setFailedCache(cache) {
  try {
    const now = Date.now();
    const cleaned = {};
    for (const [key, timestamp] of Object.entries(cache)) {
      if (now - timestamp < FAILED_CACHE_TTL) {
        cleaned[key] = timestamp;
      }
    }
    const entries = Object.entries(cleaned);
    if (entries.length > 100) {
      entries.sort((a, b) => b[1] - a[1]);
      const limited = Object.fromEntries(entries.slice(0, 100));
      localStorage.setItem(FAILED_CACHE_KEY, JSON.stringify(limited));
    } else {
      localStorage.setItem(FAILED_CACHE_KEY, JSON.stringify(cleaned));
    }
  } catch {
  }
}
function hasRecentlyFailed(key) {
  const cache = getFailedCache();
  const failedAt = cache[key];
  if (!failedAt) return false;
  if (Date.now() - failedAt > FAILED_CACHE_TTL) {
    delete cache[key];
    setFailedCache(cache);
    return false;
  }
  return true;
}
function markFailed(key) {
  const cache = getFailedCache();
  cache[key] = Date.now();
  setFailedCache(cache);
}
function clearFailed(key) {
  const cache = getFailedCache();
  delete cache[key];
  setFailedCache(cache);
}
async function fetchWithRateLimit(url, options = {}) {
  await xdexRateLimiter.acquire();
  return fetch(url, options);
}
const mintAuthorityCache = /* @__PURE__ */ new Map();
const MINT_AUTHORITY_CACHE_TTL = 30 * 60 * 1e3;
const lpTokenInfoCache = /* @__PURE__ */ new Map();
const LP_TOKEN_INFO_CACHE_TTL = 10 * 60 * 1e3;
async function fetchMintAuthority(rpcUrl, mintAddress) {
  var _a2, _b2, _c, _d, _e;
  const cacheKey = `${rpcUrl}:${mintAddress}`;
  const cached = mintAuthorityCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < MINT_AUTHORITY_CACHE_TTL) {
    return cached.authority;
  }
  try {
    const response = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "getAccountInfo",
        params: [
          mintAddress,
          { encoding: "jsonParsed" }
        ]
      })
    });
    const data = await response.json();
    const mintAuthority = ((_e = (_d = (_c = (_b2 = (_a2 = data == null ? void 0 : data.result) == null ? void 0 : _a2.value) == null ? void 0 : _b2.data) == null ? void 0 : _c.parsed) == null ? void 0 : _d.info) == null ? void 0 : _e.mintAuthority) || null;
    mintAuthorityCache.set(cacheKey, { authority: mintAuthority, timestamp: Date.now() });
    return mintAuthority;
  } catch (e) {
    logger$1.warn("[Tokens] Failed to fetch mint authority:", e.message);
    return null;
  }
}
async function fetchLPTokenInfoFromXDEX(lpMint) {
  const cacheKey = `lp:${lpMint}`;
  const cached = lpTokenInfoCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < LP_TOKEN_INFO_CACHE_TTL) {
    return cached.info;
  }
  try {
    const response = await fetchWithRateLimit(
      `https://devapi.xdex.xyz/api/xendex/tokens/${lpMint}`,
      { signal: AbortSignal.timeout(2e3) }
    );
    if (response.ok) {
      const data = await response.json();
      logger$1.log("[Tokens] XDEX devapi LP token data:", data);
      if (data.name && data.name !== "Unknown Token" && data.name.trim() !== "") {
        const info = {
          name: data.name,
          symbol: data.symbol || "XLP",
          logoURI: data.image || data.logo || data.logoURI
        };
        lpTokenInfoCache.set(cacheKey, { info, timestamp: Date.now() });
        return info;
      }
    }
  } catch (e) {
    logger$1.warn("[Tokens] XDEX devapi LP lookup failed:", e.message);
  }
  lpTokenInfoCache.set(cacheKey, { info: null, timestamp: Date.now() });
  return null;
}
async function checkAndApplyLPBranding(rpcUrl, token, network) {
  var _a2;
  const isX1 = network == null ? void 0 : network.includes("X1");
  const isSolana = network == null ? void 0 : network.includes("Solana");
  if (!isX1 && !isSolana) return false;
  try {
    const mintAuthority = await fetchMintAuthority(rpcUrl, token.mint);
    if (mintAuthority === XDEX_LP_MINT_AUTHORITY) {
      token.isLPToken = true;
      token.logoURI = XLP_LOGO_URL;
      const hasGoodName = token.name && token.name !== "XLP" && token.name !== "SLP" && token.name !== "SPL Token" && token.name !== "Token-2022" && token.name !== "XDEX LP Token" && token.name !== "SLP Token" && token.name !== "Unknown Token";
      if (hasGoodName) {
        if (!token.symbol || token.symbol === ((_a2 = token.mint) == null ? void 0 : _a2.slice(0, 4).toUpperCase())) {
          token.symbol = "XLP";
        }
        logger$1.log(`[Tokens] LP token keeping good name: ${token.mint} -> ${token.name}`);
        return true;
      }
      if (isX1) {
        logger$1.log("[Tokens] Fetching LP name from XDEX devapi for:", token.mint);
        const lpInfo = await fetchLPTokenInfoFromXDEX(token.mint);
        if (lpInfo && lpInfo.name && lpInfo.name !== "Unknown Token") {
          token.name = lpInfo.name;
          token.symbol = lpInfo.symbol || "XLP";
          logger$1.log(`[Tokens] LP token got API name: ${token.mint} -> ${token.name}`);
        } else {
          token.name = "XDEX LP Token";
          token.symbol = "XLP";
          logger$1.log(`[Tokens] LP token using fallback name: ${token.mint}`);
        }
      } else if (isSolana) {
        token.name = "SLP Token";
        token.symbol = "SLP";
        logger$1.log(`[Tokens] Solana LP token: ${token.mint}`);
      }
      token.logoURI = XLP_LOGO_URL;
      return true;
    }
  } catch (e) {
    logger$1.warn("[Tokens] LP token check failed:", e.message);
  }
  return false;
}
const METADATA_CACHE_KEY = "x1wallet_metadata_cache";
const METADATA_CACHE_TTL = 30 * 60 * 1e3;
const metadataCache = /* @__PURE__ */ new Map();
function loadMetadataCache() {
  try {
    const cached = localStorage.getItem(METADATA_CACHE_KEY);
    if (cached) {
      const data = JSON.parse(cached);
      if (data._timestamp && Date.now() - data._timestamp < METADATA_CACHE_TTL) {
        let count = 0;
        let skipped = 0;
        const genericNames = ["XLP", "SLP", "SPL Token", "Token-2022", "XDEX LP Token", "SLP Token", "Unknown Token"];
        for (const [key, value] of Object.entries(data)) {
          if (key !== "_timestamp") {
            if (value.isLPToken && genericNames.includes(value.name)) {
              skipped++;
              continue;
            }
            metadataCache.set(key, value);
            count++;
          }
        }
        logger$1.log("[Tokens] Loaded", count, "entries from cache (skipped", skipped, "LP tokens)");
      }
    }
  } catch (e) {
    logger$1.warn("[Tokens] Error loading metadata cache:", e);
  }
}
let metadataCacheSaveTimeout = null;
function saveMetadataCache() {
  if (metadataCacheSaveTimeout) {
    clearTimeout(metadataCacheSaveTimeout);
  }
  metadataCacheSaveTimeout = setTimeout(() => {
    try {
      const data = { _timestamp: Date.now() };
      let count = 0;
      for (const [key, value] of metadataCache.entries()) {
        if (count >= 200) break;
        data[key] = value;
        count++;
      }
      localStorage.setItem(METADATA_CACHE_KEY, JSON.stringify(data));
      logger$1.log("[Tokens] Saved", count, "entries to metadata cache");
    } catch (e) {
      logger$1.warn("[Tokens] Error saving metadata cache:", e);
    }
  }, 1e3);
}
loadMetadataCache();
const PRICE_CACHE_KEY = "x1wallet_price_cache";
const PRICE_CACHE_TTL = 5 * 60 * 1e3;
function getPriceCache() {
  try {
    const cached = localStorage.getItem(PRICE_CACHE_KEY);
    if (cached) {
      return JSON.parse(cached);
    }
  } catch (e) {
  }
  return {};
}
function setPriceCache(prices) {
  try {
    localStorage.setItem(PRICE_CACHE_KEY, JSON.stringify({
      ...prices,
      _timestamp: Date.now()
    }));
  } catch (e) {
  }
}
function getCachedPrice(mint) {
  const cache = getPriceCache();
  if (cache[mint] !== void 0 && cache._timestamp && Date.now() - cache._timestamp < PRICE_CACHE_TTL) {
    return cache[mint];
  }
  return void 0;
}
function updatePriceCache(mint, price) {
  const cache = getPriceCache();
  cache[mint] = price;
  cache._timestamp = Date.now();
  setPriceCache(cache);
}
async function fetchTokenMetadataFromAPI(mint) {
  try {
    const url = `${API_SERVER$1}/tokens?mint=${encodeURIComponent(mint)}&verified=true`;
    logger$1.log("[Token API] Fetching metadata for:", mint);
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 3e3);
    const response = await fetch(url, { signal: controller.signal });
    clearTimeout(timeout);
    if (!response.ok) {
      logger$1.log("[Token API] HTTP", response.status, "- Failed to fetch");
      return null;
    }
    const data = await response.json();
    if (data && data.tokens && data.tokens.length > 0) {
      const token = data.tokens[0];
      logger$1.log("[Token API] Found:", token.name, "(" + token.symbol + ")");
      return {
        name: token.name,
        symbol: token.symbol,
        logoURI: token.icon,
        price: token.price,
        mint: token.mint
      };
    }
    logger$1.log("[Token API] No token found for mint:", mint);
    return null;
  } catch (e) {
    if (e.name === "AbortError") {
      logger$1.warn("[Token API] Request timeout for:", mint);
    } else {
      logger$1.warn("[Token API] Error fetching metadata:", e);
    }
    return null;
  }
}
async function fetchFromDAS(rpcUrl, mint) {
  try {
    if (!rpcUrl.includes("helius")) return null;
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 3e3);
    const response = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "getAsset",
        params: { id: mint }
      }),
      signal: controller.signal
    });
    clearTimeout(timeout);
    const data = await response.json();
    if (data.result && data.result.content) {
      const content = data.result.content;
      const metadata = content.metadata || {};
      const links = content.links || {};
      const files = content.files || [];
      let logoURI = links.image || null;
      if (!logoURI && files.length > 0) {
        const imageFile = files.find((f2) => {
          var _a2;
          return (_a2 = f2.mime) == null ? void 0 : _a2.startsWith("image/");
        });
        if (imageFile) logoURI = imageFile.uri;
      }
      logger$1.log("[DAS API] Found metadata:", metadata.name);
      return {
        name: metadata.name,
        symbol: metadata.symbol,
        logoURI,
        uri: content.json_uri
      };
    }
    return null;
  } catch (e) {
    logger$1.warn("[DAS API] Error:", e.message);
    return null;
  }
}
async function fetchTokenAccounts(rpcUrl, ownerAddress, network = null, onUpdate = null, options = {}) {
  var _a2, _b2, _c, _d, _e, _f, _g, _h, _i;
  const tokens2 = [];
  const startTime = Date.now();
  const mode = options.mode || "refresh";
  const forceRefresh = options.forceRefresh || false;
  try {
    logger$1.log("[Tokens] Starting token fetch for:", ownerAddress, "on network:", network, "mode:", mode, "force:", forceRefresh);
    const cachedRPC = forceRefresh ? null : getCachedRPCTokenAccounts(ownerAddress, rpcUrl);
    let splTokens, token2022, xdexPrices;
    if (mode === "import" && !forceRefresh) {
      if (cachedRPC) {
        splTokens = cachedRPC.splTokens;
        token2022 = cachedRPC.token2022;
        xdexPrices = {};
        logger$1.log("[Tokens] Import mode - using cached RPC, skipping XDEX");
      } else {
        [splTokens, token2022] = await Promise.all([
          fetchTokenAccountsByProgram(rpcUrl, ownerAddress, TOKEN_PROGRAM_ID$2),
          fetchTokenAccountsByProgram(rpcUrl, ownerAddress, TOKEN_2022_PROGRAM_ID)
        ]);
        xdexPrices = {};
        setCachedRPCTokenAccounts(ownerAddress, rpcUrl, splTokens, token2022);
        logger$1.log("[Tokens] Import mode - fresh RPC, skipping XDEX");
      }
    } else if (cachedRPC) {
      splTokens = cachedRPC.splTokens;
      token2022 = cachedRPC.token2022;
      xdexPrices = await fetchXDEXWalletTokens(ownerAddress, network);
      logger$1.log("[Tokens] Fast path - cached RPC +", Date.now() - startTime, "ms for XDEX");
    } else {
      [splTokens, token2022, xdexPrices] = await Promise.all([
        fetchTokenAccountsByProgram(rpcUrl, ownerAddress, TOKEN_PROGRAM_ID$2),
        fetchTokenAccountsByProgram(rpcUrl, ownerAddress, TOKEN_2022_PROGRAM_ID),
        fetchXDEXWalletTokens(ownerAddress, network)
      ]);
      setCachedRPCTokenAccounts(ownerAddress, rpcUrl, splTokens, token2022);
    }
    logger$1.log("[Tokens] RPC done in", Date.now() - startTime, "ms - SPL:", splTokens.length, "Token2022:", token2022.length);
    logger$1.log("[Tokens] XDEX prices received for", Object.keys(xdexPrices).length, "tokens");
    tokens2.push(...splTokens, ...token2022);
    const DUST_RAW_THRESHOLD = 1;
    let dustCount = 0;
    for (const token of tokens2) {
      if (token.balance === 0 || token.uiAmount === 0 || parseInt(token.amount) === 0) {
        token.isDust = true;
        token.skipEnrichment = true;
        dustCount++;
        continue;
      }
      if (parseInt(token.amount) <= DUST_RAW_THRESHOLD) {
        token.isDust = true;
        token.skipEnrichment = true;
        dustCount++;
      }
    }
    if (dustCount > 0) {
      logger$1.log("[Tokens] Pre-filtered", dustCount, "dust tokens from pricing pipeline");
    }
    const genericLPNames = ["XLP", "SLP", "SPL Token", "Token-2022", "XDEX LP Token", "SLP Token", "Unknown Token"];
    for (const token of tokens2) {
      if (token.isDust) {
        token.symbol = ((_a2 = token.mint) == null ? void 0 : _a2.slice(0, 4)) || "DUST";
        token.name = "Dust Token";
        continue;
      }
      const cacheKey = network ? `${network}:${token.mint}` : token.mint;
      logger$1.log("[Tokens] Processing token:", (_b2 = token.mint) == null ? void 0 : _b2.slice(0, 8), "symbol:", token.symbol, "name:", token.name);
      if (metadataCache.has(cacheKey)) {
        const cached = metadataCache.get(cacheKey);
        logger$1.log("[Tokens] Found in cache:", (_c = token.mint) == null ? void 0 : _c.slice(0, 8), "isLPToken:", cached.isLPToken, "name:", cached.name);
        if (cached.isLPToken && genericLPNames.includes(cached.name)) {
          logger$1.log("[Tokens] Quick pass: skipping cached LP with generic name:", cached.name);
          Object.assign(token, cached);
          token.needsEnrichment = true;
          token.logoURI = XLP_LOGO_URL;
          const xdexPrice2 = (_d = xdexPrices[token.mint]) == null ? void 0 : _d.price;
          if (xdexPrice2 !== void 0 && xdexPrice2 !== null && !isNaN(xdexPrice2)) {
            token.price = parseFloat(xdexPrice2);
          }
          continue;
        }
        Object.assign(token, cached);
        if (cached.isLPToken) {
          token.logoURI = XLP_LOGO_URL;
        }
        const xdexPrice = (_e = xdexPrices[token.mint]) == null ? void 0 : _e.price;
        if (xdexPrice !== void 0 && xdexPrice !== null && !isNaN(xdexPrice)) {
          token.price = parseFloat(xdexPrice);
          updatePriceCache(token.mint, token.price);
        }
        continue;
      }
      const known = getKnownTokenMetadata(token.mint, network);
      if (known) {
        token.symbol = known.symbol;
        token.name = known.name;
        token.logoURI = known.logoURI;
        token.price = known.price;
        const xdexPrice = (_f = xdexPrices[token.mint]) == null ? void 0 : _f.price;
        if (xdexPrice !== void 0 && xdexPrice !== null && !isNaN(xdexPrice)) {
          token.price = parseFloat(xdexPrice);
          updatePriceCache(token.mint, token.price);
          logger$1.log("[Tokens] XDEX price for", token.symbol, ":", token.price);
        }
        metadataCache.set(cacheKey, { symbol: token.symbol, name: token.name, logoURI: token.logoURI, price: token.price });
        continue;
      }
      if (xdexPrices[token.mint]) {
        const xdexData = xdexPrices[token.mint];
        logger$1.log("[Tokens] XDEX data for:", (_g = token.mint) == null ? void 0 : _g.slice(0, 8), "symbol:", xdexData.symbol, "name:", xdexData.name, "isLPToken:", xdexData.isLPToken);
        if (xdexData.price !== void 0 && xdexData.price !== null) {
          token.price = parseFloat(xdexData.price);
          updatePriceCache(token.mint, token.price);
        }
        if (xdexData.symbol) token.symbol = xdexData.symbol;
        if (xdexData.name) token.name = xdexData.name;
        const tokenName = (xdexData.name || "").toLowerCase();
        const tokenSymbol = (xdexData.symbol || "").toUpperCase();
        const isLPToken = xdexData.isLPToken || tokenSymbol === "XLP" || tokenSymbol === "SLP" || tokenSymbol.includes("XLP") || // catches "WXNT-USDC.X XLP"
        tokenSymbol.includes("SLP") || tokenName.includes("xlp") || // catches "wxnt-usdc.x xlp"
        tokenName.includes(" lp") || tokenName.includes("lp token") || tokenName.includes("/") || tokenName.includes("xdex") && tokenName.includes("lp") || /[a-z0-9.]+\/[a-z0-9.]+/i.test(xdexData.name);
        logger$1.log("[Tokens] LP detection for", (_h = token.mint) == null ? void 0 : _h.slice(0, 8), "- isLPToken:", isLPToken, "tokenName:", tokenName, "tokenSymbol:", tokenSymbol);
        if (isLPToken) {
          token.isLPToken = true;
          token.logoURI = XLP_LOGO_URL;
          logger$1.log("[Tokens] Quick pass: LP token detected:", token.symbol, token.name, "logoURI:", token.logoURI);
          const hasGoodName = token.name && token.name !== "XLP" && token.name !== "SLP" && token.name !== "SPL Token" && token.name !== "Token-2022" && token.name !== "XDEX LP Token" && token.name !== "Unknown Token";
          if (hasGoodName) {
            metadataCache.set(cacheKey, {
              symbol: token.symbol,
              name: token.name,
              logoURI: token.logoURI,
              price: token.price,
              isLPToken: true
            });
            logger$1.log("[Tokens] Quick pass: LP token with good name:", token.name);
          } else {
            token.needsEnrichment = true;
            logger$1.log("[Tokens] Quick pass: LP token needs enrichment:", (_i = token.mint) == null ? void 0 : _i.slice(0, 8));
          }
          continue;
        }
        if (xdexData.image) {
          token.logoURI = xdexData.image;
        }
        if (xdexData.symbol && xdexData.name) {
          metadataCache.set(cacheKey, {
            symbol: token.symbol,
            name: token.name,
            logoURI: token.logoURI,
            price: token.price
          });
          continue;
        }
      }
      if (token.price === void 0 || token.price === null) {
        const cachedPrice = getCachedPrice(token.mint);
        if (cachedPrice !== void 0) {
          token.price = cachedPrice;
        }
      }
      if (!token.symbol) {
        token.symbol = token.mint ? token.mint.slice(0, 4).toUpperCase() : "UNK";
      }
      if (!token.name) {
        token.name = token.isToken2022 ? "Token-2022" : "SPL Token";
      }
    }
    logger$1.log("[Tokens] Quick pass done in", Date.now() - startTime, "ms - RETURNING IMMEDIATELY");
    const DUST_USD_THRESHOLD = 0.01;
    const tokensNeedingMetadata = tokens2.filter((t2) => {
      var _a3;
      if (t2.isDust || t2.skipEnrichment) {
        return false;
      }
      if (t2.price && t2.uiAmount) {
        const valueUsd = t2.uiAmount * t2.price;
        if (valueUsd < DUST_USD_THRESHOLD) {
          t2.skipEnrichment = true;
          logger$1.log("[Tokens] Skipping dust token:", (_a3 = t2.mint) == null ? void 0 : _a3.slice(0, 8), "value:", valueUsd);
          return false;
        }
      }
      if (t2.needsEnrichment) return true;
      const cacheKey = network ? `${network}:${t2.mint}` : t2.mint;
      if (!metadataCache.has(cacheKey)) return true;
      const cached = metadataCache.get(cacheKey);
      if (cached.isLPToken && genericLPNames.includes(cached.name)) return true;
      return !cached.logoURI;
    });
    if (tokensNeedingMetadata.length > 0) {
      logger$1.log("[Tokens] Will enrich", tokensNeedingMetadata.length, "tokens in background");
      (async () => {
        try {
          const batchSize = 10;
          let updated = false;
          for (let i = 0; i < tokensNeedingMetadata.length; i += batchSize) {
            const batch = tokensNeedingMetadata.slice(i, i + batchSize);
            await Promise.allSettled(batch.map(async (token) => {
              try {
                await enrichTokenMetadata(rpcUrl, token, network);
                updated = true;
              } catch (e) {
                logger$1.warn("[Tokens] Failed to enrich metadata for", token.mint, e.message);
              }
            }));
            if (updated && onUpdate) {
              onUpdate([...tokens2]);
              updated = false;
            }
          }
          if (onUpdate) {
            onUpdate([...tokens2]);
          }
          saveMetadataCache();
          logger$1.log("[Tokens] Background enrichment complete in", Date.now() - startTime, "ms");
        } catch (e) {
          logger$1.warn("[Tokens] Background enrichment error:", e);
        }
      })();
    }
    if (mode === "import" && onUpdate && tokens2.length > 0) {
      logger$1.log("[Tokens] Import mode - fetching prices in background");
      (async () => {
        try {
          await new Promise((r2) => setTimeout(r2, 100));
          const priceData = await fetchXDEXWalletTokens(ownerAddress, network);
          if (Object.keys(priceData).length > 0) {
            let pricesUpdated = false;
            for (const token of tokens2) {
              if (priceData[token.mint]) {
                const data = priceData[token.mint];
                if (data.price !== void 0 && data.price !== null && !isNaN(data.price)) {
                  token.price = parseFloat(data.price);
                  updatePriceCache(token.mint, token.price);
                  pricesUpdated = true;
                }
                if (data.symbol && !token.symbol) token.symbol = data.symbol;
                if (data.name && (!token.name || token.name === "Unknown Token")) token.name = data.name;
                if (data.image && !token.logoURI) token.logoURI = data.image;
              }
            }
            if (pricesUpdated) {
              logger$1.log("[Tokens] Background prices applied for", Object.keys(priceData).length, "tokens");
              onUpdate([...tokens2]);
            }
          }
        } catch (e) {
          logger$1.warn("[Tokens] Background price fetch error:", e.message);
        }
      })();
    }
    saveMetadataCache();
    logger$1.log("[Tokens] Returning", tokens2.length, "tokens");
    return tokens2;
  } catch (e) {
    logger$1.error("[Tokens] Error fetching token accounts:", e);
    return [];
  }
}
async function fetchXDEXWalletTokens(walletAddress, network) {
  var _a2;
  try {
    const networkName = network || "X1 Mainnet";
    const cacheKey = `${walletAddress}:${networkName}`;
    const cached = walletTokensCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < WALLET_TOKENS_CACHE_TTL) {
      logger$1.log("[XDEX] Using cached wallet tokens response");
      return cached.data;
    }
    const url = `https://devapi.xdex.xyz/api/xendex/wallet/tokens?wallet_address=${walletAddress}&network=${encodeURIComponent(networkName)}&price=true`;
    logger$1.log("[XDEX] Fetching wallet tokens with prices");
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 5e3);
    const response = await fetch(url, {
      signal: controller.signal,
      headers: { "Accept": "application/json" }
    });
    clearTimeout(timeout);
    if (!response.ok) {
      logger$1.warn("[XDEX] Wallet tokens API returned:", response.status);
      walletTokensCache.set(cacheKey, { data: {}, timestamp: Date.now() });
      return {};
    }
    const data = await response.json();
    const tokenList = ((_a2 = data == null ? void 0 : data.data) == null ? void 0 : _a2.tokens) || (data == null ? void 0 : data.tokens) || (Array.isArray(data) ? data : []);
    logger$1.log("[XDEX] Wallet tokens response - count:", tokenList.length);
    if (tokenList[0]) {
      logger$1.log("[XDEX] Sample token fields:", Object.keys(tokenList[0]).join(", "));
    }
    const priceMap = {};
    const extractPrice = (token) => {
      const priceValue = token.price ?? token.priceUsd ?? token.price_usd ?? token.priceUSD ?? token.usdPrice ?? token.usd_price ?? token.tokenPrice ?? token.token_price ?? null;
      if (priceValue !== null && priceValue !== void 0) {
        const parsed = parseFloat(priceValue);
        if (!isNaN(parsed) && parsed >= 0) {
          return parsed;
        }
      }
      return null;
    };
    for (const token of tokenList) {
      if (token.mint || token.address) {
        const mint = token.mint || token.address;
        const price = extractPrice(token);
        let imageUrl = token.imageUrl || token.image || token.logo || token.logoURI || token.icon;
        if (imageUrl && !imageUrl.startsWith("http")) {
          imageUrl = null;
        }
        const tokenName = (token.name || "").toLowerCase();
        const tokenSymbol = (token.symbol || "").toUpperCase();
        const isLP = tokenSymbol === "XLP" || tokenSymbol === "SLP" || tokenSymbol.includes("XLP") || // catches "WXNT-USDC.X XLP"
        tokenSymbol.includes("SLP") || tokenName.includes("xlp") || // catches "wxnt-usdc.x xlp"
        tokenName.includes(" lp") || tokenName.includes("lp token") || tokenName.includes("/") || tokenName.includes("xdex") && tokenName.includes("lp") || /[a-z0-9.]+\/[a-z0-9.]+/i.test(token.name);
        if (isLP) {
          logger$1.log("[XDEX] Detected LP token:", token.symbol, token.name);
        }
        priceMap[mint] = {
          price,
          symbol: token.symbol,
          name: token.name,
          image: isLP ? XLP_LOGO_URL : imageUrl,
          // Use XLP icon for LP tokens
          isLPToken: isLP
        };
        if (price !== null) {
          logger$1.log("[XDEX] Price found for", token.symbol || mint.slice(0, 8), ":", price);
        }
      }
    }
    logger$1.log("[XDEX] Total prices extracted:", Object.values(priceMap).filter((p2) => p2.price !== null).length);
    walletTokensCache.set(cacheKey, { data: priceMap, timestamp: Date.now() });
    return priceMap;
  } catch (e) {
    if (e.name === "AbortError") {
      logger$1.warn("[XDEX] Wallet tokens request timeout");
    } else {
      logger$1.warn("[XDEX] Failed to fetch wallet tokens:", e.message);
    }
    return {};
  }
}
async function fetchTokenAccountsByProgram(rpcUrl, ownerAddress, programId) {
  var _a2;
  if (!rpcUrl) {
    logger$1.error("[Tokens] No RPC URL provided");
    return [];
  }
  logger$1.log(`[Tokens] Fetching ${programId === TOKEN_2022_PROGRAM_ID ? "Token-2022" : "SPL Token"} accounts from:`, rpcUrl);
  const maxRetries = 2;
  let lastError = null;
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 8e3);
      const response = await fetch(rpcUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "getTokenAccountsByOwner",
          params: [
            ownerAddress,
            { programId },
            { encoding: "jsonParsed", commitment: "confirmed" }
          ]
        }),
        signal: controller.signal
      });
      clearTimeout(timeout);
      if (!response.ok) {
        logger$1.error(`[Tokens] HTTP error: ${response.status} ${response.statusText} (attempt ${attempt}/${maxRetries})`);
        lastError = new Error(`HTTP ${response.status}`);
        if (attempt < maxRetries) {
          await new Promise((r2) => setTimeout(r2, 500 * attempt));
          continue;
        }
        return [];
      }
      const data = await response.json();
      if (data.error) {
        logger$1.warn("[Tokens] RPC error fetching tokens:", data.error, `(attempt ${attempt}/${maxRetries})`);
        lastError = data.error;
        if (attempt < maxRetries) {
          await new Promise((r2) => setTimeout(r2, 500 * attempt));
          continue;
        }
        return [];
      }
      if (!((_a2 = data.result) == null ? void 0 : _a2.value)) {
        logger$1.log("[Tokens] No token accounts found");
        return [];
      }
      const tokens2 = data.result.value.map((item) => {
        const info = item.account.data.parsed.info;
        const uiAmount = info.tokenAmount.uiAmount || 0;
        return {
          address: item.pubkey,
          mint: info.mint,
          owner: info.owner,
          amount: info.tokenAmount.amount,
          decimals: info.tokenAmount.decimals,
          uiAmount,
          balance: uiAmount,
          programId,
          isToken2022: programId === TOKEN_2022_PROGRAM_ID
        };
      }).filter((t2) => parseFloat(t2.amount) > 0);
      logger$1.log(`[Tokens] Found ${tokens2.length} ${programId === TOKEN_2022_PROGRAM_ID ? "Token-2022" : "SPL"} tokens`);
      return tokens2;
    } catch (e) {
      if (e.name === "AbortError") {
        logger$1.error(`[Tokens] Request timeout (attempt ${attempt}/${maxRetries})`);
      } else {
        logger$1.error(`[Tokens] Error fetching ${programId} accounts:`, e.message || e, `(attempt ${attempt}/${maxRetries})`);
      }
      lastError = e;
      if (attempt < maxRetries) {
        await new Promise((r2) => setTimeout(r2, 500 * attempt));
        continue;
      }
    }
  }
  logger$1.error("[Tokens] All retry attempts failed:", lastError);
  return [];
}
async function enrichTokenMetadata(rpcUrl, token, network = null) {
  const cacheKey = network ? `${network}:${token.mint}` : token.mint;
  if (token.isLPToken && token.name && token.name !== "SPL Token" && token.name !== "Token-2022") {
    metadataCache.set(cacheKey, { symbol: token.symbol, name: token.name, logoURI: token.logoURI, isLPToken: true, price: token.price });
    logger$1.log("[Tokens] Preserving existing LP token data:", token.name);
    return;
  }
  if (metadataCache.has(cacheKey)) {
    const cached = metadataCache.get(cacheKey);
    if (cached.name && cached.name !== "Unknown Token" && cached.logoURI) {
      Object.assign(token, cached);
      return;
    }
  }
  const known = getKnownTokenMetadata(token.mint, network);
  if (known) {
    token.symbol = known.symbol;
    token.name = known.name;
    token.logoURI = known.logoURI;
    if (known.isToken2022 !== void 0) token.isToken2022 = known.isToken2022;
    if (known.price !== void 0) token.price = known.price;
    metadataCache.set(cacheKey, { symbol: token.symbol, name: token.name, logoURI: token.logoURI, price: token.price });
    return;
  }
  const isLP = await checkAndApplyLPBranding(rpcUrl, token, network);
  if (isLP) {
    metadataCache.set(cacheKey, { symbol: token.symbol, name: token.name, logoURI: token.logoURI, isLPToken: true, price: token.price });
    return;
  }
  let apiMetadata = null;
  try {
    apiMetadata = await fetchTokenMetadataFromAPI(token.mint);
    if (apiMetadata && apiMetadata.name && apiMetadata.logoURI) {
      token.symbol = apiMetadata.symbol || token.mint.slice(0, 4);
      token.name = apiMetadata.name;
      token.logoURI = apiMetadata.logoURI;
      token.price = apiMetadata.price || null;
      if (token.price !== null && token.price !== void 0) {
        metadataCache.set(cacheKey, { symbol: token.symbol, name: token.name, logoURI: token.logoURI, price: token.price });
        return;
      }
    }
  } catch (e) {
    logger$1.warn("[Tokens] Failed to fetch from X1 Mobile API:", e.message);
  }
  if (token.isToken2022) {
    try {
      const extMetadata = await fetchToken2022Metadata(rpcUrl, token.mint);
      if (extMetadata && extMetadata.name) {
        token.symbol = extMetadata.symbol || token.mint.slice(0, 4);
        token.name = extMetadata.name || "Unknown Token";
        token.logoURI = extMetadata.uri || null;
        if (extMetadata.uri) {
          try {
            const uriMetadata = await fetchTokenMetadataFromURI(extMetadata.uri);
            if (uriMetadata == null ? void 0 : uriMetadata.image) token.logoURI = uriMetadata.image;
          } catch (e) {
            logger$1.warn("[Tokens] Failed to fetch metadata from URI:", e.message);
          }
        }
        metadataCache.set(cacheKey, { symbol: token.symbol, name: token.name, logoURI: token.logoURI, price: token.price });
        return;
      }
    } catch (e) {
      logger$1.warn("[Tokens] Failed to fetch Token-2022 extension metadata:", e.message);
    }
  }
  try {
    const metaplexData = await fetchMetaplexMetadata(rpcUrl, token.mint);
    if (metaplexData) {
      token.symbol = (apiMetadata == null ? void 0 : apiMetadata.symbol) || metaplexData.symbol || token.mint.slice(0, 4);
      token.name = (apiMetadata == null ? void 0 : apiMetadata.name) || metaplexData.name || "Unknown Token";
      token.logoURI = null;
      token.price = (apiMetadata == null ? void 0 : apiMetadata.price) || null;
      if (metaplexData.uri && metaplexData.uri.startsWith("http")) {
        try {
          logger$1.log("[Metaplex] Fetching URI metadata:", metaplexData.uri.substring(0, 60));
          const uriMetadata = await fetchTokenMetadataFromURI(metaplexData.uri);
          if (uriMetadata == null ? void 0 : uriMetadata.image) token.logoURI = uriMetadata.image;
          if ((uriMetadata == null ? void 0 : uriMetadata.name) && !(apiMetadata == null ? void 0 : apiMetadata.name)) token.name = uriMetadata.name;
          if ((uriMetadata == null ? void 0 : uriMetadata.symbol) && !(apiMetadata == null ? void 0 : apiMetadata.symbol)) token.symbol = uriMetadata.symbol;
        } catch (e) {
          logger$1.warn("[Metaplex] Failed to fetch metadata from URI:", e.message);
        }
      }
      metadataCache.set(cacheKey, { symbol: token.symbol, name: token.name, logoURI: token.logoURI, price: token.price });
      return;
    }
  } catch (e) {
    logger$1.warn("[Tokens] Failed to fetch Metaplex on-chain metadata:", e.message);
  }
  try {
    const dasData = await fetchFromDAS(rpcUrl, token.mint);
    if (dasData && dasData.name) {
      token.symbol = dasData.symbol || token.mint.slice(0, 4);
      token.name = dasData.name;
      token.logoURI = dasData.logoURI || null;
      token.price = (apiMetadata == null ? void 0 : apiMetadata.price) || null;
      if (!token.logoURI && dasData.uri) {
        try {
          const uriMetadata = await fetchTokenMetadataFromURI(dasData.uri);
          if (uriMetadata == null ? void 0 : uriMetadata.image) token.logoURI = uriMetadata.image;
        } catch (e) {
          logger$1.warn("[Tokens] Failed to fetch metadata from DAS URI:", e.message);
        }
      }
      metadataCache.set(cacheKey, { symbol: token.symbol, name: token.name, logoURI: token.logoURI, price: token.price });
      return;
    }
  } catch (e) {
    logger$1.warn("[Tokens] Failed to fetch from DAS API:", e.message);
  }
  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 5e3);
    const jupiterResponse = await fetch(`https://lite-api.jup.ag/tokens/v1/token/${token.mint}`, {
      signal: controller.signal
    });
    clearTimeout(timeout);
    if (jupiterResponse.ok) {
      const jupiterData = await jupiterResponse.json();
      if (jupiterData && jupiterData.name) {
        token.symbol = jupiterData.symbol || token.mint.slice(0, 4);
        token.name = jupiterData.name;
        token.logoURI = jupiterData.logoURI || null;
        metadataCache.set(cacheKey, { symbol: token.symbol, name: token.name, logoURI: token.logoURI, price: token.price });
        return;
      }
    }
  } catch (e) {
  }
  const xdexCacheKey = `xdex:${token.mint}`;
  if (!hasRecentlyFailed(xdexCacheKey)) {
    try {
      logger$1.log("[Token API] Trying XDEX API for:", token.mint);
      const xdexResponse = await fetchWithRateLimit(
        "https://api.xdex.xyz/api/xendex/tokens/" + token.mint,
        { signal: AbortSignal.timeout(3e3) }
      );
      if (xdexResponse.status === 429) {
        logger$1.warn("[Token API] XDEX rate limited for:", token.mint);
        markFailed(xdexCacheKey);
      } else if (xdexResponse.status === 404) {
        markFailed(xdexCacheKey);
      } else if (xdexResponse.ok) {
        clearFailed(xdexCacheKey);
        const xdexData = await xdexResponse.json();
        logger$1.log("[Token API] XDEX response:", xdexData);
        let xdexPrice = null;
        if (xdexData.price !== void 0 && xdexData.price !== null) {
          xdexPrice = parseFloat(xdexData.price);
        } else if (xdexData.priceUsd !== void 0 && xdexData.priceUsd !== null) {
          xdexPrice = parseFloat(xdexData.priceUsd);
        }
        if (token.name && token.name !== "Unknown Token" && token.logoURI) {
          if (xdexPrice !== null && (token.price === null || token.price === void 0)) {
            token.price = xdexPrice;
            logger$1.log("[Token API] Got price from XDEX:", xdexPrice, "for", token.symbol);
          }
          metadataCache.set(cacheKey, { symbol: token.symbol, name: token.name, logoURI: token.logoURI, price: token.price });
          return;
        }
        if (xdexData.name) {
          token.symbol = xdexData.symbol || token.symbol || token.mint.slice(0, 4);
          token.name = xdexData.name;
          token.logoURI = xdexData.image || xdexData.logo || xdexData.logoURI || xdexData.icon || token.logoURI || null;
          if (xdexPrice !== null) {
            token.price = xdexPrice;
          }
          metadataCache.set(cacheKey, { symbol: token.symbol, name: token.name, logoURI: token.logoURI, price: token.price });
          return;
        }
      }
    } catch (e) {
      logger$1.warn("[Token API] XDEX API failed:", e.message);
      markFailed(xdexCacheKey);
    }
  }
  if (apiMetadata && apiMetadata.name) {
    token.symbol = apiMetadata.symbol || token.mint.slice(0, 4);
    token.name = apiMetadata.name;
    token.logoURI = null;
    token.price = apiMetadata.price || null;
    metadataCache.set(cacheKey, { symbol: token.symbol, name: token.name, logoURI: null, price: token.price });
    return;
  }
  token.symbol = token.mint.slice(0, 4) + "..";
  token.name = "Unknown Token";
  token.logoURI = null;
  metadataCache.set(token.mint, { symbol: token.symbol, name: token.name, logoURI: null });
}
async function fetchMetaplexMetadata(rpcUrl, mint) {
  var _a2;
  try {
    logger$1.log("[Metaplex] Fetching metadata for mint:", mint);
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 8e3);
    const response = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "getProgramAccounts",
        params: [
          METADATA_PROGRAM_ID,
          {
            encoding: "base64",
            filters: [{ memcmp: { offset: 33, bytes: mint } }]
          }
        ]
      }),
      signal: controller.signal
    });
    clearTimeout(timeout);
    const data = await response.json();
    if (data.error) {
      logger$1.warn("[Metaplex] RPC error:", data.error.message || data.error);
      return null;
    }
    if (!data.result || data.result.length === 0) {
      logger$1.log("[Metaplex] No metadata account found for:", mint);
      return null;
    }
    const accountData = data.result[0].account.data[0];
    const bytes = Uint8Array.from(atob(accountData), (c) => c.charCodeAt(0));
    const parsed = parseMetaplexMetadata(bytes);
    logger$1.log("[Metaplex] Parsed metadata:", parsed == null ? void 0 : parsed.name, parsed == null ? void 0 : parsed.symbol, (_a2 = parsed == null ? void 0 : parsed.uri) == null ? void 0 : _a2.substring(0, 50));
    return parsed;
  } catch (e) {
    if (e.name === "AbortError") {
      logger$1.warn("[Metaplex] Request timeout for:", mint);
    } else {
      logger$1.warn("[Metaplex] Error fetching on-chain metadata:", e.message);
    }
    return null;
  }
}
function parseMetaplexMetadata(data) {
  try {
    let offset = 65;
    const nameLen = data[offset] | data[offset + 1] << 8 | data[offset + 2] << 16 | data[offset + 3] << 24;
    offset += 4;
    const name = new TextDecoder().decode(data.slice(offset, offset + nameLen)).replace(/\0/g, "").trim();
    offset += nameLen;
    const symbolLen = data[offset] | data[offset + 1] << 8 | data[offset + 2] << 16 | data[offset + 3] << 24;
    offset += 4;
    const symbol = new TextDecoder().decode(data.slice(offset, offset + symbolLen)).replace(/\0/g, "").trim();
    offset += symbolLen;
    const uriLen = data[offset] | data[offset + 1] << 8 | data[offset + 2] << 16 | data[offset + 3] << 24;
    offset += 4;
    const uri = new TextDecoder().decode(data.slice(offset, offset + uriLen)).replace(/\0/g, "").trim();
    return { name, symbol, uri };
  } catch (e) {
    logger$1.warn("Error parsing metadata:", e);
    return null;
  }
}
async function fetchToken2022Metadata(rpcUrl, mint) {
  var _a2, _b2, _c, _d;
  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 3e3);
    const response = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "getAccountInfo",
        params: [mint, { encoding: "jsonParsed" }]
      }),
      signal: controller.signal
    });
    clearTimeout(timeout);
    const data = await response.json();
    if (!((_d = (_c = (_b2 = (_a2 = data.result) == null ? void 0 : _a2.value) == null ? void 0 : _b2.data) == null ? void 0 : _c.parsed) == null ? void 0 : _d.info)) return null;
    const info = data.result.value.data.parsed.info;
    if (info.extensions) {
      for (const ext of info.extensions) {
        if (ext.extension === "tokenMetadata") {
          const state = ext.state;
          return {
            name: state.name || null,
            symbol: state.symbol || null,
            uri: state.uri || null
          };
        }
      }
    }
    return null;
  } catch (e) {
    logger$1.warn("Error fetching Token-2022 metadata:", e);
    return null;
  }
}
async function fetchTokenMetadataFromURI(uri) {
  if (!uri) return null;
  try {
    let fetchUrl = uri;
    if (uri.startsWith("ipfs://")) {
      fetchUrl = uri.replace("ipfs://", "https://ipfs.io/ipfs/");
    } else if (uri.includes("/ipfs/") && !uri.startsWith("http")) {
      fetchUrl = "https://ipfs.io" + uri;
    }
    if (uri.startsWith("ar://")) {
      fetchUrl = uri.replace("ar://", "https://arweave.net/");
    }
    logger$1.log("[URI] Fetching metadata from:", fetchUrl.substring(0, 80));
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 8e3);
    const response = await fetch(fetchUrl, { signal: controller.signal });
    clearTimeout(timeout);
    if (!response.ok) {
      logger$1.warn("[URI] HTTP error:", response.status, "for:", fetchUrl.substring(0, 50));
      return null;
    }
    const data = await response.json();
    let image = data.image;
    if (image) {
      if (image.startsWith("ipfs://")) {
        image = image.replace("ipfs://", "https://ipfs.io/ipfs/");
      } else if (image.startsWith("ar://")) {
        image = image.replace("ar://", "https://arweave.net/");
      }
    }
    logger$1.log("[URI] Got metadata - name:", data.name, "symbol:", data.symbol, "hasImage:", !!image);
    return {
      name: data.name,
      symbol: data.symbol,
      image,
      description: data.description
    };
  } catch (e) {
    if (e.name === "AbortError") {
      logger$1.warn("[URI] Timeout fetching:", uri == null ? void 0 : uri.substring(0, 50));
    } else {
      logger$1.warn("[URI] Failed to fetch metadata from:", uri == null ? void 0 : uri.substring(0, 50), e.message);
    }
    return null;
  }
}
const tokens = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  METADATA_PROGRAM_ID,
  TOKEN_2022_PROGRAM_ID,
  TOKEN_PROGRAM_ID: TOKEN_PROGRAM_ID$2,
  fetchToken2022Metadata,
  fetchTokenAccounts,
  fetchTokenMetadataFromAPI,
  fetchTokenMetadataFromURI,
  invalidateRPCCache
}, Symbol.toStringTag, { value: "Module" }));
const API_SERVER = "https://mobile-api.x1.xyz";
function getProviderId(networkName) {
  switch (networkName) {
    case "X1 Mainnet":
      return "X1-mainnet";
    case "X1 Testnet":
      return "X1-testnet";
    case "Solana Mainnet":
      return "SOLANA-mainnet";
    case "Solana Devnet":
      return "SOLANA-devnet";
    default:
      return "X1-testnet";
  }
}
async function registerWallet(address, networkName) {
  try {
    const providerId = getProviderId(networkName);
    const response = await fetch(`${API_SERVER}/wallets/register`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        address,
        network: providerId
      })
    });
    if (!response.ok) {
      logger$1.warn("Failed to register wallet:", response.status);
      return false;
    }
    const data = await response.json();
    logger$1.log("Wallet registered:", data);
    return true;
  } catch (error) {
    logger$1.error("Error registering wallet:", error);
    return false;
  }
}
async function indexWallet(address, networkName) {
  try {
    const providerId = getProviderId(networkName);
    const response = await fetch(`${API_SERVER}/wallets/index-now`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        address,
        network: providerId
      })
    });
    if (!response.ok) {
      logger$1.warn("Failed to index wallet:", response.status);
      return null;
    }
    const data = await response.json();
    logger$1.log("Indexing result:", data);
    return data;
  } catch (error) {
    logger$1.error("Error indexing wallet:", error);
    return null;
  }
}
async function fetchTransactions(address, networkName, beforeSignature = null) {
  try {
    const providerId = getProviderId(networkName);
    let url = `${API_SERVER}/transactions/${address}?providerId=${providerId}`;
    if (beforeSignature) {
      url += `&before=${beforeSignature}`;
    }
    logger$1.log("[Activity] Fetching transactions from:", url);
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 8e3);
    const response = await fetch(url, { signal: controller.signal });
    clearTimeout(timeout);
    if (!response.ok) {
      logger$1.warn("Failed to fetch transactions:", response.status);
      indexWallet(address, networkName).catch(() => {
      });
      return [];
    }
    const data = await response.json();
    if (!data || !data.transactions || data.transactions.length === 0) {
      logger$1.log("[Activity] No transactions found, triggering background indexing...");
      indexWallet(address, networkName).catch(() => {
      });
      return [];
    }
    return formatTransactions(data.transactions, networkName);
  } catch (error) {
    if (error.name === "AbortError") {
      logger$1.warn("[Activity] API request timeout");
    } else {
      logger$1.error("Error fetching transactions:", error);
    }
    return [];
  }
}
function formatTransactions(transactions, networkName) {
  const nativeSymbol = networkName.startsWith("X1") ? "XNT" : "SOL";
  return transactions.map((tx) => {
    let date;
    if (typeof tx.timestamp === "string") {
      date = new Date(tx.timestamp);
    } else if (typeof tx.timestamp === "number") {
      date = new Date(tx.timestamp * 1e3);
    } else {
      date = /* @__PURE__ */ new Date();
    }
    const timestamp = formatTimestamp(date);
    const amount = typeof tx.amount === "string" ? parseFloat(tx.amount) : tx.amount || 0;
    let type = "received";
    if (tx.type === "SEND") {
      type = "sent";
    } else if (tx.type === "RECEIVE") {
      type = "received";
    } else if (tx.type === "SWAP") {
      type = "swap";
    }
    const token = tx.tokenSymbol || tx.symbol || nativeSymbol;
    const tokenMint = tx.tokenMint || tx.mint || null;
    const tokenIcon = tx.tokenIcon || null;
    return {
      id: tx.hash || tx.signature || `tx-${Date.now()}-${Math.random()}`,
      signature: tx.hash || tx.signature,
      type,
      amount: Math.abs(amount).toFixed(6),
      token,
      tokenMint,
      tokenIcon,
      fee: tx.fee ? parseFloat(tx.fee).toFixed(9) : "0.000005000",
      timestamp,
      rawTimestamp: date.getTime(),
      from: tx.from || tx.source,
      to: tx.to || tx.destination
    };
  }).sort((a, b) => b.rawTimestamp - a.rawTimestamp);
}
function formatTimestamp(date) {
  if (!date || isNaN(date.getTime())) {
    return "Unknown";
  }
  const now = /* @__PURE__ */ new Date();
  const diffMs = now - date;
  const diffMins = Math.floor(diffMs / 6e4);
  const diffHours = Math.floor(diffMs / 36e5);
  const diffDays = Math.floor(diffMs / 864e5);
  if (diffMins < 1) {
    return "Just now";
  } else if (diffMins < 60) {
    return `${diffMins}m ago`;
  } else if (diffHours < 24) {
    return `${diffHours}h ago`;
  } else if (diffDays < 7) {
    return `${diffDays}d ago`;
  } else {
    return date.toLocaleDateString("en-US", {
      month: "short",
      day: "numeric",
      year: date.getFullYear() !== now.getFullYear() ? "numeric" : void 0
    });
  }
}
const CORE_API = "https://core.x1.xyz/api";
async function addXP({
  user,
  network,
  category,
  action,
  transactionSignature,
  data = {},
  source = "wallet"
}) {
  if (!user || !network || !category || !action || !transactionSignature) {
    logger$1.warn("[XP] Missing required parameters for XP tracking");
    return null;
  }
  const payload = {
    user,
    network,
    category,
    action,
    transactionSignature,
    data,
    source
  };
  logger$1.log("[XP] Submitting score for:", category);
  try {
    const response = await fetch(`${CORE_API}/score/add`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      },
      body: JSON.stringify(payload)
    });
    const result = await response.json();
    if (!response.ok) {
      logger$1.error("[XP] API error");
      return { success: false, error: "XP tracking failed" };
    }
    logger$1.log("[XP] Score added successfully");
    return { success: true, data: result };
  } catch (error) {
    logger$1.error("[XP] Failed to add score");
    return { success: false, error: "XP tracking failed" };
  }
}
async function trackSwapXP({
  user,
  network,
  transactionSignature,
  inputMint,
  outputMint,
  inputAmount,
  outputAmount
}) {
  return addXP({
    user,
    network,
    category: "swap",
    action: "swap",
    transactionSignature,
    data: {
      inputMint,
      outputMint,
      inputAmount,
      outputAmount
    }
  });
}
async function trackSendXP({
  user,
  network,
  transactionSignature,
  mint,
  amount,
  recipient
}) {
  return addXP({
    user,
    network,
    category: "send",
    action: "transfer",
    transactionSignature,
    data: {
      mint,
      amount,
      recipient
    }
  });
}
async function trackConnectXP({ user, network, dapp }) {
  return addXP({
    user,
    network,
    category: "connect",
    action: "connect",
    transactionSignature: `connect_${Date.now()}`,
    data: {
      dapp
    },
    source: "wallet"
  });
}
async function trackStakeXP({
  user,
  network,
  transactionSignature,
  amount,
  stakePool,
  action = "stake"
  // "stake" or "unstake"
}) {
  return addXP({
    user,
    network,
    category: "stake",
    action,
    transactionSignature,
    data: {
      amount,
      stakePool
    }
  });
}
async function getXPBalance(walletAddress, network = "X1 Mainnet") {
  if (!walletAddress) {
    return {
      success: false,
      totalScore: 0,
      totalCurrentScore: 0,
      totalClaimedScore: 0
    };
  }
  try {
    const params = new URLSearchParams({
      user: walletAddress,
      network
    });
    const response = await fetch(`${CORE_API}/score?${params.toString()}`, {
      method: "GET",
      headers: {
        Accept: "application/json"
      }
    });
    if (!response.ok) {
      return {
        success: false,
        totalScore: 0,
        totalCurrentScore: 0,
        totalClaimedScore: 0
      };
    }
    const result = await response.json();
    if (result.success && result.data) {
      return {
        success: true,
        totalScore: result.data.totalScore || 0,
        totalCurrentScore: result.data.totalCurrentScore || 0,
        totalClaimedScore: result.data.totalClaimedScore || 0,
        network: result.data.network,
        user: result.data.user
      };
    }
    return {
      success: false,
      totalScore: 0,
      totalCurrentScore: 0,
      totalClaimedScore: 0
    };
  } catch (error) {
    logger$1.error("[XP] Failed to fetch balance:", error);
    return {
      success: false,
      totalScore: 0,
      totalCurrentScore: 0,
      totalClaimedScore: 0
    };
  }
}
const xp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addXP,
  getXPBalance,
  trackConnectXP,
  trackSendXP,
  trackStakeXP,
  trackSwapXP
}, Symbol.toStringTag, { value: "Module" }));
const STORAGE_KEY = "x1wallet_wallets";
const ACTIVE_KEY = "x1wallet_active";
const NETWORK_KEY = "x1wallet_network";
const CUSTOM_NETWORKS_KEY = "x1wallet_customRpcs";
const ENCRYPTION_ENABLED_KEY = "x1wallet_encrypted";
const BALANCE_CACHE_KEY$1 = "x1wallet_balance_cache";
function validatePasswordStrength(password) {
  if (typeof password !== "string") return { ok: false, reason: "Invalid password" };
  if (password.length < 8) return { ok: false, reason: "Password must be at least 8 characters" };
  if (!/[a-zA-Z]/.test(password)) return { ok: false, reason: "Password must contain at least one letter" };
  if (!/[0-9]/.test(password)) return { ok: false, reason: "Password must contain at least one number" };
  const banned = ["password", "123456", "qwerty", "letmein"];
  if (banned.includes(password.toLowerCase())) return { ok: false, reason: "Password too weak" };
  return { ok: true };
}
function getCachedBalance$1(publicKey, network) {
  var _a2;
  try {
    const cache = JSON.parse(localStorage.getItem(BALANCE_CACHE_KEY$1) || "{}");
    const key = `${publicKey}:${network}`;
    return ((_a2 = cache[key]) == null ? void 0 : _a2.balance) ?? 0;
  } catch {
    return 0;
  }
}
function setCachedBalance$1(publicKey, network, balance) {
  try {
    const cache = JSON.parse(localStorage.getItem(BALANCE_CACHE_KEY$1) || "{}");
    const key = `${publicKey}:${network}`;
    cache[key] = { balance, timestamp: Date.now() };
    const keys = Object.keys(cache);
    if (keys.length > 10) {
      const oldest = keys.sort((a, b) => {
        var _a2, _b2;
        return (((_a2 = cache[a]) == null ? void 0 : _a2.timestamp) || 0) - (((_b2 = cache[b]) == null ? void 0 : _b2.timestamp) || 0);
      })[0];
      delete cache[oldest];
    }
    localStorage.setItem(BALANCE_CACHE_KEY$1, JSON.stringify(cache));
  } catch {
  }
}
function getNetworkConfig(networkName) {
  if (NETWORKS[networkName]) {
    return NETWORKS[networkName];
  }
  try {
    const customNetworks = JSON.parse(localStorage.getItem(CUSTOM_NETWORKS_KEY) || "[]");
    const customNet = customNetworks.find((n2) => n2.name === networkName);
    if (customNet) {
      return {
        name: customNet.name,
        providerId: `custom-${customNet.id || Date.now()}`,
        rpcUrl: customNet.url,
        symbol: customNet.symbol || "TOKEN",
        decimals: parseInt(customNet.decimals) || 9,
        explorer: customNet.explorer || "",
        explorerTx: customNet.explorer ? `${customNet.explorer.replace(/\/$/, "")}/tx` : "",
        explorerToken: customNet.explorer ? `${customNet.explorer.replace(/\/$/, "")}/token` : "",
        isCustom: true,
        isSVM: true
        // Assume SVM compatible
      };
    }
  } catch (e) {
    logger$1.warn("Failed to load custom networks:", e);
  }
  return NETWORKS[DEFAULT_NETWORK];
}
function useWallet() {
  const [wallets, setWallets] = reactExports.useState([]);
  const [activeWalletId, setActiveWalletId] = reactExports.useState(null);
  const [network, setNetworkState] = reactExports.useState(DEFAULT_NETWORK);
  const [loading, setLoading] = reactExports.useState(true);
  const [balance, setBalance] = reactExports.useState(0);
  const [isLocked, setIsLocked] = reactExports.useState(false);
  const [encryptionPassword, setEncryptionPassword] = reactExports.useState(null);
  const isStorageEncrypted = reactExports.useCallback(() => {
    return localStorage.getItem(ENCRYPTION_ENABLED_KEY) === "true";
  }, []);
  const migrateWallet = (wallet) => {
    if (wallet.addresses && Array.isArray(wallet.addresses)) {
      return wallet;
    }
    return {
      id: wallet.id,
      name: wallet.name,
      mnemonic: wallet.mnemonic,
      type: wallet.type || "local",
      createdAt: wallet.createdAt,
      isHardware: wallet.isHardware || false,
      derivationPath: wallet.derivationPath,
      addresses: [{
        index: 0,
        publicKey: wallet.publicKey,
        privateKey: wallet.privateKey,
        name: "Address 1"
      }],
      activeAddressIndex: 0
    };
  };
  const loadWalletsFromStorage = reactExports.useCallback(async (password = null) => {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (!saved) return [];
      if (isEncrypted(saved)) {
        if (!password) {
          setIsLocked(true);
          return [];
        }
        try {
          const decrypted = await decryptData(saved, password);
          const parsed = JSON.parse(decrypted);
          setIsLocked(false);
          setEncryptionPassword(password);
          return parsed.map(migrateWallet);
        } catch (e) {
          logger$1.error("Failed to decrypt wallets:", e.message);
          throw new Error("Incorrect password");
        }
      } else {
        const parsed = JSON.parse(saved);
        setIsLocked(false);
        return parsed.map(migrateWallet);
      }
    } catch (e) {
      if (e.message === "Incorrect password") throw e;
      logger$1.error("Failed to load wallets:", e);
      return [];
    }
  }, []);
  const saveWalletsToStorage = reactExports.useCallback(async (walletsToSave, passwordOverride = null) => {
    const existingData = localStorage.getItem(STORAGE_KEY);
    if ((!walletsToSave || walletsToSave.length === 0) && existingData && existingData.length > 10) {
      logger$1.warn("[useWallet] BLOCKED: Attempted to save empty wallets over existing data");
      throw new Error("Cannot overwrite existing wallet data with empty array");
    }
    const effectivePassword = passwordOverride || encryptionPassword;
    if (!effectivePassword) {
      if (existingData && isEncrypted(existingData)) {
        logger$1.warn("[useWallet] Cannot save: wallet is locked, unlock first");
        throw new Error("Wallet is locked. Please unlock before making changes.");
      }
      throw new Error("Cannot save wallet: encryption password not set. Please set a password first.");
    }
    try {
      const jsonData = JSON.stringify(walletsToSave);
      const encrypted = await encryptData(jsonData, effectivePassword);
      localStorage.setItem(STORAGE_KEY, encrypted);
      localStorage.setItem(ENCRYPTION_ENABLED_KEY, "true");
      if (typeof chrome !== "undefined" && chrome.storage && chrome.storage.session) {
        try {
          await chrome.storage.session.set({
            x1wallet_session_wallets: jsonData,
            x1wallet_session_password: effectivePassword
          });
          console.log("[useWallet] Session storage synced with", walletsToSave.length, "wallets");
        } catch (e) {
          console.warn("[useWallet] Failed to sync session storage:", e.message);
        }
      }
    } catch (e) {
      logger$1.error("Failed to save wallets:", e);
      throw e;
    }
  }, [encryptionPassword]);
  reactExports.useEffect(() => {
    const loadWallets2 = async () => {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        const activeId = localStorage.getItem(ACTIVE_KEY);
        const savedNetwork = localStorage.getItem(NETWORK_KEY);
        console.log("[useWallet] Loading - saved data length:", saved == null ? void 0 : saved.length, "first 50 chars:", saved == null ? void 0 : saved.substring(0, 50));
        if (!saved || saved === "[]" || saved === "null" || saved === "") {
          console.log("[useWallet] Fresh install detected - clearing any stale session storage");
          if (typeof chrome !== "undefined" && chrome.storage && chrome.storage.session) {
            try {
              await chrome.storage.session.remove(["x1wallet_session_wallets", "x1wallet_session_password"]);
            } catch (e) {
            }
          }
          setWallets([]);
          setIsLocked(false);
          console.log("[useWallet] Fresh install - ready for first wallet");
        } else if (saved && isEncrypted(saved)) {
          console.log("[useWallet] Data is encrypted - checking session storage...");
          if (typeof chrome !== "undefined" && chrome.storage && chrome.storage.session) {
            try {
              const sessionData = await chrome.storage.session.get(["x1wallet_session_wallets", "x1wallet_session_password"]);
              if (sessionData.x1wallet_session_wallets && sessionData.x1wallet_session_password) {
                console.log("[useWallet] Found session data - loading from session");
                const sessionWallets = JSON.parse(sessionData.x1wallet_session_wallets);
                const migrated = sessionWallets.map(migrateWallet);
                setWallets(migrated);
                setActiveWalletId(activeId || (migrated.length > 0 ? migrated[0].id : null));
                setEncryptionPassword(sessionData.x1wallet_session_password);
                setIsLocked(false);
                console.log("[useWallet] Loaded", migrated.length, "wallets from session");
              } else {
                console.log("[useWallet] No session data - need password");
                setIsLocked(true);
              }
            } catch (sessionErr) {
              console.log("[useWallet] Session storage error:", sessionErr.message);
              setIsLocked(true);
            }
          } else {
            console.log("[useWallet] No session storage available - need password");
            setIsLocked(true);
          }
        } else if (saved) {
          console.log("[useWallet] Data is plain JSON - parsing...");
          const parsed = JSON.parse(saved);
          const migrated = parsed.map(migrateWallet);
          console.log("[useWallet] Loaded", migrated.length, "wallets");
          setWallets(migrated);
          setActiveWalletId(activeId || (migrated.length > 0 ? migrated[0].id : null));
        } else {
          console.log("[useWallet] No saved data found");
        }
        if (savedNetwork) {
          setNetworkState(savedNetwork);
          if (typeof chrome !== "undefined" && chrome.storage && chrome.storage.local) {
            chrome.storage.local.set({ [NETWORK_KEY]: savedNetwork });
          }
        } else {
          if (typeof chrome !== "undefined" && chrome.storage && chrome.storage.local) {
            chrome.storage.local.set({ [NETWORK_KEY]: DEFAULT_NETWORK });
          }
        }
      } catch (e) {
        console.error("[useWallet] Failed to load wallets:", e);
        logger$1.error("Failed to load wallets:", e);
      }
      setLoading(false);
    };
    loadWallets2();
  }, []);
  const unlockWallet = reactExports.useCallback(async (password) => {
    if (!password) throw new Error("Password is required");
    const loadedWallets = await loadWalletsFromStorage(password);
    setWallets(loadedWallets);
    const activeId = localStorage.getItem(ACTIVE_KEY);
    setActiveWalletId(activeId || (loadedWallets.length > 0 ? loadedWallets[0].id : null));
    if (typeof chrome !== "undefined" && chrome.storage && chrome.storage.session) {
      chrome.storage.session.set({
        x1wallet_session_wallets: JSON.stringify(loadedWallets),
        x1wallet_session_password: password
      }).then(() => {
        console.log("[useWallet] Saved to session storage for auto-lock");
      }).catch((e) => {
        console.warn("[useWallet] Failed to save to session storage:", e.message);
      });
    }
    return true;
  }, [loadWalletsFromStorage]);
  const lockWallet = reactExports.useCallback(() => {
    setWallets([]);
    setEncryptionPassword(null);
    setIsLocked(true);
    setBalance(0);
    if (typeof chrome !== "undefined" && chrome.storage && chrome.storage.session) {
      chrome.storage.session.remove(["x1wallet_session_wallets", "x1wallet_session_password"]).catch((e) => console.warn("[useWallet] Failed to clear session:", e.message));
    }
  }, []);
  const enableEncryption = reactExports.useCallback(async (password) => {
    const pv = validatePasswordStrength(password);
    if (!pv.ok) {
      throw new Error(pv.reason);
    }
    setEncryptionPassword(password);
    localStorage.setItem(ENCRYPTION_ENABLED_KEY, "true");
    if (wallets.length > 0) {
      const jsonData = JSON.stringify(wallets);
      const encrypted = await encryptData(jsonData, password);
      localStorage.setItem(STORAGE_KEY, encrypted);
      if (typeof chrome !== "undefined" && chrome.storage && chrome.storage.session) {
        try {
          await chrome.storage.session.set({
            x1wallet_session_wallets: jsonData,
            x1wallet_session_password: password
          });
        } catch (e) {
          console.warn("[useWallet] Failed to update session storage:", e.message);
        }
      }
    }
    return true;
  }, [wallets]);
  const setEncryptionPasswordOnly = reactExports.useCallback((password) => {
    const pv = validatePasswordStrength(password);
    if (!pv.ok) {
      throw new Error(pv.reason);
    }
    setEncryptionPassword(password);
    localStorage.setItem(ENCRYPTION_ENABLED_KEY, "true");
  }, []);
  const clearEncryptionPassword = reactExports.useCallback(() => {
    logger$1.warn("[useWallet] clearEncryptionPassword called but encryption is mandatory - ignoring");
  }, []);
  const changePassword = reactExports.useCallback(async (currentPassword, newPassword) => {
    const pv = validatePasswordStrength(newPassword);
    if (!pv.ok) {
      throw new Error(pv.reason);
    }
    const saved = localStorage.getItem(STORAGE_KEY);
    if (isEncrypted(saved)) {
      try {
        await decryptData(saved, currentPassword);
      } catch {
        throw new Error("Current password is incorrect");
      }
    }
    setEncryptionPassword(newPassword);
    const jsonData = JSON.stringify(wallets);
    const encrypted = await encryptData(jsonData, newPassword);
    localStorage.setItem(STORAGE_KEY, encrypted);
    if (typeof chrome !== "undefined" && chrome.storage && chrome.storage.session) {
      try {
        await chrome.storage.session.set({
          x1wallet_session_wallets: jsonData,
          x1wallet_session_password: newPassword
        });
      } catch (e) {
        console.warn("[useWallet] Failed to update session storage:", e.message);
      }
    }
    return true;
  }, [wallets]);
  const disableEncryption = reactExports.useCallback(async () => {
    throw new Error("Encryption cannot be disabled. Your wallet data must remain encrypted for security.");
  }, []);
  const saveWallets = reactExports.useCallback(async (newWallets, password = null) => {
    await saveWalletsToStorage(newWallets, password);
    setWallets(newWallets);
  }, [saveWalletsToStorage]);
  const loadWallets = reactExports.useCallback(async () => {
    try {
      const loadedWallets = await loadWalletsFromStorage(encryptionPassword);
      setWallets(loadedWallets);
    } catch (e) {
      logger$1.error("Failed to reload wallets:", e);
    }
  }, [loadWalletsFromStorage, encryptionPassword]);
  const activeWallet = wallets.find((w2) => w2.id === activeWalletId) || wallets[0] || null;
  const getActiveAddress = reactExports.useCallback((wallet) => {
    if (!wallet || !wallet.addresses || wallet.addresses.length === 0) return null;
    const idx = wallet.activeAddressIndex || 0;
    return wallet.addresses[idx] || wallet.addresses[0];
  }, []);
  const activeAddress = activeWallet ? getActiveAddress(activeWallet) : null;
  const createWallet = reactExports.useCallback(async (mnemonic, name = null, password = null) => {
    const hasEncryption = Boolean(encryptionPassword) || localStorage.getItem(ENCRYPTION_ENABLED_KEY) === "true";
    if (!hasEncryption) {
      if (password && wallets.length === 0) {
        await enableEncryption(password);
      } else {
        throw new Error("Please set a password before creating a wallet. Your wallet data must be encrypted.");
      }
    }
    const effectivePassword = password || encryptionPassword;
    try {
      const keypair = await mnemonicToKeypair(mnemonic, 0);
      const publicKey = encodeBase58(keypair.publicKey);
      const privateKey = encodeBase58(keypair.secretKey);
      let currentWallets = wallets;
      const savedData = localStorage.getItem(STORAGE_KEY);
      if (!savedData || savedData === "[]" || savedData === "null") {
        currentWallets = [];
      }
      if (currentWallets.length > 0) {
        const existingWallet = currentWallets.find(
          (w2) => {
            var _a2;
            return (_a2 = w2.addresses) == null ? void 0 : _a2.some((a) => a.publicKey === publicKey);
          }
        );
        if (existingWallet) {
          throw new Error("This wallet has already been imported");
        }
      }
      const walletName = name || "My Wallet";
      const newWallet = {
        id: Date.now().toString(),
        name: walletName,
        mnemonic,
        type: "local",
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        addresses: [{
          index: 0,
          publicKey,
          privateKey,
          name: "Address 1"
        }],
        activeAddressIndex: 0
      };
      const newWallets = [...currentWallets, newWallet];
      await saveWallets(newWallets, effectivePassword);
      setActiveWalletId(newWallet.id);
      localStorage.setItem(ACTIVE_KEY, newWallet.id);
      return newWallet;
    } catch (e) {
      logger$1.error("Failed to create wallet:", e);
      throw e;
    }
  }, [wallets, saveWallets, encryptionPassword, enableEncryption]);
  const importWallet = reactExports.useCallback(async (mnemonic, name = null, password = null) => {
    return createWallet(mnemonic, name, password);
  }, [createWallet]);
  const addAddress = reactExports.useCallback(async (walletId, addressName = null) => {
    const wallet = wallets.find((w2) => w2.id === walletId);
    if (!wallet || !wallet.mnemonic) {
      throw new Error("Cannot add address to this wallet (no mnemonic)");
    }
    const existingIndices = wallet.addresses.map((a) => a.index);
    let newIndex = 0;
    while (existingIndices.includes(newIndex)) {
      newIndex++;
    }
    try {
      const keypair = await mnemonicToKeypair(wallet.mnemonic, newIndex);
      const publicKey = encodeBase58(keypair.publicKey);
      const privateKey = encodeBase58(keypair.secretKey);
      const newAddress = {
        index: newIndex,
        publicKey,
        privateKey,
        name: addressName || `Address ${wallet.addresses.length + 1}`
      };
      const newWallets = wallets.map((w2) => {
        if (w2.id === walletId) {
          return {
            ...w2,
            addresses: [...w2.addresses, newAddress],
            activeAddressIndex: w2.addresses.length
          };
        }
        return w2;
      });
      await saveWallets(newWallets);
      return newAddress;
    } catch (e) {
      logger$1.error("Failed to add address:", e);
      throw e;
    }
  }, [wallets, saveWallets]);
  const removeAddress = reactExports.useCallback(async (walletId, addressIndex) => {
    const wallet = wallets.find((w2) => w2.id === walletId);
    if (!wallet) return;
    if (wallet.addresses.length <= 1) {
      throw new Error("Cannot remove the last address");
    }
    const newWallets = wallets.map((w2) => {
      if (w2.id === walletId) {
        const newAddresses = w2.addresses.filter((a) => a.index !== addressIndex);
        let newActiveIndex = w2.activeAddressIndex;
        if (w2.activeAddressIndex >= newAddresses.length) {
          newActiveIndex = newAddresses.length - 1;
        }
        return {
          ...w2,
          addresses: newAddresses,
          activeAddressIndex: newActiveIndex
        };
      }
      return w2;
    });
    await saveWallets(newWallets);
  }, [wallets, saveWallets]);
  const switchAddress = reactExports.useCallback(async (walletId, addressIndex) => {
    const newWallets = wallets.map((w2) => {
      if (w2.id === walletId) {
        const idx = w2.addresses.findIndex((a) => a.index === addressIndex);
        if (idx !== -1) {
          return { ...w2, activeAddressIndex: idx };
        }
      }
      return w2;
    });
    await saveWallets(newWallets);
  }, [wallets, saveWallets]);
  const renameAddress = reactExports.useCallback(async (walletId, addressIndex, newName) => {
    const newWallets = wallets.map((w2) => {
      if (w2.id === walletId) {
        return {
          ...w2,
          addresses: w2.addresses.map(
            (a) => a.index === addressIndex ? { ...a, name: newName } : a
          )
        };
      }
      return w2;
    });
    await saveWallets(newWallets);
  }, [wallets, saveWallets]);
  const addHardwareWallet = reactExports.useCallback(async (walletDataOrPublicKey, password = null) => {
    const isObject = typeof walletDataOrPublicKey === "object" && walletDataOrPublicKey.publicKey;
    const publicKey = isObject ? walletDataOrPublicKey.publicKey : walletDataOrPublicKey;
    const hasEncryption = Boolean(encryptionPassword) || localStorage.getItem(ENCRYPTION_ENABLED_KEY) === "true";
    if (!hasEncryption) {
      if (password && wallets.length === 0) {
        if (typeof chrome !== "undefined" && chrome.storage && chrome.storage.session) {
          try {
            await chrome.storage.session.remove(["x1wallet_session_wallets", "x1wallet_session_password"]);
          } catch (e) {
          }
        }
        await enableEncryption(password);
      } else {
        throw new Error("Please set a password before adding a wallet. Your wallet data must be encrypted.");
      }
    }
    const effectivePassword = password || encryptionPassword;
    if (!effectivePassword) {
      throw new Error("No password available for encryption. Please unlock the wallet first.");
    }
    let currentWallets = [];
    const savedData = localStorage.getItem(STORAGE_KEY);
    if (savedData && savedData !== "[]" && savedData !== "null" && savedData !== "") {
      try {
        if (isEncrypted(savedData)) {
          const decrypted = await decryptData(savedData, effectivePassword);
          currentWallets = JSON.parse(decrypted);
        } else {
          currentWallets = JSON.parse(savedData);
        }
      } catch (e) {
        if (password && password !== effectivePassword) {
          try {
            const decrypted = await decryptData(savedData, password);
            currentWallets = JSON.parse(decrypted);
          } catch (e2) {
            logger$1.error("[addHardwareWallet] Decryption failed with both passwords:", e2.message);
            throw new Error("Failed to verify existing wallets. Please try again.");
          }
        } else {
          logger$1.error("[addHardwareWallet] Could not decrypt localStorage:", e.message);
          throw new Error("Failed to verify existing wallets. Please try again.");
        }
      }
    }
    const existingWallet = currentWallets.find(
      (w2) => {
        var _a2;
        return (_a2 = w2.addresses) == null ? void 0 : _a2.some((a) => a.publicKey === publicKey);
      }
    );
    if (existingWallet) {
      throw new Error(`This wallet has already been imported as "${existingWallet.name}"`);
    }
    const newWallet = {
      id: Date.now().toString(),
      name: isObject ? walletDataOrPublicKey.name : "Hardware Wallet",
      type: isObject && walletDataOrPublicKey.type || "ledger",
      isHardware: true,
      mnemonic: null,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      derivationPath: isObject ? walletDataOrPublicKey.derivationPath : "44'/501'/0'/0'",
      derivationScheme: isObject ? walletDataOrPublicKey.derivationScheme : null,
      connectionType: isObject ? walletDataOrPublicKey.connectionType : null,
      addresses: [{
        index: 0,
        publicKey,
        privateKey: null,
        name: "Address 1"
      }],
      activeAddressIndex: 0
    };
    logger$1.log("Adding hardware wallet:", newWallet.name, "to", currentWallets.length, "existing wallets");
    const newWallets = [...currentWallets, newWallet];
    await saveWallets(newWallets, effectivePassword);
    localStorage.setItem(ACTIVE_KEY, newWallet.id);
    setActiveWalletId(newWallet.id);
    return new Promise((resolve) => {
      setTimeout(() => resolve(newWallet), 100);
    });
  }, [wallets, saveWallets, encryptionPassword, enableEncryption]);
  const switchWallet = reactExports.useCallback((walletId) => {
    setActiveWalletId(walletId);
    localStorage.setItem(ACTIVE_KEY, walletId);
    if (typeof chrome !== "undefined" && chrome.storage && chrome.storage.local) {
      chrome.storage.local.set({ [ACTIVE_KEY]: walletId });
    }
  }, []);
  const selectWallet = switchWallet;
  reactExports.useEffect(() => {
    if (!(activeAddress == null ? void 0 : activeAddress.publicKey)) return;
    if (typeof window !== "undefined" && window.location.search.includes("request=")) {
      return;
    }
    if (typeof chrome !== "undefined" && chrome.runtime && chrome.runtime.sendMessage) {
      chrome.runtime.sendMessage({
        type: "account-changed",
        publicKey: activeAddress.publicKey
      }).catch((err) => {
        logger$1.warn("[useWallet] Failed to notify account change:", err);
      });
    }
  }, [activeAddress == null ? void 0 : activeAddress.publicKey]);
  const updateWallet = reactExports.useCallback(async (walletId, updates) => {
    const newWallets = wallets.map(
      (w2) => w2.id === walletId ? { ...w2, ...updates } : w2
    );
    await saveWallets(newWallets);
  }, [wallets, saveWallets]);
  const removeWallet = reactExports.useCallback(async (walletId) => {
    const newWallets = wallets.filter((w2) => w2.id !== walletId);
    if (newWallets.length === 0) {
      localStorage.removeItem(STORAGE_KEY);
      localStorage.removeItem("x1wallet");
      localStorage.removeItem(ACTIVE_KEY);
      localStorage.removeItem(ENCRYPTION_ENABLED_KEY);
      localStorage.removeItem("x1wallet_encrypted");
      if (typeof chrome !== "undefined" && chrome.storage) {
        try {
          await chrome.storage.local.remove([
            STORAGE_KEY,
            "x1wallet",
            "x1wallet_encrypted"
          ]);
        } catch (e) {
        }
      }
      setWallets([]);
      setActiveWalletId(null);
      setEncryptionPassword(null);
      setIsLocked(false);
      return;
    }
    await saveWallets(newWallets);
    if (activeWalletId === walletId) {
      const newActive = newWallets[0].id;
      setActiveWalletId(newActive);
      localStorage.setItem(ACTIVE_KEY, newActive);
    }
  }, [wallets, activeWalletId, saveWallets]);
  const reorderWallets = reactExports.useCallback(async (newWalletsOrder) => {
    const reorderedWallets = newWalletsOrder.map((newW) => {
      return wallets.find((w2) => w2.id === newW.id) || newW;
    });
    await saveWallets(reorderedWallets);
  }, [wallets, saveWallets]);
  const clearWallet = reactExports.useCallback(async () => {
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem("x1wallet");
    localStorage.removeItem(ACTIVE_KEY);
    localStorage.removeItem(ENCRYPTION_ENABLED_KEY);
    localStorage.removeItem("x1wallet_auth");
    localStorage.removeItem("x1wallet_encrypted");
    localStorage.removeItem("passwordProtection");
    localStorage.removeItem("passwordHash");
    if (typeof chrome !== "undefined" && chrome.storage) {
      try {
        await chrome.storage.local.remove([
          "x1wallet_auth",
          STORAGE_KEY,
          "x1wallet",
          "x1wallet_encrypted"
        ]);
        if (chrome.storage.session) {
          await chrome.storage.session.remove(["x1wallet_session_wallets", "x1wallet_session_password"]);
        }
      } catch (e) {
      }
    }
    setWallets([]);
    setActiveWalletId(null);
    setEncryptionPassword(null);
    setIsLocked(false);
  }, []);
  const setNetwork = reactExports.useCallback((net) => {
    setBalance(0);
    setNetworkState(net);
    localStorage.setItem(NETWORK_KEY, net);
    if (typeof chrome !== "undefined" && chrome.storage && chrome.storage.local) {
      chrome.storage.local.set({ [NETWORK_KEY]: net });
      if (chrome.runtime && chrome.runtime.sendMessage) {
        chrome.runtime.sendMessage({
          type: "network-changed",
          network: net
        }).catch((err) => {
          logger$1.warn("[useWallet] Failed to notify network change:", err);
        });
      }
    }
  }, []);
  const formatAddress = reactExports.useCallback((address, chars = 4) => {
    if (!address) return "";
    return `${address.slice(0, chars)}...${address.slice(-chars)}`;
  }, []);
  const refreshBalance = reactExports.useCallback(async () => {
    var _a2;
    if (!activeAddress) return;
    const networkConfig = getNetworkConfig(network);
    if (!networkConfig) return;
    const rpcUrl = networkConfig.rpcUrl;
    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 8e3);
      const response = await fetch(rpcUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "getBalance",
          params: [activeAddress.publicKey, { commitment: "confirmed" }]
        }),
        signal: controller.signal
      });
      clearTimeout(timeout);
      if (!response.ok) return;
      const data = await response.json();
      if (data.error) return;
      let bal = 0;
      if (((_a2 = data.result) == null ? void 0 : _a2.value) !== void 0) {
        bal = data.result.value / Math.pow(10, networkConfig.decimals);
      }
      setBalance(bal);
      setCachedBalance$1(activeAddress.publicKey, network, bal);
    } catch (e) {
      logger$1.error("[Balance] Failed to fetch:", e.message);
    }
  }, [activeAddress, network]);
  reactExports.useEffect(() => {
    if (activeAddress && !isLocked) {
      const cachedBal = getCachedBalance$1(activeAddress.publicKey, network);
      if (cachedBal > 0) {
        logger$1.log("[Balance] Loaded from cache:", cachedBal);
        setBalance(cachedBal);
      }
      refreshBalance();
    }
  }, [activeAddress, network, refreshBalance, isLocked]);
  const walletWithAddress = activeWallet ? {
    id: activeWallet.id,
    name: activeWallet.name,
    type: activeWallet.type,
    createdAt: activeWallet.createdAt,
    isHardware: activeWallet.isHardware,
    derivationPath: activeWallet.derivationPath,
    addresses: activeWallet.addresses,
    activeAddressIndex: activeWallet.activeAddressIndex,
    publicKey: activeAddress == null ? void 0 : activeAddress.publicKey,
    privateKey: activeAddress == null ? void 0 : activeAddress.privateKey,
    activeAddress
  } : null;
  const getMnemonic = reactExports.useCallback((walletId) => {
    const targetWallet = walletId ? wallets.find((w2) => w2.id === walletId) : activeWallet;
    return (targetWallet == null ? void 0 : targetWallet.mnemonic) || null;
  }, [wallets, activeWallet]);
  const getWalletForBackup = reactExports.useCallback((walletId) => {
    return wallets.find((w2) => w2.id === walletId) || null;
  }, [wallets]);
  const sanitizedWallets = wallets.map((w2) => {
    var _a2, _b2;
    const activeAddr = ((_a2 = w2.addresses) == null ? void 0 : _a2[w2.activeAddressIndex || 0]) || ((_b2 = w2.addresses) == null ? void 0 : _b2[0]);
    return {
      id: w2.id,
      name: w2.name,
      type: w2.type,
      createdAt: w2.createdAt,
      isHardware: w2.isHardware,
      derivationPath: w2.derivationPath,
      addresses: w2.addresses,
      activeAddressIndex: w2.activeAddressIndex,
      avatar: w2.avatar,
      hasMnemonic: !!w2.mnemonic,
      // Include publicKey at wallet level for backwards compatibility
      publicKey: (activeAddr == null ? void 0 : activeAddr.publicKey) || w2.publicKey
    };
  });
  return {
    // State
    wallets: sanitizedWallets,
    wallet: walletWithAddress,
    activeWallet: walletWithAddress,
    activeAddress,
    activeWalletId,
    network,
    loading,
    balance,
    isLocked,
    isEncrypted: isStorageEncrypted(),
    // Wallet Actions
    createWallet,
    importWallet,
    addHardwareWallet,
    switchWallet,
    selectWallet,
    updateWallet,
    removeWallet,
    reorderWallets,
    clearWallet,
    loadWallets,
    saveWallets,
    // Added for direct saving
    // Address Actions
    addAddress,
    removeAddress,
    switchAddress,
    renameAddress,
    // Encryption Actions
    unlockWallet,
    lockWallet,
    enableEncryption,
    setEncryptionPasswordOnly,
    clearEncryptionPassword,
    // saveWalletsUnencrypted REMOVED - encryption is mandatory
    changePassword,
    disableEncryption,
    // Other
    setNetwork,
    refreshBalance,
    formatAddress,
    getMnemonic,
    getWalletForBackup
  };
}
function WelcomeScreen({ onCreateWallet, onImportWallet, onHardwareWallet, onBack }) {
  const isExtensionPopup = typeof chrome !== "undefined" && chrome.runtime && chrome.runtime.id && window.innerWidth < 500;
  const handleHardwareWallet = () => {
    if (isExtensionPopup) {
      const extensionUrl = chrome.runtime.getURL("index.html");
      chrome.tabs.create({ url: extensionUrl + "?hw=1" });
      window.close();
    } else {
      onHardwareWallet();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen welcome-screen no-nav", children: [
    onBack && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: onBack, style: { position: "absolute", top: 16, left: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "welcome-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "/icons/128-x1.png", alt: "X1", className: "welcome-logo", style: { width: 100, height: 100, objectFit: "contain" } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "X1 Wallet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "tagline", children: "Built for X1. Designed for You." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "welcome-buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: onCreateWallet, children: "Create New Wallet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-secondary", onClick: onImportWallet, children: "Import Existing Wallet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "btn-secondary", onClick: handleHardwareWallet, style: { display: "flex", alignItems: "center", justifyContent: "center", gap: 8 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "6", width: "20", height: "12", rx: "2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "8", cy: "12", r: "1.5" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "16", cy: "12", r: "1.5" })
          ] }),
          "Connect Hardware Wallet"
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "welcome-footer", children: "Powered by X1 Blockchain" })
  ] });
}
function CreateWallet({ onComplete, onBack, passwordProtection: propPasswordProtection, sessionPassword }) {
  const [step, setStep] = reactExports.useState("choose");
  const [seedLength, setSeedLength] = reactExports.useState(12);
  const [mnemonic, setMnemonic] = reactExports.useState("");
  const [customWords, setCustomWords] = reactExports.useState(Array(12).fill(""));
  const [suggestions, setSuggestions] = reactExports.useState([]);
  const [activeInput, setActiveInput] = reactExports.useState(-1);
  const [verifyIndices, setVerifyIndices] = reactExports.useState([]);
  const [verifyInputs, setVerifyInputs] = reactExports.useState({});
  const [walletName, setWalletName] = reactExports.useState("");
  const [error, setError] = reactExports.useState("");
  const [copied, setCopied] = reactExports.useState(false);
  const [generating, setGenerating] = reactExports.useState(false);
  const inputRefs = reactExports.useRef([]);
  const [password, setPassword] = reactExports.useState("");
  const [confirmPassword, setConfirmPassword] = reactExports.useState("");
  const [showPassword, setShowPassword] = reactExports.useState(false);
  const [existingPasswordDetected, setExistingPasswordDetected] = reactExports.useState(false);
  const [passwordRequired, setPasswordRequired] = reactExports.useState(propPasswordProtection !== false);
  const [verifying, setVerifying] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const checkPassword = async () => {
      try {
        const { hasPassword } = await __vitePreload(async () => {
          const { hasPassword: hasPassword2 } = await import("./wallet.js");
          return { hasPassword: hasPassword2 };
        }, true ? [] : void 0);
        const has = await hasPassword();
        const walletsData = localStorage.getItem("x1wallet_wallets");
        const isEmpty = !walletsData || walletsData === "[]" || walletsData === "null" || walletsData === "";
        setPasswordRequired(true);
        setExistingPasswordDetected(has && !isEmpty);
        logger$1.log("[CreateWallet] Password required, existing password:", has && !isEmpty);
      } catch (e) {
        logger$1.error("[CreateWallet] Error checking password:", e);
        setExistingPasswordDetected(false);
        setPasswordRequired(true);
      }
    };
    checkPassword();
  }, [propPasswordProtection]);
  const [wordsRevealed, setWordsRevealed] = reactExports.useState(/* @__PURE__ */ new Set());
  const [allRevealed, setAllRevealed] = reactExports.useState(false);
  const [windowBlurred, setWindowBlurred] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const handleBlur = () => setWindowBlurred(true);
    const handleFocus = () => setWindowBlurred(false);
    window.addEventListener("blur", handleBlur);
    window.addEventListener("focus", handleFocus);
    return () => {
      window.removeEventListener("blur", handleBlur);
      window.removeEventListener("focus", handleFocus);
    };
  }, []);
  const toggleWordReveal = (index) => {
    setWordsRevealed((prev) => {
      const next = new Set(prev);
      if (next.has(index)) {
        next.delete(index);
      } else {
        next.add(index);
      }
      return next;
    });
  };
  const toggleAllRevealed = () => {
    if (allRevealed) {
      setWordsRevealed(/* @__PURE__ */ new Set());
      setAllRevealed(false);
    } else {
      const allIndices = new Set(mnemonic.split(" ").map((_, i) => i));
      setWordsRevealed(allIndices);
      setAllRevealed(true);
    }
  };
  const generateNew = async () => {
    try {
      setGenerating(true);
      const strength = seedLength === 12 ? 128 : 256;
      const newMnemonic = await generateMnemonic(strength);
      logger$1.log("Generated mnemonic:", newMnemonic.split(" ").length, "words");
      setMnemonic(newMnemonic);
      setStep("generate");
    } catch (err) {
      logger$1.error("Error generating mnemonic:", err);
      setError("Failed to generate mnemonic. Please try again.");
    } finally {
      setGenerating(false);
    }
  };
  const switchToCustom = () => {
    setCustomWords(Array(seedLength).fill(""));
    setStep("custom");
  };
  const handleLengthChange = (len) => {
    setSeedLength(len);
    setCustomWords(Array(len).fill(""));
  };
  const handleWordChange = (index, value) => {
    const word = value.toLowerCase().trim();
    const newWords = [...customWords];
    newWords[index] = word;
    setCustomWords(newWords);
    setError("");
    if (word.length > 0) {
      const matches = WORDLIST.filter((w2) => w2.startsWith(word)).slice(0, 5);
      setSuggestions(matches);
      setActiveInput(index);
    } else {
      setSuggestions([]);
    }
  };
  const selectSuggestion = (word) => {
    var _a2;
    const newWords = [...customWords];
    newWords[activeInput] = word;
    setCustomWords(newWords);
    setSuggestions([]);
    if (activeInput < seedLength - 1) {
      (_a2 = inputRefs.current[activeInput + 1]) == null ? void 0 : _a2.focus();
    }
  };
  const handleKeyDown = (e, index) => {
    var _a2;
    if (e.key === "Tab" || e.key === "Enter") {
      if (suggestions.length > 0) {
        e.preventDefault();
        selectSuggestion(suggestions[0]);
      }
    } else if (e.key === " ") {
      if (customWords[index]) {
        e.preventDefault();
        if (index < seedLength - 1) {
          (_a2 = inputRefs.current[index + 1]) == null ? void 0 : _a2.focus();
        }
      }
    }
  };
  const isValidWord = (word) => {
    if (!word) return null;
    return WORDLIST.includes(word.toLowerCase());
  };
  const handlePaste = async () => {
    try {
      const text = await navigator.clipboard.readText();
      const words = text.trim().toLowerCase().split(/\s+/);
      if (words.length === 12 || words.length === 24) {
        setSeedLength(words.length);
        setCustomWords(words);
        setError("");
      } else {
        setError("Invalid phrase. Must be 12 or 24 words.");
      }
    } catch {
      setError("Failed to paste from clipboard");
    }
  };
  const validateCustomPhrase = async () => {
    const words = customWords.filter((w2) => w2.trim());
    if (words.length !== seedLength) {
      setError(`Please fill in all ${seedLength} words`);
      return;
    }
    const invalidWords = words.filter((w2) => !WORDLIST.includes(w2.toLowerCase()));
    if (invalidWords.length > 0) {
      setError(`Invalid words: ${invalidWords.join(", ")}`);
      return;
    }
    const phrase = words.join(" ");
    const isValid = await validateMnemonic(phrase);
    if (!isValid) {
      setError("Invalid seed phrase checksum. Please check your words.");
      return;
    }
    setMnemonic(phrase);
    setupVerification(phrase);
  };
  const setupVerification = (phrase) => {
    const words = phrase.split(" ");
    const indices = [];
    while (indices.length < 3) {
      const idx = Math.floor(Math.random() * words.length);
      if (!indices.includes(idx)) indices.push(idx);
    }
    indices.sort((a, b) => a - b);
    setVerifyIndices(indices);
    setVerifyInputs({});
    setStep("verify");
  };
  const checkVerification = () => {
    const words = mnemonic.split(" ");
    const allCorrect = verifyIndices.every(
      (idx) => {
        var _a2;
        return ((_a2 = verifyInputs[idx]) == null ? void 0 : _a2.toLowerCase()) === words[idx];
      }
    );
    if (allCorrect) {
      setStep("name");
    } else {
      setError("Words do not match. Please try again.");
    }
  };
  const validatePassword = (pwd) => {
    if (!pwd || pwd.length < 8) {
      return "Password must be at least 8 characters";
    }
    if (!/[a-zA-Z]/.test(pwd)) {
      return "Password must contain at least one letter";
    }
    if (!/[0-9]/.test(pwd)) {
      return "Password must contain at least one number";
    }
    const commonPatterns = ["password", "12345678", "qwerty", "abcdef", "letmein"];
    const lowerPwd = String(pwd).toLowerCase();
    for (const pattern of commonPatterns) {
      if (lowerPwd.includes(pattern)) {
        return "Password contains a common weak pattern";
      }
    }
    return null;
  };
  const handleNameContinue = async () => {
    if (!passwordRequired) {
      onComplete(mnemonic, walletName.trim() || "My Wallet", null);
      return;
    }
    if (sessionPassword) {
      try {
        const { checkPassword } = await __vitePreload(async () => {
          const { checkPassword: checkPassword2 } = await import("./wallet.js");
          return { checkPassword: checkPassword2 };
        }, true ? [] : void 0);
        const isValid = await checkPassword(sessionPassword);
        if (isValid) {
          onComplete(mnemonic, walletName.trim() || "My Wallet", sessionPassword);
          return;
        }
      } catch (e) {
        logger$1.warn("[CreateWallet] Session password verification failed:", e);
      }
    }
    if (existingPasswordDetected) {
      setStep("verify-password");
      setPassword("");
      setError("");
    } else {
      setStep("password");
      setError("");
    }
  };
  const handleVerifyAndComplete = async () => {
    if (!password) {
      setError("Please enter your password");
      return;
    }
    setVerifying(true);
    setError("");
    try {
      const { checkPassword } = await __vitePreload(async () => {
        const { checkPassword: checkPassword2 } = await import("./wallet.js");
        return { checkPassword: checkPassword2 };
      }, true ? [] : void 0);
      const isValid = await checkPassword(password);
      if (!isValid) {
        setError("Incorrect password");
        setVerifying(false);
        return;
      }
      onComplete(mnemonic, walletName.trim() || "My Wallet", password);
    } catch (err) {
      logger$1.error("Password verification error:", err);
      logger$1.log("[CreateWallet] Verification failed, falling back to password creation");
      setStep("password");
      setPassword("");
      setError("");
      setVerifying(false);
    }
  };
  const handleComplete = () => {
    const pwdError = validatePassword(password);
    if (pwdError) {
      setError(pwdError);
      return;
    }
    if (password !== confirmPassword) {
      setError("Passwords do not match");
      return;
    }
    onComplete(mnemonic, walletName.trim() || "My Wallet", password);
  };
  const copyMnemonic = () => {
    const cleanMnemonic = mnemonic.trim().toLowerCase().split(/\s+/).join(" ");
    logger$1.log("Copying mnemonic: [REDACTED]", cleanMnemonic.split(" ").length, "words");
    navigator.clipboard.writeText(cleanMnemonic);
    setCopied(true);
    setTimeout(() => {
      navigator.clipboard.writeText("").catch(() => {
      });
      logger$1.log("Clipboard cleared for security");
    }, 3e4);
    setTimeout(() => setCopied(false), 2e3);
  };
  if (step === "choose") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen seed-container no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: onBack, style: { alignSelf: "flex-start", marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Create New Wallet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "seed-subtitle", children: "Choose how to create your seed phrase" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "seed-length-selector", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `seed-length-btn ${seedLength === 12 ? "active" : ""}`,
            onClick: () => handleLengthChange(12),
            children: "12 Words"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `seed-length-btn ${seedLength === 24 ? "active" : ""}`,
            onClick: () => handleLengthChange(24),
            children: "24 Words"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "create-options", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "create-option", onClick: generateNew, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "create-option-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "7.5 4.21 12 6.81 16.5 4.21" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "7.5 19.79 7.5 14.6 3 12" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "21 12 16.5 14.6 16.5 19.79" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "3.27 6.96 12 12.01 20.73 6.96" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "22.08", x2: "12", y2: "12" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "create-option-text", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "create-option-title", children: "Generate Random Phrase" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "create-option-desc", children: "Cryptographically secure (recommended)" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "create-option", onClick: switchToCustom, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "create-option-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "create-option-text", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "create-option-title", children: "Create Custom Phrase" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "create-option-desc", children: "Select words from BIP-39 wordlist" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
        ] })
      ] })
    ] });
  }
  if (step === "generate") {
    const words = mnemonic.split(" ");
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `screen seed-container no-nav ${windowBlurred ? "window-blurred" : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setStep("choose"), style: { alignSelf: "flex-start", marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Your Seed Phrase" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "seed-subtitle", children: "Write down these words in order and store safely" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: "btn-secondary reveal-toggle",
          onClick: toggleAllRevealed,
          style: { marginBottom: 12, fontSize: 12 },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: allRevealed ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
            ] }) }),
            allRevealed ? "Hide All Words" : "Reveal All Words"
          ]
        }
      ),
      windowBlurred && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "blur-overlay", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " Window not in focus - seed phrase hidden" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `seed-grid ${windowBlurred ? "blurred" : ""}`, children: words.map((word, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `seed-word ${wordsRevealed.has(i) || allRevealed ? "revealed" : "masked"}`,
          onClick: () => toggleWordReveal(i),
          title: "Click to reveal/hide",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "seed-number", children: i + 1 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "seed-text", children: (wordsRevealed.has(i) || allRevealed) && !windowBlurred ? word : "" })
          ]
        },
        i
      )) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "seed-actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "btn-secondary", onClick: generateNew, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M23 4v6h-6" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 20v-6h6" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15" })
          ] }),
          "Regenerate"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "btn-secondary", onClick: copyMnemonic, children: [
          copied ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "var(--success)", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })
          ] }),
          copied ? "Copied!" : "Copy"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "warning-box", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Never share your seed phrase. Anyone with these words can access your funds." })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: () => setupVerification(mnemonic), children: "I've Written It Down" })
    ] });
  }
  if (step === "custom") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen seed-container no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setStep("choose"), style: { alignSelf: "flex-start", marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Custom Seed Phrase" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "seed-subtitle", children: [
        "Enter ",
        seedLength,
        " words from the BIP-39 wordlist"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "seed-length-selector", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `seed-length-btn ${seedLength === 12 ? "active" : ""}`,
            onClick: () => handleLengthChange(12),
            children: "12 Words"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `seed-length-btn ${seedLength === 24 ? "active" : ""}`,
            onClick: () => handleLengthChange(24),
            children: "24 Words"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "paste-btn", onClick: handlePaste, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "8", y: "2", width: "8", height: "4", rx: "1", ry: "1" })
        ] }),
        "Paste from Clipboard"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "seed-input-grid", children: customWords.map((word, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "seed-input-word", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "seed-input-number", children: i + 1 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            ref: (el2) => inputRefs.current[i] = el2,
            type: "text",
            value: word,
            onChange: (e) => handleWordChange(i, e.target.value),
            onKeyDown: (e) => handleKeyDown(e, i),
            onFocus: () => {
              setActiveInput(i);
              if (word) {
                const matches = WORDLIST.filter((w2) => w2.startsWith(word)).slice(0, 5);
                setSuggestions(matches);
              }
            },
            onBlur: () => setTimeout(() => setSuggestions([]), 200),
            className: isValidWord(word) === true ? "valid" : isValidWord(word) === false ? "error" : "",
            placeholder: "word",
            autoComplete: "off",
            autoCapitalize: "off"
          }
        )
      ] }, i)) }),
      suggestions.length > 0 && activeInput >= 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "suggestions-dropdown", children: suggestions.map((word, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: `suggestion ${i === 0 ? "first" : ""}`,
          onClick: () => selectSuggestion(word),
          children: word
        },
        word
      )) }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: validateCustomPhrase, children: "Continue" })
    ] });
  }
  if (step === "verify") {
    mnemonic.split(" ");
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen seed-container no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setStep("generate"), style: { alignSelf: "flex-start", marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Verify Phrase" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "seed-subtitle", children: "Enter the following words to confirm" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "verify-inputs", children: verifyIndices.map((idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "verify-input", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { children: [
          "Word #",
          idx + 1
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            className: "form-input",
            value: verifyInputs[idx] || "",
            onChange: (e) => setVerifyInputs({ ...verifyInputs, [idx]: e.target.value }),
            placeholder: `Enter word #${idx + 1}`,
            autoComplete: "off"
          }
        )
      ] }, idx)) }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: checkVerification, children: "Verify & Continue" })
    ] });
  }
  if (step === "name") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen seed-container no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setStep("verify"), style: { alignSelf: "flex-start", marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Name Your Wallet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "seed-subtitle", children: "Give your wallet a name to identify it" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "form-group", style: { marginTop: 24 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          className: "form-input",
          value: walletName,
          onChange: (e) => setWalletName(e.target.value),
          placeholder: "My Wallet",
          autoFocus: true
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: handleNameContinue, style: { marginTop: 24 }, children: "Continue" })
    ] });
  }
  if (step === "password") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen seed-container no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setStep("name"), style: { alignSelf: "flex-start", marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center", marginBottom: 24 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
          width: 64,
          height: 64,
          borderRadius: "50%",
          background: "rgba(var(--x1-blue-rgb), 0.1)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          margin: "0 auto 16px"
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "32", height: "32", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "11", width: "18", height: "11", rx: "2", ry: "2" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Secure Your Wallet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "seed-subtitle", children: "Create a password to encrypt your wallet. This protects your seed phrase and private keys." })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", style: { marginBottom: 16 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Password" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: showPassword ? "text" : "password",
              className: "form-input",
              value: password,
              onChange: (e) => {
                setPassword(e.target.value);
                setError("");
              },
              placeholder: "Enter password",
              autoFocus: true
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: () => setShowPassword(!showPassword),
              style: {
                position: "absolute",
                right: 12,
                top: "50%",
                transform: "translateY(-50%)",
                background: "none",
                border: "none",
                cursor: "pointer",
                padding: 4
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-secondary)", strokeWidth: "2", children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
              ] }) })
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", style: { marginBottom: 16 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Confirm Password" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: showPassword ? "text" : "password",
              className: "form-input",
              value: confirmPassword,
              onChange: (e) => {
                setConfirmPassword(e.target.value);
                setError("");
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: () => setShowPassword(!showPassword),
              style: {
                position: "absolute",
                right: 12,
                top: "50%",
                transform: "translateY(-50%)",
                background: "none",
                border: "none",
                cursor: "pointer",
                padding: 4
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-secondary)", strokeWidth: "2", children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
              ] }) })
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-box", style: { marginBottom: 16 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Min 8 characters with at least one letter and one number." })
      ] }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", style: { marginBottom: 16 }, children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: handleComplete, children: "Create Wallet" })
    ] });
  }
  if (step === "verify-password") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen seed-container no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setStep("name"), style: { alignSelf: "flex-start", marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center", marginBottom: 24 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
          width: 64,
          height: 64,
          borderRadius: "50%",
          background: "rgba(var(--x1-blue-rgb), 0.1)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          margin: "0 auto 16px"
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "32", height: "32", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "11", width: "18", height: "11", rx: "2", ry: "2" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Verify Password" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "seed-subtitle", children: "Enter your existing password to create this wallet." })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", style: { marginBottom: 16 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Password" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: showPassword ? "text" : "password",
              className: "form-input",
              value: password,
              onChange: (e) => {
                setPassword(e.target.value);
                setError("");
              },
              placeholder: "Enter your password",
              autoFocus: true,
              onKeyDown: (e) => e.key === "Enter" && handleVerifyAndComplete()
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: () => setShowPassword(!showPassword),
              style: {
                position: "absolute",
                right: 12,
                top: "50%",
                transform: "translateY(-50%)",
                background: "none",
                border: "none",
                cursor: "pointer",
                padding: 4
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-secondary)", strokeWidth: "2", children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
              ] }) })
            }
          )
        ] })
      ] }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", style: { marginBottom: 16 }, children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "btn-primary",
          onClick: handleVerifyAndComplete,
          disabled: verifying,
          children: verifying ? "Verifying..." : "Create Wallet"
        }
      )
    ] });
  }
  return null;
}
function ImportWallet({ onComplete, onBack, onCompletePrivateKey, sessionPassword }) {
  const [importType, setImportType] = reactExports.useState("phrase");
  const [seedLength, setSeedLength] = reactExports.useState(12);
  const [words, setWords] = reactExports.useState(Array(12).fill(""));
  const [walletName, setWalletName] = reactExports.useState("");
  const [step, setStep] = reactExports.useState("import");
  const [error, setError] = reactExports.useState("");
  const [suggestions, setSuggestions] = reactExports.useState([]);
  const [activeInput, setActiveInput] = reactExports.useState(-1);
  const inputRefs = reactExports.useRef([]);
  const [privateKeyInput, setPrivateKeyInput] = reactExports.useState("");
  const [password, setPassword] = reactExports.useState("");
  const [confirmPassword, setConfirmPassword] = reactExports.useState("");
  const [showPassword, setShowPassword] = reactExports.useState(false);
  const [existingPasswordDetected, setExistingPasswordDetected] = reactExports.useState(false);
  const [passwordRequired, setPasswordRequired] = reactExports.useState(true);
  const [verifying, setVerifying] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const checkPassword = async () => {
      try {
        setPasswordRequired(true);
        const encryptionEnabled = localStorage.getItem("x1wallet_encrypted") === "true";
        const storedProtection = localStorage.getItem("x1wallet_passwordProtection");
        const protectionIsOff = !storedProtection || storedProtection === "false";
        if (protectionIsOff && !encryptionEnabled) {
          setExistingPasswordDetected(false);
          logger$1.log("[ImportWallet] Protection is OFF and no encryption - will create new password");
          return;
        }
        const localAuth = localStorage.getItem("x1wallet_auth");
        const hasLocalAuth = localAuth && localAuth !== "null" && localAuth.length > 10;
        const { hasPassword } = await __vitePreload(async () => {
          const { hasPassword: hasPassword2 } = await import("./wallet.js");
          return { hasPassword: hasPassword2 };
        }, true ? [] : void 0);
        const has = await hasPassword();
        const walletsData = localStorage.getItem("x1wallet_wallets");
        const isEmpty = !walletsData || walletsData === "[]" || walletsData === "null" || walletsData === "";
        const passwordExists = has || hasLocalAuth || encryptionEnabled;
        setExistingPasswordDetected(passwordExists && !isEmpty);
        logger$1.log("[ImportWallet] Password check - service:", has, "localStorage:", hasLocalAuth, "encrypted:", encryptionEnabled, "wallets:", !isEmpty);
      } catch (e) {
        logger$1.error("[ImportWallet] Error checking password:", e);
        setExistingPasswordDetected(false);
        setPasswordRequired(true);
      }
    };
    checkPassword();
  }, []);
  const handleLengthChange = (len) => {
    setSeedLength(len);
    setWords(Array(len).fill(""));
    setError("");
  };
  const handleWordChange = (index, value) => {
    const word = value.toLowerCase().trim();
    const newWords = [...words];
    newWords[index] = word;
    setWords(newWords);
    setError("");
    if (word.length > 0) {
      const matches = WORDLIST.filter((w2) => w2.startsWith(word)).slice(0, 5);
      setSuggestions(matches);
      setActiveInput(index);
    } else {
      setSuggestions([]);
    }
  };
  const selectSuggestion = (word) => {
    var _a2;
    const newWords = [...words];
    newWords[activeInput] = word;
    setWords(newWords);
    setSuggestions([]);
    if (activeInput < seedLength - 1) {
      (_a2 = inputRefs.current[activeInput + 1]) == null ? void 0 : _a2.focus();
    }
  };
  const handleKeyDown = (e, index) => {
    var _a2, _b2;
    if (e.key === "Tab" || e.key === "Enter") {
      e.preventDefault();
      if (suggestions.length > 0) {
        selectSuggestion(suggestions[0]);
      } else if (e.key === "Enter") {
        if (index === seedLength - 1) {
          const filledWords = words.filter((w2) => w2.trim());
          if (filledWords.length === seedLength) {
            handleContinue();
          }
        } else {
          (_a2 = inputRefs.current[index + 1]) == null ? void 0 : _a2.focus();
        }
      }
    } else if (e.key === " " && words[index]) {
      e.preventDefault();
      if (index < seedLength - 1) (_b2 = inputRefs.current[index + 1]) == null ? void 0 : _b2.focus();
    }
  };
  const handlePaste = async () => {
    try {
      const text = await navigator.clipboard.readText();
      const pastedWords = text.trim().toLowerCase().split(/\s+/);
      if (pastedWords.length === 12 || pastedWords.length === 24) {
        setSeedLength(pastedWords.length);
        setWords(pastedWords);
        setError("");
      } else {
        setError("Invalid phrase. Must be 12 or 24 words.");
      }
    } catch {
      setError("Failed to paste from clipboard");
    }
  };
  const isValidWord = (word) => {
    if (!word) return null;
    return WORDLIST.includes(word.toLowerCase());
  };
  const handleContinue = async () => {
    const filledWords = words.filter((w2) => w2.trim());
    if (filledWords.length !== seedLength) {
      setError(`Please fill in all ${seedLength} words`);
      return;
    }
    const invalidWords = filledWords.filter((w2) => !WORDLIST.includes(w2.toLowerCase()));
    if (invalidWords.length > 0) {
      setError(`Invalid words: ${invalidWords.join(", ")}`);
      return;
    }
    const phrase = filledWords.join(" ");
    const isValid = await validateMnemonic(phrase);
    if (!isValid) {
      setError("Invalid seed phrase checksum");
      return;
    }
    setStep("name");
  };
  const validatePassword = (pwd) => {
    if (!pwd || pwd.length < 8) {
      return "Password must be at least 8 characters";
    }
    if (!/[a-zA-Z]/.test(pwd)) {
      return "Password must contain at least one letter";
    }
    if (!/[0-9]/.test(pwd)) {
      return "Password must contain at least one number";
    }
    const commonPatterns = ["password", "12345678", "qwerty", "abcdef", "letmein"];
    const lowerPwd = String(pwd).toLowerCase();
    for (const pattern of commonPatterns) {
      if (lowerPwd.includes(pattern)) {
        return "Password contains a common weak pattern";
      }
    }
    return null;
  };
  const handleNameContinue = async () => {
    if (!passwordRequired) {
      onComplete(words.join(" "), walletName || "Imported Wallet", null);
      return;
    }
    if (sessionPassword) {
      try {
        const { checkPassword } = await __vitePreload(async () => {
          const { checkPassword: checkPassword2 } = await import("./wallet.js");
          return { checkPassword: checkPassword2 };
        }, true ? [] : void 0);
        const isValid = await checkPassword(sessionPassword);
        if (isValid) {
          onComplete(words.join(" "), walletName || "Imported Wallet", sessionPassword);
          return;
        }
      } catch (e) {
        logger$1.warn("[ImportWallet] Session password verification failed:", e);
      }
    }
    if (existingPasswordDetected) {
      setStep("verify-password");
      setPassword("");
      setError("");
    } else {
      setStep("password");
      setError("");
    }
  };
  const handleVerifyAndComplete = async () => {
    if (!password) {
      setError("Please enter your password");
      return;
    }
    setVerifying(true);
    setError("");
    try {
      const { checkPassword } = await __vitePreload(async () => {
        const { checkPassword: checkPassword2 } = await import("./wallet.js");
        return { checkPassword: checkPassword2 };
      }, true ? [] : void 0);
      const isValid = await checkPassword(password);
      if (!isValid) {
        setError("Incorrect password");
        setVerifying(false);
        return;
      }
      onComplete(words.join(" "), walletName || "Imported Wallet", password);
    } catch (err) {
      logger$1.error("Password verification error:", err);
      logger$1.log("[ImportWallet] Verification failed, falling back to password creation");
      setStep("password");
      setPassword("");
      setError("");
      setVerifying(false);
    }
  };
  const handleComplete = () => {
    const pwdError = validatePassword(password);
    if (pwdError) {
      setError(pwdError);
      return;
    }
    if (password !== confirmPassword) {
      setError("Passwords do not match");
      return;
    }
    onComplete(words.join(" "), walletName || "Imported Wallet", password);
  };
  const handlePrivateKeyImport = async () => {
    setError("");
    if (!privateKeyInput.trim()) {
      setError("Please enter a private key");
      return;
    }
    try {
      const trimmedInput = privateKeyInput.trim();
      let keyBytes = null;
      if (trimmedInput.startsWith("[") && trimmedInput.endsWith("]")) {
        try {
          const parsed = JSON.parse(trimmedInput);
          if (Array.isArray(parsed) && parsed.every((n2) => typeof n2 === "number" && n2 >= 0 && n2 <= 255)) {
            keyBytes = new Uint8Array(parsed);
          } else {
            setError("Invalid byte array format");
            return;
          }
        } catch (jsonErr) {
          setError("Invalid byte array format");
          return;
        }
      } else {
        const base58Regex = /^[1-9A-HJ-NP-Za-km-z]+$/;
        if (!base58Regex.test(trimmedInput)) {
          setError("Invalid private key format");
          return;
        }
        const { decodeBase58: decodeBase582 } = await __vitePreload(async () => {
          const { decodeBase58: decodeBase583 } = await Promise.resolve().then(() => base58);
          return { decodeBase58: decodeBase583 };
        }, true ? void 0 : void 0);
        keyBytes = decodeBase582(trimmedInput);
      }
      if (keyBytes.length !== 64 && keyBytes.length !== 32) {
        setError(`Invalid key length: ${keyBytes.length} bytes (expected 32 or 64)`);
        return;
      }
      let secretKey = keyBytes;
      let publicKey;
      if (keyBytes.length === 32) {
        const { getPublicKey: getPublicKey2 } = await __vitePreload(async () => {
          const { getPublicKey: getPublicKey3 } = await Promise.resolve().then(() => bip44);
          return { getPublicKey: getPublicKey3 };
        }, true ? void 0 : void 0);
        publicKey = getPublicKey2(keyBytes);
        secretKey = new Uint8Array(64);
        secretKey.set(keyBytes, 0);
        secretKey.set(publicKey, 32);
      } else {
        publicKey = keyBytes.slice(32);
      }
      const { encodeBase58: encodeBase582 } = await __vitePreload(async () => {
        const { encodeBase58: encodeBase583 } = await Promise.resolve().then(() => base58);
        return { encodeBase58: encodeBase583 };
      }, true ? void 0 : void 0);
      const privateKeyBase58 = encodeBase582(secretKey);
      setPrivateKeyInput(privateKeyBase58);
      setStep("name-pk");
    } catch (err) {
      logger$1.error("Import error:", err);
      setError("Failed to import: " + err.message);
    }
  };
  const handleNamePkContinue = async () => {
    if (!passwordRequired) {
      await completePrivateKeyImport(null);
      return;
    }
    if (sessionPassword) {
      try {
        const { checkPassword } = await __vitePreload(async () => {
          const { checkPassword: checkPassword2 } = await import("./wallet.js");
          return { checkPassword: checkPassword2 };
        }, true ? [] : void 0);
        const isValid = await checkPassword(sessionPassword);
        if (isValid) {
          await completePrivateKeyImport(sessionPassword);
          return;
        }
      } catch (e) {
        logger$1.warn("[ImportWallet] Session password verification failed:", e);
      }
    }
    if (existingPasswordDetected) {
      setStep("verify-password-pk");
      setPassword("");
      setError("");
    } else {
      setStep("password-pk");
      setError("");
    }
  };
  const handleVerifyAndCompletePk = async () => {
    if (!password) {
      setError("Please enter your password");
      return;
    }
    setVerifying(true);
    setError("");
    try {
      const { checkPassword } = await __vitePreload(async () => {
        const { checkPassword: checkPassword2 } = await import("./wallet.js");
        return { checkPassword: checkPassword2 };
      }, true ? [] : void 0);
      const isValid = await checkPassword(password);
      if (!isValid) {
        setError("Incorrect password");
        setVerifying(false);
        return;
      }
      await completePrivateKeyImport(password);
    } catch (err) {
      logger$1.error("Password verification error:", err);
      logger$1.log("[ImportWallet] Verification failed, falling back to password creation");
      setStep("password-pk");
      setPassword("");
      setError("");
      setVerifying(false);
    }
  };
  const completePrivateKeyImport = async (pwd) => {
    try {
      const trimmedInput = privateKeyInput.trim();
      const { decodeBase58: decodeBase582, encodeBase58: encodeBase582 } = await __vitePreload(async () => {
        const { decodeBase58: decodeBase583, encodeBase58: encodeBase583 } = await Promise.resolve().then(() => base58);
        return { decodeBase58: decodeBase583, encodeBase58: encodeBase583 };
      }, true ? void 0 : void 0);
      let keyBytes;
      if (trimmedInput.startsWith("[")) {
        keyBytes = new Uint8Array(JSON.parse(trimmedInput));
      } else {
        keyBytes = decodeBase582(trimmedInput);
      }
      let publicKeyBytes;
      if (keyBytes.length === 64) {
        publicKeyBytes = keyBytes.slice(32);
      } else {
        const { getPublicKey: getPublicKey2 } = await __vitePreload(async () => {
          const { getPublicKey: getPublicKey3 } = await Promise.resolve().then(() => bip44);
          return { getPublicKey: getPublicKey3 };
        }, true ? void 0 : void 0);
        publicKeyBytes = getPublicKey2(keyBytes);
      }
      const publicKeyBase58 = encodeBase582(publicKeyBytes);
      const privateKeyBase58 = trimmedInput;
      onCompletePrivateKey({
        publicKey: publicKeyBase58,
        privateKey: privateKeyBase58,
        name: walletName || "Imported Wallet",
        password: pwd
      });
    } catch (err) {
      logger$1.error("Private key import error:", err);
      setError("Failed to import: " + err.message);
    }
  };
  const handleCompletePrivateKey = async () => {
    const pwdError = validatePassword(password);
    if (pwdError) {
      setError(pwdError);
      return;
    }
    if (password !== confirmPassword) {
      setError("Passwords do not match");
      return;
    }
    if (!onCompletePrivateKey) {
      setError("Secure import handler not available. Please try again or contact support.");
      logger$1.error("[ImportWallet] onCompletePrivateKey handler not provided - this is a security requirement");
      return;
    }
    try {
      const trimmedKey = privateKeyInput.trim();
      const { decodeBase58: decodeBase582, encodeBase58: encodeBase582 } = await __vitePreload(async () => {
        const { decodeBase58: decodeBase583, encodeBase58: encodeBase583 } = await Promise.resolve().then(() => base58);
        return { decodeBase58: decodeBase583, encodeBase58: encodeBase583 };
      }, true ? void 0 : void 0);
      const decoded = decodeBase582(trimmedKey);
      let secretKey = decoded;
      let publicKey;
      if (decoded.length === 32) {
        const { getPublicKey: getPublicKey2 } = await __vitePreload(async () => {
          const { getPublicKey: getPublicKey3 } = await Promise.resolve().then(() => bip44);
          return { getPublicKey: getPublicKey3 };
        }, true ? void 0 : void 0);
        publicKey = getPublicKey2(decoded);
        secretKey = new Uint8Array(64);
        secretKey.set(decoded, 0);
        secretKey.set(publicKey, 32);
      } else {
        publicKey = decoded.slice(32);
      }
      const publicKeyBase58 = encodeBase582(publicKey);
      const privateKeyBase58 = encodeBase582(secretKey);
      onCompletePrivateKey({
        publicKey: publicKeyBase58,
        privateKey: privateKeyBase58,
        name: walletName || "Imported Wallet",
        password
      });
    } catch (err) {
      setError("Failed to complete import: " + err.message);
    }
  };
  if (step === "name") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", type: "button", onClick: () => setStep("import"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "Name Your Wallet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-right" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen-content seed-container", style: { paddingTop: 0 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "seed-subtitle", children: "Give your imported wallet a name" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "form-group", style: { marginTop: 24 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "text", className: "form-input", value: walletName, onChange: (e) => setWalletName(e.target.value), onKeyDown: (e) => e.key === "Enter" && handleNameContinue(), placeholder: "My Imported Wallet", autoFocus: true }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", type: "button", onClick: handleNameContinue, style: { marginTop: 24 }, children: "Continue" })
      ] })
    ] });
  }
  if (step === "password") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", type: "button", onClick: () => setStep("name"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "Secure Wallet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-right" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen-content seed-container", style: { paddingTop: 0 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center", marginBottom: 24 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            width: 64,
            height: 64,
            borderRadius: "50%",
            background: "rgba(var(--x1-blue-rgb), 0.1)",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            margin: "0 auto 16px"
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "32", height: "32", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "11", width: "18", height: "11", rx: "2", ry: "2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "seed-subtitle", children: "Create a password to encrypt your wallet" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", style: { marginBottom: 16 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: showPassword ? "text" : "password",
                className: "form-input",
                value: password,
                onChange: (e) => {
                  setPassword(e.target.value);
                  setError("");
                },
                placeholder: "Enter password",
                autoFocus: true
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => setShowPassword(!showPassword),
                style: {
                  position: "absolute",
                  right: 12,
                  top: "50%",
                  transform: "translateY(-50%)",
                  background: "none",
                  border: "none",
                  cursor: "pointer",
                  padding: 4
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-secondary)", strokeWidth: "2", children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
                ] }) })
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", style: { marginBottom: 16 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Confirm Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: showPassword ? "text" : "password",
                className: "form-input",
                value: confirmPassword,
                onChange: (e) => {
                  setConfirmPassword(e.target.value);
                  setError("");
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => setShowPassword(!showPassword),
                style: {
                  position: "absolute",
                  right: 12,
                  top: "50%",
                  transform: "translateY(-50%)",
                  background: "none",
                  border: "none",
                  cursor: "pointer",
                  padding: 4
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-secondary)", strokeWidth: "2", children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
                ] }) })
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-box", style: { marginBottom: 16 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Min 8 characters with at least one letter and one number." })
        ] }),
        error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", style: { marginBottom: 16 }, children: error }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", type: "button", onClick: handleComplete, children: "Import Wallet" })
      ] })
    ] });
  }
  if (step === "verify-password") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", type: "button", onClick: () => setStep("name"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "Verify Password" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-right" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen-content seed-container", style: { paddingTop: 0 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center", marginBottom: 24 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            width: 64,
            height: 64,
            borderRadius: "50%",
            background: "rgba(var(--x1-blue-rgb), 0.1)",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            margin: "0 auto 16px"
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "32", height: "32", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "11", width: "18", height: "11", rx: "2", ry: "2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "seed-subtitle", children: "Enter your existing password to import this wallet" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", style: { marginBottom: 16 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: showPassword ? "text" : "password",
                className: "form-input",
                value: password,
                onChange: (e) => {
                  setPassword(e.target.value);
                  setError("");
                },
                placeholder: "Enter your password",
                autoFocus: true,
                onKeyDown: (e) => e.key === "Enter" && handleVerifyAndComplete()
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => setShowPassword(!showPassword),
                style: {
                  position: "absolute",
                  right: 12,
                  top: "50%",
                  transform: "translateY(-50%)",
                  background: "none",
                  border: "none",
                  cursor: "pointer",
                  padding: 4
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-secondary)", strokeWidth: "2", children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
                ] }) })
              }
            )
          ] })
        ] }),
        error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", style: { marginBottom: 16 }, children: error }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn-primary",
            type: "button",
            onClick: handleVerifyAndComplete,
            disabled: verifying,
            children: verifying ? "Verifying..." : "Import Wallet"
          }
        )
      ] })
    ] });
  }
  if (step === "name-pk") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", type: "button", onClick: () => setStep("import"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "Name Your Wallet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-right" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen-content seed-container", style: { paddingTop: 0 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "seed-subtitle", children: "Give your imported wallet a name" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "form-group", style: { marginTop: 24 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "text", className: "form-input", value: walletName, onChange: (e) => setWalletName(e.target.value), onKeyDown: (e) => e.key === "Enter" && handleNamePkContinue(), placeholder: "My Imported Wallet", autoFocus: true }) }),
        error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: error }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", type: "button", onClick: handleNamePkContinue, style: { marginTop: 24 }, children: "Continue" })
      ] })
    ] });
  }
  if (step === "password-pk") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", type: "button", onClick: () => setStep("name-pk"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "Secure Wallet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-right" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen-content seed-container", style: { paddingTop: 0 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center", marginBottom: 24 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            width: 64,
            height: 64,
            borderRadius: "50%",
            background: "rgba(var(--x1-blue-rgb), 0.1)",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            margin: "0 auto 16px"
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "32", height: "32", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "11", width: "18", height: "11", rx: "2", ry: "2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "seed-subtitle", children: "Create a password to encrypt your wallet" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", style: { marginBottom: 16 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: showPassword ? "text" : "password",
                className: "form-input",
                value: password,
                onChange: (e) => {
                  setPassword(e.target.value);
                  setError("");
                },
                placeholder: "Enter password",
                autoFocus: true
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => setShowPassword(!showPassword),
                style: {
                  position: "absolute",
                  right: 12,
                  top: "50%",
                  transform: "translateY(-50%)",
                  background: "none",
                  border: "none",
                  cursor: "pointer",
                  padding: 4
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-secondary)", strokeWidth: "2", children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
                ] }) })
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", style: { marginBottom: 16 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Confirm Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: showPassword ? "text" : "password",
                className: "form-input",
                value: confirmPassword,
                onChange: (e) => {
                  setConfirmPassword(e.target.value);
                  setError("");
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => setShowPassword(!showPassword),
                style: {
                  position: "absolute",
                  right: 12,
                  top: "50%",
                  transform: "translateY(-50%)",
                  background: "none",
                  border: "none",
                  cursor: "pointer",
                  padding: 4
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-secondary)", strokeWidth: "2", children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
                ] }) })
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-box", style: { marginBottom: 16 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Min 8 characters with at least one letter and one number." })
        ] }),
        error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", style: { marginBottom: 16 }, children: error }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", type: "button", onClick: handleCompletePrivateKey, children: "Import Wallet" })
      ] })
    ] });
  }
  if (step === "verify-password-pk") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", type: "button", onClick: () => setStep("name-pk"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "Verify Password" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-right" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen-content seed-container", style: { paddingTop: 0 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center", marginBottom: 24 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            width: 64,
            height: 64,
            borderRadius: "50%",
            background: "rgba(var(--x1-blue-rgb), 0.1)",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            margin: "0 auto 16px"
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "32", height: "32", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "11", width: "18", height: "11", rx: "2", ry: "2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "seed-subtitle", children: "Enter your existing password to import this wallet" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", style: { marginBottom: 16 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: showPassword ? "text" : "password",
                className: "form-input",
                value: password,
                onChange: (e) => {
                  setPassword(e.target.value);
                  setError("");
                },
                placeholder: "Enter your password",
                autoFocus: true,
                onKeyDown: (e) => e.key === "Enter" && handleVerifyAndCompletePk()
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => setShowPassword(!showPassword),
                style: {
                  position: "absolute",
                  right: 12,
                  top: "50%",
                  transform: "translateY(-50%)",
                  background: "none",
                  border: "none",
                  cursor: "pointer",
                  padding: 4
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-secondary)", strokeWidth: "2", children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
                ] }) })
              }
            )
          ] })
        ] }),
        error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", style: { marginBottom: 16 }, children: error }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn-primary",
            type: "button",
            onClick: handleVerifyAndCompletePk,
            disabled: verifying,
            children: verifying ? "Verifying..." : "Import Wallet"
          }
        )
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen no-nav", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", type: "button", onClick: onBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "Import Wallet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-right" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen-content seed-container", style: { paddingTop: 0 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "seed-subtitle", children: "Choose how to import your wallet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "import-type-selector", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            type: "button",
            className: `import-type-btn ${importType === "phrase" ? "active" : ""}`,
            onClick: () => {
              setImportType("phrase");
              setError("");
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2L2 7l10 5 10-5-10-5z" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2 17l10 5 10-5" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2 12l10 5 10-5" })
              ] }),
              "Seed Phrase"
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            type: "button",
            className: `import-type-btn ${importType === "privatekey" ? "active" : ""}`,
            onClick: () => {
              setImportType("privatekey");
              setError("");
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4" }) }),
              "Private Key / Bytes"
            ]
          }
        )
      ] }),
      importType === "phrase" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "seed-length-selector", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: `seed-length-btn ${seedLength === 12 ? "active" : ""}`, onClick: () => handleLengthChange(12), children: "12 Words" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: `seed-length-btn ${seedLength === 24 ? "active" : ""}`, onClick: () => handleLengthChange(24), children: "24 Words" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { type: "button", className: "paste-btn", onClick: handlePaste, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "8", y: "2", width: "8", height: "4", rx: "1", ry: "1" })
          ] }),
          "Paste from Clipboard"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "seed-input-grid", children: words.map((word, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "seed-input-word", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "seed-input-number", children: i + 1 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              ref: (el2) => inputRefs.current[i] = el2,
              type: "text",
              value: word,
              onChange: (e) => handleWordChange(i, e.target.value),
              onKeyDown: (e) => handleKeyDown(e, i),
              onFocus: () => {
                setActiveInput(i);
                if (word) setSuggestions(WORDLIST.filter((w2) => w2.startsWith(word)).slice(0, 5));
              },
              onBlur: () => setTimeout(() => setSuggestions([]), 200),
              className: isValidWord(word) === true ? "valid" : isValidWord(word) === false ? "error" : "",
              placeholder: "word",
              autoComplete: "off",
              autoCapitalize: "off"
            }
          )
        ] }, i)) }),
        suggestions.length > 0 && activeInput >= 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "suggestions-dropdown", children: suggestions.map((word, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `suggestion ${i === 0 ? "first" : ""}`, onClick: () => selectSuggestion(word), children: word }, word)) }),
        error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: error }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", type: "button", onClick: handleContinue, children: "Continue" })
      ] }),
      importType === "privatekey" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "warning-box", style: { marginTop: 16 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Enter your private key. Never share this with anyone." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", style: { marginTop: 16 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Private Key" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              className: "form-input private-key-input",
              placeholder: "Paste Key (private or byte array)",
              value: privateKeyInput,
              onChange: (e) => {
                setPrivateKeyInput(e.target.value);
                setError("");
              },
              rows: 4
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-box", style: { marginTop: 12 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Accepts base58 format or byte array [1,2,3,...] format." })
        ] }),
        error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", style: { marginTop: 16 }, children: error }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", type: "button", onClick: handlePrivateKeyImport, style: { marginTop: 20 }, children: "Continue" })
      ] })
    ] })
  ] });
}
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer2[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m2, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports$1) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$1.Buffer = Buffer2;
  exports$1.SlowBuffer = SlowBuffer;
  exports$1.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$1.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b) return 0;
    let x2 = a.length;
    let y2 = b.length;
    for (let i = 0, len = Math.min(x2, y2); i < len; ++i) {
      if (a[i] !== b[i]) {
        x2 = a[i];
        y2 = b[i];
        break;
      }
    }
    if (x2 < y2) return -1;
    if (y2 < x2) return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b, n2, m2) {
    const i = b[n2];
    b[n2] = b[m2];
    b[m2] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b) {
    if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer2.compare(this, b) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max = exports$1.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end - start;
    const len = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x2 = thisCopy[i];
        y2 = targetCopy[i];
        break;
      }
    }
    if (x2 < y2) return -1;
    if (y2 < x2) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 2] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 1] = hi2;
    hi2 = hi2 >> 8;
    buf[offset] = hi2;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E2(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength3) {
    if (value > max || value < min) {
      const n2 = typeof min === "bigint" ? "n" : "";
      let range;
      {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
        } else {
          range = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
        }
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      "offset",
      `>= ${0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi2, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi2 = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
const isDev = typeof process !== "undefined" ? false : typeof window !== "undefined" && ((_b = window.location) == null ? void 0 : _b.hostname) === "localhost";
const logger = {
  log: (...args) => isDev && console.log("[Hardware]", ...args),
  warn: (...args) => console.warn("[Hardware]", ...args),
  // Always log warnings
  error: (...args) => console.error("[Hardware]", ...args)
  // Always log errors
};
if (typeof window !== "undefined") {
  window.Buffer = buffer.Buffer;
}
const LEDGER_STATES = {
  DISCONNECTED: "disconnected",
  CONNECTING: "connecting",
  CONNECTED: "connected",
  APP_CLOSED: "app_closed",
  READY: "ready",
  ERROR: "error"
};
const HW_TYPES = {
  LEDGER: "ledger",
  TREZOR: "trezor"
};
const CONNECTION_TYPES = {
  USB: "usb",
  BLUETOOTH: "bluetooth"
};
const DERIVATION_SCHEMES = {
  // Standard BIP44: m/44'/501'/{account}'
  BIP44_STANDARD: {
    id: "bip44_standard",
    name: "Standard (BIP44)",
    description: "m/44'/501'/<account>'",
    getPath: (index) => `44'/501'/${index}'`
  },
  // Extended BIP44: m/44'/501'/{account}'/0'
  BIP44_EXTENDED: {
    id: "bip44_extended",
    name: "Extended (BIP44)",
    description: "m/44'/501'/<account>'/0'",
    getPath: (index) => `44'/501'/${index}'/0'`
  },
  // Legacy BIP44 Change: m/44'/501'/0'/{account}'
  BIP44_LEGACY: {
    id: "bip44_legacy",
    name: "Legacy",
    description: "m/44'/501'/0'/<account>'",
    getPath: (index) => `44'/501'/0'/${index}'`
  }
};
class HardwareWalletService {
  constructor() {
    this.transport = null;
    this.solanaApp = null;
    this.deviceType = null;
    this.connectionType = null;
    this.state = LEDGER_STATES.DISCONNECTED;
    this.publicKey = null;
    this.derivationPath = "44'/501'/0'/0'";
    this.currentScheme = DERIVATION_SCHEMES.BIP44_EXTENDED;
    this.sessionInvalid = false;
  }
  // Mark session as invalid and close transport
  // Call this after ANY Ledger transport/status error
  async invalidateSession(reason = "unknown") {
    logger.warn("[Hardware] Invalidating session:", reason);
    this.sessionInvalid = true;
    await this.disconnect();
  }
  // Check if session is valid, throw if not
  ensureValidSession() {
    if (this.sessionInvalid) {
      throw new Error("Ledger session expired. Please reconnect your device and open the Solana app.");
    }
  }
  // Preflight check - verify Solana app is responsive before signing
  async preflightCheck() {
    if (!this.solanaApp) {
      throw new Error("Solana app not initialized");
    }
    try {
      await this.solanaApp.getAppConfiguration();
      return true;
    } catch (err) {
      logger.error("[Hardware] Preflight check failed:", err.message);
      await this.invalidateSession("preflight failed: " + err.message);
      throw new Error("Ledger not ready. Please unlock your device and open the Solana app.");
    }
  }
  // Check if WebUSB/WebHID is supported
  isSupported() {
    return typeof navigator !== "undefined" && (navigator.usb !== void 0 || navigator.hid !== void 0 || navigator.bluetooth !== void 0);
  }
  // Check if Bluetooth is supported
  isBluetoothSupported() {
    return typeof navigator !== "undefined" && navigator.bluetooth !== void 0;
  }
  // Get transport type available
  getAvailableTransport() {
    if (navigator.hid) return "webhid";
    if (navigator.usb) return "webusb";
    return null;
  }
  // Get all supported derivation schemes
  getDerivationSchemes() {
    return Object.values(DERIVATION_SCHEMES);
  }
  // Set the current derivation scheme
  setDerivationScheme(schemeId) {
    const scheme = Object.values(DERIVATION_SCHEMES).find((s) => s.id === schemeId);
    if (scheme) {
      this.currentScheme = scheme;
      logger.log("Derivation scheme set to:", scheme.name);
    }
  }
  // Get current derivation scheme
  getCurrentScheme() {
    return this.currentScheme;
  }
  // Connect to Ledger device via USB or Bluetooth
  async connect(connectionType = CONNECTION_TYPES.USB) {
    var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
    if (!this.isSupported()) {
      throw new Error("WebUSB/WebHID not supported in this browser");
    }
    if (this.transport) {
      logger.log("Transport already exists, closing it first...");
      try {
        await this.transport.close();
      } catch (e) {
        logger.warn("Error closing existing transport:", e);
      }
      this.transport = null;
      this.solanaApp = null;
    }
    this.state = LEDGER_STATES.CONNECTING;
    this.connectionType = connectionType;
    try {
      if (connectionType === CONNECTION_TYPES.BLUETOOTH) {
        logger.log("Using Bluetooth transport");
        if (!this.isBluetoothSupported()) {
          throw new Error("Bluetooth is not supported in this browser. Please use Chrome or Edge.");
        }
        const TransportModule = await __vitePreload(() => import("./TransportWebBLE.js"), true ? __vite__mapDeps([0,1,2,3,4]) : void 0);
        const Transport = TransportModule.default;
        try {
          logger.log("Requesting Bluetooth Ledger device...");
          this.transport = await Transport.create();
          logger.log("Bluetooth transport created successfully");
        } catch (e) {
          logger.error("Bluetooth connection failed:", e);
          logger.error("Error name:", e == null ? void 0 : e.name);
          logger.error("Error message:", e == null ? void 0 : e.message);
          logger.error("Error stack:", e == null ? void 0 : e.stack);
          if (((_a2 = e.message) == null ? void 0 : _a2.includes("User cancelled")) || e.name === "TransportOpenUserCancelled") {
            throw new Error("Bluetooth pairing cancelled. Please try again.");
          }
          if ((_b2 = e.message) == null ? void 0 : _b2.includes("Bluetooth adapter not available")) {
            throw new Error("Bluetooth is not available. Please enable Bluetooth on your device.");
          }
          if ((_c = e.message) == null ? void 0 : _c.includes("GATT")) {
            throw new Error("Bluetooth connection dropped. Please:\n Keep tapping your Ledger to keep it awake\n Move it closer to your computer\n Try again");
          }
          throw new Error(`Bluetooth connection failed: ${(e == null ? void 0 : e.message) || (e == null ? void 0 : e.name) || "Unknown error"}`);
        }
      } else {
        const transportType = this.getAvailableTransport();
        logger.log("Transport type available:", transportType);
        if (transportType === "webhid") {
          logger.log("Using WebHID transport");
          let existingDevices = [];
          try {
            existingDevices = await navigator.hid.getDevices();
            logger.log("Existing authorized HID devices:", existingDevices.length);
            const ledgerDevices = existingDevices.filter((d) => d.vendorId === 11415);
            logger.log("Ledger devices found:", ledgerDevices.length);
            for (const device of ledgerDevices) {
              console.log("[Hardware] Ledger device:", {
                productId: "0x" + device.productId.toString(16),
                productName: device.productName,
                collections: (_d = device.collections) == null ? void 0 : _d.map((c) => ({
                  usagePage: "0x" + c.usagePage.toString(16),
                  usage: "0x" + c.usage.toString(16)
                }))
              });
              const isFido = (_e = device.collections) == null ? void 0 : _e.some((c) => c.usagePage === 61904);
              if (isFido) {
                console.warn("[Hardware]  This device is a FIDO interface - may not work for signing!");
              }
              const isMain = (_f = device.collections) == null ? void 0 : _f.some((c) => c.usagePage === 65440);
              if (isMain) {
                console.log("[Hardware]  This device is the main Ledger interface");
              }
            }
          } catch (e) {
            logger.log("Could not enumerate existing devices:", e.message);
          }
          try {
            const TransportModule = await __vitePreload(() => import("./TransportWebHID.js"), true ? __vite__mapDeps([5,1,2,3,6]) : void 0);
            const Transport = TransportModule.default;
            logger.log("Requesting Ledger device via WebHID...");
            console.log("[Hardware] About to call Transport.create() - device picker should appear");
            console.log("[Hardware] Note: For Nano X, make sure to select the main interface, not FIDO");
            const transportPromise = Transport.create();
            const timeoutPromise = new Promise((_, reject) => {
              setTimeout(() => {
                reject(new Error("Device picker timeout. This can happen if:\n Chrome blocked the popup (check for blocked popup icon)\n The extension window lost focus\n macOS requires additional permissions\n\nTry: Click this window, ensure it has focus, then click Connect again."));
              }, 3e4);
            });
            this.transport = await Promise.race([transportPromise, timeoutPromise]);
            console.log("[Hardware] Transport.create() returned successfully");
            if ((_g = this.transport) == null ? void 0 : _g.device) {
              const device = this.transport.device;
              console.log("[Hardware] Connected to device:", {
                productId: "0x" + ((_h = device.productId) == null ? void 0 : _h.toString(16)),
                productName: device.productName,
                collections: (_i = device.collections) == null ? void 0 : _i.map((c) => {
                  var _a3, _b3;
                  return {
                    usagePage: "0x" + ((_a3 = c.usagePage) == null ? void 0 : _a3.toString(16)),
                    usage: "0x" + ((_b3 = c.usage) == null ? void 0 : _b3.toString(16))
                  };
                })
              });
              const isFido = (_j = device.collections) == null ? void 0 : _j.some((c) => c.usagePage === 61904);
              if (isFido) {
                console.error("[Hardware]  Connected to FIDO interface! This will cause 0x6a81 errors.");
                console.error("[Hardware] Please disconnect and reconnect, selecting a different interface.");
              }
            }
            logger.log("Transport created successfully");
          } catch (e) {
            logger.error("WebHID transport creation failed:", e);
            console.error("[Hardware] WebHID error:", e == null ? void 0 : e.name, e == null ? void 0 : e.message);
            if ((e == null ? void 0 : e.name) === "TransportOpenUserCancelled") {
              throw new Error("Device selection cancelled. Please try again and select your Ledger.");
            }
            if ((_k = e == null ? void 0 : e.message) == null ? void 0 : _k.includes("No device selected")) {
              throw new Error("No Ledger device selected. Please try again.");
            }
            if (((_l = e == null ? void 0 : e.message) == null ? void 0 : _l.includes("timeout")) || ((_m = e == null ? void 0 : e.message) == null ? void 0 : _m.includes("Device picker"))) {
              throw e;
            }
            if ((e == null ? void 0 : e.name) === "NotAllowedError") {
              throw new Error("Chrome blocked device access. Ensure this window has focus and try again.");
            }
            throw new Error(`WebHID connection failed: ${(e == null ? void 0 : e.message) || (e == null ? void 0 : e.name) || "Unknown error"}`);
          }
        } else if (transportType === "webusb") {
          logger.log("Using WebUSB transport");
          const TransportModule = await __vitePreload(() => import("./TransportWebUSB.js"), true ? __vite__mapDeps([7,1,2,3,6]) : void 0);
          const Transport = TransportModule.default;
          this.transport = await Transport.create();
        } else {
          throw new Error("No compatible transport available (WebHID or WebUSB required)");
        }
      }
      this.deviceType = HW_TYPES.LEDGER;
      this.state = LEDGER_STATES.CONNECTED;
      logger.log("Ledger connected via", connectionType);
      return true;
    } catch (error) {
      this.state = LEDGER_STATES.ERROR;
      logger.error("Ledger connection error:", error);
      logger.error("Error name:", error.name);
      logger.error("Error message:", error.message);
      if (error.name === "TransportOpenUserCancelled" || ((_n = error.message) == null ? void 0 : _n.includes("user cancelled"))) {
        throw new Error("Connection cancelled. Please click Connect and select your Ledger device from the popup.");
      }
      if ((_o = error.message) == null ? void 0 : _o.includes("No device selected")) {
        throw new Error("No Ledger device selected. Please try again and select your device.");
      }
      if ((_p = error.message) == null ? void 0 : _p.includes("Access denied")) {
        throw new Error("Access denied. Please:\n Make sure Ledger Live is closed\n Unlock your Ledger device\n Open the Solana app on the device\n Try unplugging and replugging the USB");
      }
      if ((_q = error.message) == null ? void 0 : _q.includes("Unable to claim interface")) {
        throw new Error("Another application is using your Ledger. Please close Ledger Live and any other wallet apps.");
      }
      if (((_r = error.message) == null ? void 0 : _r.includes("NotFoundError")) || ((_s = error.message) == null ? void 0 : _s.includes("no device"))) {
        throw new Error("No Ledger device found. Please:\n Connect your Ledger via USB\n Unlock it with your PIN\n Open the Solana app");
      }
      throw new Error(`Failed to connect: ${error.message || "Unknown error"}`);
    }
  }
  // Open Solana/X1 app on Ledger
  async openApp() {
    logger.log("[Hardware] openApp called, transport exists:", !!this.transport);
    if (!this.transport) {
      logger.log("[Hardware] No transport, attempting to reconnect...");
      try {
        const transportType = this.getAvailableTransport();
        if (transportType === "webhid") {
          const TransportModule = await __vitePreload(() => import("./TransportWebHID.js"), true ? __vite__mapDeps([5,1,2,3,6]) : void 0);
          const Transport = TransportModule.default;
          try {
            this.transport = await Transport.openConnected();
          } catch (e) {
            logger.log("[Hardware] openConnected failed:", e.message);
            this.transport = null;
          }
          if (!this.transport) {
            this.transport = await Transport.create();
          }
          logger.log("[Hardware] Reconnected via", transportType);
        } else {
          throw new Error("Ledger not connected. Please go back and connect again.");
        }
      } catch (e) {
        logger.error("[Hardware] Reconnection failed:", e);
        throw new Error("Ledger not connected. Please go back and connect again.");
      }
    }
    try {
      const SolanaModule = await __vitePreload(() => import("./Solana.js"), true ? __vite__mapDeps([8,3]) : void 0);
      const Solana = SolanaModule.default;
      this.solanaApp = new Solana(this.transport);
      const config = await this.solanaApp.getAppConfiguration();
      logger.log("Solana app version:", config.version);
      this.sessionInvalid = false;
      this.state = LEDGER_STATES.READY;
      return config;
    } catch (error) {
      this.state = LEDGER_STATES.APP_CLOSED;
      logger.error("Solana app error:", error);
      await this.invalidateSession("openApp failed: " + error.message);
      if (error.statusCode === 28160 || error.statusCode === 27904) {
        throw new Error("Please open the Solana app on your Ledger device.");
      }
      if (error.statusCode === 28161) {
        throw new Error("Ledger is locked. Please unlock it and try again.");
      }
      throw new Error("Could not connect to Solana app. Please make sure it is open on your Ledger.");
    }
  }
  // Get public key from Ledger
  async getPublicKey(path = null, display = false) {
    if (!this.solanaApp) {
      await this.openApp();
    }
    const derivePath2 = path || this.derivationPath;
    try {
      const result = await this.solanaApp.getAddress(derivePath2, display);
      this.publicKey = result.address.toString("hex");
      const publicKeyBase58 = this.bufferToBase58(result.address);
      return publicKeyBase58;
    } catch (error) {
      logger.error("Get public key error:", error);
      if (error.statusCode === 27013) {
        throw new Error("Transaction rejected by user");
      }
      throw error;
    }
  }
  // Get accounts for a specific derivation scheme
  async getAccountsForScheme(scheme, startIndex = 0, count = 5) {
    const accounts = [];
    for (let i = startIndex; i < startIndex + count; i++) {
      const path = scheme.getPath(i);
      try {
        const address = await this.getPublicKey(path, false);
        accounts.push({
          index: i,
          path,
          address,
          scheme: scheme.id,
          schemeName: scheme.name,
          label: `Account ${i + 1}`
        });
      } catch (e) {
        logger.warn(`Could not get account ${i} for scheme ${scheme.id}:`, e);
        break;
      }
    }
    return accounts;
  }
  // Get accounts from all schemes (for discovery)
  async discoverAccounts(count = 5) {
    const allAccounts = [];
    const seenAddresses = /* @__PURE__ */ new Set();
    for (const scheme of Object.values(DERIVATION_SCHEMES)) {
      try {
        const accounts = await this.getAccountsForScheme(scheme, 0, count);
        for (const account of accounts) {
          if (!seenAddresses.has(account.address)) {
            seenAddresses.add(account.address);
            allAccounts.push(account);
          }
        }
      } catch (e) {
        logger.warn(`Failed to get accounts for scheme ${scheme.id}:`, e);
      }
    }
    return allAccounts;
  }
  // Sign transaction with Ledger
  async signTransaction(transaction2, path = null) {
    var _a2, _b2;
    this.ensureValidSession();
    if (!this.solanaApp) {
      await this.openApp();
    }
    await this.preflightCheck();
    let derivePath2 = path || this.derivationPath;
    if (derivePath2 && derivePath2.startsWith("m/")) {
      derivePath2 = derivePath2.slice(2);
    }
    if (!derivePath2 || derivePath2 === "null" || derivePath2 === "undefined") {
      derivePath2 = "44'/501'/0'/0'";
      logger.log("[Hardware] Using default derivation path as provided path was invalid");
    }
    logger.log("[Hardware] signTransaction using derivation path:", derivePath2, "(passed:", path, ", default:", this.derivationPath, ")");
    try {
      const txBuffer = buffer.Buffer.isBuffer(transaction2) ? transaction2 : buffer.Buffer.from(transaction2);
      const result = await this.solanaApp.signTransaction(derivePath2, txBuffer);
      return result.signature;
    } catch (error) {
      logger.error("Sign transaction error:", error);
      logger.error("[Hardware] Derivation path that failed:", derivePath2);
      if (error.statusCode === 27013) {
        throw new Error("Transaction rejected by user");
      }
      if (error.statusCode === 27264) {
        throw new Error("Invalid transaction data");
      }
      if (error.statusCode === 27265 || error.statusCode === 27265 || ((_a2 = error.message) == null ? void 0 : _a2.includes("0x6a81")) || ((_b2 = error.message) == null ? void 0 : _b2.includes("UNKNOWN_ERROR"))) {
        await this.invalidateSession("signTransaction transport error: " + error.message);
        throw new Error('Ledger signing failed. Please try: 1) Enable "Blind Sign" in Ledger Solana app settings, 2) Update Solana app via Ledger Live, 3) Close Ledger Live if running, 4) Reconnect your Ledger');
      }
      if (error.name === "TransportStatusError") {
        await this.invalidateSession("signTransaction transport error: " + error.message);
      }
      throw error;
    }
  }
  // Sign message with Ledger (off-chain)
  async signMessage(message, path = null) {
    var _a2, _b2;
    this.ensureValidSession();
    if (!this.solanaApp) {
      await this.openApp();
    }
    await this.preflightCheck();
    let derivePath2 = path || this.derivationPath;
    if (derivePath2 && derivePath2.startsWith("m/")) {
      derivePath2 = derivePath2.slice(2);
    }
    if (!derivePath2 || derivePath2 === "null" || derivePath2 === "undefined") {
      derivePath2 = "44'/501'/0'/0'";
    }
    const msgBuffer = buffer.Buffer.isBuffer(message) ? message : message instanceof Uint8Array ? buffer.Buffer.from(message) : buffer.Buffer.from(message, "utf8");
    try {
      const result = await this.solanaApp.signOffchainMessage(derivePath2, msgBuffer);
      return result.signature;
    } catch (err) {
      if (err.statusCode === 27265 || err.statusCode === 27265 || ((_a2 = err.message) == null ? void 0 : _a2.includes("0x6a81")) || ((_b2 = err.message) == null ? void 0 : _b2.includes("UNKNOWN_ERROR"))) {
        await this.invalidateSession("signMessage transport error: " + err.message);
        throw new Error('Ledger signing failed. Please try: 1) Enable "Blind Sign" in Ledger Solana app settings, 2) Update Solana app via Ledger Live, 3) Close Ledger Live if running, 4) Reconnect your Ledger');
      }
      if (err.name === "TransportStatusError") {
        await this.invalidateSession("signMessage transport error: " + err.message);
      }
      throw err;
    }
  }
  // Disconnect from Ledger
  async disconnect() {
    if (this.transport) {
      try {
        await this.transport.close();
      } catch (e) {
        logger.warn("Error closing transport:", e);
      }
    }
    this.transport = null;
    this.solanaApp = null;
    this.deviceType = null;
    this.connectionType = null;
    this.state = LEDGER_STATES.DISCONNECTED;
    this.publicKey = null;
  }
  // Get different derivation paths (legacy method for compatibility)
  getDerivationPaths() {
    return [
      { path: "44'/501'/0'/0'", label: "Default (m/44'/501'/0'/0')" },
      { path: "44'/501'/0'", label: "Legacy (m/44'/501'/0')" },
      { path: "44'/501'/1'/0'", label: "Account 2 (m/44'/501'/1'/0')" },
      { path: "44'/501'/2'/0'", label: "Account 3 (m/44'/501'/2'/0')" },
      { path: "44'/501'/3'/0'", label: "Account 4 (m/44'/501'/3'/0')" }
    ];
  }
  // Set derivation path
  setDerivationPath(path) {
    this.derivationPath = path;
  }
  // Helper: Buffer to Base58
  bufferToBase58(buffer2) {
    const ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    let bytes = Array.from(buffer2);
    let digits = [0];
    for (let i = 0; i < bytes.length; i++) {
      let carry = bytes[i];
      for (let j = 0; j < digits.length; j++) {
        carry += digits[j] << 8;
        digits[j] = carry % 58;
        carry = carry / 58 | 0;
      }
      while (carry > 0) {
        digits.push(carry % 58);
        carry = carry / 58 | 0;
      }
    }
    for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {
      digits.push(0);
    }
    return digits.reverse().map((d) => ALPHABET2[d]).join("");
  }
  // Get current state
  getState() {
    return this.state;
  }
  // Check if ready to sign
  isReady() {
    return this.state === LEDGER_STATES.READY;
  }
}
class TrezorWalletService {
  constructor() {
    this.trezorConnect = null;
    this.deviceType = HW_TYPES.TREZOR;
    this.state = LEDGER_STATES.DISCONNECTED;
    this.publicKey = null;
    this.derivationPath = "m/44'/501'/0'/0'";
    this.initialized = false;
  }
  // Initialize Trezor Connect
  async init() {
    var _a2, _b2;
    if (this.initialized) return;
    try {
      logger.log("[Trezor] Starting initialization...");
      const importPromise = __vitePreload(() => import("./index.js").then((n2) => n2.i), true ? __vite__mapDeps([9,4,2]) : void 0);
      const timeoutPromise = new Promise(
        (_, reject) => setTimeout(() => reject(new Error("Trezor Connect import timeout")), 1e4)
      );
      const TrezorConnect = await Promise.race([importPromise, timeoutPromise]);
      logger.log("[Trezor] Module imported");
      this.trezorConnect = TrezorConnect.default;
      if (this.trezorConnect.isInitialized && this.trezorConnect.isInitialized()) {
        logger.log("[Trezor] Already initialized");
        this.initialized = true;
        return;
      }
      logger.log("[Trezor] Calling init...");
      await this.trezorConnect.init({
        lazyLoad: true,
        // Let operations trigger the popup
        manifest: {
          email: "support@x1.xyz",
          appUrl: typeof chrome !== "undefined" && ((_a2 = chrome.runtime) == null ? void 0 : _a2.id) ? `chrome-extension://${chrome.runtime.id}` : window.location.origin
        },
        transports: ["BridgeTransport", "WebUsbTransport"],
        // Try Bridge first, then WebUSB
        connectSrc: "https://connect.trezor.io/9/",
        popup: true,
        // Use popup mode
        debug: isDev
      });
      this.initialized = true;
      logger.log("[Trezor] Connect initialized successfully");
    } catch (e) {
      if ((_b2 = e.message) == null ? void 0 : _b2.includes("already initialized")) {
        this.initialized = true;
        logger.log("[Trezor] Was already initialized");
        return;
      }
      logger.error("[Trezor] Failed to initialize:", e);
      throw new Error("Failed to initialize Trezor: " + e.message);
    }
  }
  // Check if supported
  isSupported() {
    return typeof navigator !== "undefined" && navigator.usb !== void 0;
  }
  // Get derivation schemes (same as Ledger for Solana)
  getDerivationSchemes() {
    return Object.values(DERIVATION_SCHEMES);
  }
  // Connect to Trezor - just initialize, actual connection happens on first use
  async connect() {
    this.state = LEDGER_STATES.CONNECTING;
    try {
      await this.init();
      this.state = LEDGER_STATES.CONNECTED;
      logger.log("Trezor Connect ready");
      return true;
    } catch (e) {
      this.state = LEDGER_STATES.ERROR;
      logger.error("Trezor initialization error:", e);
      throw e;
    }
  }
  // Open app (no-op for Trezor - Solana is built-in)
  async openApp() {
    await this.init();
    this.state = LEDGER_STATES.READY;
    return { version: "native" };
  }
  // Get public key from Trezor
  async getPublicKey(path = null, display = false) {
    var _a2;
    await this.init();
    const derivePath2 = path || this.derivationPath;
    const fullPath = derivePath2.startsWith("m/") ? derivePath2 : `m/${derivePath2}`;
    try {
      const result = await this.trezorConnect.solanaGetPublicKey({
        path: fullPath,
        showOnTrezor: display
      });
      if (!result.success) {
        throw new Error(((_a2 = result.payload) == null ? void 0 : _a2.error) || "Failed to get public key");
      }
      this.publicKey = result.payload.publicKey;
      return result.payload.publicKey;
    } catch (e) {
      logger.error("Trezor getPublicKey error:", e);
      throw e;
    }
  }
  // Get accounts for a scheme
  async getAccountsForScheme(scheme, startIndex = 0, count = 5) {
    const accounts = [];
    for (let i = startIndex; i < startIndex + count; i++) {
      const path = scheme.getPath(i);
      try {
        const address = await this.getPublicKey(path, false);
        accounts.push({
          index: i,
          path,
          address,
          scheme: scheme.id,
          schemeName: scheme.name,
          label: `Account ${i + 1}`
        });
      } catch (e) {
        logger.warn(`Could not get Trezor account ${i}:`, e);
        break;
      }
    }
    return accounts;
  }
  // Discover accounts from all schemes
  async discoverAccounts(count = 5) {
    const allAccounts = [];
    const seenAddresses = /* @__PURE__ */ new Set();
    for (const scheme of Object.values(DERIVATION_SCHEMES)) {
      try {
        const accounts = await this.getAccountsForScheme(scheme, 0, count);
        for (const account of accounts) {
          if (!seenAddresses.has(account.address)) {
            seenAddresses.add(account.address);
            allAccounts.push(account);
          }
        }
      } catch (e) {
        logger.warn(`Failed to get Trezor accounts for scheme ${scheme.id}:`, e);
      }
    }
    return allAccounts;
  }
  // Sign transaction with Trezor
  async signTransaction(transaction2, path = null) {
    var _a2, _b2;
    await this.init();
    const derivePath2 = path || this.derivationPath;
    const fullPath = derivePath2.startsWith("m/") ? derivePath2 : `m/${derivePath2}`;
    try {
      const txBuffer = buffer.Buffer.isBuffer(transaction2) ? transaction2 : buffer.Buffer.from(transaction2);
      const result = await this.trezorConnect.solanaSignTransaction({
        path: fullPath,
        serializedTx: txBuffer.toString("hex")
      });
      if (!result.success) {
        if (((_a2 = result.payload) == null ? void 0 : _a2.code) === "Failure_ActionCancelled") {
          throw new Error("Transaction rejected by user");
        }
        throw new Error(((_b2 = result.payload) == null ? void 0 : _b2.error) || "Failed to sign transaction");
      }
      return buffer.Buffer.from(result.payload.signature, "hex");
    } catch (e) {
      logger.error("Trezor signTransaction error:", e);
      throw e;
    }
  }
  // Sign message (off-chain) - Note: Trezor may have limited support
  async signMessage(message, path = null) {
    await this.init();
    throw new Error("Message signing is not yet supported on Trezor for Solana");
  }
  // Disconnect
  async disconnect() {
    if (this.trezorConnect) {
      try {
        await this.trezorConnect.dispose();
      } catch (e) {
        logger.warn("Error disposing Trezor Connect:", e);
      }
    }
    this.initialized = false;
    this.state = LEDGER_STATES.DISCONNECTED;
    this.publicKey = null;
  }
  // Get derivation paths (legacy compatibility)
  getDerivationPaths() {
    return [
      { path: "44'/501'/0'/0'", label: "Default (m/44'/501'/0'/0')" },
      { path: "44'/501'/0'", label: "Legacy (m/44'/501'/0')" },
      { path: "44'/501'/1'/0'", label: "Account 2 (m/44'/501'/1'/0')" },
      { path: "44'/501'/2'/0'", label: "Account 3 (m/44'/501'/2'/0')" }
    ];
  }
  setDerivationPath(path) {
    this.derivationPath = path;
  }
  getState() {
    return this.state;
  }
  isReady() {
    return this.state === LEDGER_STATES.READY;
  }
}
const hardwareWallet = new HardwareWalletService();
const trezorWallet = new TrezorWalletService();
function getHardwareWallet(type) {
  if (type === HW_TYPES.TREZOR) {
    return trezorWallet;
  }
  return hardwareWallet;
}
function HardwareWallet({ onComplete, onBack, isFirstWallet = false, existingWallets = [], network = "X1 Testnet", isFullTab = false }) {
  const [step, setStep] = reactExports.useState("select");
  const [deviceType, setDeviceType] = reactExports.useState(null);
  const [connectionType, setConnectionType] = reactExports.useState(CONNECTION_TYPES.USB);
  const [status, setStatus] = reactExports.useState("");
  const [error, setError] = reactExports.useState("");
  const [loading, setLoading] = reactExports.useState(false);
  const [loadingMore, setLoadingMore] = reactExports.useState(false);
  const [accounts, setAccounts] = reactExports.useState([]);
  const [selectedAccounts, setSelectedAccounts] = reactExports.useState([]);
  const [walletName, setWalletName] = reactExports.useState("");
  const [derivationPaths] = reactExports.useState(hardwareWallet.getDerivationPaths());
  const [loadedCount, setLoadedCount] = reactExports.useState(0);
  const [selectedScheme, setSelectedScheme] = reactExports.useState(DERIVATION_SCHEMES.BIP44_STANDARD);
  const [customPath, setCustomPath] = reactExports.useState("");
  const [showCustomPath, setShowCustomPath] = reactExports.useState(false);
  const [balances, setBalances] = reactExports.useState({});
  const [loadingBalances, setLoadingBalances] = reactExports.useState(false);
  const [password, setPassword] = reactExports.useState("");
  const [confirmPassword, setConfirmPassword] = reactExports.useState("");
  const [passwordError, setPasswordError] = reactExports.useState("");
  const [showPassword, setShowPassword] = reactExports.useState(false);
  const getWallet = () => getHardwareWallet(deviceType);
  const existingAddresses = existingWallets.flatMap(
    (w2) => {
      var _a2;
      return ((_a2 = w2.addresses) == null ? void 0 : _a2.map((a) => a.publicKey)) || [];
    }
  );
  const isAlreadyImported = (address) => existingAddresses.includes(address);
  const fetchBalances = async (accountList) => {
    var _a2;
    if (!accountList || accountList.length === 0) return;
    setLoadingBalances(true);
    const networkConfig = NETWORKS[network] || NETWORKS["X1 Testnet"];
    const rpcUrl = networkConfig.rpcUrl;
    try {
      const newBalances = {};
      for (const account of accountList) {
        try {
          const response = await fetch(rpcUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              jsonrpc: "2.0",
              id: 1,
              method: "getBalance",
              params: [account.address]
            })
          });
          const data = await response.json();
          if (((_a2 = data.result) == null ? void 0 : _a2.value) !== void 0) {
            newBalances[account.address] = data.result.value / 1e9;
          }
        } catch (e) {
          logger$1.warn("[HardwareWallet] Failed to fetch balance for", account.address);
        }
      }
      setBalances((prev) => ({ ...prev, ...newBalances }));
    } catch (e) {
      logger$1.error("[HardwareWallet] Failed to fetch balances:", e);
    } finally {
      setLoadingBalances(false);
    }
  };
  const toggleAccountSelection = (account) => {
    if (isAlreadyImported(account.address)) return;
    setSelectedAccounts((prev) => {
      const isSelected = prev.some((a) => a.path === account.path);
      if (isSelected) {
        return prev.filter((a) => a.path !== account.path);
      } else {
        return [...prev, account];
      }
    });
  };
  const formatBalance2 = (balance) => {
    if (balance === void 0 || balance === null) return "...";
    if (balance === 0) return "0";
    if (balance < 1e-4) return "<0.0001";
    return balance.toFixed(4);
  };
  logger$1.log("[HardwareWallet] Rendering with step:", step, "loading:", loading, "deviceType:", deviceType);
  const isSupported = hardwareWallet.isSupported();
  const selectDevice = (type) => {
    setDeviceType(type);
    setError("");
    if (type === HW_TYPES.TREZOR) {
      setConnectionType(CONNECTION_TYPES.USB);
      setStep("connect");
    } else {
      setStep("connection");
    }
  };
  const selectConnectionType = (type) => {
    setConnectionType(type);
    setStep("connect");
  };
  const connectDevice = async () => {
    if (loading) {
      logger$1.log("[HardwareWallet] Already connecting, ignoring...");
      return;
    }
    setLoading(true);
    setError("");
    setStatus(`Connecting to ${deviceType === HW_TYPES.TREZOR ? "Trezor" : "Ledger"}...`);
    logger$1.log("[HardwareWallet] Starting connection... current step:", step, "deviceType:", deviceType);
    try {
      const wallet = getWallet();
      await wallet.connect(connectionType);
      logger$1.log("[HardwareWallet] Device connected, setting step to app");
      setStatus("Device connected!");
      setStep("app");
      logger$1.log("[HardwareWallet] Step updated");
    } catch (err) {
      logger$1.error("[HardwareWallet] Connection failed:", err);
      logger$1.error("[HardwareWallet] Error name:", err == null ? void 0 : err.name);
      logger$1.error("[HardwareWallet] Error message:", err == null ? void 0 : err.message);
      logger$1.error("[HardwareWallet] Error stack:", err == null ? void 0 : err.stack);
      const errorMsg = (err == null ? void 0 : err.message) || (err == null ? void 0 : err.name) || `Failed to connect to device. Make sure ${deviceType === HW_TYPES.TREZOR ? "Trezor" : "Ledger"} is connected and unlocked.`;
      setError(errorMsg);
    } finally {
      setLoading(false);
    }
  };
  const openAppAndSelectScheme = async () => {
    setLoading(true);
    setError("");
    setStatus(deviceType === HW_TYPES.TREZOR ? "Connecting to Trezor..." : "Opening Solana app...");
    try {
      const wallet = getWallet();
      await wallet.openApp();
      setStatus("Ready!");
      setLoading(false);
      setStep("scheme");
    } catch (err) {
      setError(err.message || "Failed to open app");
      setLoading(false);
    }
  };
  const getAccountsForScheme = async () => {
    setLoading(true);
    setError("");
    setStatus("Getting accounts...");
    try {
      const wallet = getWallet();
      const accountList = await wallet.getAccountsForScheme(selectedScheme, 0, 5);
      if (accountList.length === 0) {
        throw new Error(`No accounts found. Make sure ${deviceType === HW_TYPES.TREZOR ? "Trezor is unlocked" : "the Solana app is open on your Ledger"}.`);
      }
      setAccounts(accountList);
      setLoadedCount(accountList.length);
      setSelectedAccounts([]);
      setLoading(false);
      setShowCustomPath(false);
      setStep("account");
      fetchBalances(accountList);
    } catch (err) {
      setError(err.message || "Failed to get accounts");
      setLoading(false);
    }
  };
  const getAccountForCustomPath = async () => {
    if (!customPath.trim()) {
      setError("Please enter a derivation path");
      return;
    }
    setLoading(true);
    setError("");
    setStatus("Getting account...");
    try {
      const wallet = getWallet();
      let path = customPath.trim();
      if (path.startsWith("m/")) {
        path = path.slice(2);
      }
      const publicKey = await wallet.getPublicKey(path, false);
      const account = {
        address: publicKey,
        path,
        label: "Custom Path",
        index: 0
      };
      setAccounts([account]);
      setLoadedCount(1);
      setSelectedAccounts([account]);
      setLoading(false);
      setStep("account");
      fetchBalances([account]);
    } catch (err) {
      setError(err.message || "Failed to get account for custom path");
      setLoading(false);
    }
  };
  const scanAllPaths = async () => {
    setLoading(true);
    setError("");
    setStatus("Scanning all paths...");
    try {
      const wallet = getWallet();
      const allAccounts = [];
      const seenAddresses = /* @__PURE__ */ new Set();
      for (const scheme of Object.values(DERIVATION_SCHEMES)) {
        setStatus(`Scanning ${scheme.name}...`);
        try {
          const schemeAccounts = await wallet.getAccountsForScheme(scheme, 0, 5);
          for (const account of schemeAccounts) {
            if (!seenAddresses.has(account.address)) {
              seenAddresses.add(account.address);
              allAccounts.push({
                ...account,
                label: `${scheme.name} #${account.index}`,
                schemeName: scheme.name
              });
            }
          }
        } catch (e) {
          logger$1.warn(`Failed to scan ${scheme.name}:`, e);
        }
      }
      if (allAccounts.length === 0) {
        throw new Error("No accounts found on any derivation path.");
      }
      setAccounts(allAccounts);
      setLoadedCount(allAccounts.length);
      setSelectedAccount(allAccounts[0]);
      setLoading(false);
      setShowCustomPath(false);
      setStep("account");
    } catch (err) {
      setError(err.message || "Failed to scan paths");
      setLoading(false);
    }
  };
  const loadMoreAccounts = async () => {
    setLoadingMore(true);
    setError("");
    try {
      const wallet = getWallet();
      const newAccounts = await wallet.getAccountsForScheme(selectedScheme, loadedCount, 5);
      if (newAccounts.length > 0) {
        setAccounts([...accounts, ...newAccounts]);
        setLoadedCount(loadedCount + newAccounts.length);
        fetchBalances(newAccounts);
      }
    } catch (err) {
      setError(err.message || "Failed to load more accounts");
    }
    setLoadingMore(false);
  };
  const verifyOnDevice = async () => {
    if (selectedAccounts.length === 0) return;
    const accountToVerify = selectedAccounts[0];
    setLoading(true);
    setStatus(`Please verify address on your ${deviceType === HW_TYPES.TREZOR ? "Trezor" : "Ledger"}...`);
    try {
      const wallet = getWallet();
      await wallet.getPublicKey(accountToVerify.path, true);
      setLoading(false);
      setStatus("Address verified!");
    } catch (err) {
      setError(err.message || "Verification cancelled");
      setLoading(false);
    }
  };
  const handleComplete = () => {
    if (selectedAccounts.length === 0) return;
    if (isFirstWallet) {
      setStep("password");
      return;
    }
    if (selectedAccounts.length === 1) {
      const account = selectedAccounts[0];
      onComplete({
        type: deviceType,
        name: walletName || `${deviceType === "trezor" ? "Trezor" : "Ledger"} ${account.label}`,
        publicKey: account.address,
        derivationPath: account.path,
        derivationScheme: account.scheme || selectedScheme,
        isHardware: true,
        connectionType
      });
    } else {
      const walletsToAdd = selectedAccounts.map((account, idx) => ({
        type: deviceType,
        name: `${deviceType === "trezor" ? "Trezor" : "Ledger"} ${account.label}`,
        publicKey: account.address,
        derivationPath: account.path,
        derivationScheme: account.scheme || selectedScheme,
        isHardware: true,
        connectionType
      }));
      onComplete(walletsToAdd);
    }
  };
  const [submitting, setSubmitting] = reactExports.useState(false);
  const handlePasswordSubmit = async () => {
    if (submitting) return;
    setPasswordError("");
    if (!password || password.length < 8) {
      setPasswordError("Password must be at least 8 characters");
      return;
    }
    if (!/[a-zA-Z]/.test(password)) {
      setPasswordError("Password must contain at least one letter");
      return;
    }
    if (!/[0-9]/.test(password)) {
      setPasswordError("Password must contain at least one number");
      return;
    }
    if (password !== confirmPassword) {
      setPasswordError("Passwords do not match");
      return;
    }
    setSubmitting(true);
    if (selectedAccounts.length === 1) {
      const account = selectedAccounts[0];
      onComplete({
        type: deviceType,
        name: walletName || `${deviceType === "trezor" ? "Trezor" : "Ledger"} ${account.label}`,
        publicKey: account.address,
        derivationPath: account.path,
        derivationScheme: account.scheme || selectedScheme,
        isHardware: true,
        connectionType,
        password
        // Include password for first wallet setup
      });
    } else {
      const walletsToAdd = selectedAccounts.map((account, idx) => ({
        type: deviceType,
        name: `${deviceType === "trezor" ? "Trezor" : "Ledger"} ${account.label}`,
        publicKey: account.address,
        derivationPath: account.path,
        derivationScheme: account.scheme || selectedScheme,
        isHardware: true,
        connectionType,
        password: idx === 0 ? password : null
        // Only first needs password
      }));
      onComplete(walletsToAdd);
    }
  };
  reactExports.useEffect(() => {
    return () => {
      if (step !== "name") {
        hardwareWallet.disconnect();
      }
    };
  }, [step]);
  if (!isSupported) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen hardware-screen no-nav", children: [
      !isFullTab && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: onBack, style: { alignSelf: "flex-start", marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-error-state", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hardware-error-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: "var(--error)", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "8", x2: "12", y2: "12" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "16", x2: "12.01", y2: "16" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Browser Not Supported" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Hardware wallet connection requires WebUSB or WebHID support." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "hardware-hint", children: "Please use Chrome, Edge, or Brave browser." })
      ] })
    ] });
  }
  if (step === "select") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen hardware-screen no-nav", children: [
      !isFullTab && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: onBack, style: { alignSelf: "flex-start", marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Connect Hardware Wallet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "hardware-subtitle", children: "Select your hardware wallet device" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-options", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "hardware-option", onClick: () => selectDevice(HW_TYPES.LEDGER), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hardware-option-icon ledger", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "32", height: "32", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "6", width: "18", height: "12", rx: "2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "6", y: "9", width: "5", height: "6", rx: "1" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14", y1: "10", x2: "18", y2: "10" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14", y1: "12", x2: "18", y2: "12" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14", y1: "14", x2: "17", y2: "14" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-option-text", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-option-title", children: "Ledger" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-option-desc", children: "Nano S, Nano S Plus, Nano X, Flex" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "hardware-option", onClick: () => selectDevice(HW_TYPES.TREZOR), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hardware-option-icon trezor", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "32", height: "32", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2L4 6v6c0 5.5 3.4 10.3 8 12 4.6-1.7 8-6.5 8-12V6l-8-4z" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 8v4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "15", r: "1" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-option-text", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-option-title", children: "Trezor" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-option-desc", children: "Model T, Safe 3, Safe 5" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-info", style: { marginBottom: 24 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "16", x2: "12", y2: "12" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "8", x2: "12.01", y2: "8" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Hardware wallets keep your private keys secure on a physical device." })
      ] })
    ] });
  }
  if (step === "connection") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen hardware-screen no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setStep("select"), style: { alignSelf: "flex-start", marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Connection Method" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "hardware-subtitle", children: "How would you like to connect?" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-options", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "hardware-option", onClick: () => selectConnectionType(CONNECTION_TYPES.USB), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hardware-option-icon usb", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "32", height: "32", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2v6m0 0l3-3m-3 3l-3-3" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 14v4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8 18h8" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18v2h6v-2" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-option-text", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-option-title", children: "USB Cable" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-option-desc", children: "All Ledger devices" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "hardware-option", onClick: () => selectConnectionType(CONNECTION_TYPES.BLUETOOTH), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hardware-option-icon bluetooth", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "32", height: "32", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6.5 6.5l11 11L12 23V1l5.5 5.5-11 11" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-option-text", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-option-title", children: "Bluetooth" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-option-desc", children: "Ledger Nano X only" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
        ] })
      ] })
    ] });
  }
  if (step === "connect") {
    const isTrezor = deviceType === HW_TYPES.TREZOR;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen hardware-screen no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => {
        getWallet().disconnect();
        setStep("select");
      }, style: { alignSelf: "flex-start", marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { children: [
        "Connect Your ",
        isTrezor ? "Trezor" : "Ledger"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-steps", children: [
        isTrezor && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-step", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hardware-step-number", children: "1" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-step-content", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-step-title", children: "Install Trezor Bridge" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "hardware-step-desc", children: [
              "Required for browser connections. ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://suite.trezor.io/web/bridge/", target: "_blank", rel: "noopener noreferrer", style: { color: "var(--accent-color)" }, children: "Download Trezor Bridge" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-step", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hardware-step-number", children: isTrezor ? "2" : "1" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-step-content", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-step-title", children: isTrezor ? "Connect your Trezor" : connectionType === CONNECTION_TYPES.BLUETOOTH ? "Enable Bluetooth" : "Connect your Ledger" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-step-desc", children: isTrezor ? "Use the USB cable to connect your Trezor device" : connectionType === CONNECTION_TYPES.BLUETOOTH ? "On Ledger: Settings  Bluetooth  Enable. On computer: Turn on Bluetooth" : "Use the USB cable to connect your device" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-step", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hardware-step-number", children: isTrezor ? "3" : "2" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-step-content", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "hardware-step-title", children: [
              "Unlock your ",
              isTrezor ? "Trezor" : "Ledger"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-step-desc", children: isTrezor ? "Enter your PIN when prompted" : "Enter your PIN code on the device" })
          ] })
        ] }),
        !isTrezor && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-step", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hardware-step-number", children: "3" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-step-content", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-step-title", children: connectionType === CONNECTION_TYPES.BLUETOOTH ? "Keep Ledger on home screen" : "Open the Solana app" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-step-desc", children: connectionType === CONNECTION_TYPES.BLUETOOTH ? "Stay on the dashboard (don't open any app yet)" : "Navigate to and open the Solana app" })
          ] })
        ] })
      ] }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", style: { whiteSpace: "pre-line" }, children: error }),
      status && loading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-message", children: status }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "btn-primary",
          onClick: connectDevice,
          disabled: loading,
          children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "spinner-small" }),
            "Connecting..."
          ] }) : isTrezor ? "Connect Trezor" : connectionType === CONNECTION_TYPES.BLUETOOTH ? "Connect via Bluetooth" : "Connect Ledger"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-info", style: { marginTop: 16 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "var(--warning)", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "8", x2: "12", y2: "12" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "16", x2: "12.01", y2: "16" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: isTrezor ? "Make sure Trezor Bridge is running and Trezor Suite is closed." : "Make sure your Ledger is unlocked with the Solana app open." })
      ] }),
      !isTrezor && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "hardware-hint", children: [
        "Don't have the Solana app? Install it via ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://www.ledger.com/ledger-live", target: "_blank", rel: "noopener noreferrer", children: "Ledger Live" })
      ] })
    ] });
  }
  if (step === "app") {
    const isTrezor = deviceType === HW_TYPES.TREZOR;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen hardware-screen no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => {
        getWallet().disconnect();
        setStep(isTrezor ? "select" : "connection");
      }, style: { alignSelf: "flex-start", marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-connecting", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hardware-device-icon connected", children: isTrezor ? /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: "var(--success)", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2L4 6v6c0 5.5 3.4 10.3 8 12 4.6-1.7 8-6.5 8-12V6l-8-4z" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "9 12 12 15 16 10" })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: "var(--success)", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "6", width: "20", height: "12", rx: "2" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 10v4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "1" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: isTrezor ? "Trezor Connected" : "Ledger Connected" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: isTrezor ? "Click Continue to select your account" : "Now open the Solana app on your device and click Continue" })
      ] }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: error }),
      status && loading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-message", children: status }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "btn-primary",
          onClick: openAppAndSelectScheme,
          disabled: loading,
          children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "spinner-small" }),
            status || "Loading..."
          ] }) : "Continue"
        }
      )
    ] });
  }
  if (step === "scheme") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen hardware-screen no-nav", style: { justifyContent: "flex-start", paddingTop: 20, paddingBottom: 20 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setStep("app"), style: { alignSelf: "flex-start", marginBottom: 20 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { marginBottom: 6 }, children: "Select Derivation Path" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { margin: "0 0 20px 0", fontSize: 14, color: "var(--text-muted)" }, children: "Choose the path that matches your wallet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: 10, flex: 1 }, children: Object.values(DERIVATION_SCHEMES).map((scheme) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: () => setSelectedScheme(scheme),
          style: {
            border: selectedScheme.id === scheme.id ? "2px solid var(--x1-blue)" : "1px solid var(--border-color)",
            background: selectedScheme.id === scheme.id ? "rgba(0, 122, 255, 0.1)" : "var(--bg-secondary)",
            padding: "16px",
            borderRadius: 12,
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            textAlign: "center",
            gap: 4,
            cursor: "pointer",
            transition: "all 0.15s ease"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 16, fontWeight: 600, color: "var(--text-primary)" }, children: scheme.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 13, color: "var(--text-muted)", fontFamily: "monospace" }, children: scheme.description })
          ]
        },
        scheme.id
      )) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
        display: "flex",
        gap: 10,
        padding: "12px 14px",
        background: "var(--bg-secondary)",
        borderRadius: 10,
        marginTop: 16,
        marginBottom: 16,
        fontSize: 13,
        color: "var(--text-secondary)",
        alignItems: "flex-start"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", style: { flexShrink: 0, marginTop: 1 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "16", x2: "12", y2: "12" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "8", x2: "12.01", y2: "8" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Not sure?" }),
          ` Try "Standard (BIP44)" first. If your accounts don't appear, go back and try another path.`
        ] })
      ] }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", style: { marginBottom: 12 }, children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "btn-primary",
          onClick: getAccountsForScheme,
          disabled: loading,
          style: { padding: "14px", fontSize: 15 },
          children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "spinner-small" }),
            status || "Loading..."
          ] }) : "Continue"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "btn-secondary",
          onClick: scanAllPaths,
          disabled: loading,
          style: { padding: "12px", fontSize: 14, marginTop: 10 },
          children: loading ? "Scanning..." : "Scan All Paths"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: 12, color: "var(--text-muted)", textAlign: "center", marginTop: 8 }, children: `Use "Scan All Paths" if you're not sure which path your wallet uses` })
    ] });
  }
  if (step === "account") {
    const nativeSymbol = (network == null ? void 0 : network.includes("Solana")) ? "SOL" : "XNT";
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen hardware-screen no-nav", style: { display: "flex", flexDirection: "column", paddingTop: 20, paddingBottom: 20 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setStep("scheme"), style: { alignSelf: "flex-start", marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { marginBottom: 6 }, children: "Select Accounts" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { margin: "0 0 8px 0", fontSize: 14, color: "var(--text-muted)" }, children: [
        "Using: ",
        selectedScheme.name
      ] }),
      selectedAccounts.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { margin: "0 0 16px 0", fontSize: 13, color: "var(--x1-blue)" }, children: [
        selectedAccounts.length,
        " account",
        selectedAccounts.length > 1 ? "s" : "",
        " selected"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: 8, marginBottom: 16 }, children: [
        accounts.map((account) => {
          const alreadyImported = isAlreadyImported(account.address);
          const isSelected = selectedAccounts.some((a) => a.path === account.path);
          const balance = balances[account.address];
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              onClick: () => !alreadyImported && toggleAccountSelection(account),
              style: {
                display: "flex",
                alignItems: "center",
                gap: 12,
                padding: "10px 12px",
                background: alreadyImported ? "var(--bg-tertiary)" : isSelected ? "rgba(2, 116, 251, 0.1)" : "var(--bg-secondary)",
                border: isSelected ? "1px solid var(--x1-blue)" : "1px solid var(--border-color)",
                borderRadius: 10,
                cursor: alreadyImported ? "not-allowed" : "pointer",
                opacity: alreadyImported ? 0.5 : 1,
                transition: "all 0.15s ease"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                  width: 32,
                  height: 32,
                  borderRadius: 8,
                  background: "var(--bg-tertiary)",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  flexShrink: 0
                }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "6", width: "20", height: "14", rx: "2" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2 10h20" })
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: 0 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center" }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontWeight: 600, fontSize: 14, color: "var(--text-primary)" }, children: account.label }),
                    alreadyImported && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
                      fontSize: 10,
                      color: "var(--text-muted)",
                      background: "var(--bg-secondary)",
                      padding: "2px 6px",
                      borderRadius: 4
                    }, children: "Already Added" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    marginTop: 2
                  }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: 12, color: "var(--text-muted)", fontFamily: "monospace" }, children: [
                      account.address.slice(0, 6),
                      "...",
                      account.address.slice(-6)
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
                      fontSize: 12,
                      color: balance > 0 ? "var(--success)" : "var(--text-muted)",
                      fontWeight: balance > 0 ? 600 : 400
                    }, children: loadingBalances ? "..." : `${formatBalance2(balance)} ${nativeSymbol}` })
                  ] })
                ] }),
                isSelected && /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) })
              ]
            },
            account.path
          );
        }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: loadMoreAccounts,
            disabled: loadingMore,
            style: {
              padding: "8px",
              background: "transparent",
              border: "1px dashed var(--border-color)",
              borderRadius: 8,
              color: "var(--text-muted)",
              fontSize: 13,
              cursor: loadingMore ? "not-allowed" : "pointer"
            },
            children: loadingMore ? "Loading..." : "+ Load More Accounts"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 8 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => setShowCustomPath(!showCustomPath),
              style: {
                padding: "8px",
                background: "transparent",
                border: "none",
                color: "var(--text-muted)",
                fontSize: 13,
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                gap: 6,
                width: "100%",
                justifyContent: "center"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11", cy: "11", r: "8" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "21", y1: "21", x2: "16.65", y2: "16.65" })
                ] }),
                "Can't find your wallet? Try custom path"
              ]
            }
          ),
          showCustomPath && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
            marginTop: 8,
            padding: 12,
            background: "var(--bg-secondary)",
            borderRadius: 8,
            border: "1px solid var(--border-color)"
          }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontSize: 12, color: "var(--text-muted)", marginBottom: 6, display: "block" }, children: "Custom Derivation Path" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: customPath,
                onChange: (e) => setCustomPath(e.target.value),
                placeholder: "44'/501'/0'/0'",
                style: {
                  width: "100%",
                  padding: "10px 12px",
                  background: "var(--bg-tertiary)",
                  border: "1px solid var(--border-color)",
                  borderRadius: 6,
                  color: "var(--text-primary)",
                  fontFamily: "monospace",
                  fontSize: 13,
                  marginBottom: 8,
                  boxSizing: "border-box"
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "var(--text-muted)", marginBottom: 8 }, children: "Common paths: 44'/501'/0' (Standard), 44'/501'/0'/0' (Phantom)" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: getAccountForCustomPath,
                disabled: loading || !customPath.trim(),
                style: {
                  width: "100%",
                  padding: "10px",
                  background: "var(--accent-color)",
                  border: "none",
                  borderRadius: 6,
                  color: "white",
                  fontSize: 13,
                  cursor: loading || !customPath.trim() ? "not-allowed" : "pointer",
                  opacity: loading || !customPath.trim() ? 0.6 : 1
                },
                children: loading ? "Loading..." : "Load Custom Path"
              }
            )
          ] })
        ] })
      ] }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", style: { marginTop: 12 }, children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-buttons-row", style: { display: "flex", gap: 12, marginTop: "auto", paddingTop: 16 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn-secondary",
            onClick: verifyOnDevice,
            disabled: loading || selectedAccounts.length === 0,
            style: { flex: "1 1 0", minWidth: 0, height: 48, fontSize: 14 },
            children: loading ? "Verifying..." : "Verify on Device"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn-primary",
            onClick: () => selectedAccounts.length === 1 ? setStep("name") : handleComplete(),
            disabled: selectedAccounts.length === 0,
            style: { flex: "1 1 0", minWidth: 0, height: 48, fontSize: 14 },
            children: selectedAccounts.length > 1 ? `Import ${selectedAccounts.length} Wallets` : "Continue"
          }
        )
      ] })
    ] });
  }
  if (step === "name") {
    const selectedAccount = selectedAccounts[0];
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen hardware-screen no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setStep("account"), style: { alignSelf: "flex-start", marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hardware-success-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: "var(--success)", strokeWidth: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M22 11.08V12a10 10 0 1 1-5.93-9.14" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "22 4 12 14.01 9 11.01" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Name Your Wallet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "hardware-subtitle", children: "Give your hardware wallet a name" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "form-group", style: { marginTop: 24 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          className: "form-input",
          value: walletName,
          onChange: (e) => setWalletName(e.target.value),
          placeholder: `${deviceType === "trezor" ? "Trezor" : "Ledger"} ${(selectedAccount == null ? void 0 : selectedAccount.label) || "Wallet"}`,
          autoFocus: true
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-summary", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-summary-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-summary-label", children: "Device" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-summary-value", children: deviceType === "trezor" ? "Trezor" : "Ledger" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-summary-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-summary-label", children: "Connection" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-summary-value", children: connectionType === CONNECTION_TYPES.BLUETOOTH ? "Bluetooth" : "USB" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-summary-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-summary-label", children: "Path Type" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-summary-value", children: selectedScheme.name })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-summary-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-summary-label", children: "Account" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-summary-value", children: selectedAccount == null ? void 0 : selectedAccount.label })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-summary-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-summary-label", children: "Derivation" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "hardware-summary-value", style: { fontFamily: "monospace", fontSize: 11 }, children: [
            "m/",
            selectedAccount == null ? void 0 : selectedAccount.path
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-summary-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hardware-summary-label", children: "Address" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "hardware-summary-value address", children: [
            selectedAccount == null ? void 0 : selectedAccount.address.slice(0, 12),
            "...",
            selectedAccount == null ? void 0 : selectedAccount.address.slice(-8)
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "warning-box", style: { marginTop: 16 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "var(--warning)", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Blind Signing Warning:" }),
          " Some transactions may not display full details on your ",
          deviceType === "trezor" ? "Trezor" : "Ledger",
          " screen. Always verify transaction details in the wallet before confirming on your device. If you can't verify the full transaction on your device, consider enabling blind signing only for trusted dApps."
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: handleComplete, style: { marginTop: 24, marginBottom: 24 }, children: isFirstWallet ? "Continue" : "Import Wallet" })
    ] });
  }
  if (step === "password") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen hardware-screen no-nav", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setStep(selectedAccounts.length === 1 ? "name" : "account"), style: { alignSelf: "flex-start", marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hardware-success-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "11", width: "18", height: "11", rx: "2", ry: "2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Set App Password" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "hardware-subtitle", children: "Create a password to secure your wallet app" }),
      passwordError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", style: { marginTop: 16 }, children: passwordError }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", style: { marginTop: 24 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "form-label", children: "Password" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: showPassword ? "text" : "password",
              className: "form-input",
              value: password,
              onChange: (e) => setPassword(e.target.value),
              placeholder: "Enter password (min 8 characters)",
              autoFocus: true
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: () => setShowPassword(!showPassword),
              style: {
                position: "absolute",
                right: 12,
                top: "50%",
                transform: "translateY(-50%)",
                background: "none",
                border: "none",
                cursor: "pointer",
                padding: 4
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-secondary)", strokeWidth: "2", children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
              ] }) })
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", style: { marginTop: 16 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "form-label", children: "Confirm Password" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: showPassword ? "text" : "password",
              className: "form-input",
              value: confirmPassword,
              onChange: (e) => setConfirmPassword(e.target.value),
              placeholder: "Confirm password",
              onKeyDown: (e) => e.key === "Enter" && handlePasswordSubmit()
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: () => setShowPassword(!showPassword),
              style: {
                position: "absolute",
                right: 12,
                top: "50%",
                transform: "translateY(-50%)",
                background: "none",
                border: "none",
                cursor: "pointer",
                padding: 4
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-secondary)", strokeWidth: "2", children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
              ] }) })
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "var(--text-muted)", marginTop: 16 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Password requirements:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { style: { marginLeft: 16, marginTop: 8 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { style: { color: password.length >= 8 ? "var(--success)" : "var(--text-muted)" }, children: "At least 8 characters" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { style: { color: /[a-zA-Z]/.test(password) ? "var(--success)" : "var(--text-muted)" }, children: "At least one letter" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { style: { color: /[0-9]/.test(password) ? "var(--success)" : "var(--text-muted)" }, children: "At least one number" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "warning-box", style: { marginTop: 24 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "var(--warning)", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "This password protects the wallet app. Your ",
          deviceType === "trezor" ? "Trezor" : "Ledger",
          " device remains your primary security - transactions still require physical confirmation on your device."
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "btn-primary",
          onClick: handlePasswordSubmit,
          style: { marginTop: 24, marginBottom: 24 },
          disabled: !password || !confirmPassword || submitting,
          children: submitting ? "Setting up..." : "Complete Setup"
        }
      )
    ] });
  }
  return null;
}
const X1_LOGO_URL$1 = "/icons/48-x1.png";
function X1Logo({ size = 40, className = "" }) {
  const [error, setError] = reactExports.useState(false);
  const logoSize = Math.round(size * 0.8);
  if (error) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: size,
        height: size,
        viewBox: "0 0 100 100",
        className,
        style: { borderRadius: "50%", display: "block", flexShrink: 0 },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "50", cy: "50", r: "50", fill: "#000" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "text",
            {
              x: "50",
              y: "64",
              textAnchor: "middle",
              fill: "#0274fb",
              fontSize: "40",
              fontWeight: "bold",
              fontFamily: "Arial, sans-serif",
              children: "X1"
            }
          )
        ]
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `x1-logo-container ${className}`,
      style: {
        width: size,
        height: size,
        minWidth: size,
        minHeight: size,
        borderRadius: "50%",
        background: "#000",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        flexShrink: 0,
        overflow: "hidden"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: X1_LOGO_URL$1,
          alt: "X1",
          style: {
            width: logoSize,
            height: logoSize,
            objectFit: "contain",
            display: "block"
          },
          onError: () => setError(true)
        }
      )
    }
  );
}
const imageCache$1 = /* @__PURE__ */ new Map();
const pendingFetches = /* @__PURE__ */ new Map();
const lastFetchTime = /* @__PURE__ */ new Map();
const FETCH_DEBOUNCE_MS = 2e3;
function getFetchCacheKey(walletAddress, network) {
  return `${walletAddress}:${network}`;
}
const TOKEN_CACHE_KEY = "x1wallet_token_cache";
const BALANCE_CACHE_KEY = "x1wallet_balance_cache";
function getCachedBalance(walletAddress, network) {
  try {
    const cache = JSON.parse(localStorage.getItem(BALANCE_CACHE_KEY) || "{}");
    const key = `${walletAddress}:${network}`;
    const entry = cache[key];
    if (entry && entry.balance !== void 0) {
      return entry.balance;
    }
  } catch (e) {
  }
  return null;
}
function setCachedBalance(walletAddress, network, balance) {
  try {
    const cache = JSON.parse(localStorage.getItem(BALANCE_CACHE_KEY) || "{}");
    const key = `${walletAddress}:${network}`;
    cache[key] = { balance, timestamp: Date.now() };
    const keys = Object.keys(cache);
    if (keys.length > 10) {
      const oldest = keys.sort((a, b) => {
        var _a2, _b2;
        return (((_a2 = cache[a]) == null ? void 0 : _a2.timestamp) || 0) - (((_b2 = cache[b]) == null ? void 0 : _b2.timestamp) || 0);
      })[0];
      delete cache[oldest];
    }
    localStorage.setItem(BALANCE_CACHE_KEY, JSON.stringify(cache));
  } catch (e) {
  }
}
function getTokenCacheKey(walletAddress, network) {
  return `${walletAddress}:${network}`;
}
const sessionTokenCache = /* @__PURE__ */ new Map();
function getCachedTokens(walletAddress, network) {
  try {
    const key = getTokenCacheKey(walletAddress, network);
    if (sessionTokenCache.has(key)) {
      const entry2 = sessionTokenCache.get(key);
      logger$1.log("[TokenCache] Memory hit:", entry2.tokens.length, "tokens");
      return entry2.tokens;
    }
    const cache = JSON.parse(localStorage.getItem(TOKEN_CACHE_KEY) || "{}");
    const entry = cache[key];
    if (entry && entry.tokens && entry.timestamp) {
      sessionTokenCache.set(key, entry);
      logger$1.log("[TokenCache] LocalStorage hit:", entry.tokens.length, "tokens");
      return entry.tokens;
    }
  } catch (e) {
    logger$1.warn("[TokenCache] Error reading cache:", e);
  }
  return null;
}
function setCachedTokens(walletAddress, network, tokens2) {
  try {
    const key = getTokenCacheKey(walletAddress, network);
    const entry = { tokens: tokens2, timestamp: Date.now() };
    sessionTokenCache.set(key, entry);
    const cache = JSON.parse(localStorage.getItem(TOKEN_CACHE_KEY) || "{}");
    cache[key] = entry;
    const keys = Object.keys(cache);
    if (keys.length > 10) {
      const oldest = keys.sort((a, b) => {
        var _a2, _b2;
        return (((_a2 = cache[a]) == null ? void 0 : _a2.timestamp) || 0) - (((_b2 = cache[b]) == null ? void 0 : _b2.timestamp) || 0);
      })[0];
      delete cache[oldest];
    }
    localStorage.setItem(TOKEN_CACHE_KEY, JSON.stringify(cache));
    logger$1.log("[TokenCache] Saved", tokens2.length, "tokens for", key);
  } catch (e) {
    logger$1.warn("[TokenCache] Error saving cache:", e);
  }
}
const XLP_ICON_PATH = "/icons/48-xlp.png";
function preloadImage$1(url) {
  if (!url || imageCache$1.has(url)) return;
  const img = new Image();
  img.src = url;
  imageCache$1.set(url, img);
}
preloadImage$1(XLP_ICON_PATH);
function preloadTokenImages(tokens2) {
  if (!tokens2) return;
  tokens2.forEach((token) => {
    const tokenName = (token.name || "").toLowerCase();
    const tokenSymbol = (token.symbol || "").toUpperCase();
    const isLP = token.isLPToken || tokenSymbol === "XLP" || tokenSymbol === "SLP" || tokenSymbol.includes("XLP") || tokenSymbol.includes("SLP") || tokenName.includes("xlp") || tokenName.includes(" lp") || tokenName.includes("lp token") || tokenName.includes("/") || tokenName.includes("xdex") && tokenName.includes("lp");
    if (isLP) {
      preloadImage$1(XLP_ICON_PATH);
    } else if (token.logoURI) {
      preloadImage$1(token.logoURI);
    }
  });
}
async function fetchRpcWithRetry(rpcUrl, body, maxRetries = 5) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(rpcUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: typeof body === "string" ? body : JSON.stringify(body)
      });
      if (response.status === 429) {
        const baseDelay = 1e3 * Math.pow(2, attempt - 1);
        const jitter = Math.random() * 500;
        const delay = Math.min(baseDelay + jitter, 8e3);
        logger$1.warn(`[RPC] Rate limited (429), waiting ${Math.round(delay)}ms (attempt ${attempt}/${maxRetries})`);
        await new Promise((r2) => setTimeout(r2, delay));
        continue;
      }
      return response;
    } catch (err) {
      if (attempt === maxRetries) throw err;
      await new Promise((r2) => setTimeout(r2, 1e3));
    }
  }
  throw new Error("RPC request failed after max retries");
}
const ACTIVITY_CACHE_KEY = "x1wallet_activity_cache";
function getCachedActivity(walletAddress, network) {
  try {
    const cache = JSON.parse(localStorage.getItem(ACTIVITY_CACHE_KEY) || "{}");
    const key = `${walletAddress}:${network}`;
    const entry = cache[key];
    if (entry && entry.transactions) {
      logger$1.log("[ActivityCache] Found cached activity for", key, "- count:", entry.transactions.length);
      return entry.transactions;
    }
  } catch (e) {
    logger$1.warn("[ActivityCache] Error reading cache:", e);
  }
  return null;
}
function setCachedActivity(walletAddress, network, transactions) {
  try {
    const cache = JSON.parse(localStorage.getItem(ACTIVITY_CACHE_KEY) || "{}");
    const key = `${walletAddress}:${network}`;
    cache[key] = {
      transactions: transactions.slice(0, 50),
      // Keep only last 50 to prevent bloat
      timestamp: Date.now()
    };
    const keys = Object.keys(cache);
    if (keys.length > 10) {
      const oldest = keys.sort((a, b) => {
        var _a2, _b2;
        return (((_a2 = cache[a]) == null ? void 0 : _a2.timestamp) || 0) - (((_b2 = cache[b]) == null ? void 0 : _b2.timestamp) || 0);
      })[0];
      delete cache[oldest];
    }
    localStorage.setItem(ACTIVITY_CACHE_KEY, JSON.stringify(cache));
    logger$1.log("[ActivityCache] Saved", transactions.length, "transactions for", key);
  } catch (e) {
    logger$1.warn("[ActivityCache] Error saving cache:", e);
  }
}
function ActivityList({ walletAddress, network, networkConfig, refreshKey }) {
  const [transactions, setTransactions] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [isRefreshing, setIsRefreshing] = reactExports.useState(false);
  const [sortOrder, setSortOrder] = reactExports.useState("desc");
  reactExports.useEffect(() => {
    if (walletAddress && network) {
      const cached = getCachedActivity(walletAddress, network);
      if (cached && cached.length > 0) {
        logger$1.log("[ActivityList] Loading cached activity:", cached.length);
        setTransactions(cached);
        setLoading(false);
      }
    }
  }, [walletAddress, network]);
  const normalizeTimestamp = (tx) => {
    let ts = tx.rawTimestamp || tx.timestamp || 0;
    if (ts > 0 && ts < 4102444800) {
      ts = ts * 1e3;
    }
    return ts;
  };
  const fetchTransactions$1 = async (showLoading = true) => {
    if (!walletAddress) return;
    if (showLoading && transactions.length === 0) setLoading(true);
    setIsRefreshing(true);
    try {
      registerWallet(walletAddress, network).catch(() => {
      });
      const localHistory = getTransactionHistory(walletAddress, network, "desc");
      const [apiTxs, blockchainTxs] = await Promise.all([
        fetchTransactions(walletAddress, network).catch((e) => {
          return [];
        }),
        (networkConfig == null ? void 0 : networkConfig.rpcUrl) ? fetchBlockchainTransactions(networkConfig.rpcUrl, walletAddress, 20, network).catch((e) => {
          return [];
        }) : Promise.resolve([])
      ]);
      const allTxs = [];
      const seen2 = /* @__PURE__ */ new Set();
      const localTypeMap = /* @__PURE__ */ new Map();
      const preserveTypes = ["stake", "unstake", "wrap", "unwrap"];
      for (const tx of localHistory) {
        if (tx.signature && preserveTypes.includes(tx.type)) {
          localTypeMap.set(tx.signature, {
            type: tx.type,
            description: tx.description,
            amount: tx.amount,
            symbol: tx.symbol,
            toAmount: tx.toAmount,
            toSymbol: tx.toSymbol
          });
        }
      }
      for (const tx of blockchainTxs) {
        if (tx.signature && !seen2.has(tx.signature)) {
          seen2.add(tx.signature);
          const isX1Network2 = network == null ? void 0 : network.startsWith("X1");
          let txSymbol = tx.symbol || tx.token;
          if (isX1Network2 && txSymbol === "SOL") {
            txSymbol = "XNT";
          }
          const localData = localTypeMap.get(tx.signature);
          const formatted = formatTransaction({
            ...tx,
            // Preserve local type if it's a stake/unstake/wrap/unwrap
            ...localData ? localData : {},
            symbol: (localData == null ? void 0 : localData.symbol) || txSymbol || (networkConfig == null ? void 0 : networkConfig.symbol) || (isX1Network2 ? "XNT" : "SOL"),
            network
          });
          allTxs.push({
            ...formatted,
            _sortTs: normalizeTimestamp(formatted)
          });
        }
      }
      for (const tx of apiTxs) {
        if (tx.signature && !seen2.has(tx.signature)) {
          seen2.add(tx.signature);
          const formatted = formatTransaction(tx);
          allTxs.push({
            ...formatted,
            _sortTs: normalizeTimestamp(formatted)
          });
        }
      }
      for (const tx of localHistory) {
        if (tx.signature && !seen2.has(tx.signature)) {
          seen2.add(tx.signature);
          const formatted = formatTransaction(tx);
          allTxs.push({
            ...formatted,
            _sortTs: normalizeTimestamp(formatted)
          });
        } else if (!tx.signature) {
          const formatted = formatTransaction(tx);
          allTxs.push({
            ...formatted,
            _sortTs: normalizeTimestamp(formatted)
          });
        }
      }
      allTxs.sort((a, b) => {
        return sortOrder === "asc" ? a._sortTs - b._sortTs : b._sortTs - a._sortTs;
      });
      setTransactions(allTxs);
      setCachedActivity(walletAddress, network, allTxs);
    } catch (e) {
      logger$1.error("Failed to fetch transactions:", e);
    } finally {
      setLoading(false);
      setIsRefreshing(false);
    }
  };
  reactExports.useEffect(() => {
    fetchTransactions$1();
  }, [walletAddress, network, networkConfig == null ? void 0 : networkConfig.rpcUrl, refreshKey, sortOrder]);
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "activity-loading", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }) });
  }
  const openExplorer = (signature) => {
    const url = getTxExplorerUrl(network, signature);
    window.open(url, "_blank");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "activity-list", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "activity-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Transaction History" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "activity-header-buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            className: "sort-toggle-btn",
            onClick: () => setSortOrder((prev) => prev === "desc" ? "asc" : "desc"),
            title: sortOrder === "desc" ? "Showing newest first" : "Showing oldest first",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "10", height: "10", viewBox: "0 0 10 10", fill: "none", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", children: sortOrder === "desc" ? /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 1v8M1 5l4 4 4-4" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 9V1M1 5l4-4 4 4" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: sortOrder === "desc" ? "Newest" : "Oldest" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `activity-refresh-btn ${isRefreshing ? "spinning" : ""}`,
            onClick: () => fetchTransactions$1(false),
            disabled: isRefreshing,
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M23 4v6h-6M1 20v-6h6" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15" })
            ] })
          }
        )
      ] })
    ] }),
    transactions.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "1.5", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "22 12 18 12 15 21 9 3 6 12 2 12" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No transactions yet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "empty-state-sub", children: "Your transaction history will appear here" })
    ] }) : transactions.map((tx, i) => {
      const isFailed = tx.status === "failed";
      const isSwap = tx.type === "swap" || tx.type === "wrap" || tx.type === "unwrap" || tx.isSwap;
      const isStake = tx.type === "stake";
      const isUnstake = tx.type === "unstake";
      const isReward = tx.type === "reward" || tx.isReward;
      const isDapp = tx.type === "dapp" || tx.isDappInteraction;
      let isSend;
      if (isDapp) {
        isSend = tx.from === walletAddress;
      } else if (tx.type === "send" || tx.type === "sent") {
        isSend = tx.from === walletAddress || tx.walletAddress === walletAddress && tx.to !== walletAddress;
      } else if (tx.type === "receive" || tx.type === "received" || isReward) {
        isSend = false;
      } else if (tx.from && tx.to) {
        isSend = tx.from === walletAddress && tx.to !== walletAddress;
      } else {
        isSend = tx.type === "send" || tx.type === "sent";
      }
      const iconType = isFailed ? "failed" : isDapp ? "dapp" : isStake ? "stake" : isUnstake ? "unstake" : isReward ? "reward" : isSwap ? "swap" : isSend ? "send" : "receive";
      const getTitle = () => {
        if (isDapp) return "dApp Interaction";
        if (isReward) return `Staking Reward`;
        if (isStake) return `Staked ${tx.symbol || "XNT"}`;
        if (isUnstake) return `Unstaked ${tx.symbol || "XNT"}`;
        if (isSwap) {
          if (tx.type === "wrap") return `Wrapped ${tx.symbol || "XNT"}`;
          if (tx.type === "unwrap") return `Unwrapped ${tx.symbol || "wXNT"}`;
          return `Swapped ${tx.symbol || tx.token}`;
        }
        if (isSend) return `Sent ${tx.token || tx.symbol}`;
        return `Received ${tx.token || tx.symbol}`;
      };
      const getSubtitle = () => {
        var _a2, _b2;
        if (isDapp) {
          if (tx.dappProgram) {
            return `Program: ${tx.dappProgram.slice(0, 4)}...${tx.dappProgram.slice(-4)}`;
          }
          return isSend ? "Outgoing" : "Incoming";
        }
        if (isReward) {
          return "Net gain from staking";
        }
        if (isStake) {
          const match = (_a2 = tx.description) == null ? void 0 : _a2.match(/([\d.]+)\s*pXNT/);
          return match ? ` ${match[1]} pXNT` : " pXNT";
        }
        if (isUnstake) {
          const match = (_b2 = tx.description) == null ? void 0 : _b2.match(/([\d.]+)\s*XNT/);
          return match ? ` ${match[1]} XNT` : " XNT";
        }
        if (isSwap) return ` ${tx.toSymbol || tx.toToken || "Token"}`;
        if (isSend) return `To: ${tx.shortTo || (tx.to ? tx.to.slice(0, 4) + "..." + tx.to.slice(-4) : "...")}`;
        return `From: ${tx.shortFrom || (tx.from ? tx.from.slice(0, 4) + "..." + tx.from.slice(-4) : "...")}`;
      };
      const getAmountDisplay = () => {
        const formatAmount = (num) => {
          if (typeof num !== "number") return num || "0";
          if (num >= 1) return parseFloat(num.toFixed(2)).toString();
          return parseFloat(num.toFixed(6)).toString();
        };
        const amount = formatAmount(tx.amount);
        const symbol = tx.symbol || tx.token || ((currentNetwork == null ? void 0 : currentNetwork.includes("Solana")) ? "SOL" : "XNT");
        if (isDapp) {
          return isSend ? `-${amount} ${symbol}` : `+${amount} ${symbol}`;
        }
        if (isReward) return `+${amount} ${symbol}`;
        if (isStake) return `${amount} ${tx.symbol || "XNT"}`;
        if (isUnstake) return `+${amount} ${tx.symbol || "XNT"}`;
        if (isSwap) {
          if (tx.toAmount && tx.toSymbol) {
            const toAmount = formatAmount(tx.toAmount);
            return `${amount} ${symbol}  ${toAmount} ${tx.toSymbol}`;
          }
          return `${amount} ${symbol}`;
        }
        if (isSend) return `-${amount} ${symbol}`;
        return `+${amount} ${symbol}`;
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "activity-item",
          onClick: () => tx.signature && openExplorer(tx.signature),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `activity-icon ${iconType}`, children: isFailed ? (
              /* Failed - red X */
              /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2.5", strokeLinecap: "round", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
              ] })
            ) : isDapp ? (
              /* dApp - grid/app icon */
              /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "7", height: "7", rx: "1" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "14", y: "3", width: "7", height: "7", rx: "1" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "14", width: "7", height: "7", rx: "1" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "14", y: "14", width: "7", height: "7", rx: "1" })
              ] })
            ) : isReward ? (
              /* Reward - star/gift icon */
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2" }) })
            ) : isStake || isUnstake ? (
              /* Stake/Unstake - layers icon */
              /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2L2 7l10 5 10-5-10-5z" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2 17l10 5 10-5" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2 12l10 5 10-5" })
              ] })
            ) : isSwap ? (
              /* Swap arrows */
              /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17 2l4 4-4 4" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3 11V9a4 4 0 0 1 4-4h14" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 22l-4-4 4-4" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 13v2a4 4 0 0 1-4 4H3" })
              ] })
            ) : isSend ? (
              /* Send - arrow up */
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2.5", strokeLinecap: "round", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 19V5M5 12l7-7 7 7" }) })
            ) : (
              /* Receive - arrow down */
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2.5", strokeLinecap: "round", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 5v14M5 12l7 7 7-7" }) })
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "activity-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "activity-title", children: getTitle() }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "activity-subtitle", children: getSubtitle() })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "activity-amount-col", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `activity-amount ${iconType}`, children: getAmountDisplay() }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "activity-date", children: tx.dateStr || tx.timestamp })
            ] })
          ]
        },
        tx.signature || tx.id || i
      );
    })
  ] });
}
function NFTsTab({ wallet, networkConfig }) {
  var _a2, _b2, _c, _d;
  const [nfts, setNfts] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [error, setError] = reactExports.useState("");
  const [selectedNft, setSelectedNft] = reactExports.useState(null);
  const [sendMode, setSendMode] = reactExports.useState(false);
  const [recipient, setRecipient] = reactExports.useState("");
  const [sending, setSending] = reactExports.useState(false);
  const [sendError, setSendError] = reactExports.useState("");
  const [sendSuccess, setSendSuccess] = reactExports.useState(false);
  const [txHash, setTxHash] = reactExports.useState("");
  const [showHidden, setShowHidden] = reactExports.useState(false);
  const [hiddenNfts, setHiddenNfts] = reactExports.useState(() => {
    try {
      return JSON.parse(localStorage.getItem("x1wallet_hidden_nfts") || "[]");
    } catch {
      return [];
    }
  });
  const walletAddress = ((_a2 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _a2.publicKey) || (wallet == null ? void 0 : wallet.publicKey);
  const privateKey = (_b2 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _b2.privateKey;
  const network = wallet == null ? void 0 : wallet.network;
  const rpcUrl = networkConfig == null ? void 0 : networkConfig.rpcUrl;
  const toggleHideNft = (mint) => {
    setHiddenNfts((prev) => {
      const newHidden = prev.includes(mint) ? prev.filter((m2) => m2 !== mint) : [...prev, mint];
      localStorage.setItem("x1wallet_hidden_nfts", JSON.stringify(newHidden));
      return newHidden;
    });
    setSelectedNft(null);
  };
  const visibleNfts = showHidden ? nfts : nfts.filter((nft) => !hiddenNfts.includes(nft.mint));
  const hiddenCount = nfts.filter((nft) => hiddenNfts.includes(nft.mint)).length;
  const handleSendNft = async () => {
    var _a3, _b3;
    if (!recipient || !selectedNft) return;
    setSending(true);
    setSendError("");
    try {
      if (recipient.length < 32 || recipient.length > 44) {
        throw new Error("Invalid recipient address");
      }
      const blockhashResponse = await fetchRpcWithRetry(rpcUrl, {
        jsonrpc: "2.0",
        id: 1,
        method: "getLatestBlockhash",
        params: [{ commitment: "finalized" }]
      });
      const blockhashData = await blockhashResponse.json();
      if (blockhashData.error) throw new Error(blockhashData.error.message);
      const blockhash = (_b3 = (_a3 = blockhashData.result) == null ? void 0 : _a3.value) == null ? void 0 : _b3.blockhash;
      if (!blockhash) throw new Error("Failed to get blockhash");
      const programId = selectedNft.isToken2022 ? "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb" : "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
      if (selectedNft.isCompressed || !selectedNft.address) {
        const proofResponse = await fetchRpcWithRetry(rpcUrl, {
          jsonrpc: "2.0",
          id: 1,
          method: "getAssetProof",
          params: { id: selectedNft.mint }
        });
        const proofData = await proofResponse.json();
        if (proofData.error) {
          throw new Error("Failed to get asset proof: " + proofData.error.message);
        }
        const proof = proofData.result;
        if (!proof || !proof.proof) {
          throw new Error("This NFT cannot be transferred. It may not be a valid compressed NFT.");
        }
        const assetResponse = await fetchRpcWithRetry(rpcUrl, {
          jsonrpc: "2.0",
          id: 1,
          method: "getAsset",
          params: { id: selectedNft.mint }
        });
        const assetData = await assetResponse.json();
        if (assetData.error || !assetData.result) {
          throw new Error("Failed to get asset details");
        }
        const asset = assetData.result;
        const { createCompressedNftTransfer: createCompressedNftTransfer2 } = await __vitePreload(async () => {
          const { createCompressedNftTransfer: createCompressedNftTransfer3 } = await Promise.resolve().then(() => transaction);
          return { createCompressedNftTransfer: createCompressedNftTransfer3 };
        }, true ? void 0 : void 0);
        const tx2 = await createCompressedNftTransfer2({
          assetId: selectedNft.mint,
          owner: walletAddress,
          newOwner: recipient.trim(),
          proof,
          asset,
          recentBlockhash: blockhash,
          privateKey
        });
        const sendResponse2 = await fetchRpcWithRetry(rpcUrl, {
          jsonrpc: "2.0",
          id: 1,
          method: "sendTransaction",
          params: [tx2, { encoding: "base64", preflightCommitment: "confirmed" }]
        });
        const sendData2 = await sendResponse2.json();
        if (sendData2.error) throw new Error(sendData2.error.message);
        setTxHash(sendData2.result);
        setSendSuccess(true);
        setNfts((prev) => prev.filter((n2) => n2.mint !== selectedNft.mint));
        return;
      }
      let fromTokenAccount = selectedNft.address;
      if (!fromTokenAccount) {
        const { findExistingATA: findExistingATA2 } = await __vitePreload(async () => {
          const { findExistingATA: findExistingATA3 } = await Promise.resolve().then(() => transaction);
          return { findExistingATA: findExistingATA3 };
        }, true ? void 0 : void 0);
        fromTokenAccount = await findExistingATA2(rpcUrl, walletAddress, selectedNft.mint, programId);
        if (!fromTokenAccount) {
          throw new Error("Could not find your token account for this NFT. This may be a compressed NFT (cNFT) which cannot be transferred with standard methods.");
        }
      }
      const { createTokenTransferTransaction: createTokenTransferTransaction2 } = await __vitePreload(async () => {
        const { createTokenTransferTransaction: createTokenTransferTransaction3 } = await Promise.resolve().then(() => transaction);
        return { createTokenTransferTransaction: createTokenTransferTransaction3 };
      }, true ? void 0 : void 0);
      const tx = await createTokenTransferTransaction2({
        fromPubkey: walletAddress,
        toPubkey: recipient.trim(),
        mint: selectedNft.mint,
        amount: 1,
        decimals: 0,
        fromTokenAccount,
        recentBlockhash: blockhash,
        privateKey,
        programId,
        rpcUrl
      });
      const sendResponse = await fetchRpcWithRetry(rpcUrl, {
        jsonrpc: "2.0",
        id: 1,
        method: "sendTransaction",
        params: [tx, { encoding: "base64", preflightCommitment: "confirmed" }]
      });
      const sendData = await sendResponse.json();
      if (sendData.error) throw new Error(sendData.error.message);
      setTxHash(sendData.result);
      setSendSuccess(true);
      setNfts((prev) => prev.filter((n2) => n2.mint !== selectedNft.mint));
    } catch (err) {
      logger$1.error("[NFT Send] Error:", err);
      setSendError(err.message || "Failed to send NFT");
    } finally {
      setSending(false);
    }
  };
  const resetSendState = () => {
    setSendMode(false);
    setRecipient("");
    setSendError("");
    setSendSuccess(false);
    setTxHash("");
  };
  const IPFS_GATEWAYS = [
    "https://gateway.pinata.cloud/ipfs/",
    "https://cloudflare-ipfs.com/ipfs/",
    "https://ipfs.io/ipfs/",
    "https://nftstorage.link/ipfs/",
    "https://dweb.link/ipfs/"
  ];
  const normalizeIpfsUrl = (url) => {
    if (!url) return null;
    if (url.startsWith("http://") || url.startsWith("https://")) {
      return url;
    }
    if (url.startsWith("ipfs://")) {
      const cid = url.replace("ipfs://", "");
      return `${IPFS_GATEWAYS[0]}${cid}`;
    }
    if (url.startsWith("/ipfs/")) {
      return `${IPFS_GATEWAYS[0]}${url.slice(6)}`;
    }
    return url;
  };
  const nftMetadataCache = reactExports.useRef(/* @__PURE__ */ new Map());
  const fetchMetadata = async (uri) => {
    if (nftMetadataCache.current.has(uri)) {
      return nftMetadataCache.current.get(uri);
    }
    try {
      let fetchUrl = normalizeIpfsUrl(uri);
      const response = await fetch(fetchUrl, {
        headers: { "Accept": "application/json" },
        signal: AbortSignal.timeout(5e3)
        // 5 second timeout
      });
      if (!response.ok) {
        return null;
      }
      const json = await response.json();
      nftMetadataCache.current.set(uri, json);
      return json;
    } catch (err) {
      logger$1.warn("[NFT] Failed to fetch metadata:", uri);
      return null;
    }
  };
  reactExports.useEffect(() => {
    if (!walletAddress || !rpcUrl) {
      setLoading(false);
      return;
    }
    const fetchNFTs = async () => {
      var _a3, _b3, _c2, _d2, _e, _f, _g, _h;
      setLoading(true);
      setError("");
      try {
        const isSolana = network == null ? void 0 : network.includes("Solana");
        const isHelius = rpcUrl == null ? void 0 : rpcUrl.includes("helius");
        if (isSolana && isHelius) {
          try {
            const dasResponse = await fetch(rpcUrl, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                jsonrpc: "2.0",
                id: 1,
                method: "getAssetsByOwner",
                params: {
                  ownerAddress: walletAddress,
                  page: 1,
                  limit: 1e3
                }
              })
            });
            const dasData = await dasResponse.json();
            if (((_a3 = dasData == null ? void 0 : dasData.result) == null ? void 0 : _a3.items) && dasData.result.items.length > 0) {
              const nftItemsFromDAS = dasData.result.items.filter((item) => {
                const iface = item.interface;
                if (iface === "FungibleToken" || iface === "FungibleAsset") return false;
                return true;
              });
              let mintToTokenAccount = /* @__PURE__ */ new Map();
              try {
                const [tokenAccountsResponse, token2022Response2] = await Promise.all([
                  fetchRpcWithRetry(rpcUrl, {
                    jsonrpc: "2.0",
                    id: 1,
                    method: "getTokenAccountsByOwner",
                    params: [
                      walletAddress,
                      { programId: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" },
                      { encoding: "jsonParsed" }
                    ]
                  }),
                  fetchRpcWithRetry(rpcUrl, {
                    jsonrpc: "2.0",
                    id: 2,
                    method: "getTokenAccountsByOwner",
                    params: [
                      walletAddress,
                      { programId: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb" },
                      { encoding: "jsonParsed" }
                    ]
                  })
                ]);
                const [tokenAccountsData, token2022Data] = await Promise.all([
                  tokenAccountsResponse.json(),
                  token2022Response2.json()
                ]);
                const allTokenAccounts = [
                  ...((_b3 = tokenAccountsData == null ? void 0 : tokenAccountsData.result) == null ? void 0 : _b3.value) || [],
                  ...((_c2 = token2022Data == null ? void 0 : token2022Data.result) == null ? void 0 : _c2.value) || []
                ];
                for (const acc of allTokenAccounts) {
                  const info = (_f = (_e = (_d2 = acc.account) == null ? void 0 : _d2.data) == null ? void 0 : _e.parsed) == null ? void 0 : _f.info;
                  if (info == null ? void 0 : info.mint) {
                    mintToTokenAccount.set(info.mint, acc.pubkey);
                  }
                }
              } catch (err) {
                logger$1.warn("[NFT] Failed to fetch token accounts:", err);
              }
              const nftItems = nftItemsFromDAS.map((item) => {
                var _a4, _b4, _c3, _d3, _e2, _f2, _g2, _h2, _i, _j, _k, _l, _m, _n, _o, _p;
                const tokenAccountAddress = mintToTokenAccount.get(item.id);
                const isCompressed = ((_a4 = item.compression) == null ? void 0 : _a4.compressed) === true;
                return {
                  mint: item.id,
                  address: tokenAccountAddress || null,
                  name: ((_c3 = (_b4 = item.content) == null ? void 0 : _b4.metadata) == null ? void 0 : _c3.name) || `NFT ${(_d3 = item.id) == null ? void 0 : _d3.slice(0, 8)}...`,
                  symbol: ((_f2 = (_e2 = item.content) == null ? void 0 : _e2.metadata) == null ? void 0 : _f2.symbol) || "",
                  image: ((_h2 = (_g2 = item.content) == null ? void 0 : _g2.links) == null ? void 0 : _h2.image) || ((_k = (_j = (_i = item.content) == null ? void 0 : _i.files) == null ? void 0 : _j[0]) == null ? void 0 : _k.uri) || ((_l = item.content) == null ? void 0 : _l.json_uri) || null,
                  description: ((_n = (_m = item.content) == null ? void 0 : _m.metadata) == null ? void 0 : _n.description) || "",
                  attributes: ((_p = (_o = item.content) == null ? void 0 : _o.metadata) == null ? void 0 : _p.attributes) || [],
                  isToken2022: item.interface === "ProgrammableNFT",
                  isCompressed,
                  loading: false
                };
              });
              logger$1.log("[NFT] Loaded", nftItems.length, "NFTs via DAS");
              if (nftItems.length > 0) {
                setNfts(nftItems);
                setLoading(false);
                return;
              }
            }
          } catch (dasError) {
            logger$1.error("[NFT] DAS API error:", dasError);
          }
        }
        const [tokenResponse, token2022Response] = await Promise.all([
          fetch(rpcUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              jsonrpc: "2.0",
              id: 1,
              method: "getTokenAccountsByOwner",
              params: [
                walletAddress,
                { programId: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" },
                { encoding: "jsonParsed" }
              ]
            })
          }),
          fetch(rpcUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              jsonrpc: "2.0",
              id: 2,
              method: "getTokenAccountsByOwner",
              params: [
                walletAddress,
                { programId: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb" },
                { encoding: "jsonParsed" }
              ]
            })
          })
        ]);
        const [data, data2022] = await Promise.all([
          tokenResponse.json(),
          token2022Response.json()
        ]);
        const tokenAccounts = ((_g = data == null ? void 0 : data.result) == null ? void 0 : _g.value) || [];
        const tokenAccounts2022 = ((_h = data2022 == null ? void 0 : data2022.result) == null ? void 0 : _h.value) || [];
        const filterNFTs = (accounts) => accounts.filter((acc) => {
          var _a4, _b4, _c3, _d3, _e2;
          const info = (_c3 = (_b4 = (_a4 = acc.account) == null ? void 0 : _a4.data) == null ? void 0 : _b4.parsed) == null ? void 0 : _c3.info;
          return info && ((_d3 = info.tokenAmount) == null ? void 0 : _d3.decimals) === 0 && ((_e2 = info.tokenAmount) == null ? void 0 : _e2.uiAmount) === 1;
        });
        const nftAccounts = filterNFTs(tokenAccounts);
        const nftAccounts2022 = filterNFTs(tokenAccounts2022);
        const allNftMints = [
          ...nftAccounts.map((acc) => {
            var _a4, _b4, _c3;
            const info = (_c3 = (_b4 = (_a4 = acc.account) == null ? void 0 : _a4.data) == null ? void 0 : _b4.parsed) == null ? void 0 : _c3.info;
            return {
              mint: info == null ? void 0 : info.mint,
              address: acc.pubkey,
              isToken2022: false
            };
          }),
          ...nftAccounts2022.map((acc) => {
            var _a4, _b4, _c3;
            const info = (_c3 = (_b4 = (_a4 = acc.account) == null ? void 0 : _a4.data) == null ? void 0 : _b4.parsed) == null ? void 0 : _c3.info;
            return {
              mint: info == null ? void 0 : info.mint,
              address: acc.pubkey,
              isToken2022: true
            };
          })
        ];
        logger$1.log("[NFT] Found", allNftMints.length, "potential NFTs");
        const basicNfts = allNftMints.map((nft) => {
          var _a4;
          return {
            ...nft,
            name: `NFT ${(_a4 = nft.mint) == null ? void 0 : _a4.slice(0, 8)}...`,
            symbol: "",
            image: null,
            loading: true
          };
        });
        setNfts(basicNfts);
        const nftsWithMetadata = await Promise.all(
          allNftMints.map(async (nft) => {
            var _a4, _b4, _c3, _d3, _e2, _f2, _g2, _h2, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
            try {
              if (isSolana && isHelius) {
                try {
                  const assetResponse = await fetch(rpcUrl, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                      jsonrpc: "2.0",
                      id: 1,
                      method: "getAsset",
                      params: { id: nft.mint }
                    })
                  });
                  const assetData = await assetResponse.json();
                  if (assetData == null ? void 0 : assetData.result) {
                    const item = assetData.result;
                    return {
                      ...nft,
                      name: ((_b4 = (_a4 = item.content) == null ? void 0 : _a4.metadata) == null ? void 0 : _b4.name) || `NFT ${(_c3 = nft.mint) == null ? void 0 : _c3.slice(0, 8)}...`,
                      symbol: ((_e2 = (_d3 = item.content) == null ? void 0 : _d3.metadata) == null ? void 0 : _e2.symbol) || "",
                      image: ((_g2 = (_f2 = item.content) == null ? void 0 : _f2.links) == null ? void 0 : _g2.image) || ((_j = (_i = (_h2 = item.content) == null ? void 0 : _h2.files) == null ? void 0 : _i[0]) == null ? void 0 : _j.uri) || null,
                      description: ((_l = (_k = item.content) == null ? void 0 : _k.metadata) == null ? void 0 : _l.description) || "",
                      attributes: ((_n = (_m = item.content) == null ? void 0 : _m.metadata) == null ? void 0 : _n.attributes) || [],
                      loading: false
                    };
                  }
                } catch (dasErr) {
                  logger$1.warn("[NFT] DAS getAsset failed for", nft.mint, dasErr);
                }
              }
              const METADATA_PROGRAM_ID2 = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";
              const controller = new AbortController();
              const timeout = setTimeout(() => controller.abort(), 5e3);
              const pdaResponse = await fetch(rpcUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  jsonrpc: "2.0",
                  id: 1,
                  method: "getProgramAccounts",
                  params: [
                    METADATA_PROGRAM_ID2,
                    {
                      encoding: "base64",
                      filters: [
                        { memcmp: { offset: 33, bytes: nft.mint } }
                      ]
                    }
                  ]
                }),
                signal: controller.signal
              });
              clearTimeout(timeout);
              const pdaData = await pdaResponse.json();
              const metadataAccount = (_o = pdaData == null ? void 0 : pdaData.result) == null ? void 0 : _o[0];
              if (metadataAccount) {
                const accountData = (_q = (_p = metadataAccount.account) == null ? void 0 : _p.data) == null ? void 0 : _q[0];
                if (accountData) {
                  const buffer2 = Uint8Array.from(atob(accountData), (c) => c.charCodeAt(0));
                  let offset = 65;
                  const nameLen = buffer2[offset] | buffer2[offset + 1] << 8 | buffer2[offset + 2] << 16 | buffer2[offset + 3] << 24;
                  offset += 4;
                  const name = new TextDecoder().decode(buffer2.slice(offset, offset + Math.min(nameLen, 32))).replace(/\0/g, "").trim();
                  offset += 32;
                  const symbolLen = buffer2[offset] | buffer2[offset + 1] << 8 | buffer2[offset + 2] << 16 | buffer2[offset + 3] << 24;
                  offset += 4;
                  const symbol = new TextDecoder().decode(buffer2.slice(offset, offset + Math.min(symbolLen, 10))).replace(/\0/g, "").trim();
                  offset += 10;
                  const uriLen = buffer2[offset] | buffer2[offset + 1] << 8 | buffer2[offset + 2] << 16 | buffer2[offset + 3] << 24;
                  offset += 4;
                  const uri = new TextDecoder().decode(buffer2.slice(offset, offset + Math.min(uriLen, 200))).replace(/\0/g, "").trim();
                  let image = null;
                  let description = "";
                  let attributes = [];
                  if (uri && (uri.startsWith("http") || uri.startsWith("ipfs"))) {
                    const offChainMeta = await fetchMetadata(uri);
                    if (offChainMeta) {
                      image = normalizeIpfsUrl(offChainMeta.image);
                      description = offChainMeta.description || "";
                      attributes = offChainMeta.attributes || [];
                    }
                  }
                  return {
                    ...nft,
                    name: name || `NFT ${(_r = nft.mint) == null ? void 0 : _r.slice(0, 8)}...`,
                    symbol,
                    uri,
                    image,
                    description,
                    attributes,
                    loading: false
                  };
                }
              }
              return {
                ...nft,
                name: `NFT ${(_s = nft.mint) == null ? void 0 : _s.slice(0, 8)}...`,
                symbol: "",
                image: null,
                loading: false
              };
            } catch (err) {
              return {
                ...nft,
                name: `NFT ${(_t = nft.mint) == null ? void 0 : _t.slice(0, 8)}...`,
                symbol: "",
                image: null,
                loading: false
              };
            }
          })
        );
        setNfts(nftsWithMetadata);
      } catch (err) {
        logger$1.error("[NFTs] Fetch error:", err);
        setError("Failed to load NFTs");
      } finally {
        setLoading(false);
      }
    };
    fetchNFTs();
  }, [walletAddress, rpcUrl, network]);
  if (sendSuccess) {
    const explorerUrl = getTxExplorerUrl(network, txHash);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-detail", style: { textAlign: "center", paddingTop: 40 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "64", height: "64", viewBox: "0 0 24 24", fill: "none", stroke: "var(--success)", strokeWidth: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 12l2 2 4-4" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { marginTop: 16, marginBottom: 8 }, children: "NFT Sent!" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { color: "var(--text-muted)", marginBottom: 16 }, children: [
        selectedNft == null ? void 0 : selectedNft.name,
        " has been sent successfully."
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "a",
        {
          href: explorerUrl,
          target: "_blank",
          rel: "noopener noreferrer",
          style: { color: "var(--x1-blue)", fontSize: 13 },
          children: "View Transaction "
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "btn-primary",
          onClick: () => {
            resetSendState();
            setSelectedNft(null);
          },
          style: { marginTop: 24 },
          children: "Done"
        }
      )
    ] });
  }
  if (sendMode && selectedNft) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-detail", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "back-btn", onClick: resetSendState, style: { marginBottom: 16 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { marginLeft: 8 }, children: "Back" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { marginBottom: 16 }, children: "Send NFT" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 12, marginBottom: 20, padding: 12, background: "var(--bg-secondary)", borderRadius: 8 }, children: [
        selectedNft.image ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: selectedNft.image, alt: selectedNft.name, style: { width: 48, height: 48, borderRadius: 8, objectFit: "cover" } }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: 48, height: 48, background: "var(--bg-tertiary)", borderRadius: 8, display: "flex", alignItems: "center", justifyContent: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "1.5", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "18", height: "18", rx: "2" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: 600 }, children: selectedNft.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "var(--text-muted)" }, children: [
            (_c = selectedNft.mint) == null ? void 0 : _c.slice(0, 8),
            "...",
            (_d = selectedNft.mint) == null ? void 0 : _d.slice(-4)
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: 16 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontSize: 12, color: "var(--text-muted)", marginBottom: 8, display: "block" }, children: "Recipient Address" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: recipient,
            onChange: (e) => setRecipient(e.target.value),
            placeholder: "Enter wallet address",
            style: {
              width: "100%",
              padding: "12px",
              background: "var(--bg-secondary)",
              border: "1px solid var(--border-color)",
              borderRadius: 8,
              color: "var(--text-primary)",
              fontSize: 14,
              boxSizing: "border-box"
            }
          }
        )
      ] }),
      sendError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
        padding: 12,
        background: "rgba(239, 68, 68, 0.1)",
        border: "1px solid rgba(239, 68, 68, 0.3)",
        borderRadius: 8,
        color: "#ef4444",
        fontSize: 13,
        marginBottom: 16
      }, children: sendError }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "btn-primary",
          onClick: handleSendNft,
          disabled: sending || !recipient,
          children: sending ? "Sending..." : "Send NFT"
        }
      )
    ] });
  }
  if (selectedNft) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-detail", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "back-btn", onClick: () => setSelectedNft(null), style: { marginBottom: 16 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { marginLeft: 8 }, children: "Back" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-detail-image", children: [
        selectedNft.image ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: selectedNft.image,
            alt: selectedNft.name,
            style: { width: "100%", borderRadius: 12 },
            onError: (e) => {
              logger$1.warn("[NFT] Image failed to load:", selectedNft.image);
              e.target.style.display = "none";
              e.target.nextSibling.style.display = "flex";
            }
          }
        ) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
          display: selectedNft.image ? "none" : "flex",
          width: "100%",
          aspectRatio: "1",
          background: "var(--bg-tertiary)",
          borderRadius: 12,
          alignItems: "center",
          justifyContent: "center"
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "64", height: "64", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "1.5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "18", height: "18", rx: "2" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "8.5", cy: "8.5", r: "1.5" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 15l-5-5L5 21" })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { marginTop: 16, marginBottom: 8 }, children: selectedNft.name }),
      selectedNft.symbol && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "var(--text-muted)", marginBottom: 8 }, children: selectedNft.symbol }),
      selectedNft.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: 13, color: "var(--text-muted)", marginBottom: 16 }, children: selectedNft.description }),
      selectedNft.isCompressed && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
        background: "rgba(99, 102, 241, 0.1)",
        border: "1px solid rgba(99, 102, 241, 0.3)",
        borderRadius: 8,
        padding: 10,
        marginBottom: 12,
        fontSize: 12,
        color: "var(--text-muted)"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#818cf8" }, children: "" }),
        " Compressed NFT (cNFT)"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: "btn-primary",
          onClick: () => setSendMode(true),
          style: { marginBottom: 12 },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", style: { marginRight: 8 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M22 2L11 13" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M22 2l-7 20-4-9-9-4 20-7z" })
            ] }),
            "Send NFT"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "btn-secondary",
          onClick: () => toggleHideNft(selectedNft.mint),
          style: { marginBottom: 16, width: "100%" },
          children: hiddenNfts.includes(selectedNft.mint) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", style: { marginRight: 8 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
            ] }),
            "Unhide NFT"
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", style: { marginRight: 8 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0112 20c-7 0-11-8-11-8a18.45 18.45 0 015.06-5.94M9.9 4.24A9.12 9.12 0 0112 4c7 0 11 8 11 8a18.5 18.5 0 01-2.16 3.19m-6.72-1.07a3 3 0 11-4.24-4.24" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
            ] }),
            "Hide NFT"
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { background: "var(--bg-secondary)", borderRadius: 8, padding: 12, marginBottom: 12 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "var(--text-muted)", marginBottom: 4 }, children: "Mint Address" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, wordBreak: "break-all" }, children: selectedNft.mint })
      ] }),
      selectedNft.attributes && selectedNft.attributes.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 16 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { style: { marginBottom: 12, fontSize: 14 }, children: "Attributes" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "grid", gridTemplateColumns: "repeat(2, 1fr)", gap: 8 }, children: selectedNft.attributes.map((attr, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { background: "var(--bg-secondary)", borderRadius: 8, padding: 10, textAlign: "center" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 10, color: "var(--text-muted)", textTransform: "uppercase" }, children: attr.trait_type }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 13, fontWeight: 600, marginTop: 2 }, children: attr.value })
        ] }, i)) })
      ] })
    ] });
  }
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Loading NFTs..." })
    ] });
  }
  if (error) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: "var(--error)", strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "8", x2: "12", y2: "12" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "16", x2: "12.01", y2: "16" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: error })
    ] });
  }
  if (nfts.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-state", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "18", height: "18", rx: "2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "8.5", cy: "8.5", r: "1.5" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 15l-5-5L5 21" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No NFTs found" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 12, color: "var(--text-muted)", marginTop: 4 }, children: "NFTs will appear here when you receive them" })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    hiddenCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        onClick: () => setShowHidden(!showHidden),
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "space-between",
          padding: "8px 12px",
          marginBottom: 12,
          background: "var(--bg-tertiary)",
          borderRadius: 8,
          cursor: "pointer",
          fontSize: 13
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "var(--text-muted)" }, children: [
            showHidden ? "Showing" : "Hiding",
            " ",
            hiddenCount,
            " hidden NFT",
            hiddenCount > 1 ? "s" : ""
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "var(--x1-blue)" }, children: showHidden ? "Hide" : "Show" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nft-grid", children: visibleNfts.map((nft, index) => {
      var _a3, _b3;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "nft-card",
          onClick: () => setSelectedNft(nft),
          style: {
            cursor: "pointer",
            opacity: hiddenNfts.includes(nft.mint) ? 0.5 : 1
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-image", children: [
              nft.image ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: nft.image,
                  alt: nft.name,
                  style: { width: "100%", height: "100%", objectFit: "cover", borderRadius: 8 },
                  onError: (e) => {
                    logger$1.warn("[NFT] Grid image failed to load:", nft.image);
                    e.target.style.display = "none";
                    e.target.nextSibling.style.display = "flex";
                  },
                  onLoad: () => logger$1.log("[NFT] Image loaded:", nft.name)
                }
              ) : null,
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                display: nft.image ? "none" : "flex",
                width: "100%",
                height: "100%",
                alignItems: "center",
                justifyContent: "center",
                background: "var(--bg-tertiary)",
                borderRadius: 8
              }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "40", height: "40", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "1.5", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "18", height: "18", rx: "2" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "8.5", cy: "8.5", r: "1.5" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 15l-5-5L5 21" })
              ] }) }),
              hiddenNfts.includes(nft.mint) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                position: "absolute",
                top: 4,
                right: 4,
                background: "rgba(0,0,0,0.7)",
                borderRadius: 4,
                padding: "2px 6px",
                fontSize: 10,
                color: "#999"
              }, children: "Hidden" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nft-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "nft-name", children: nft.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "nft-mint", children: [
                (_a3 = nft.mint) == null ? void 0 : _a3.slice(0, 4),
                "...",
                (_b3 = nft.mint) == null ? void 0 : _b3.slice(-4)
              ] })
            ] })
          ]
        },
        nft.mint || index
      );
    }) })
  ] });
}
function DefiTab({ wallet, tokens: tokens2, isSolana, onStake }) {
  var _a2;
  const [xpBalance, setXpBalance] = reactExports.useState(null);
  const [xpLoading, setXpLoading] = reactExports.useState(true);
  reactExports.useEffect(() => {
    const fetchXP = async () => {
      var _a3;
      if (!((_a3 = wallet.wallet) == null ? void 0 : _a3.publicKey)) return;
      setXpLoading(true);
      try {
        const { getXPBalance: getXPBalance2 } = await __vitePreload(async () => {
          const { getXPBalance: getXPBalance3 } = await Promise.resolve().then(() => xp);
          return { getXPBalance: getXPBalance3 };
        }, true ? void 0 : void 0);
        const result = await getXPBalance2(wallet.wallet.publicKey, wallet.network);
        setXpBalance(result);
      } catch (err) {
        logger$1.error("[DefiTab] Failed to fetch XP:", err);
        setXpBalance({ totalScore: 0, totalCurrentScore: 0, totalClaimedScore: 0 });
      }
      setXpLoading(false);
    };
    fetchXP();
  }, [(_a2 = wallet.wallet) == null ? void 0 : _a2.publicKey, wallet.network]);
  const pxntToken = tokens2.find((t2) => t2.symbol === "pXNT");
  const pxntBalance = parseFloat((pxntToken == null ? void 0 : pxntToken.balance) || (pxntToken == null ? void 0 : pxntToken.uiAmount) || 0);
  const hasPxnt = pxntBalance > 0;
  const xlpTokens = tokens2.filter(
    (t2) => {
      var _a3, _b2, _c;
      return ((_a3 = t2.symbol) == null ? void 0 : _a3.includes("XLP")) || ((_b2 = t2.symbol) == null ? void 0 : _b2.includes("LP")) || ((_c = t2.name) == null ? void 0 : _c.toLowerCase().includes("liquidity"));
    }
  );
  const isX1 = wallet.network === "X1 Mainnet";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "defi-tab", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "defi-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "defi-section-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "defi-section-title", children: "CORE XP" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://core.x1.xyz", target: "_blank", rel: "noopener noreferrer", className: "defi-section-link", title: "Open CORE", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "15 3 21 3 21 9" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "10", y1: "14", x2: "21", y2: "3" })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "defi-item xp-item", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "defi-item-icon xp", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "defi-item-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "defi-item-title", children: "Available XP" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "defi-item-desc", children: (xpBalance == null ? void 0 : xpBalance.totalClaimedScore) > 0 && `Claimed: ${xpBalance.totalClaimedScore.toLocaleString(void 0, { maximumFractionDigits: 2 })}` })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "defi-item-value xp-value", children: xpLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "loading-dots", children: "..." }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "xp-score", children: ((xpBalance == null ? void 0 : xpBalance.totalCurrentScore) || 0).toLocaleString(void 0, { maximumFractionDigits: 2 }) }) })
      ] })
    ] }),
    isX1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "defi-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "defi-section-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "defi-section-title", children: "Staking" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "defi-item clickable",
          onClick: onStake,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "defi-item-icon stake", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2L2 7l10 5 10-5-10-5z" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2 17l10 5 10-5" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2 12l10 5 10-5" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "defi-item-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "defi-item-title", children: "XNT Staking" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "defi-item-desc", children: hasPxnt ? `${pxntBalance.toFixed(4)} pXNT staked` : "Stake XNT to earn rewards" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "defi-item-action", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) }) })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "defi-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "defi-section-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "defi-section-title", children: "Liquidity Pools" }) }),
      xlpTokens.length > 0 ? xlpTokens.map((lp, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "defi-item", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "defi-item-icon liquidity", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8 12h8M12 8v8" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "defi-item-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "defi-item-title", children: lp.name || lp.symbol || "LP Token" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "defi-item-desc", children: [
            parseFloat(lp.balance || lp.uiAmount || 0).toFixed(6),
            " tokens"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "defi-item-value", children: lp.usdValue ? `$${lp.usdValue.toFixed(2)}` : "" })
      ] }, idx)) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "defi-empty", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "No liquidity positions" }) })
    ] })
  ] });
}
const SOLANA_LOGO_URL$3 = "/icons/48-sol.png";
function NetworkLogo$2({ network, size = 40 }) {
  const x1LogoSize = Math.round(size * 0.8);
  const solanaLogoSize = Math.round(size * 0.95);
  if (network == null ? void 0 : network.includes("Solana")) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "network-logo-container",
        style: {
          width: size,
          height: size,
          minWidth: size,
          minHeight: size,
          borderRadius: "50%",
          background: "#000",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          flexShrink: 0,
          overflow: "hidden"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: SOLANA_LOGO_URL$3,
            alt: "Solana",
            style: {
              width: solanaLogoSize,
              height: solanaLogoSize,
              objectFit: "contain",
              display: "block"
            }
          }
        )
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "network-logo-container",
      style: {
        width: size,
        height: size,
        minWidth: size,
        minHeight: size,
        borderRadius: "50%",
        background: "#000",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        flexShrink: 0,
        overflow: "hidden"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: "/icons/48-x1.png",
          alt: "X1",
          style: {
            width: x1LogoSize,
            height: x1LogoSize,
            objectFit: "contain",
            display: "block"
          },
          onError: (e) => {
            e.target.style.display = "none";
            e.target.parentElement.innerHTML = '<span style="color: #0274fb; font-weight: bold; font-size: ' + Math.round(size * 0.4) + 'px;">X1</span>';
          }
        }
      )
    }
  );
}
function NetworkPanel({ network, networks, onSelect, onClose, onCustomRpc }) {
  const mainnets = Object.keys(networks).filter((n2) => !n2.includes("Testnet") && !n2.includes("Devnet"));
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "slide-panel-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "panel-back-btn", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Select Network" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "network-section-label", children: "Networks" }),
      mainnets.map((net, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `network-option ${network === net ? "active" : ""}`,
          onClick: () => {
            onSelect(net);
            onClose();
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(NetworkLogo$2, { network: net, size: 40 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "network-option-info", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "network-name", children: net }) }),
            network === net && /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) })
          ]
        },
        net
      )),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "network-info-note", style: {
        padding: "12px 16px",
        fontSize: "12px",
        color: "var(--text-muted)",
        marginTop: "12px"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", style: { marginRight: 6, verticalAlign: -2 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 16v-4M12 8h.01" })
        ] }),
        "Testnets available in Settings  Network"
      ] })
    ] })
  ] }) });
}
function WalletPanel({ wallets, activeId, network, onSelect, onManage, onClose, onEditWallet, onShowAddWallet, onReorderWallets }) {
  const [copiedId, setCopiedId] = reactExports.useState(null);
  const [draggedId, setDraggedId] = reactExports.useState(null);
  const [dragOverId, setDragOverId] = reactExports.useState(null);
  const [balances, setBalances] = reactExports.useState({});
  const [loadingBalances, setLoadingBalances] = reactExports.useState(true);
  reactExports.useEffect(() => {
    let isMounted = true;
    const fetchBalances = async () => {
      if (!isMounted) return;
      setLoadingBalances(true);
      const newBalances = {};
      const networkConfig = NETWORKS[network] || NETWORKS["X1 Mainnet"];
      const rpcUrl = (networkConfig == null ? void 0 : networkConfig.rpcUrl) || "https://rpc.mainnet.x1.xyz";
      const promises = wallets.map(async (w2) => {
        var _a2, _b2, _c, _d, _e;
        try {
          const address = w2.publicKey || ((_b2 = (_a2 = w2.addresses) == null ? void 0 : _a2[w2.activeAddressIndex || 0]) == null ? void 0 : _b2.publicKey) || ((_d = (_c = w2.addresses) == null ? void 0 : _c[0]) == null ? void 0 : _d.publicKey);
          if (!address) return { id: w2.id, balance: null };
          const response = await fetch(rpcUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              jsonrpc: "2.0",
              id: 1,
              method: "getBalance",
              params: [address]
            })
          });
          const data = await response.json();
          if (((_e = data.result) == null ? void 0 : _e.value) !== void 0) {
            return { id: w2.id, balance: data.result.value / 1e9 };
          }
          return { id: w2.id, balance: null };
        } catch (err) {
          return { id: w2.id, balance: null };
        }
      });
      const results = await Promise.all(promises);
      results.forEach((r2) => {
        newBalances[r2.id] = r2.balance;
      });
      if (isMounted) {
        setBalances(newBalances);
        setLoadingBalances(false);
      }
    };
    if ((wallets == null ? void 0 : wallets.length) > 0) {
      fetchBalances();
    }
    return () => {
      isMounted = false;
    };
  }, []);
  const formatBalance2 = (balance) => {
    if (balance === null || balance === void 0) return "...";
    if (balance === 0) return "0";
    if (balance < 1e-4) return "<0.0001";
    if (balance < 1) return balance.toFixed(4);
    if (balance < 1e3) return balance.toFixed(2);
    if (balance < 1e6) return (balance / 1e3).toFixed(1) + "K";
    return (balance / 1e6).toFixed(1) + "M";
  };
  const tokenSymbol = (network == null ? void 0 : network.includes("Solana")) ? "SOL" : "XNT";
  const copyAddress = (e, walletId, address) => {
    e.stopPropagation();
    navigator.clipboard.writeText(address);
    setCopiedId(walletId);
    setTimeout(() => setCopiedId(null), 2e3);
  };
  const formatAddress = (addr) => {
    if (!addr) return "";
    return `${addr.slice(0, 8)}...${addr.slice(-8)}`;
  };
  const getActiveAddress = (w2) => {
    if (!w2.addresses || w2.addresses.length === 0) return { publicKey: w2.publicKey, name: "Address 1" };
    const idx = w2.activeAddressIndex || 0;
    return w2.addresses[idx] || w2.addresses[0];
  };
  const isImage = (avatar) => avatar && avatar.startsWith("data:image");
  const handleDragStart = (e, walletId) => {
    setDraggedId(walletId);
    e.dataTransfer.effectAllowed = "move";
    setTimeout(() => {
      e.target.style.opacity = "0.5";
    }, 0);
  };
  const handleDragEnd = (e) => {
    e.target.style.opacity = "1";
    setDraggedId(null);
    setDragOverId(null);
  };
  const handleDragOver = (e, walletId) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = "move";
    if (walletId !== draggedId) {
      setDragOverId(walletId);
    }
  };
  const handleDragLeave = (e) => {
    setDragOverId(null);
  };
  const handleDrop = (e, targetId) => {
    e.preventDefault();
    if (draggedId && targetId && draggedId !== targetId && onReorderWallets) {
      const draggedIndex = wallets.findIndex((w2) => w2.id === draggedId);
      const targetIndex = wallets.findIndex((w2) => w2.id === targetId);
      if (draggedIndex !== -1 && targetIndex !== -1) {
        const newWallets = [...wallets];
        const [draggedWallet] = newWallets.splice(draggedIndex, 1);
        newWallets.splice(targetIndex, 0, draggedWallet);
        onReorderWallets(newWallets);
      }
    }
    setDraggedId(null);
    setDragOverId(null);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "slide-panel-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "slide-panel-title", children: "Select Wallet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: 32 } })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "slide-panel-content", children: wallets.map((w2) => {
      var _a2, _b2;
      const activeAddr = getActiveAddress(w2);
      const hasImage = isImage(w2.avatar);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `wallet-panel-item ${activeId === w2.id ? "active" : ""} ${dragOverId === w2.id ? "drag-over" : ""}`,
          onClick: () => {
            onSelect(w2.id);
            onClose();
          },
          draggable: true,
          onDragStart: (e) => handleDragStart(e, w2.id),
          onDragEnd: handleDragEnd,
          onDragOver: (e) => handleDragOver(e, w2.id),
          onDragLeave: handleDragLeave,
          onDrop: (e) => handleDrop(e, w2.id),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallet-item-avatar", children: hasImage ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: w2.avatar, alt: w2.name }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallet-avatar-initials", children: w2.isHardware ? "L" : ((_b2 = (_a2 = w2.name) == null ? void 0 : _a2.charAt(0)) == null ? void 0 : _b2.toUpperCase()) || "W" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-item-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-item-row1", style: { display: "flex", alignItems: "center", gap: 6 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallet-item-name", children: w2.name }),
                activeId === w2.id && /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
                  fontSize: 12,
                  fontWeight: 600,
                  color: balances[w2.id] > 0 ? "var(--success)" : "var(--text-muted)",
                  marginLeft: "auto"
                }, children: loadingBalances ? "..." : `${formatBalance2(balances[w2.id])} ${tokenSymbol}` })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-item-row2", style: { display: "flex", alignItems: "center", gap: 4 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallet-item-address", children: formatAddress(activeAddr.publicKey) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "wallet-item-copy",
                    onClick: (e) => copyAddress(e, w2.id, activeAddr.publicKey),
                    children: copiedId === w2.id ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "var(--success)", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })
                    ] })
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "wallet-item-edit",
                onClick: (e) => {
                  e.stopPropagation();
                  onClose();
                  onEditWallet(w2);
                },
                title: "Edit wallet",
                style: { alignSelf: "flex-start", marginTop: 2 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" })
                ] })
              }
            )
          ]
        },
        w2.id
      );
    }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "slide-panel-footer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "panel-action-btn full-width", onClick: () => {
      onClose();
      onShowAddWallet();
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 8v8M8 12h8" })
      ] }),
      "Add Wallet"
    ] }) })
  ] }) });
}
function AddWalletPanel({ onClose, onCreateNew, onImport, onHardware }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "slide-panel-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Add Wallet" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "slide-panel-content", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "add-wallet-options", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "add-wallet-option", onClick: () => {
        onClose();
        onCreateNew();
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "add-wallet-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2l9 4.5v5c0 5.5-3.84 10.74-9 12-5.16-1.26-9-6.5-9-12v-5L12 2z" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 8v8M8 12h8" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "add-wallet-text", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "add-wallet-title", children: "Create New Wallet" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "add-wallet-desc", children: "Generate a new seed phrase" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "add-wallet-option", onClick: () => {
        onClose();
        onImport();
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "add-wallet-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "7 10 12 15 17 10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "15", x2: "12", y2: "3" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "add-wallet-text", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "add-wallet-title", children: "Import Wallet" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "add-wallet-desc", children: "Seed phrase or private key" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "add-wallet-option", onClick: () => {
        onClose();
        onHardware();
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "add-wallet-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "7", width: "20", height: "10", rx: "2" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "2" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6 7V5a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v2" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "add-wallet-text", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "add-wallet-title", children: "Hardware Wallet" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "add-wallet-desc", children: "Connect Ledger or Trezor" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
      ] })
    ] }) })
  ] }) });
}
function PrivateKeyByteArray({ privateKey }) {
  const [copied, setCopied] = reactExports.useState(false);
  const [byteArray, setByteArray] = reactExports.useState("");
  React.useEffect(() => {
    const convertToByteArray = async () => {
      try {
        const { decodeBase58: decodeBase582 } = await __vitePreload(async () => {
          const { decodeBase58: decodeBase583 } = await Promise.resolve().then(() => base58);
          return { decodeBase58: decodeBase583 };
        }, true ? void 0 : void 0);
        const bytes = decodeBase582(privateKey);
        const arrayStr = "[" + Array.from(bytes).join(",") + "]";
        setByteArray(arrayStr);
      } catch (e) {
        setByteArray("Error converting key");
      }
    };
    if (privateKey) {
      convertToByteArray();
    }
  }, [privateKey]);
  const copyByteArray = () => {
    navigator.clipboard.writeText(byteArray);
    setCopied(true);
    setTimeout(() => setCopied(false), 2e3);
  };
  if (!byteArray) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
    marginTop: 12,
    padding: 12,
    background: "rgba(255, 59, 48, 0.1)",
    border: "1px solid rgba(255, 59, 48, 0.3)",
    borderRadius: 8
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
      display: "flex",
      alignItems: "center",
      gap: 6,
      marginBottom: 10,
      color: "#ff3b30",
      fontSize: 11,
      fontWeight: 600
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "9", x2: "12", y2: "13" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "17", x2: "12.01", y2: "17" })
      ] }),
      "Never share this with anyone!"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
      fontSize: 9,
      fontFamily: "monospace",
      color: "var(--text-primary)",
      wordBreak: "break-all",
      lineHeight: 1.3,
      padding: "8px",
      background: "var(--bg-secondary)",
      borderRadius: 6,
      marginBottom: 8
    }, children: byteArray }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: copyByteArray,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          gap: 6,
          width: "100%",
          padding: "8px 10px",
          background: "var(--bg-tertiary)",
          border: "1px solid var(--border-color)",
          borderRadius: 6,
          color: copied ? "var(--success)" : "var(--text-primary)",
          fontSize: 12,
          fontWeight: 500,
          cursor: "pointer"
        },
        children: copied ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }),
          "Copied!"
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })
          ] }),
          "Copy Byte Array"
        ] })
      }
    )
  ] });
}
function EditWalletPanel({ walletData, onSave, onClose, onRemove }) {
  var _a2, _b2, _c;
  const [name, setName] = reactExports.useState(walletData.name || "");
  const [avatar, setAvatar] = reactExports.useState(walletData.avatar || "");
  const [showRemoveConfirm, setShowRemoveConfirm] = reactExports.useState(false);
  const [copiedAddress, setCopiedAddress] = reactExports.useState(false);
  const [showPrivateKey, setShowPrivateKey] = reactExports.useState(null);
  const [copiedKey, setCopiedKey] = reactExports.useState(false);
  const fileInputRef = React.useRef(null);
  const walletActions = walletData.walletActions || {};
  const handleFileSelect = (e) => {
    var _a3;
    const file = (_a3 = e.target.files) == null ? void 0 : _a3[0];
    if (file) {
      if (file.size > 5 * 1024 * 1024) {
        alert("Image must be less than 5MB");
        return;
      }
      const reader = new FileReader();
      reader.onload = (event) => {
        setAvatar(event.target.result);
      };
      reader.readAsDataURL(file);
    }
  };
  const handleSave = () => {
    onSave({
      ...walletData,
      name: name.trim() || walletData.name,
      avatar
    });
  };
  const clearAvatar = () => {
    setAvatar("");
  };
  const handleRemove = () => {
    if (onRemove) {
      onRemove(walletData.id);
      onClose();
    }
  };
  const copyAddress = () => {
    var _a3;
    const addr = (_a3 = addresses[0]) == null ? void 0 : _a3.publicKey;
    if (addr) {
      navigator.clipboard.writeText(addr);
      setCopiedAddress(true);
      setTimeout(() => setCopiedAddress(false), 2e3);
    }
  };
  const copyPrivateKey = () => {
    var _a3;
    const key = (_a3 = addresses[0]) == null ? void 0 : _a3.privateKey;
    if (key) {
      navigator.clipboard.writeText(key);
      setCopiedKey(true);
      setTimeout(() => setCopiedKey(false), 2e3);
    }
  };
  const addresses = walletData.addresses || [{
    index: 0,
    publicKey: walletData.publicKey,
    privateKey: walletData.privateKey,
    name: "Address 1"
  }];
  const hasMnemonic = !walletData.isPrivateKeyOnly && !walletData.isHardware && walletData.type !== "privatekey";
  const primaryAddress = ((_a2 = addresses[0]) == null ? void 0 : _a2.publicKey) || "";
  const privateKey = ((_b2 = addresses[0]) == null ? void 0 : _b2.privateKey) || "";
  const isImage = avatar && avatar.startsWith("data:image");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "slide-panel-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel large", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Edit Wallet" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "edit-avatar-row", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "edit-avatar-preview-small", children: isImage ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: avatar, alt: "Wallet avatar" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ((_c = name == null ? void 0 : name.charAt(0)) == null ? void 0 : _c.toUpperCase()) || "W" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "edit-avatar-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: "avatar-action-btn",
              onClick: () => {
                var _a3;
                return (_a3 = fileInputRef.current) == null ? void 0 : _a3.click();
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "17 8 12 3 7 8" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "3", x2: "12", y2: "15" })
                ] }),
                "Upload"
              ]
            }
          ),
          isImage && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: "avatar-action-btn",
              onClick: clearAvatar,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
                ] }),
                "Remove"
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            ref: fileInputRef,
            type: "file",
            accept: "image/png,image/jpeg,image/gif,image/webp",
            onChange: handleFileSelect,
            style: { display: "none" }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group compact", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Wallet Name" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            className: "form-input",
            value: name,
            onChange: (e) => setName(e.target.value),
            placeholder: "Enter wallet name"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group compact", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Address" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
          display: "flex",
          alignItems: "center",
          gap: 8,
          padding: "12px 14px",
          background: "var(--bg-secondary)",
          borderRadius: 10,
          marginTop: 8
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
            flex: 1,
            fontSize: 12,
            fontFamily: "monospace",
            color: "var(--text-primary)",
            wordBreak: "break-all",
            lineHeight: 1.4
          }, children: primaryAddress }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: copyAddress,
              style: {
                background: "none",
                border: "none",
                padding: 6,
                cursor: "pointer",
                color: copiedAddress ? "var(--success)" : "var(--text-muted)",
                flexShrink: 0
              },
              children: copiedAddress ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })
              ] })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
          display: "flex",
          gap: 8,
          marginTop: 12
        }, children: [
          hasMnemonic && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => {
                var _a3;
                return (_a3 = walletActions.showRecoveryPhrase) == null ? void 0 : _a3.call(walletActions, walletData.id);
              },
              style: {
                flex: 1,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: 5,
                padding: "10px 6px",
                background: "var(--bg-tertiary)",
                border: "1px solid var(--border-color)",
                borderRadius: 8,
                color: "var(--text-primary)",
                fontSize: 11,
                fontWeight: 500,
                cursor: "pointer"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "11", width: "18", height: "11", rx: "2", ry: "2" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" })
                ] }),
                "Seed"
              ]
            }
          ),
          privateKey && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => setShowPrivateKey(showPrivateKey === "base58" ? null : "base58"),
              style: {
                flex: 1,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: 5,
                padding: "10px 6px",
                background: showPrivateKey === "base58" ? "rgba(0, 122, 255, 0.15)" : "var(--bg-tertiary)",
                border: showPrivateKey === "base58" ? "1px solid var(--x1-blue)" : "1px solid var(--border-color)",
                borderRadius: 8,
                color: showPrivateKey === "base58" ? "var(--x1-blue)" : "var(--text-primary)",
                fontSize: 11,
                fontWeight: 500,
                cursor: "pointer"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4" }) }),
                "Key"
              ]
            }
          ),
          privateKey && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => setShowPrivateKey(showPrivateKey === "bytes" ? null : "bytes"),
              style: {
                flex: 1,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: 5,
                padding: "10px 6px",
                background: showPrivateKey === "bytes" ? "rgba(0, 122, 255, 0.15)" : "var(--bg-tertiary)",
                border: showPrivateKey === "bytes" ? "1px solid var(--x1-blue)" : "1px solid var(--border-color)",
                borderRadius: 8,
                color: showPrivateKey === "bytes" ? "var(--x1-blue)" : "var(--text-primary)",
                fontSize: 11,
                fontWeight: 500,
                cursor: "pointer"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "7", height: "7" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "14", y: "3", width: "7", height: "7" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "14", y: "14", width: "7", height: "7" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "14", width: "7", height: "7" })
                ] }),
                "Bytes"
              ]
            }
          )
        ] }),
        showPrivateKey === "base58" && privateKey && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
          marginTop: 12,
          padding: 12,
          background: "rgba(255, 59, 48, 0.1)",
          border: "1px solid rgba(255, 59, 48, 0.3)",
          borderRadius: 8
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
            display: "flex",
            alignItems: "center",
            gap: 6,
            marginBottom: 10,
            color: "#ff3b30",
            fontSize: 11,
            fontWeight: 600
          }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "9", x2: "12", y2: "13" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "17", x2: "12.01", y2: "17" })
            ] }),
            "Never share this with anyone!"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            fontSize: 10,
            fontFamily: "monospace",
            color: "var(--text-primary)",
            wordBreak: "break-all",
            lineHeight: 1.4,
            padding: "8px",
            background: "var(--bg-secondary)",
            borderRadius: 6,
            marginBottom: 8
          }, children: privateKey }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: copyPrivateKey,
              style: {
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: 6,
                width: "100%",
                padding: "8px 10px",
                background: "var(--bg-tertiary)",
                border: "1px solid var(--border-color)",
                borderRadius: 6,
                color: copiedKey ? "var(--success)" : "var(--text-primary)",
                fontSize: 12,
                fontWeight: 500,
                cursor: "pointer"
              },
              children: copiedKey ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }),
                "Copied!"
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })
                ] }),
                "Copy Private Key"
              ] })
            }
          )
        ] }),
        showPrivateKey === "bytes" && privateKey && /* @__PURE__ */ jsxRuntimeExports.jsx(PrivateKeyByteArray, { privateKey })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "danger-zone-section", children: !showRemoveConfirm ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: "danger-zone-trigger",
          onClick: () => setShowRemoveConfirm(true),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "3 6 5 6 21 6" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" })
            ] }),
            "Remove Wallet"
          ]
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "remove-confirm-box", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Remove wallet? Make sure you have your seed phrase!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "remove-confirm-btns", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-secondary", onClick: () => setShowRemoveConfirm(false), children: "Cancel" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-danger", onClick: handleRemove, children: "Remove" })
        ] })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "slide-panel-footer", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: handleSave, children: "Save Changes" }) })
  ] }) });
}
function RecoveryPhrasePanel({ wallet, onClose }) {
  const [revealed, setRevealed] = reactExports.useState(false);
  const [copied, setCopied] = reactExports.useState(false);
  const [password, setPassword] = reactExports.useState("");
  const [passwordError, setPasswordError] = reactExports.useState("");
  const [passwordVerified, setPasswordVerified] = reactExports.useState(false);
  const phrase = (wallet == null ? void 0 : wallet.mnemonic) || (wallet == null ? void 0 : wallet.seedPhrase) || "";
  const words = phrase ? phrase.split(" ") : [];
  const storedPwdProtection = localStorage.getItem("x1wallet_passwordProtection");
  const passwordProtection = storedPwdProtection ? JSON.parse(storedPwdProtection) : false;
  const [hasAuthData, setHasAuthData] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const checkAuth = async () => {
      try {
        const { hasPassword } = await __vitePreload(async () => {
          const { hasPassword: hasPassword2 } = await import("./wallet.js");
          return { hasPassword: hasPassword2 };
        }, true ? [] : void 0);
        const result = await hasPassword();
        setHasAuthData(result);
      } catch {
        setHasAuthData(!!localStorage.getItem("x1wallet_auth"));
      }
    };
    checkAuth();
  }, []);
  const requiresPassword = passwordProtection && hasAuthData;
  const copyPhrase = () => {
    navigator.clipboard.writeText(phrase);
    setCopied(true);
    setTimeout(() => setCopied(false), 2e3);
  };
  const verifyPassword2 = async () => {
    setPasswordError("");
    if (!password) {
      setPasswordError("Please enter your password");
      return;
    }
    try {
      const { checkPassword } = await __vitePreload(async () => {
        const { checkPassword: checkPassword2 } = await import("./wallet.js");
        return { checkPassword: checkPassword2 };
      }, true ? [] : void 0);
      const isValid = await checkPassword(password);
      if (!isValid) {
        setPasswordError("Incorrect password");
        return;
      }
      setPasswordVerified(true);
    } catch (err) {
      setPasswordError(err.message || "Password verification failed");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "slide-panel-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel large", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel-header", style: { display: "flex", alignItems: "center", gap: 12 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "back-btn",
          onClick: onClose,
          style: { background: "none", border: "none", padding: 8, cursor: "pointer" },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { margin: 0 }, children: "Seed Phrase" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: "12px 16px",
        background: "var(--bg-secondary)",
        borderRadius: 12,
        marginBottom: 20
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontWeight: 600 }, children: (wallet == null ? void 0 : wallet.name) || "Wallet" }) }),
      !revealed ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center", padding: "40px 20px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: 20 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "64", height: "64", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "1.5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
        ] }) }),
        requiresPassword && !passwordVerified ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "var(--text-muted)", marginBottom: 16 }, children: "Enter your password to reveal seed phrase" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { maxWidth: 280, margin: "0 auto" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "password",
                className: "form-input",
                placeholder: "Enter password",
                value: password,
                onChange: (e) => {
                  setPassword(e.target.value);
                  setPasswordError("");
                },
                onKeyDown: (e) => e.key === "Enter" && verifyPassword2(),
                autoFocus: true,
                style: { marginBottom: 12, textAlign: "center" }
              }
            ),
            passwordError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: "#ff3b30", fontSize: 13, marginBottom: 12 }, children: passwordError }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: verifyPassword2, style: { width: "100%" }, children: "Verify Password" })
          ] })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "var(--text-muted)", marginBottom: 24 }, children: "Your seed phrase is hidden for security" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: () => setRevealed(true), children: "Reveal Phrase" })
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "warning-box compact", style: { marginBottom: 16 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "#ffa502", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "9", x2: "12", y2: "13" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "17", x2: "12.01", y2: "17" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Never share this with anyone!" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "seed-phrase-grid", children: words.map((word, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "seed-word-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "seed-word-num", children: i + 1 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "seed-word-text", children: word })
        ] }, i)) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: 12, marginTop: 20 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-secondary",
              onClick: copyPhrase,
              style: { display: "flex", alignItems: "center", justifyContent: "center", gap: 12 },
              children: copied ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "var(--success)", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Copied!" })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Copy to Clipboard" })
              ] })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: onClose, children: "Done" })
        ] })
      ] })
    ] })
  ] }) });
}
function BrowserScreen({ wallet, onBack }) {
  const [url, setUrl] = reactExports.useState("");
  const [currentUrl, setCurrentUrl] = reactExports.useState("");
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const dapps = [
    {
      name: "X1 Blockchain",
      url: "https://x1.xyz",
      logo: "/icons/48-x1.png",
      desc: "Layer-1 Blockchain",
      color: "#0274fb"
    },
    {
      name: "XDEX",
      url: "https://xdex.xyz",
      logo: "/icons/48-xdex.png",
      desc: "X1 Native DEX",
      color: "#0274fb"
    },
    {
      name: "Degen",
      url: "https://degen.fyi",
      logo: "/icons/48-degen.png",
      desc: "Launchpad",
      color: "#ff6b35"
    },
    {
      name: "Vero",
      url: "https://vero.x1.xyz/",
      letter: "V",
      desc: "Predictive Markets",
      color: "#8b5cf6"
    },
    {
      name: "Bridge",
      url: "https://bridge.x1.xyz/",
      letter: "B",
      desc: "Cross-Chain Bridge",
      color: "#14F195"
    },
    {
      name: "Explorer",
      url: "https://explorer.mainnet.x1.xyz/",
      logo: "/icons/48-x1.png",
      desc: "X1 Mainnet Explorer",
      color: "#00d26a"
    }
  ];
  const DAppIcon = ({ dapp }) => {
    if (dapp.logo) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: dapp.logo, alt: dapp.name, style: { width: 32, height: 32, borderRadius: 8, objectFit: "cover" } });
    }
    if (dapp.letter) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
        fontSize: 20,
        fontWeight: 700,
        color: dapp.color || "var(--text-primary)",
        fontFamily: '-apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif'
      }, children: dapp.letter });
    }
    if (dapp.svgIcon === "explorer") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "22", height: "22", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-primary)", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "7", height: "7", rx: "1" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "14", y: "3", width: "7", height: "7", rx: "1" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "14", width: "7", height: "7", rx: "1" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "14", y: "14", width: "7", height: "7", rx: "1" })
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 20, fontWeight: 700, color: "var(--text-primary)" }, children: "?" });
  };
  const handleNavigate = (targetUrl) => {
    if (!targetUrl) return;
    let finalUrl = targetUrl;
    if (!targetUrl.startsWith("http")) {
      finalUrl = "https://" + targetUrl;
    }
    setIsLoading(true);
    setCurrentUrl(finalUrl);
    setTimeout(() => setIsLoading(false), 500);
  };
  const handleKeyPress = (e) => {
    if (e.key === "Enter") {
      handleNavigate(url);
    }
  };
  const expandToSidePanel = () => {
    const expandUrl = currentUrl || "https://xdex.xyz";
    window.open(expandUrl, "_blank", "width=420,height=680,right=0,top=0");
  };
  if (currentUrl) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen browser-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "browser-nav-bar", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "browser-nav-btn", onClick: () => setCurrentUrl(""), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "browser-url-display", children: [
          isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "loading-dot" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "url-text", children: currentUrl.replace("https://", "").split("/")[0] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "browser-nav-btn", onClick: () => window.open(currentUrl, "_blank"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "15 3 21 3 21 9" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "10", y1: "14", x2: "21", y2: "3" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "browser-nav-btn", onClick: expandToSidePanel, title: "Expand to side panel", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "18", height: "18", rx: "2" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "9", y1: "3", x2: "9", y2: "21" })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "browser-iframe-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "iframe",
        {
          src: currentUrl,
          title: "dApp Browser",
          sandbox: "allow-scripts allow-same-origin allow-forms allow-popups"
        }
      ) })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen browser-screen", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "browser-header", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "browser-search-bar", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11", cy: "11", r: "8" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "21", y1: "21", x2: "16.65", y2: "16.65" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          placeholder: "Search or enter URL",
          value: url,
          onChange: (e) => setUrl(e.target.value),
          onKeyPress: handleKeyPress
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "browser-expand-btn", onClick: expandToSidePanel, title: "Expand to side panel", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "18", height: "18", rx: "2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "9", y1: "3", x2: "9", y2: "21" })
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "browser-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Featured dApps" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dapp-grid", children: dapps.map((dapp) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "dapp-card",
          onClick: () => handleNavigate(dapp.url),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dapp-icon", style: { background: dapp.logo ? "transparent" : "#000", border: dapp.logo ? "none" : "1px solid var(--border-color)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DAppIcon, { dapp }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-name", children: dapp.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-desc", children: dapp.desc })
            ] })
          ]
        },
        dapp.name
      )) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Quick Actions" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "browser-quick-actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "browser-action-card", onClick: () => handleNavigate("https://xdex.xyz/swap"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "browser-action-icon", style: { background: "rgba(2, 116, 251, 0.15)", color: "#0274fb" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17 2l4 4-4 4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3 11V9a4 4 0 0 1 4-4h14" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 22l-4-4 4-4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 13v2a4 4 0 0 1-4 4H3" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "browser-action-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "browser-action-title", children: "Swap Tokens" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "browser-action-desc", children: "Exchange on XDEX" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "browser-action-card", onClick: () => handleNavigate("https://bridge.x1.xyz/"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "browser-action-icon", style: { background: "rgba(20, 241, 149, 0.15)", color: "#14F195" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "4", y1: "22", x2: "4", y2: "15" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "20", y1: "22", x2: "20", y2: "15" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "browser-action-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "browser-action-title", children: "Bridge Assets" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "browser-action-desc", children: "Cross-chain transfer" })
          ] })
        ] })
      ] })
    ] })
  ] });
}
function WalletMain({ wallet, userTokens: initialTokens = [], onTokensUpdate, onSend, onReceive, onSwap, onBridge, onStake, onSettings, onCreateWallet, onImportWallet, onHardwareWallet, activityRefreshKey: externalRefreshKey = 0, balanceRefreshKey = 0, onTokenClick }) {
  var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const [activeTab, setActiveTab] = reactExports.useState("tokens");
  const [bottomNav, setBottomNav] = reactExports.useState("assets");
  const [showNetworkPanel, setShowNetworkPanel] = reactExports.useState(false);
  const [showWalletPanel, setShowWalletPanel] = reactExports.useState(false);
  const [walletPanelKey, setWalletPanelKey] = reactExports.useState(0);
  const [showAddWalletPanel, setShowAddWalletPanel] = reactExports.useState(false);
  const [showMoreMenu, setShowMoreMenu] = reactExports.useState(false);
  const [copied, setCopied] = reactExports.useState(false);
  const [editingWalletId, setEditingWalletId] = reactExports.useState(null);
  const [showRecoveryFor, setShowRecoveryFor] = reactExports.useState(null);
  const [isRefreshing, setIsRefreshing] = reactExports.useState(false);
  const [lastRefresh, setLastRefresh] = reactExports.useState(Date.now());
  const [tokens2, setTokens] = reactExports.useState(() => {
    var _a3;
    if ((_a3 = wallet.wallet) == null ? void 0 : _a3.publicKey) {
      const cached = getCachedTokens(wallet.wallet.publicKey, wallet.network);
      if (cached && cached.length > 0) {
        logger$1.log("[WalletMain] Initialized from cache:", cached.length, "tokens");
        return cached;
      }
    }
    return initialTokens;
  });
  const [tokensLoading, setTokensLoading] = reactExports.useState(() => {
    var _a3;
    if ((_a3 = wallet.wallet) == null ? void 0 : _a3.publicKey) {
      const cached = getCachedTokens(wallet.wallet.publicKey, wallet.network);
      if (cached && cached.length > 0) return false;
    }
    return initialTokens.length === 0;
  });
  const [copiedTokenMint, setCopiedTokenMint] = reactExports.useState(null);
  const [showHiddenTokens, setShowHiddenTokens] = reactExports.useState(false);
  const [hiddenTokens, setHiddenTokens] = reactExports.useState(() => {
    try {
      const saved = localStorage.getItem("x1wallet_hidden_tokens");
      return saved ? JSON.parse(saved) : [];
    } catch {
      return [];
    }
  });
  const [internalRefreshKey, setInternalRefreshKey] = reactExports.useState(0);
  const [tokenRefreshKey, setTokenRefreshKey] = reactExports.useState(0);
  const [prevBalanceRefreshKey, setPrevBalanceRefreshKey] = reactExports.useState(0);
  const lastManualRefresh = reactExports.useRef(0);
  const currentWalletRef = reactExports.useRef((_a2 = wallet.wallet) == null ? void 0 : _a2.publicKey);
  const currentNetworkRef = reactExports.useRef(wallet.network);
  reactExports.useEffect(() => {
    if (initialTokens.length > 0 && tokens2.length === 0) {
      setTokens(initialTokens);
      setTokensLoading(false);
    }
  }, [initialTokens]);
  reactExports.useEffect(() => {
    var _a3;
    if (((_a3 = wallet.wallet) == null ? void 0 : _a3.publicKey) && wallet.balance !== void 0 && wallet.balance !== null) {
      setCachedBalance(wallet.wallet.publicKey, wallet.network, wallet.balance);
    }
  }, [wallet.balance, (_b2 = wallet.wallet) == null ? void 0 : _b2.publicKey, wallet.network]);
  reactExports.useEffect(() => {
    const shouldOpenNetwork = sessionStorage.getItem("openNetworkPanel");
    if (shouldOpenNetwork === "true") {
      sessionStorage.removeItem("openNetworkPanel");
      setShowNetworkPanel(true);
    }
  }, []);
  const activityRefreshKey = internalRefreshKey + externalRefreshKey;
  const networkConfig = getNetworkConfig(wallet.network) || NETWORKS["X1 Mainnet"];
  const isSolana = (_c = wallet.network) == null ? void 0 : _c.includes("Solana");
  const tokensUsdValue = tokens2.reduce((total, token) => {
    let price = token.price || 0;
    if (token.symbol === "USDC" || token.symbol === "USDT" || token.symbol === "USDC.X") {
      price = 1;
    } else if (token.symbol === "pXNT") {
      price = 1;
    } else if (token.symbol === "WXNT") {
      price = 1;
    }
    const tokenValue = (token.uiAmount || 0) * price;
    logger$1.log("[Portfolio] Token:", token.symbol, "uiAmount:", token.uiAmount, "price:", price, "value:", tokenValue);
    return total + tokenValue;
  }, 0);
  const displayBalance = (() => {
    var _a3;
    if (wallet.balance !== void 0 && wallet.balance !== null && wallet.balance > 0) {
      return wallet.balance;
    }
    if ((_a3 = wallet.wallet) == null ? void 0 : _a3.publicKey) {
      const cached = getCachedBalance(wallet.wallet.publicKey, wallet.network);
      if (cached !== null) {
        return cached;
      }
    }
    return wallet.balance || 0;
  })();
  const nativePrice = isSolana ? 150 : 1;
  const nativeUsdValue = displayBalance * nativePrice;
  const totalPortfolioUsd = tokensUsdValue + nativeUsdValue;
  logger$1.log("[Portfolio] Total USD:", totalPortfolioUsd, "tokens:", tokensUsdValue, "native:", nativeUsdValue);
  const formatUsd = (value) => {
    if (value === null || value === void 0 || isNaN(value)) return "$0.00";
    if (value === 0) return "$0.00";
    if (value < 0.01) return "<$0.01";
    return "$" + value.toLocaleString(void 0, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  };
  const formatBalance2 = (balance, maxDecimals = 6) => {
    if (balance === 0 || balance === null || balance === void 0) return "0";
    if (balance < 1e-6) return balance.toExponential(2);
    if (balance >= 1e3) {
      return balance.toLocaleString(void 0, { maximumFractionDigits: maxDecimals });
    }
    const fixed = balance.toFixed(maxDecimals);
    return parseFloat(fixed).toString();
  };
  const toggleHiddenToken = (tokenMint) => {
    setHiddenTokens((prev) => {
      const newHidden = prev.includes(tokenMint) ? prev.filter((m2) => m2 !== tokenMint) : [...prev, tokenMint];
      localStorage.setItem("x1wallet_hidden_tokens", JSON.stringify(newHidden));
      return newHidden;
    });
  };
  const editingWallet = editingWalletId ? (_d = wallet.wallets) == null ? void 0 : _d.find((w2) => w2.id === editingWalletId) : null;
  const fetchTokens = async (isInitialLoad = false, forceRefresh = false, mode = null) => {
    var _a3, _b3;
    if (!((_a3 = wallet.wallet) == null ? void 0 : _a3.publicKey) || !(networkConfig == null ? void 0 : networkConfig.rpcUrl)) {
      logger$1.log("[WalletMain] Cannot fetch tokens - missing:", {
        publicKey: (_b3 = wallet.wallet) == null ? void 0 : _b3.publicKey,
        rpcUrl: networkConfig == null ? void 0 : networkConfig.rpcUrl,
        network: wallet.network
      });
      return;
    }
    const fetchMode = mode || (isInitialLoad ? "import" : "refresh");
    const fetchWallet = wallet.wallet.publicKey;
    const fetchNetwork = wallet.network;
    const cacheKey = getFetchCacheKey(fetchWallet, fetchNetwork);
    if (!forceRefresh && !isInitialLoad) {
      const lastFetch = lastFetchTime.get(cacheKey);
      if (lastFetch && Date.now() - lastFetch < FETCH_DEBOUNCE_MS) {
        logger$1.log("[WalletMain] Skipping fetch - too recent:", Date.now() - lastFetch, "ms ago");
        return;
      }
    }
    if (pendingFetches.has(cacheKey)) {
      logger$1.log("[WalletMain] Reusing pending fetch for:", cacheKey);
      return pendingFetches.get(cacheKey);
    }
    logger$1.log("[WalletMain] Fetching tokens for:", fetchWallet, "on", fetchNetwork, "mode:", fetchMode);
    if (isInitialLoad && tokens2.length === 0) {
      setTokensLoading(true);
    }
    const fetchPromise = (async () => {
      try {
        const handleTokenUpdate = (updatedTokens) => {
          if (currentWalletRef.current !== fetchWallet || currentNetworkRef.current !== fetchNetwork) {
            logger$1.log("[WalletMain] Ignoring stale background update");
            return;
          }
          const tokenList2 = updatedTokens.filter((token) => {
            const isNFT = token.decimals === 0 && token.uiAmount === 1;
            return !isNFT;
          });
          logger$1.log("[WalletMain] Background token update:", tokenList2.length, "tokens");
          setTokens(tokenList2);
          setCachedTokens(fetchWallet, fetchNetwork, tokenList2);
          if (onTokensUpdate) onTokensUpdate(tokenList2);
        };
        const allTokens = await fetchTokenAccounts(networkConfig.rpcUrl, fetchWallet, fetchNetwork, handleTokenUpdate, { mode: fetchMode, forceRefresh });
        lastFetchTime.set(cacheKey, Date.now());
        if (currentWalletRef.current !== fetchWallet || currentNetworkRef.current !== fetchNetwork) {
          logger$1.log("[WalletMain] Ignoring stale fetch result");
          return;
        }
        const tokenList = allTokens.filter((token) => {
          const isNFT = token.decimals === 0 && token.uiAmount === 1;
          return !isNFT;
        });
        logger$1.log("[WalletMain] Fetched tokens:", tokenList.length);
        setTokens(tokenList);
        setCachedTokens(fetchWallet, fetchNetwork, tokenList);
        preloadTokenImages(tokenList);
        if (onTokensUpdate) onTokensUpdate(tokenList);
      } catch (err) {
        logger$1.error("[WalletMain] Failed to fetch tokens:", err);
      } finally {
        pendingFetches.delete(cacheKey);
        if (currentWalletRef.current === fetchWallet && currentNetworkRef.current === fetchNetwork) {
          setTokensLoading(false);
        }
      }
    })();
    pendingFetches.set(cacheKey, fetchPromise);
    return fetchPromise;
  };
  const prevTokenRefreshKeyRef = reactExports.useRef(0);
  reactExports.useEffect(() => {
    var _a3;
    if (tokenRefreshKey > prevTokenRefreshKeyRef.current) {
      prevTokenRefreshKeyRef.current = tokenRefreshKey;
      logger$1.log("[WalletMain] Token refresh triggered by key change:", tokenRefreshKey);
      if (((_a3 = wallet.wallet) == null ? void 0 : _a3.publicKey) && (networkConfig == null ? void 0 : networkConfig.rpcUrl)) {
        fetchTokens(false, true);
      }
    }
  }, [tokenRefreshKey, (_e = wallet.wallet) == null ? void 0 : _e.publicKey, networkConfig == null ? void 0 : networkConfig.rpcUrl]);
  reactExports.useEffect(() => {
    var _a3;
    if (balanceRefreshKey > prevBalanceRefreshKey) {
      logger$1.log("[WalletMain] Balance refresh triggered by key change");
      setPrevBalanceRefreshKey(balanceRefreshKey);
      lastManualRefresh.current = Date.now();
      if ((_a3 = wallet.wallet) == null ? void 0 : _a3.publicKey) {
        invalidateRPCCache(wallet.wallet.publicKey);
        wallet.refreshBalance();
        fetchTokens(false, true);
      }
    }
  }, [balanceRefreshKey, prevBalanceRefreshKey, (_f = wallet.wallet) == null ? void 0 : _f.publicKey]);
  const prevNetworkRef = reactExports.useRef(wallet.network);
  const prevWalletRef = reactExports.useRef((_g = wallet.wallet) == null ? void 0 : _g.publicKey);
  const lastTxRefreshRef = reactExports.useRef(0);
  const lastKnownTxTimeRef = reactExports.useRef(0);
  reactExports.useEffect(() => {
    const handleRuntimeMessage = (message) => {
      var _a3;
      if (message.type === "balance-refresh-needed") {
        const now = Date.now();
        if (now - lastTxRefreshRef.current < 1500) {
          logger$1.log("[WalletMain] Skipping duplicate refresh signal");
          return;
        }
        lastTxRefreshRef.current = now;
        logger$1.log("[WalletMain] Received balance-refresh-needed signal - refreshing immediately");
        if ((_a3 = wallet.wallet) == null ? void 0 : _a3.publicKey) {
          invalidateRPCCache(wallet.wallet.publicKey);
          wallet.refreshBalance();
          setTokenRefreshKey((prev) => prev + 1);
          setInternalRefreshKey((prev) => prev + 1);
        }
      }
    };
    const handleStorageChange = (changes, areaName) => {
      var _a3;
      if (areaName === "local" && changes.x1wallet_last_tx_time) {
        const newTxTime = changes.x1wallet_last_tx_time.newValue;
        if (newTxTime && newTxTime > lastKnownTxTimeRef.current) {
          lastKnownTxTimeRef.current = newTxTime;
          const now = Date.now();
          if (now - lastTxRefreshRef.current < 1500) {
            return;
          }
          lastTxRefreshRef.current = now;
          logger$1.log("[WalletMain] Detected transaction via storage change - refreshing");
          if ((_a3 = wallet.wallet) == null ? void 0 : _a3.publicKey) {
            invalidateRPCCache(wallet.wallet.publicKey);
            wallet.refreshBalance();
            setTokenRefreshKey((prev) => prev + 1);
            setInternalRefreshKey((prev) => prev + 1);
          }
        }
      }
    };
    const checkForMissedTransactions = async () => {
      var _a3;
      if (typeof chrome !== "undefined" && chrome.storage) {
        try {
          const result = await chrome.storage.local.get("x1wallet_last_tx_time");
          const lastTxTime = result.x1wallet_last_tx_time || 0;
          if (lastTxTime > lastKnownTxTimeRef.current) {
            logger$1.log("[WalletMain] Found missed transaction, triggering refresh");
            lastKnownTxTimeRef.current = lastTxTime;
            if ((_a3 = wallet.wallet) == null ? void 0 : _a3.publicKey) {
              invalidateRPCCache(wallet.wallet.publicKey);
              wallet.refreshBalance();
              setTokenRefreshKey((prev) => prev + 1);
              setInternalRefreshKey((prev) => prev + 1);
            }
          }
        } catch (e) {
        }
      }
    };
    checkForMissedTransactions();
    const pollInterval = setInterval(checkForMissedTransactions, 2e3);
    if (typeof chrome !== "undefined" && chrome.runtime) {
      chrome.runtime.onMessage.addListener(handleRuntimeMessage);
    }
    if (typeof chrome !== "undefined" && chrome.storage) {
      chrome.storage.onChanged.addListener(handleStorageChange);
    }
    return () => {
      clearInterval(pollInterval);
      if (typeof chrome !== "undefined" && chrome.runtime) {
        chrome.runtime.onMessage.removeListener(handleRuntimeMessage);
      }
      if (typeof chrome !== "undefined" && chrome.storage) {
        chrome.storage.onChanged.removeListener(handleStorageChange);
      }
    };
  }, [(_h = wallet.wallet) == null ? void 0 : _h.publicKey, wallet.refreshBalance]);
  reactExports.useEffect(() => {
    var _a3, _b3, _c2, _d2, _e2;
    const networkChanged = prevNetworkRef.current !== wallet.network;
    const walletChanged = prevWalletRef.current !== ((_a3 = wallet.wallet) == null ? void 0 : _a3.publicKey);
    prevNetworkRef.current = wallet.network;
    prevWalletRef.current = (_b3 = wallet.wallet) == null ? void 0 : _b3.publicKey;
    currentWalletRef.current = (_c2 = wallet.wallet) == null ? void 0 : _c2.publicKey;
    currentNetworkRef.current = wallet.network;
    if (walletChanged || networkChanged) {
      logger$1.log("[WalletMain] Wallet/network changed - network:", networkChanged, "wallet:", walletChanged);
      const newCacheKey = getFetchCacheKey((_d2 = wallet.wallet) == null ? void 0 : _d2.publicKey, wallet.network);
      lastFetchTime.delete(newCacheKey);
      if ((_e2 = wallet.wallet) == null ? void 0 : _e2.publicKey) {
        const cachedTokens = getCachedTokens(wallet.wallet.publicKey, wallet.network);
        if (cachedTokens && cachedTokens.length > 0) {
          logger$1.log("[WalletMain] Using cached tokens:", cachedTokens.length);
          setTokens(cachedTokens);
          setTokensLoading(false);
          preloadTokenImages(cachedTokens);
        } else {
          setTokens([]);
          setTokensLoading(true);
        }
        logger$1.log("[WalletMain] Fetching fresh data in background");
        Promise.all([
          wallet.refreshBalance(),
          fetchTokens((cachedTokens == null ? void 0 : cachedTokens.length) === 0, true)
          // forceRefresh=true for new wallet/network
        ]).catch(logger$1.error);
        setInternalRefreshKey((prev) => prev + 1);
      } else {
        setTokens([]);
        setTokensLoading(true);
      }
    }
    const tokenInterval = setInterval(() => {
      var _a4;
      if (Date.now() - lastManualRefresh.current < 8e3) {
        logger$1.log("[WalletMain] Skipping interval refresh - manual refresh was recent");
        return;
      }
      if ((_a4 = wallet.wallet) == null ? void 0 : _a4.publicKey) {
        Promise.all([
          wallet.refreshBalance().catch(logger$1.error),
          fetchTokens(false, true)
          // forceRefresh=true to bypass debounce and get fresh data
        ]).then(() => {
          setLastRefresh(Date.now());
        });
      }
    }, 1e4);
    const activityInterval = setInterval(() => {
      var _a4;
      if ((_a4 = wallet.wallet) == null ? void 0 : _a4.publicKey) {
        setInternalRefreshKey((prev) => prev + 1);
      }
    }, 3e4);
    return () => {
      clearInterval(tokenInterval);
      clearInterval(activityInterval);
    };
  }, [(_i = wallet.wallet) == null ? void 0 : _i.publicKey, wallet.network]);
  const copyAddress = () => {
    var _a3;
    navigator.clipboard.writeText(((_a3 = wallet.wallet) == null ? void 0 : _a3.publicKey) || "");
    setCopied(true);
    setTimeout(() => setCopied(false), 2e3);
  };
  if (bottomNav === "browser") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "screen main-screen", children: /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserScreen, { wallet, onBack: () => setBottomNav("assets") }) });
  }
  ((_k = (_j = wallet.wallet) == null ? void 0 : _j.publicKey) == null ? void 0 : _k.slice(-5)) || "";
  ((_l = wallet.wallet) == null ? void 0 : _l.avatar) && wallet.wallet.avatar.startsWith("data:image");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen main-screen", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "main-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-brand", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "/icons/48-x1.png", alt: "X1 Wallet", style: { width: 32, height: 32, objectFit: "contain" } }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-center-area", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "wallet-selector-btn", onClick: () => {
        setWalletPanelKey((k2) => k2 + 1);
        setShowWalletPanel(true);
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "header-copy-icon",
            onClick: (e) => {
              e.stopPropagation();
              copyAddress();
            },
            title: copied ? "Copied!" : "Copy address",
            children: copied ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "var(--success)", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-divider" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallet-selector-name", children: ((_m = wallet.wallet) == null ? void 0 : _m.name) || "Wallet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "10", height: "10", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2.5", className: "selector-arrow", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6 9l6 6 6-6" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-divider" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "header-network-icon",
            onClick: (e) => {
              e.stopPropagation();
              setShowNetworkPanel(true);
            },
            title: "Change network",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(NetworkLogo$2, { network: wallet.network, size: 18 })
          }
        )
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-actions", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "header-action-btn",
          onClick: async () => {
            try {
              if (typeof chrome !== "undefined" && chrome.windows) {
                const currentWindow = await chrome.windows.getCurrent();
                await chrome.sidePanel.open({ windowId: currentWindow.id });
                window.close();
              }
            } catch (e) {
              logger$1.log("Side panel not available:", e);
            }
          },
          title: "Open in Side Panel",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "18", height: "18", rx: "2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "15", y1: "3", x2: "15", y2: "21" })
          ] })
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tabs", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: `tab ${activeTab === "tokens" ? "active" : ""}`, onClick: () => setActiveTab("tokens"), children: "Tokens" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: `tab ${activeTab === "defi" ? "active" : ""}`, onClick: () => setActiveTab("defi"), children: "DeFi" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: `tab ${activeTab === "nfts" ? "active" : ""}`, onClick: () => setActiveTab("nfts"), children: "NFTs" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: `tab ${activeTab === "activity" ? "active" : ""}`, onClick: () => setActiveTab("activity"), children: "Activity" })
    ] }),
    activeTab === "tokens" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "balance-row", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "balance-amount", children: formatUsd(totalPortfolioUsd) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "balance-usd", children: [
        formatBalance2(displayBalance),
        " ",
        networkConfig.symbol
      ] })
    ] }),
    activeTab === "tokens" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "action-buttons", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "action-btn", onClick: onReceive, title: "Receive", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "action-icon-sleek receive", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 5v14M5 12l7 7 7-7" }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "action-btn", onClick: () => onSend(null), title: "Send", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "action-icon-sleek send", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 19V5M5 12l7-7 7 7" }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "action-btn", onClick: onSwap, title: "Swap", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "action-icon-sleek swap", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17 2l4 4-4 4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3 11V9a4 4 0 0 1 4-4h14" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 22l-4-4 4-4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 13v2a4 4 0 0 1-4 4H3" })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "action-btn", onClick: () => setShowMoreMenu(true), title: "More", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "action-icon-sleek more", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "1.5" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "19", cy: "12", r: "1.5" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "5", cy: "12", r: "1.5" })
      ] }) }) })
    ] }),
    showMoreMenu && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "slide-panel-overlay", onClick: () => setShowMoreMenu(false), children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "slide-panel small", onClick: (e) => e.stopPropagation(), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "more-menu-item", onClick: () => {
        setShowMoreMenu(false);
        onBridge();
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "more-menu-icon bridge", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "4", y1: "22", x2: "4", y2: "15" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "20", y1: "22", x2: "20", y2: "15" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "more-menu-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "more-menu-title", children: "Bridge" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "more-menu-desc", children: "Transfer across chains" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "more-menu-item", onClick: () => {
        logger$1.log("[WalletMain] Stake clicked");
        setShowMoreMenu(false);
        onStake();
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "more-menu-icon stake", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2L2 7l10 5 10-5-10-5z" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2 17l10 5 10-5" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2 12l10 5 10-5" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "more-menu-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "more-menu-title", children: "Stake" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "more-menu-desc", children: "Earn rewards on your tokens" })
        ] })
      ] })
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "main-content", children: [
      activeTab === "tokens" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-list", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "token-item clickable",
            onClick: () => onTokenClick ? onTokenClick({
              symbol: networkConfig.symbol,
              name: isSolana ? "Solana" : "X1 Native Token",
              balance: displayBalance,
              uiAmount: displayBalance,
              mint: null,
              isNative: true,
              logoURI: null,
              usdValue: nativeUsdValue
            }) : onSend(null),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(NetworkLogo$2, { network: wallet.network, size: 40 }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-info", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-name", children: isSolana ? "Solana" : "X1 Native Token" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "token-amount-sub", children: [
                  formatBalance2(displayBalance),
                  " ",
                  networkConfig.symbol
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-balance", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-usd", children: formatUsd(nativeUsdValue) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-change neutral", children: "0.00%" })
              ] })
            ]
          }
        ),
        tokensLoading && tokens2.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-loading", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner-small" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Loading tokens..." })
        ] }),
        tokens2.filter((token) => showHiddenTokens || !hiddenTokens.includes(token.mint)).map((token) => {
          var _a3;
          const isHidden = hiddenTokens.includes(token.mint);
          const tokenName = (token.name || "").toLowerCase();
          const tokenSymbol = (token.symbol || "").toUpperCase();
          const isLP = token.isLPToken === true || tokenSymbol === "XLP" || tokenSymbol === "SLP" || tokenSymbol.includes("XLP") || // NEW: catches "WXNT-USDC.X XLP" symbol
          tokenSymbol.includes("SLP") || // NEW: catches SLP variants
          tokenName.includes("xlp") || // NEW: catches "wxnt-usdc.x xlp"
          tokenName.includes(" lp") || tokenName.includes("lp token") || tokenName.includes("/") || tokenName.includes("xdex") && tokenName.includes("lp");
          const effectiveLogoUrl = isLP ? XLP_ICON_PATH : token.logoURI;
          const hasLogo = effectiveLogoUrl && (effectiveLogoUrl.startsWith("http") || effectiveLogoUrl.startsWith("/"));
          if (isLP || tokenName.includes("lp") || tokenName.includes("xlp") || tokenSymbol.includes("XLP")) {
            console.log("[LP Check]", {
              name: token.name,
              symbol: token.symbol,
              isLPToken: token.isLPToken,
              detected: isLP,
              effectiveLogoUrl,
              hasLogo
            });
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `token-item clickable${isHidden ? " token-hidden" : ""}`,
              onClick: () => onTokenClick ? onTokenClick(token) : onSend(token),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-icon", children: [
                  hasLogo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "img",
                    {
                      src: effectiveLogoUrl,
                      alt: token.symbol,
                      className: "token-logo",
                      onError: (e) => {
                        console.error("[Image Load Failed]", effectiveLogoUrl, "for", token.name);
                        e.target.style.display = "none";
                        if (e.target.nextSibling) {
                          e.target.nextSibling.style.display = "flex";
                        }
                      },
                      onLoad: () => {
                        if (isLP) console.log("[LP Icon Loaded]", effectiveLogoUrl);
                      }
                    }
                  ) : null,
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: `token-logo-fallback ${token.symbol === "pXNT" ? "pxnt" : ""} ${isLP ? "lp-token" : ""}`,
                      style: { display: hasLogo ? "none" : "flex" },
                      children: isLP ? "LP" : token.symbol === "pXNT" ? "pXNT" : ((_a3 = token.symbol) == null ? void 0 : _a3.charAt(0)) || "?"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-info", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-name-row", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-name", children: token.name || "Unknown Token" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        className: "token-copy-btn",
                        onClick: (e) => {
                          e.stopPropagation();
                          navigator.clipboard.writeText(token.mint);
                          setCopiedTokenMint(token.mint);
                          setTimeout(() => setCopiedTokenMint(null), 2e3);
                        },
                        title: "Copy token address",
                        children: copiedTokenMint === token.mint ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "var(--success)", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "2", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })
                        ] })
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        className: "token-hide-btn",
                        onClick: (e) => {
                          e.stopPropagation();
                          toggleHiddenToken(token.mint);
                        },
                        title: isHidden ? "Show token" : "Hide token",
                        children: isHidden ? /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "2", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
                        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "2", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
                        ] })
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "token-amount-sub", children: [
                    (token.uiAmount || 0).toLocaleString(void 0, { maximumFractionDigits: 6 }),
                    " ",
                    token.symbol
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-balance", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-usd", children: (() => {
                    let price = token.price;
                    if (token.symbol === "USDC" || token.symbol === "USDT" || token.symbol === "USDC.X") {
                      price = 1;
                    } else if (token.symbol === "pXNT") {
                      price = 1;
                    } else if (token.symbol === "WXNT") {
                      price = 1;
                    }
                    if (price === void 0 || price === null) {
                      return "--";
                    }
                    const value = (token.uiAmount || 0) * price;
                    return value > 0 ? `$${value.toLocaleString(void 0, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` : "$0.00";
                  })() }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-change neutral", children: "0.00%" })
                ] })
              ]
            },
            token.address
          );
        }),
        hiddenTokens.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            className: "show-hidden-tokens-btn",
            onClick: () => setShowHiddenTokens(!showHiddenTokens),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: showHiddenTokens ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
              ] }) }),
              showHiddenTokens ? "Hide" : "Show",
              " ",
              hiddenTokens.length,
              " hidden token",
              hiddenTokens.length !== 1 ? "s" : ""
            ]
          }
        )
      ] }),
      activeTab === "nfts" && /* @__PURE__ */ jsxRuntimeExports.jsx(NFTsTab, { wallet, networkConfig }),
      activeTab === "defi" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DefiTab,
        {
          wallet,
          tokens: tokens2,
          isSolana,
          onStake
        }
      ),
      activeTab === "activity" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        ActivityList,
        {
          walletAddress: (_n = wallet.wallet) == null ? void 0 : _n.publicKey,
          network: wallet.network,
          networkConfig,
          refreshKey: activityRefreshKey
        }
      )
    ] }),
    showNetworkPanel && /* @__PURE__ */ jsxRuntimeExports.jsx(
      NetworkPanel,
      {
        network: wallet.network,
        networks: NETWORKS,
        onSelect: wallet.setNetwork,
        onClose: () => setShowNetworkPanel(false)
      }
    ),
    showWalletPanel && /* @__PURE__ */ jsxRuntimeExports.jsx(
      WalletPanel,
      {
        wallets: wallet.wallets,
        activeId: wallet.activeWalletId,
        network: wallet.network,
        onSelect: wallet.switchWallet,
        onClose: () => setShowWalletPanel(false),
        onEditWallet: (w2) => setEditingWalletId(w2.id),
        onShowAddWallet: () => setShowAddWalletPanel(true),
        onReorderWallets: wallet.reorderWallets
      },
      walletPanelKey
    ),
    showAddWalletPanel && /* @__PURE__ */ jsxRuntimeExports.jsx(
      AddWalletPanel,
      {
        onClose: () => setShowAddWalletPanel(false),
        onCreateNew: onCreateWallet,
        onImport: onImportWallet,
        onHardware: onHardwareWallet
      }
    ),
    editingWallet && /* @__PURE__ */ jsxRuntimeExports.jsx(
      EditWalletPanel,
      {
        walletData: {
          ...editingWallet,
          walletActions: {
            showRecoveryPhrase: (walletId) => {
              var _a3;
              const w2 = wallet.getWalletForBackup ? wallet.getWalletForBackup(walletId) : (_a3 = wallet.wallets) == null ? void 0 : _a3.find((w22) => w22.id === walletId);
              if (w2) setShowRecoveryFor(w2);
            }
          }
        },
        onSave: (updatedWallet) => {
          wallet.updateWallet(updatedWallet.id, { name: updatedWallet.name, avatar: updatedWallet.avatar });
          setEditingWalletId(null);
        },
        onClose: () => setEditingWalletId(null),
        onRemove: (walletId) => {
          wallet.removeWallet(walletId);
          setEditingWalletId(null);
        }
      }
    ),
    showRecoveryFor && /* @__PURE__ */ jsxRuntimeExports.jsx(
      RecoveryPhrasePanel,
      {
        wallet: showRecoveryFor,
        onClose: () => setShowRecoveryFor(null)
      }
    )
  ] });
}
function ViewKeysModal({ wallet, onClose }) {
  var _a2;
  const [showPrivate, setShowPrivate] = reactExports.useState(false);
  const [showSeed, setShowSeed] = reactExports.useState(false);
  const [copied, setCopied] = reactExports.useState("");
  const copy = (text, type) => {
    navigator.clipboard.writeText(text);
    setCopied(type);
    setTimeout(() => setCopied(""), 2e3);
  };
  if (wallet.type === "ledger") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Wallet Keys" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, children: "" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "warning-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Hardware wallet keys are stored securely on your device and cannot be exported." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "key-display", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Public Address" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "key-value", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: wallet.publicKey }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => copy(wallet.publicKey, "public"), children: copied === "public" ? "" : "Copy" })
          ] })
        ] })
      ] })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content large", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Wallet Keys" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "warning-box danger", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Never share your private key or seed phrase. Anyone with access can steal your funds!" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "key-display", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Public Address" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "key-value", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: wallet.publicKey }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => copy(wallet.publicKey, "public"), children: copied === "public" ? "" : "Copy" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "key-display", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Private Key" }),
        !showPrivate ? /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "reveal-btn", onClick: () => setShowPrivate(true), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
          ] }),
          "Reveal Private Key"
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "key-value private", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: wallet.privateKey }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => copy(wallet.privateKey, "private"), children: copied === "private" ? "" : "Copy" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "key-display", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Seed Phrase" }),
        !showSeed ? /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "reveal-btn", onClick: () => setShowSeed(true), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
          ] }),
          "Reveal Seed Phrase"
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "seed-grid compact", children: (_a2 = wallet.mnemonic) == null ? void 0 : _a2.split(" ").map((word, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "seed-word", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "seed-number", children: i + 1 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "seed-text", children: word })
          ] }, i)) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-copy", onClick: () => copy(wallet.mnemonic, "seed"), children: copied === "seed" ? " Copied!" : "Copy Seed Phrase" })
        ] })
      ] })
    ] })
  ] }) });
}
function EditWalletModal({ wallet, onSave, onClose }) {
  const [name, setName] = reactExports.useState(wallet.name);
  const handleSave = () => {
    onSave({ name });
    onClose();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Edit Wallet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: onClose, children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-body", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Wallet Name" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          className: "form-input",
          value: name,
          onChange: (e) => setName(e.target.value),
          placeholder: "My Wallet"
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-footer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-secondary", onClick: onClose, children: "Cancel" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: handleSave, children: "Save" })
    ] })
  ] }) });
}
function formatBalance(balance) {
  if (balance === null || balance === void 0) return "...";
  if (balance === 0) return "0";
  if (balance < 1e-3) return "<0.001";
  if (balance < 1) return balance.toFixed(4);
  if (balance < 1e3) return balance.toFixed(2);
  if (balance < 1e6) return (balance / 1e3).toFixed(2) + "K";
  return (balance / 1e6).toFixed(2) + "M";
}
function WalletManager({ wallet, onBack, onCreateWallet, onImportWallet, onHardwareWallet }) {
  var _a2;
  const [showAddModal, setShowAddModal] = reactExports.useState(false);
  const [showKeysModal, setShowKeysModal] = reactExports.useState(null);
  const [showEditModal, setShowEditModal] = reactExports.useState(null);
  const [confirmDelete, setConfirmDelete] = reactExports.useState(null);
  const [balances, setBalances] = reactExports.useState({});
  const [loadingBalances, setLoadingBalances] = reactExports.useState(true);
  reactExports.useEffect(() => {
    var _a3;
    const fetchBalances = async () => {
      var _a4, _b2, _c, _d, _e;
      setLoadingBalances(true);
      const newBalances = {};
      for (const w2 of wallet.wallets) {
        try {
          const address = w2.publicKey || ((_b2 = (_a4 = w2.addresses) == null ? void 0 : _a4[0]) == null ? void 0 : _b2.publicKey);
          if (!address) continue;
          const rpcUrl = ((_c = wallet.network) == null ? void 0 : _c.includes("Devnet")) ? "https://api.devnet.solana.com" : ((_d = wallet.network) == null ? void 0 : _d.includes("Testnet")) ? "https://api.testnet.solana.com" : "https://xolana.xen.network";
          const response = await fetch(rpcUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              jsonrpc: "2.0",
              id: 1,
              method: "getBalance",
              params: [address]
            })
          });
          const data = await response.json();
          if (((_e = data.result) == null ? void 0 : _e.value) !== void 0) {
            newBalances[w2.id] = data.result.value / 1e9;
          }
        } catch (err) {
          logger$1.error(`Failed to fetch balance for ${w2.name}:`, err);
          newBalances[w2.id] = null;
        }
      }
      setBalances(newBalances);
      setLoadingBalances(false);
    };
    if (((_a3 = wallet.wallets) == null ? void 0 : _a3.length) > 0) {
      fetchBalances();
    }
  }, [wallet.wallets, wallet.network]);
  const handleRemove = (w2) => {
    if (confirmDelete === w2.id) {
      wallet.removeWallet(w2.id);
      setConfirmDelete(null);
    } else {
      setConfirmDelete(w2.id);
      setTimeout(() => setConfirmDelete(null), 3e3);
    }
  };
  const handleAddOption = (type) => {
    setShowAddModal(false);
    if (type === "create") onCreateWallet();
    else if (type === "import") onImportWallet();
    else if (type === "hardware") onHardwareWallet == null ? void 0 : onHardwareWallet();
  };
  const tokenSymbol = ((_a2 = wallet.network) == null ? void 0 : _a2.includes("Solana")) ? "SOL" : "X1";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: onBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Manage Wallets" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallet-list", children: wallet.wallets.map((w2) => {
        var _a3, _b2;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `wallet-card ${wallet.activeWalletId === w2.id ? "active" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-card-main", onClick: () => wallet.switchWallet(w2.id), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallet-card-icon", children: w2.type === "ledger" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "6", width: "20", height: "12", rx: "2" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 12h.01" })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20 12V8H6a2 2 0 0 1-2-2c0-1.1.9-2 2-2h12v4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4 6v12c0 1.1.9 2 2 2h14v-4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18 12a2 2 0 0 0-2 2c0 1.1.9 2 2 2h4v-4h-4z" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-card-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", width: "100%" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallet-card-name", children: w2.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
                  fontSize: 13,
                  fontWeight: 600,
                  color: balances[w2.id] > 0 ? "var(--success)" : "var(--text-muted)",
                  marginLeft: 8
                }, children: loadingBalances ? "..." : `${formatBalance(balances[w2.id])} ${tokenSymbol}` })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "wallet-card-address", children: [
                (_a3 = w2.publicKey) == null ? void 0 : _a3.slice(0, 8),
                "...",
                (_b2 = w2.publicKey) == null ? void 0 : _b2.slice(-6)
              ] }),
              w2.type === "ledger" && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallet-badge", children: "Ledger" })
            ] }),
            wallet.activeWalletId === w2.id && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallet-active-badge", children: "Active" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-card-actions", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "wallet-action-btn", onClick: () => setShowEditModal(w2), title: "Edit", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "wallet-action-btn", onClick: () => setShowKeysModal(w2), title: "View Keys", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4" }) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: `wallet-action-btn danger ${confirmDelete === w2.id ? "confirming" : ""}`,
                onClick: () => handleRemove(w2),
                title: "Remove",
                children: confirmDelete === w2.id ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 10 }, children: "Confirm?" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "3 6 5 6 21 6" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" })
                ] })
              }
            )
          ] })
        ] }, w2.id);
      }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "add-wallet-btn", onClick: () => setShowAddModal(true), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 8v8M8 12h8" })
        ] }),
        "Add Wallet"
      ] })
    ] }),
    showAddModal && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay", onClick: () => setShowAddModal(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content large", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Add Wallet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal-close", onClick: () => setShowAddModal(false), children: "" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-body", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "add-wallet-options", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "add-wallet-option", onClick: () => handleAddOption("create"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "option-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 5v14M5 12h14" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "option-text", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "option-title", children: "Create New Wallet" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "option-desc", children: "Generate a new seed phrase" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "add-wallet-option", onClick: () => handleAddOption("import"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "option-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "7 10 12 15 17 10" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "15", x2: "12", y2: "3" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "option-text", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "option-title", children: "Import Wallet" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "option-desc", children: "Use existing seed phrase" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "add-wallet-option", onClick: () => handleAddOption("hardware"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "option-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "6", width: "20", height: "12", rx: "2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 12h.01" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17 12h.01" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 12h.01" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "option-text", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "option-title", children: "Hardware Wallet" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "option-desc", children: "Connect Ledger via USB or Bluetooth" })
          ] })
        ] })
      ] }) })
    ] }) }),
    showKeysModal && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ViewKeysModal,
      {
        wallet: wallet.getWalletForBackup ? wallet.getWalletForBackup(showKeysModal.id) || showKeysModal : showKeysModal,
        onClose: () => setShowKeysModal(null)
      }
    ),
    showEditModal && /* @__PURE__ */ jsxRuntimeExports.jsx(
      EditWalletModal,
      {
        wallet: showEditModal,
        onSave: (updates) => wallet.updateWallet(showEditModal.id, updates),
        onClose: () => setShowEditModal(null)
      }
    )
  ] });
}
const storage$1 = {
  get: (key, defaultValue) => {
    try {
      return JSON.parse(localStorage.getItem(`x1wallet_${key}`)) ?? defaultValue;
    } catch {
      return defaultValue;
    }
  },
  set: (key, value) => {
    localStorage.setItem(`x1wallet_${key}`, JSON.stringify(value));
    if (typeof chrome !== "undefined" && chrome.storage) {
      chrome.storage.local.set({ [`x1wallet_${key}`]: value }).catch(() => {
      });
    }
  }
};
async function syncFromChromeStorage() {
  if (typeof chrome !== "undefined" && chrome.storage) {
    try {
      const keys = [
        "darkMode",
        "autoLock",
        "currency",
        "notifications",
        "skipSimulation",
        "passwordProtection",
        "biometricEnabled",
        "customExplorer",
        "passwordHash"
      ];
      const result = await chrome.storage.local.get(keys.map((k2) => `x1wallet_${k2}`));
      for (const key of keys) {
        const chromeKey = `x1wallet_${key}`;
        if (result[chromeKey] !== void 0) {
          localStorage.setItem(chromeKey, JSON.stringify(result[chromeKey]));
        }
      }
    } catch (e) {
    }
  }
}
async function hasPasswordSet() {
  const legacyHash = localStorage.getItem("x1wallet_passwordHash");
  if (legacyHash && legacyHash !== "null") return true;
  if (typeof chrome !== "undefined" && chrome.storage) {
    try {
      const result = await chrome.storage.local.get("x1wallet_auth");
      if (result.x1wallet_auth) return true;
    } catch (e) {
    }
  }
  const localAuth = localStorage.getItem("x1wallet_auth");
  if (localAuth) return true;
  return false;
}
function SettingsScreen({ wallet, onBack, onLock, initialPasswordProtection, onPasswordProtectionChange, onAutoLockChange }) {
  var _a2, _b2, _c, _d, _e, _f, _g, _h;
  const [subScreen, setSubScreen] = reactExports.useState(null);
  const [darkMode, setDarkMode] = reactExports.useState(() => storage$1.get("darkMode", true));
  const [autoLock, setAutoLock] = reactExports.useState(() => {
    const saved = storage$1.get("autoLock", 5);
    if (saved === -1) {
      storage$1.set("autoLock", 1440);
      return 1440;
    }
    return saved;
  });
  const [currency, setCurrency] = reactExports.useState(() => storage$1.get("currency", "USD"));
  const [notifications, setNotifications] = reactExports.useState(() => storage$1.get("notifications", true));
  const [skipSimulation, setSkipSimulation] = reactExports.useState(() => storage$1.get("skipSimulation", false));
  const [passwordProtection, setPasswordProtection] = reactExports.useState(() => storage$1.get("passwordProtection", false));
  const [hasPassword, setHasPassword] = reactExports.useState(false);
  const [biometricEnabled, setBiometricEnabled] = reactExports.useState(() => storage$1.get("biometricEnabled", false));
  const [customExplorer, setCustomExplorer] = reactExports.useState(() => storage$1.get("customExplorer", ""));
  const [copied, setCopied] = reactExports.useState(false);
  const [showRemoveConfirm, setShowRemoveConfirm] = reactExports.useState(false);
  const [appVersion, setAppVersion] = reactExports.useState("0.0.0");
  reactExports.useEffect(() => {
    try {
      if (typeof chrome !== "undefined" && chrome.runtime && chrome.runtime.getManifest) {
        const manifest = chrome.runtime.getManifest();
        setAppVersion(manifest.version || "0.0.0");
      }
    } catch (e) {
    }
  }, []);
  reactExports.useEffect(() => {
    const currentValue = storage$1.get("passwordProtection", false);
    setPasswordProtection(currentValue);
  }, []);
  reactExports.useEffect(() => {
    if (initialPasswordProtection !== void 0 && initialPasswordProtection !== passwordProtection) {
      setPasswordProtection(initialPasswordProtection);
    }
  }, [initialPasswordProtection]);
  reactExports.useEffect(() => {
    syncFromChromeStorage().then(() => {
      setDarkMode(storage$1.get("darkMode", true));
      setAutoLock(storage$1.get("autoLock", 5));
      setPasswordProtection(storage$1.get("passwordProtection", false));
    });
    hasPasswordSet().then((has) => {
      setHasPassword(has);
      if (has && storage$1.get("passwordProtection", null) === null) {
        setPasswordProtection(true);
        storage$1.set("passwordProtection", true);
        if (onPasswordProtectionChange) {
          onPasswordProtectionChange(true);
        }
      }
    });
  }, [onPasswordProtectionChange]);
  const [biometricAvailable, setBiometricAvailable] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const checkBiometric = async () => {
      try {
        const isExtension = typeof chrome !== "undefined" && chrome.runtime && chrome.runtime.id;
        if (isExtension) {
          setBiometricAvailable(false);
          return;
        }
        if (window.PublicKeyCredential) {
          const available = await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
          setBiometricAvailable(available);
        } else {
          setBiometricAvailable(false);
        }
      } catch (e) {
        setBiometricAvailable(false);
      }
    };
    checkBiometric();
  }, []);
  const [currentPassword, setCurrentPassword] = reactExports.useState("");
  const [newPassword, setNewPassword] = reactExports.useState("");
  const [confirmPassword, setConfirmPassword] = reactExports.useState("");
  const [passwordError, setPasswordError] = reactExports.useState("");
  const [passwordSuccess, setPasswordSuccess] = reactExports.useState(false);
  const [showNewPassword, setShowNewPassword] = reactExports.useState(false);
  const [recoveryView, setRecoveryView] = reactExports.useState("menu");
  const [showPhrase, setShowPhrase] = reactExports.useState(false);
  const [newMnemonic, setNewMnemonic] = reactExports.useState("");
  const [customWords, setCustomWords] = reactExports.useState(Array(12).fill(""));
  const [seedLength, setSeedLength] = reactExports.useState(12);
  const [recoveryError, setRecoveryError] = reactExports.useState("");
  const [showPrivateKey, setShowPrivateKey] = reactExports.useState(false);
  const [privateKeyView, setPrivateKeyView] = reactExports.useState("menu");
  const [importPrivateKey, setImportPrivateKey] = reactExports.useState("");
  const [privateKeyError, setPrivateKeyError] = reactExports.useState("");
  const [privateKeyCopied, setPrivateKeyCopied] = reactExports.useState(false);
  const [passwordVerified, setPasswordVerified] = reactExports.useState(false);
  const [verifyPassword2, setVerifyPassword] = reactExports.useState("");
  const [verifyError, setVerifyError] = reactExports.useState("");
  const [showAddRpc, setShowAddRpc] = reactExports.useState(false);
  const [customRpc, setCustomRpc] = reactExports.useState({ name: "", url: "", symbol: "", decimals: 9, explorer: "" });
  const [customRpcs, setCustomRpcs] = reactExports.useState(() => {
    try {
      return JSON.parse(localStorage.getItem("x1wallet_customRpcs")) || [];
    } catch {
      return [];
    }
  });
  const [error, setError] = reactExports.useState("");
  const [rpcOverrides, setRpcOverrides] = reactExports.useState(() => {
    try {
      return JSON.parse(localStorage.getItem("x1wallet_rpcOverrides")) || {};
    } catch {
      return {};
    }
  });
  const [editingRpcOverride, setEditingRpcOverride] = reactExports.useState(null);
  const [rpcOverrideUrl, setRpcOverrideUrl] = reactExports.useState("");
  const [notifPermission, setNotifPermission] = reactExports.useState(
    () => typeof Notification !== "undefined" ? Notification.permission : "denied"
  );
  const [txAlerts, setTxAlerts] = reactExports.useState(() => storage$1.get("txAlerts", true));
  const [priceAlerts, setPriceAlerts] = reactExports.useState(() => storage$1.get("priceAlerts", false));
  const [securityAlerts, setSecurityAlerts] = reactExports.useState(() => storage$1.get("securityAlerts", true));
  reactExports.useEffect(() => {
    document.documentElement.setAttribute("data-theme", darkMode ? "dark" : "light");
    storage$1.set("darkMode", darkMode);
  }, [darkMode]);
  reactExports.useEffect(() => {
    storage$1.set("autoLock", autoLock);
    if (onAutoLockChange) {
      onAutoLockChange(autoLock);
    }
  }, [autoLock, onAutoLockChange]);
  reactExports.useEffect(() => {
    storage$1.set("currency", currency);
  }, [currency]);
  reactExports.useEffect(() => {
    storage$1.set("notifications", notifications);
  }, [notifications]);
  reactExports.useEffect(() => {
    storage$1.set("skipSimulation", skipSimulation);
  }, [skipSimulation]);
  reactExports.useEffect(() => {
    storage$1.set("biometricEnabled", biometricEnabled);
  }, [biometricEnabled]);
  reactExports.useEffect(() => {
    storage$1.set("customExplorer", customExplorer);
  }, [customExplorer]);
  reactExports.useEffect(() => {
    if (subScreen !== "recovery") {
      setRecoveryView("menu");
      setShowPhrase(false);
      setNewMnemonic("");
      setCustomWords(Array(12).fill(""));
      setRecoveryError("");
      setPasswordVerified(false);
      setVerifyPassword("");
      setVerifyError("");
    }
  }, [subScreen]);
  reactExports.useEffect(() => {
    if (subScreen !== "privatekey") {
      setShowPrivateKey(false);
      setPrivateKeyView("menu");
      setImportPrivateKey("");
      setPrivateKeyError("");
      setPrivateKeyCopied(false);
      setPasswordVerified(false);
      setVerifyPassword("");
      setVerifyError("");
    }
  }, [subScreen]);
  const copyAddress = () => {
    var _a3;
    navigator.clipboard.writeText(((_a3 = wallet.wallet) == null ? void 0 : _a3.publicKey) || "");
    setCopied(true);
    setTimeout(() => setCopied(false), 2e3);
  };
  const saveCustomRpc = () => {
    var _a3, _b3, _c2, _d2;
    if (!((_a3 = customRpc.name) == null ? void 0 : _a3.trim())) {
      setError("Please enter a network name");
      return;
    }
    if (!((_b3 = customRpc.url) == null ? void 0 : _b3.trim())) {
      setError("Please enter an RPC URL");
      return;
    }
    if (!customRpc.url.startsWith("http://") && !customRpc.url.startsWith("https://")) {
      setError("RPC URL must start with http:// or https://");
      return;
    }
    const newNetwork = {
      ...customRpc,
      id: Date.now(),
      name: customRpc.name.trim(),
      url: customRpc.url.trim(),
      symbol: ((_c2 = customRpc.symbol) == null ? void 0 : _c2.trim()) || "TOKEN",
      decimals: parseInt(customRpc.decimals) || 9,
      explorer: ((_d2 = customRpc.explorer) == null ? void 0 : _d2.trim()) || ""
    };
    const newRpcs = [...customRpcs, newNetwork];
    setCustomRpcs(newRpcs);
    localStorage.setItem("x1wallet_customRpcs", JSON.stringify(newRpcs));
    setShowAddRpc(false);
    setCustomRpc({ name: "", url: "", symbol: "", decimals: 9, explorer: "" });
    setError("");
  };
  const removeCustomRpc = (id2) => {
    const newRpcs = customRpcs.filter((r2) => r2.id !== id2);
    setCustomRpcs(newRpcs);
    localStorage.setItem("x1wallet_customRpcs", JSON.stringify(newRpcs));
  };
  const saveRpcOverride = (networkName) => {
    const url = rpcOverrideUrl.trim();
    if (url && !url.startsWith("http://") && !url.startsWith("https://")) {
      setError("RPC URL must start with http:// or https://");
      return;
    }
    const newOverrides = { ...rpcOverrides };
    if (url) {
      newOverrides[networkName] = url;
    } else {
      delete newOverrides[networkName];
    }
    setRpcOverrides(newOverrides);
    localStorage.setItem("x1wallet_rpcOverrides", JSON.stringify(newOverrides));
    setEditingRpcOverride(null);
    setRpcOverrideUrl("");
    setError("");
  };
  const clearRpcOverrideForNetwork = (networkName) => {
    const newOverrides = { ...rpcOverrides };
    delete newOverrides[networkName];
    setRpcOverrides(newOverrides);
    localStorage.setItem("x1wallet_rpcOverrides", JSON.stringify(newOverrides));
  };
  const startEditingRpcOverride = (networkName) => {
    setEditingRpcOverride(networkName);
    setRpcOverrideUrl(rpcOverrides[networkName] || "");
    setError("");
  };
  const verifyUserPassword = async () => {
    try {
      const { checkPassword } = await __vitePreload(async () => {
        const { checkPassword: checkPassword2 } = await import("./wallet.js");
        return { checkPassword: checkPassword2 };
      }, true ? [] : void 0);
      const isValid = await checkPassword(verifyPassword2);
      if (isValid) {
        setPasswordVerified(true);
        setVerifyError("");
        setVerifyPassword("");
      } else {
        setVerifyError("Incorrect password");
      }
    } catch (err) {
      setVerifyError(err.message || "Password verification failed");
    }
  };
  const [hasPasswordProtection, setHasPasswordProtection] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const checkPasswordProtection = async () => {
      if (!passwordProtection) {
        setHasPasswordProtection(false);
        return;
      }
      try {
        const { hasPassword: hasPassword2 } = await __vitePreload(async () => {
          const { hasPassword: hasPassword22 } = await import("./wallet.js");
          return { hasPassword: hasPassword22 };
        }, true ? [] : void 0);
        const result = await hasPassword2();
        setHasPasswordProtection(result);
      } catch {
        setHasPasswordProtection(!!storage$1.get("x1wallet_auth", null));
      }
    };
    checkPasswordProtection();
  }, [passwordProtection]);
  if (subScreen === "autolock") {
    const options = [
      { value: 0, label: "Immediately" },
      { value: 1, label: "1 minute" },
      { value: 5, label: "5 minutes" },
      { value: 15, label: "15 minutes" },
      { value: 30, label: "30 minutes" },
      { value: 60, label: "1 hour" },
      { value: 1440, label: "1 day" }
    ];
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setSubScreen(null), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Auto-Lock Timer" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-content", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "radio-group", children: options.map((opt) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `radio-option ${autoLock === opt.value ? "selected" : ""}`, onClick: () => setAutoLock(opt.value), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "radio-option-text", children: opt.label }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "radio-option-check", children: autoLock === opt.value && /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "white", strokeWidth: "3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }) })
      ] }, opt.value)) }) })
    ] });
  }
  if (subScreen === "currency") {
    const currencies = [
      { code: "USD", name: "US Dollar", symbol: "$" },
      { code: "EUR", name: "Euro", symbol: "" },
      { code: "GBP", name: "British Pound", symbol: "" },
      { code: "JPY", name: "Japanese Yen", symbol: "" },
      { code: "CAD", name: "Canadian Dollar", symbol: "C$" },
      { code: "AUD", name: "Australian Dollar", symbol: "A$" },
      { code: "CNY", name: "Chinese Yuan", symbol: "" },
      { code: "KRW", name: "Korean Won", symbol: "" }
    ];
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setSubScreen(null), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Currency" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-content", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "radio-group", children: currencies.map((c) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `radio-option ${currency === c.code ? "selected" : ""}`, onClick: () => setCurrency(c.code), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "radio-option-text", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            c.symbol,
            " ",
            c.code
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: 12, color: "var(--text-muted)" }, children: [
            " - ",
            c.name
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "radio-option-check", children: currency === c.code && /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "white", strokeWidth: "3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }) })
      ] }, c.code)) }) })
    ] });
  }
  if (subScreen === "recovery") {
    if (recoveryView === "menu") {
      const hasMnemonic = wallet.getMnemonic ? !!wallet.getMnemonic() : false;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setSubScreen(null), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Seed Phrase" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-content", children: [
          hasMnemonic ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => setRecoveryView("view"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-text", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "View Seed Phrase" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-item-desc", children: "Backup your 12 or 24 words" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
          ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-box", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "This wallet was imported via private key and does not have a seed phrase. To backup, use Settings  Private Key." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "warning-box", style: { marginTop: 20 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "#ffa502", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "9", x2: "12", y2: "13" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "17", x2: "12.01", y2: "17" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Your seed phrase gives full access to all addresses in this wallet. Never share it with anyone!" })
          ] }),
          hasMnemonic && ((_a2 = wallet.wallet) == null ? void 0 : _a2.addresses) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-box", style: { marginTop: 12 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "This wallet has ",
              wallet.wallet.addresses.length,
              " address",
              wallet.wallet.addresses.length > 1 ? "es" : "",
              ". All addresses can be recovered from this single seed phrase."
            ] })
          ] })
        ] })
      ] });
    }
    if (recoveryView === "view") {
      const phrase = wallet.getMnemonic ? wallet.getMnemonic() : "";
      const words = phrase ? phrase.split(" ") : [];
      if (hasPasswordProtection && !passwordVerified) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setRecoveryView("menu"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Verify Password" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-content", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reveal-phrase-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "reveal-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "11", width: "18", height: "11", rx: "2", ry: "2" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Enter your password to view seed phrase" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "form-group", style: { marginTop: 16, width: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "password",
                className: "form-input",
                placeholder: "Enter password",
                value: verifyPassword2,
                onChange: (e) => setVerifyPassword(e.target.value),
                onKeyDown: (e) => e.key === "Enter" && verifyUserPassword(),
                autoFocus: true
              }
            ) }),
            verifyError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: verifyError }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: verifyUserPassword, disabled: !verifyPassword2, children: "Verify" })
          ] }) })
        ] });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => {
            setShowPhrase(false);
            setPasswordVerified(false);
            setRecoveryView("menu");
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "View Seed Phrase" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-content", children: !showPhrase ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reveal-phrase-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "reveal-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Your seed phrase is hidden for security." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: () => setShowPhrase(true), children: "Reveal Phrase" })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "warning-box", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "#ffa502", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "9", x2: "12", y2: "13" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "17", x2: "12.01", y2: "17" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Never share your seed phrase with anyone!" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "seed-phrase-display", children: words.length > 0 ? words.map((word, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "seed-word", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "seed-number", children: i + 1 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "seed-text", children: word })
          ] }, i)) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { textAlign: "center", color: "var(--text-muted)" }, children: "No seed phrase available for hardware wallets" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "12px", marginTop: "20px" }, children: [
            words.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                className: "btn-secondary",
                style: { display: "flex", alignItems: "center", justifyContent: "center", gap: "12px" },
                onClick: () => {
                  navigator.clipboard.writeText(phrase);
                  setCopied(true);
                  setTimeout(() => setCopied(false), 2e3);
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: copied ? "Copied!" : "Copy to Clipboard" })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "btn-primary",
                onClick: () => {
                  setShowPhrase(false);
                  setPasswordVerified(false);
                  setRecoveryView("menu");
                },
                children: "Done"
              }
            )
          ] })
        ] }) })
      ] });
    }
    return null;
  }
  if (subScreen === "privatekey") {
    const currentPrivateKey = ((_b2 = wallet.wallet) == null ? void 0 : _b2.privateKey) || "";
    const copyPrivateKey = () => {
      navigator.clipboard.writeText(currentPrivateKey);
      setPrivateKeyCopied(true);
      setTimeout(() => setPrivateKeyCopied(false), 2e3);
    };
    const handleImportPrivateKey = async () => {
      setPrivateKeyError("");
      if (!importPrivateKey.trim()) {
        setPrivateKeyError("Please enter a private key");
        return;
      }
      try {
        const trimmedKey = importPrivateKey.trim();
        const base58Regex = /^[1-9A-HJ-NP-Za-km-z]+$/;
        if (!base58Regex.test(trimmedKey)) {
          setPrivateKeyError("Invalid private key format (not base58)");
          return;
        }
        const { decodeBase58: decodeBase582, encodeBase58: encodeBase582 } = await __vitePreload(async () => {
          const { decodeBase58: decodeBase583, encodeBase58: encodeBase583 } = await Promise.resolve().then(() => base58);
          return { decodeBase58: decodeBase583, encodeBase58: encodeBase583 };
        }, true ? void 0 : void 0);
        const decoded = decodeBase582(trimmedKey);
        if (decoded.length !== 64 && decoded.length !== 32) {
          setPrivateKeyError(`Invalid key length: ${decoded.length} bytes (expected 32 or 64)`);
          return;
        }
        let secretKey = decoded;
        let publicKey;
        if (decoded.length === 32) {
          const { getPublicKey: getPublicKey2 } = await __vitePreload(async () => {
            const { getPublicKey: getPublicKey3 } = await Promise.resolve().then(() => bip44);
            return { getPublicKey: getPublicKey3 };
          }, true ? void 0 : void 0);
          publicKey = getPublicKey2(decoded);
          secretKey = new Uint8Array(64);
          secretKey.set(decoded, 0);
          secretKey.set(publicKey, 32);
        } else {
          publicKey = decoded.slice(32);
        }
        const publicKeyBase58 = encodeBase582(publicKey);
        const privateKeyBase58 = encodeBase582(secretKey);
        const newWallet = {
          id: Date.now().toString(),
          name: `Imported ${publicKeyBase58.slice(0, 4)}...`,
          publicKey: publicKeyBase58,
          privateKey: privateKeyBase58,
          mnemonic: null,
          // No mnemonic for imported private keys
          type: "imported",
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        const existingWallets = JSON.parse(localStorage.getItem("x1wallet_wallets") || "[]");
        if (existingWallets.some((w2) => w2.publicKey === publicKeyBase58)) {
          setPrivateKeyError("This wallet is already imported");
          return;
        }
        existingWallets.push(newWallet);
        localStorage.setItem("x1wallet_wallets", JSON.stringify(existingWallets));
        localStorage.setItem("x1wallet_active", newWallet.id);
        alert(`Wallet imported successfully!

Address: ${publicKeyBase58.slice(0, 20)}...`);
        setImportPrivateKey("");
        setPrivateKeyView("menu");
        window.location.reload();
      } catch (err) {
        logger$1.error("Import error:", err);
        setPrivateKeyError("Failed to import: " + err.message);
      }
    };
    if (privateKeyView === "menu") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sub-screen-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setSubScreen(null), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Private Key" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sub-screen-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "warning-box", style: { marginBottom: 20 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Never share your private key. Anyone with your private key has full control of your wallet." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => setPrivateKeyView("view"), children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "View Private Key" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-item-desc", children: "Export your private key" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => setPrivateKeyView("import"), children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "7 10 12 15 17 10" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "15", x2: "12", y2: "3" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Import Private Key" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-item-desc", children: "Import wallet from private key" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
            ] })
          ] })
        ] })
      ] });
    }
    if (privateKeyView === "view") {
      if (hasPasswordProtection && !passwordVerified) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sub-screen-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setPrivateKeyView("menu"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Verify Password" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sub-screen-content", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "reveal-phrase-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "reveal-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "11", width: "18", height: "11", rx: "2", ry: "2" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Enter your password to view private key" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "form-group", style: { marginTop: 16, width: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "password",
                className: "form-input",
                placeholder: "Enter password",
                value: verifyPassword2,
                onChange: (e) => setVerifyPassword(e.target.value),
                onKeyDown: (e) => e.key === "Enter" && verifyUserPassword(),
                autoFocus: true
              }
            ) }),
            verifyError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: verifyError }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: verifyUserPassword, disabled: !verifyPassword2, children: "Verify" })
          ] }) })
        ] });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sub-screen-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => {
            setShowPrivateKey(false);
            setPasswordVerified(false);
            setPrivateKeyView("menu");
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "View Private Key" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sub-screen-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "warning-box danger", style: { marginBottom: 20 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "DO NOT share this key with anyone! It provides full access to your wallet." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Wallet Address" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "readonly-field", children: [
              (_d = (_c = wallet.wallet) == null ? void 0 : _c.publicKey) == null ? void 0 : _d.slice(0, 20),
              "...",
              (_f = (_e = wallet.wallet) == null ? void 0 : _e.publicKey) == null ? void 0 : _f.slice(-8)
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Private Key (Base58)" }),
            !showPrivateKey ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "private-key-hidden", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  className: "btn-secondary",
                  style: { display: "flex", alignItems: "center", gap: 8 },
                  onClick: () => setShowPrivateKey(true),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
                    ] }),
                    "Reveal"
                  ]
                }
              )
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "private-key-revealed", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("code", { className: "private-key-text", children: currentPrivateKey }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "private-key-actions", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    className: "btn-secondary",
                    style: { display: "flex", alignItems: "center", gap: 8 },
                    onClick: () => setShowPrivateKey(false),
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
                      ] }),
                      "Hide"
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "btn-primary",
                    style: { display: "flex", alignItems: "center", gap: 8 },
                    onClick: copyPrivateKey,
                    children: privateKeyCopied ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }),
                      "Copied!"
                    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })
                      ] }),
                      "Copy"
                    ] })
                  }
                )
              ] })
            ] })
          ] }),
          (wallet.getMnemonic ? wallet.getMnemonic() : null) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-box", style: { marginTop: 16 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "This wallet also has a seed phrase which can be viewed in Seed Phrase settings." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-primary",
              style: { marginTop: 20 },
              onClick: () => {
                setShowPrivateKey(false);
                setPasswordVerified(false);
                setPrivateKeyView("menu");
              },
              children: "Done"
            }
          )
        ] })
      ] });
    }
    if (privateKeyView === "import") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sub-screen-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setPrivateKeyView("menu"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Import Private Key" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sub-screen-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "settings-description", children: "Enter a base58-encoded private key to import an existing wallet." }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Private Key" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "textarea",
              {
                className: "form-input private-key-input",
                placeholder: "Enter your private key (base58)",
                value: importPrivateKey,
                onChange: (e) => {
                  setImportPrivateKey(e.target.value);
                  setPrivateKeyError("");
                },
                rows: 3
              }
            )
          ] }),
          privateKeyError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: privateKeyError }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-primary",
              onClick: handleImportPrivateKey,
              style: { marginTop: 16 },
              children: "Import Wallet"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-box", style: { marginTop: 20 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Accepts 64-byte secret keys (88 chars) or 32-byte seeds (44 chars) in base58 format." })
          ] })
        ] })
      ] });
    }
    return null;
  }
  if (subScreen === "changepassword") {
    const handlePasswordChange = async () => {
      setPasswordError("");
      setPasswordSuccess(false);
      try {
        const { checkPassword, setupPassword, validatePasswordStrength: validatePasswordStrength2, hasPassword: checkHasPass } = await __vitePreload(async () => {
          const { checkPassword: checkPassword2, setupPassword: setupPassword2, validatePasswordStrength: validatePasswordStrength3, hasPassword: checkHasPass2 } = await import("./wallet.js");
          return { checkPassword: checkPassword2, setupPassword: setupPassword2, validatePasswordStrength: validatePasswordStrength3, hasPassword: checkHasPass2 };
        }, true ? [] : void 0);
        const hasExisting = await checkHasPass();
        if (hasExisting) {
          if (!currentPassword) {
            setPasswordError("Please enter your current password");
            return;
          }
          const isValid = await checkPassword(currentPassword);
          if (!isValid) {
            setPasswordError("Current password is incorrect");
            return;
          }
        }
        const validation = validatePasswordStrength2(newPassword);
        if (!validation.valid) {
          setPasswordError(validation.error);
          return;
        }
        if (newPassword !== confirmPassword) {
          setPasswordError("Passwords do not match");
          return;
        }
        if (hasExisting && wallet.changePassword) {
          await wallet.changePassword(currentPassword, newPassword);
        } else if (wallet.enableEncryption) {
          await wallet.enableEncryption(newPassword);
        }
        await setupPassword(newPassword);
        storage$1.set("passwordProtection", true);
        setPasswordProtection(true);
        if (onPasswordProtectionChange) {
          onPasswordProtectionChange(true);
        }
        setPasswordSuccess(true);
        setCurrentPassword("");
        setNewPassword("");
        setConfirmPassword("");
        setTimeout(() => {
          setSubScreen("password");
          setPasswordSuccess(false);
        }, 1500);
      } catch (err) {
        setPasswordError(err.message || "Failed to change password");
      }
    };
    const hasExistingPassword = hasPassword;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => {
          setSubScreen("password");
          setPasswordError("");
          setCurrentPassword("");
          setNewPassword("");
          setConfirmPassword("");
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: hasExistingPassword ? "Change Password" : "Set Password" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-content", children: [
        hasExistingPassword && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Current Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "password",
              className: "form-input",
              placeholder: "Enter current password",
              value: currentPassword,
              onChange: (e) => setCurrentPassword(e.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "New Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: showNewPassword ? "text" : "password",
                className: "form-input",
                placeholder: "Enter new password (min 12 chars)",
                value: newPassword,
                onChange: (e) => setNewPassword(e.target.value)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => setShowNewPassword(!showNewPassword),
                style: {
                  position: "absolute",
                  right: 12,
                  top: "50%",
                  transform: "translateY(-50%)",
                  background: "none",
                  border: "none",
                  cursor: "pointer",
                  padding: 4
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-secondary)", strokeWidth: "2", children: showNewPassword ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
                ] }) })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "password-requirements", style: { fontSize: 11, color: "var(--text-muted)", marginTop: 6 }, children: "Requirements: 12+ chars, uppercase, lowercase, number, special character" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Confirm New Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: showNewPassword ? "text" : "password",
                className: "form-input",
                value: confirmPassword,
                onChange: (e) => setConfirmPassword(e.target.value)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => setShowNewPassword(!showNewPassword),
                style: {
                  position: "absolute",
                  right: 12,
                  top: "50%",
                  transform: "translateY(-50%)",
                  background: "none",
                  border: "none",
                  cursor: "pointer",
                  padding: 4
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-secondary)", strokeWidth: "2", children: showNewPassword ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1", y1: "1", x2: "23", y2: "23" })
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" })
                ] }) })
              }
            )
          ] })
        ] }),
        passwordError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: passwordError }),
        passwordSuccess && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "success-message", children: [
          "Password ",
          hasExistingPassword ? "updated" : "set",
          " successfully!"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: handlePasswordChange, children: hasExistingPassword ? "Update Password" : "Set Password" })
      ] })
    ] });
  }
  if (subScreen === "password") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => {
          setSubScreen(null);
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Manage Password" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => setSubScreen("changepassword"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-text", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: hasPassword ? "Change Password" : "Set Password" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-item-desc", children: hasPassword ? "Update your current password" : "Create a new password" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-item-right", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "16", x2: "12", y2: "12" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "8", x2: "12.01", y2: "8" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: hasPassword ? "Password protects your wallet from unauthorized access on this device." : "Set a password to protect your wallet from unauthorized access." })
        ] })
      ] })
    ] });
  }
  if (subScreen === "biometric") {
    const handleBiometricToggle = async () => {
      if (!biometricEnabled) {
        if (window.PublicKeyCredential) {
          try {
            const available = await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
            if (available) {
              setBiometricEnabled(true);
            } else {
              alert("Biometric authentication is not available on this device.");
            }
          } catch {
            alert("Biometric authentication is not supported in this browser.");
          }
        } else {
          alert("Biometric authentication is not supported in this browser.");
        }
      } else {
        setBiometricEnabled(false);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setSubScreen(null), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Biometric Unlock" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: handleBiometricToggle, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 11c0 3.517-1.009 6.799-2.753 9.571m-3.44-2.04l.054-.09A13.916 13.916 0 0 0 8 11a4 4 0 1 1 8 0c0 1.017-.07 2.019-.203 3m-2.118 6.844A21.88 21.88 0 0 0 15.171 17m3.839 1.132c.645-2.266.99-4.659.99-7.132A8 8 0 0 0 8 4.07M3 15.364c.64-1.319 1-2.8 1-4.364 0-1.457.39-2.823 1.07-4" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-text", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Enable Biometric Unlock" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-item-desc", children: "Use fingerprint or face recognition" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `toggle ${biometricEnabled ? "active" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "toggle-handle" }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "16", x2: "12", y2: "12" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "8", x2: "12.01", y2: "8" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Biometric unlock uses your device's fingerprint or face recognition to quickly access your wallet." })
        ] }),
        biometricEnabled && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "success-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "var(--success)", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M22 11.08V12a10 10 0 1 1-5.93-9.14" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "22 4 12 14.01 9 11.01" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Biometric unlock is enabled and ready to use." })
        ] })
      ] })
    ] });
  }
  if (subScreen === "notifications") {
    const requestPermission = async () => {
      if (typeof Notification === "undefined") {
        alert("Notifications are not supported in this browser.");
        return;
      }
      try {
        const permission = await Notification.requestPermission();
        setNotifPermission(permission);
        if (permission === "granted") {
          setNotifications(true);
          new Notification("X1 Wallet", {
            body: "Notifications enabled successfully!",
            icon: "/icons/icon128.png"
          });
        }
      } catch (err) {
        logger$1.error("Failed to request notification permission:", err);
      }
    };
    const testNotification = () => {
      if (typeof Notification !== "undefined" && Notification.permission === "granted") {
        new Notification("X1 Wallet", {
          body: "This is a test notification.",
          icon: "/icons/icon128.png"
        });
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setSubScreen(null), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Notifications" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-section", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => setNotifications(!notifications), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.73 21a2 2 0 0 1-3.46 0" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-text", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Enable Notifications" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-item-desc", children: "Receive alerts for transactions and updates" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `toggle ${notifications ? "active" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "toggle-handle" }) })
        ] }) }),
        notifications && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Notification Types" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => {
            setTxAlerts(!txAlerts);
            storage$1.set("txAlerts", !txAlerts);
          }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "1", x2: "12", y2: "23" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-text", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Transaction Alerts" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-item-desc", children: "Incoming and outgoing transactions" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `toggle ${txAlerts ? "active" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "toggle-handle" }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => {
            setPriceAlerts(!priceAlerts);
            storage$1.set("priceAlerts", !priceAlerts);
          }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "22 12 18 12 15 21 9 3 6 12 2 12" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-text", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Price Alerts" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-item-desc", children: "Significant price changes" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `toggle ${priceAlerts ? "active" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "toggle-handle" }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => {
            setSecurityAlerts(!securityAlerts);
            storage$1.set("securityAlerts", !securityAlerts);
          }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "8", x2: "12", y2: "12" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "16", x2: "12.01", y2: "16" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-text", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Security Alerts" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-item-desc", children: "Login attempts and security events" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `toggle ${securityAlerts ? "active" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "toggle-handle" }) })
          ] })
        ] }),
        typeof Notification !== "undefined" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Browser Permission" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "permission-status", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `permission-badge ${notifPermission}`, children: notifPermission === "granted" ? " Granted" : notifPermission === "denied" ? " Denied" : "? Not Set" }) }),
          notifPermission !== "granted" && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: requestPermission, style: { marginTop: 12 }, children: "Enable Browser Notifications" }),
          notifPermission === "granted" && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-secondary", onClick: testNotification, style: { marginTop: 12 }, children: "Send Test Notification" }),
          notifPermission === "denied" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-box", style: { marginTop: 12 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "16", x2: "12", y2: "12" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "8", x2: "12.01", y2: "8" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Notifications are blocked. Please enable them in your browser settings." })
          ] })
        ] })
      ] })
    ] });
  }
  if (subScreen === "explorer") {
    const currentNetwork2 = (wallet == null ? void 0 : wallet.network) || "X1 Mainnet";
    const isSolana = currentNetwork2.includes("Solana");
    const isTestnet = currentNetwork2.includes("Testnet") || currentNetwork2.includes("Devnet");
    const x1MainnetExplorers = [
      { name: "X1 Explorer", url: "https://explorer.x1.xyz" }
    ];
    const x1TestnetExplorers = [
      { name: "X1 Testnet Explorer", url: "https://explorer.testnet.x1.xyz" }
    ];
    const solanaExplorers = [
      { name: "Solscan", url: "https://solscan.io" },
      { name: "Solana Explorer", url: "https://explorer.solana.com" },
      { name: "SolanaFM", url: "https://solana.fm" }
    ];
    let explorers;
    if (isSolana) {
      explorers = solanaExplorers;
    } else if (isTestnet) {
      explorers = x1TestnetExplorers;
    } else {
      explorers = x1MainnetExplorers;
    }
    const defaultExplorer = ((_g = explorers[0]) == null ? void 0 : _g.url) || "";
    let explorerKey;
    if (isSolana) {
      explorerKey = currentNetwork2.includes("Devnet") ? "solanaDevnetExplorer" : "solanaExplorer";
    } else {
      explorerKey = isTestnet ? "x1TestnetExplorer" : "x1Explorer";
    }
    const storedExplorer = storage$1.get(explorerKey, "") || defaultExplorer;
    const isPresetExplorer = explorers.some((e) => e.url === storedExplorer);
    const customExplorerValue = isPresetExplorer ? "" : storedExplorer;
    const handleSelectExplorer = (url) => {
      storage$1.set(explorerKey, url);
      setCustomExplorer(url);
    };
    const handleCustomExplorerChange = (e) => {
      const value = e.target.value;
      if (value) {
        storage$1.set(explorerKey, value);
        setCustomExplorer(value);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setSubScreen(null), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Block Explorer" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
            isSolana ? "Solana" : "X1",
            " Explorers"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { fontSize: 12, color: "var(--text-muted)", marginBottom: 12 }, children: [
            "Current network: ",
            currentNetwork2
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "radio-group", children: [
            explorers.map((exp) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: `radio-option ${storedExplorer === exp.url ? "selected" : ""}`,
                onClick: () => handleSelectExplorer(exp.url),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "radio-option-text", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: exp.name }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 11, color: "var(--text-muted)", display: "block" }, children: exp.url })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "radio-option-check", children: storedExplorer === exp.url && /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "white", strokeWidth: "3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }) })
                ]
              },
              exp.url
            )),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: `radio-option ${!isPresetExplorer ? "selected" : ""}`,
                onClick: () => {
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "radio-option-text", style: { flex: 1 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Custom" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "text",
                        className: "form-input",
                        placeholder: "https://your-explorer.com",
                        value: customExplorerValue,
                        onChange: handleCustomExplorerChange,
                        onClick: (e) => e.stopPropagation(),
                        style: { marginTop: 8, fontSize: 12 }
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "radio-option-check", children: !isPresetExplorer && /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "white", strokeWidth: "3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }) })
                ]
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-section", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: 12, color: "var(--text-muted)" }, children: "For custom explorers, use the base URL. Transactions will be viewed at: [url]/tx/[hash]" }) })
      ] })
    ] });
  }
  if (subScreen === "network") {
    if (showAddRpc) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => {
            setShowAddRpc(false);
            setError("");
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Add Custom Network" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-content", children: [
          error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", style: { marginBottom: "16px", padding: "12px", background: "rgba(239, 68, 68, 0.1)", borderRadius: "8px", color: "#ef4444", fontSize: "13px" }, children: error }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Network Name *" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                className: "form-input",
                placeholder: "e.g. My Custom Network",
                value: customRpc.name,
                onChange: (e) => setCustomRpc({ ...customRpc, name: e.target.value })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "RPC URL *" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                className: "form-input",
                placeholder: "https://rpc.example.com",
                value: customRpc.url,
                onChange: (e) => setCustomRpc({ ...customRpc, url: e.target.value })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Token Symbol" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                className: "form-input",
                placeholder: "e.g. ETH, SOL, XNT",
                value: customRpc.symbol,
                onChange: (e) => setCustomRpc({ ...customRpc, symbol: e.target.value })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Decimals" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                min: "0",
                className: "form-input",
                placeholder: "9",
                value: customRpc.decimals,
                onChange: (e) => {
                  const value = e.target.value;
                  if (value.startsWith("-") || parseFloat(value) < 0) return;
                  setCustomRpc({ ...customRpc, decimals: value });
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Block Explorer URL (optional)" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                className: "form-input",
                placeholder: "https://explorer.example.com",
                value: customRpc.explorer,
                onChange: (e) => setCustomRpc({ ...customRpc, explorer: e.target.value })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-primary",
              onClick: saveCustomRpc,
              style: { marginTop: "8px" },
              children: "Add Network"
            }
          )
        ] })
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setSubScreen(null), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Network" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Mainnets" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "radio-group", children: Object.keys(NETWORKS).filter((n2) => !n2.includes("Testnet") && !n2.includes("Devnet")).map((net) => {
            var _a3;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "4px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `radio-option ${wallet.network === net ? "selected" : ""}`,
                  onClick: () => wallet.setNetwork(net),
                  style: { position: "relative" },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "radio-option-text", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: net }),
                      rpcOverrides[net] && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: 11, color: "var(--primary)", display: "block" }, children: [
                        "Custom: ",
                        rpcOverrides[net].length > 30 ? rpcOverrides[net].slice(0, 30) + "..." : rpcOverrides[net]
                      ] })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "button",
                        {
                          onClick: (e) => {
                            e.stopPropagation();
                            startEditingRpcOverride(net);
                          },
                          style: { background: "none", border: "none", color: rpcOverrides[net] ? "var(--primary)" : "var(--text-muted)", cursor: "pointer", padding: "4px" },
                          title: "Set custom RPC",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" })
                          ] })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "radio-option-check", children: wallet.network === net && /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "white", strokeWidth: "3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }) })
                    ] })
                  ]
                }
              ),
              editingRpcOverride === net && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "12px", background: "var(--bg-secondary)", borderRadius: "8px", marginTop: "8px", marginBottom: "8px" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "13px", fontWeight: 500, marginBottom: "8px" }, children: [
                  "Custom RPC for ",
                  net
                ] }),
                error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", style: { marginBottom: "8px", fontSize: "12px" }, children: error }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    className: "form-input",
                    placeholder: ((_a3 = NETWORKS[net]) == null ? void 0 : _a3.rpcUrl) || "https://rpc.example.com",
                    value: rpcOverrideUrl,
                    onChange: (e) => setRpcOverrideUrl(e.target.value),
                    style: { marginBottom: "8px" }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "btn-primary",
                      style: { flex: 1, padding: "8px" },
                      onClick: () => saveRpcOverride(net),
                      children: "Save"
                    }
                  ),
                  rpcOverrides[net] && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "btn-secondary",
                      style: { flex: 1, padding: "8px", color: "var(--error)" },
                      onClick: () => {
                        clearRpcOverrideForNetwork(net);
                        setEditingRpcOverride(null);
                      },
                      children: "Clear"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "btn-secondary",
                      style: { flex: 1, padding: "8px" },
                      onClick: () => {
                        setEditingRpcOverride(null);
                        setRpcOverrideUrl("");
                        setError("");
                      },
                      children: "Cancel"
                    }
                  )
                ] })
              ] })
            ] }, net);
          }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Testnets / Devnets" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "radio-group", children: Object.keys(NETWORKS).filter((n2) => n2.includes("Testnet") || n2.includes("Devnet")).map((net) => {
            var _a3;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "4px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `radio-option ${wallet.network === net ? "selected" : ""}`,
                  onClick: () => wallet.setNetwork(net),
                  style: { position: "relative" },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "radio-option-text", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: net }),
                      rpcOverrides[net] && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: 11, color: "var(--primary)", display: "block" }, children: [
                        "Custom: ",
                        rpcOverrides[net].length > 30 ? rpcOverrides[net].slice(0, 30) + "..." : rpcOverrides[net]
                      ] })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "button",
                        {
                          onClick: (e) => {
                            e.stopPropagation();
                            startEditingRpcOverride(net);
                          },
                          style: { background: "none", border: "none", color: rpcOverrides[net] ? "var(--primary)" : "var(--text-muted)", cursor: "pointer", padding: "4px" },
                          title: "Set custom RPC",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" })
                          ] })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "radio-option-check", children: wallet.network === net && /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "white", strokeWidth: "3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }) })
                    ] })
                  ]
                }
              ),
              editingRpcOverride === net && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "12px", background: "var(--bg-secondary)", borderRadius: "8px", marginTop: "8px", marginBottom: "8px" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "13px", fontWeight: 500, marginBottom: "8px" }, children: [
                  "Custom RPC for ",
                  net
                ] }),
                error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", style: { marginBottom: "8px", fontSize: "12px" }, children: error }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    className: "form-input",
                    placeholder: ((_a3 = NETWORKS[net]) == null ? void 0 : _a3.rpcUrl) || "https://rpc.example.com",
                    value: rpcOverrideUrl,
                    onChange: (e) => setRpcOverrideUrl(e.target.value),
                    style: { marginBottom: "8px" }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "btn-primary",
                      style: { flex: 1, padding: "8px" },
                      onClick: () => saveRpcOverride(net),
                      children: "Save"
                    }
                  ),
                  rpcOverrides[net] && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "btn-secondary",
                      style: { flex: 1, padding: "8px", color: "var(--error)" },
                      onClick: () => {
                        clearRpcOverrideForNetwork(net);
                        setEditingRpcOverride(null);
                      },
                      children: "Clear"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "btn-secondary",
                      style: { flex: 1, padding: "8px" },
                      onClick: () => {
                        setEditingRpcOverride(null);
                        setRpcOverrideUrl("");
                        setError("");
                      },
                      children: "Cancel"
                    }
                  )
                ] })
              ] })
            ] }, net);
          }) })
        ] }),
        customRpcs.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Custom Networks" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "radio-group", children: customRpcs.map((rpc) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `radio-option ${wallet.network === rpc.name ? "selected" : ""}`,
              onClick: () => wallet.setNetwork(rpc.name),
              style: { position: "relative" },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "radio-circle", children: wallet.network === rpc.name && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "radio-dot" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "radio-option-text", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: rpc.name }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 11, color: "var(--text-muted)", display: "block" }, children: rpc.url })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: (e) => {
                      e.stopPropagation();
                      removeCustomRpc(rpc.id);
                    },
                    style: { background: "none", border: "none", color: "var(--error)", cursor: "pointer", padding: 8, marginLeft: "auto" },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "3 6 5 6 21 6" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" })
                    ] })
                  }
                )
              ]
            },
            rpc.id
          )) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "add-token-btn", onClick: () => setShowAddRpc(true), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 8v8M8 12h8" })
          ] }),
          "Add Custom RPC"
        ] })
      ] })
    ] });
  }
  if (subScreen === "about") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setSubScreen(null), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "About" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-content", style: { textAlign: "center", paddingTop: 40 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(X1Logo, { size: 64 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { marginTop: 16, marginBottom: 4 }, children: "X1 Wallet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { color: "var(--text-muted)", marginBottom: 8 }, children: [
          "Version ",
          appVersion
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { color: "var(--text-muted)", marginBottom: 24, fontSize: 12 }, children: [
          "Network: ",
          (wallet == null ? void 0 : wallet.network) || "Unknown"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "about-links", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://x1.xyz", target: "_blank", rel: "noopener noreferrer", className: "about-link", children: "Website" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://docs.x1.xyz", target: "_blank", rel: "noopener noreferrer", className: "about-link", children: "Documentation" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://x.com/x1_chain", target: "_blank", rel: "noopener noreferrer", className: "about-link", children: "X" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://t.me/x1_wallet", target: "_blank", rel: "noopener noreferrer", className: "about-link", children: "Telegram" })
        ] })
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen settings-screen", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "page-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "Settings" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Account" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: copyAddress, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "7", r: "4" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Wallet Address" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-right", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-value", children: wallet.formatAddress((_h = wallet.wallet) == null ? void 0 : _h.publicKey, 6) }),
            copied ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "var(--success)", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Network" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => setSubScreen("network"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "2", y1: "12", x2: "22", y2: "12" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Network" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-right", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-value", children: wallet.network }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => setSubScreen("explorer"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11", cy: "11", r: "8" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "21", y1: "21", x2: "16.65", y2: "16.65" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Block Explorer" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-right", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-value", children: (() => {
              const currentNet = (wallet == null ? void 0 : wallet.network) || "X1 Mainnet";
              const isSolana = currentNet.includes("Solana");
              const isTestnet = currentNet.includes("Testnet") || currentNet.includes("Devnet");
              let explorerKey;
              if (isSolana) {
                explorerKey = currentNet.includes("Devnet") ? "solanaDevnetExplorer" : "solanaExplorer";
              } else {
                explorerKey = isTestnet ? "x1TestnetExplorer" : "x1Explorer";
              }
              const storedExplorer = storage$1.get(explorerKey, "");
              if (!storedExplorer) {
                if (isSolana) return "Solscan";
                if (isTestnet) return "X1 Testnet Explorer";
                return "X1 Explorer";
              }
              if (storedExplorer.includes("solscan")) return "Solscan";
              if (storedExplorer.includes("solana.com")) return "Solana Explorer";
              if (storedExplorer.includes("solana.fm")) return "SolanaFM";
              if (storedExplorer.includes("testnet.x1.xyz")) return "X1 Testnet Explorer";
              if (storedExplorer.includes("x1.xyz")) return "X1 Explorer";
              return "Custom";
            })() }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Security" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: onLock, style: { cursor: "pointer" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "var(--warning)", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "11", width: "18", height: "11", rx: "2", ry: "2" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "16", r: "1" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "var(--warning)" }, children: "Lock Wallet Now" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-item-right", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "var(--warning)", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => setSubScreen("password"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "11", width: "18", height: "11", rx: "2", ry: "2" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Manage Password" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-right", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-value", children: "Required" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => setSubScreen("autolock"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "12 6 12 12 16 14" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Auto-Lock Timer" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-right", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-value", children: autoLock === 0 ? "Immediately" : autoLock === 60 ? "1 hour" : autoLock === 1440 ? "1 day" : `${autoLock} min` }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
          ] })
        ] }),
        biometricAvailable && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => setSubScreen("biometric"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 11c0 3.517-1.009 6.799-2.753 9.571m-3.44-2.04l.054-.09A13.916 13.916 0 0 0 8 11a4 4 0 1 1 8 0c0 1.017-.07 2.019-.203 3m-2.118 6.844A21.88 21.88 0 0 0 15.171 17m3.839 1.132c.645-2.266.99-4.659.99-7.132A8 8 0 0 0 8 4.07M3 15.364c.64-1.319 1-2.8 1-4.364 0-1.457.39-2.823 1.07-4" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Biometric Unlock" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-right", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-value", children: biometricEnabled ? "On" : "Off" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => setSkipSimulation(!skipSimulation), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "5 3 19 12 5 21 5 3" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Fast Mode" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "var(--text-muted)", marginTop: 2 }, children: "Skip transaction simulation for faster sends" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `toggle ${skipSimulation ? "active" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "toggle-handle" }) })
        ] }),
        skipSimulation && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-info", style: { color: "var(--warning, #f59e0b)" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "9", x2: "12", y2: "13" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "17", x2: "12.01", y2: "17" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Warning: Transactions won't be verified before sending. Failed transactions will still consume network fees." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "16", x2: "12", y2: "12" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "8", x2: "12.01", y2: "8" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Seed phrases and private keys are managed per-wallet. Click the wallet selector  Edit to access them." })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Preferences" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => setDarkMode(!darkMode), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Dark Mode" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `toggle ${darkMode ? "active" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "toggle-handle" }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => setSubScreen("notifications"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.73 21a2 2 0 0 1-3.46 0" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Notifications" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-right", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-value", children: notifications ? "On" : "Off" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => setSubScreen("currency"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 6v12M9 9h4.5a2.5 2.5 0 0 1 0 5H9" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Currency" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-right", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "settings-value", children: currency }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "About" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item", onClick: () => setSubScreen("about"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 16v-4M12 8h.01" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "About X1 Wallet" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-item-right", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 18l6-6-6-6" }) }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-section danger", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-item", onClick: onLock, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-item-left", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", stroke: "var(--error)", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "11", width: "18", height: "11", rx: "2", ry: "2" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "var(--error)" }, children: "Reset Wallet" })
      ] }) }) })
    ] })
  ] });
}
const SOLANA_LOGO_URL$2 = "/icons/48-sol.png";
function getPriorityOptions$2(network) {
  const isX1 = network == null ? void 0 : network.includes("X1");
  if (isX1) {
    return [
      { id: "auto", name: "Auto", fee: 0, description: "Standard speed" },
      { id: "fast", name: "Fast", fee: 1e-3, description: "Higher priority" },
      { id: "turbo", name: "Turbo", fee: 5e-3, description: "Very high priority" },
      { id: "degen", name: "Degen", fee: 0.01, description: "Maximum priority" },
      { id: "custom", name: "Custom", fee: 0, description: "Set your own fee" }
    ];
  }
  return [
    { id: "auto", name: "Auto", fee: 0, description: "Standard speed" },
    { id: "fast", name: "Fast", fee: 5e-6, description: "Higher priority" },
    { id: "turbo", name: "Turbo", fee: 5e-5, description: "Very high priority" },
    { id: "degen", name: "Degen", fee: 1e-3, description: "Maximum priority" },
    { id: "custom", name: "Custom", fee: 0, description: "Set your own fee" }
  ];
}
function getBaseFee$2(network) {
  const isX1 = network == null ? void 0 : network.includes("X1");
  return isX1 ? 2e-3 : 5e-6;
}
function NetworkLogo$1({ network, size = 40 }) {
  const solanaLogoSize = Math.round(size * 0.95);
  if (network == null ? void 0 : network.includes("Solana")) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
      width: size,
      height: size,
      minWidth: size,
      minHeight: size,
      borderRadius: "50%",
      background: "#000",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0,
      overflow: "hidden"
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: SOLANA_LOGO_URL$2,
        alt: "Solana",
        style: {
          width: solanaLogoSize,
          height: solanaLogoSize,
          objectFit: "contain",
          display: "block"
        }
      }
    ) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(X1Logo, { size });
}
const STEPS = {
  TOKEN: 0,
  RECIPIENT: 1,
  AMOUNT: 2,
  CONFIRM: 3,
  SUCCESS: 4
};
function SendFlow({ wallet, selectedToken: initialToken, userTokens = [], onBack, onSuccess }) {
  var _a2, _b2, _c, _d;
  const [step, setStep] = reactExports.useState(initialToken ? STEPS.RECIPIENT : STEPS.TOKEN);
  const [slideDirection, setSlideDirection] = reactExports.useState("right");
  const [recipient, setRecipient] = reactExports.useState("");
  const [recipientName, setRecipientName] = reactExports.useState("");
  const [currentToken, setCurrentToken] = reactExports.useState(initialToken);
  const [amount, setAmount] = reactExports.useState("");
  const [sending, setSending] = reactExports.useState(false);
  const [error, setError] = reactExports.useState("");
  const [txHash, setTxHash] = reactExports.useState("");
  const [hwStatus, setHwStatus] = reactExports.useState("");
  const [addressWarning, setAddressWarning] = reactExports.useState("");
  const [myWallets, setMyWallets] = reactExports.useState([]);
  const [recentAddresses, setRecentAddresses] = reactExports.useState([]);
  const [priority, setPriority] = reactExports.useState("auto");
  const [customFee, setCustomFee] = reactExports.useState("");
  const isHardwareWallet = ((_a2 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _a2.isHardware) || ((_b2 = wallet == null ? void 0 : wallet.activeWallet) == null ? void 0 : _b2.isHardware) || (wallet == null ? void 0 : wallet.isHardware) || false;
  const network = (wallet == null ? void 0 : wallet.network) || "X1 Mainnet";
  const networkConfig = NETWORKS[network] || {
    symbol: "XNT",
    decimals: 9,
    rpcUrl: "https://rpc.testnet.x1.xyz"
  };
  const nativeToken = {
    symbol: networkConfig.symbol,
    name: network.includes("Solana") ? "Solana" : "X1 Native Token",
    mint: null,
    decimals: networkConfig.decimals,
    uiAmount: (wallet == null ? void 0 : wallet.balance) || 0,
    balance: (wallet == null ? void 0 : wallet.balance) || 0,
    logoURI: null,
    isNative: true
  };
  const tokensWithBalance = (userTokens || []).filter((t2) => {
    const bal = parseFloat(t2.uiAmount) || parseFloat(t2.balance) || 0;
    const rawAmount = parseInt(t2.amount) || 0;
    return bal > 0 || rawAmount > 0;
  });
  const availableTokens = [nativeToken, ...tokensWithBalance];
  const isTokenSend = currentToken && currentToken.mint;
  const displaySymbol = isTokenSend ? currentToken.symbol : networkConfig.symbol;
  const displayBalance = isTokenSend ? parseFloat(currentToken.balance || currentToken.uiAmount) || 0 : (wallet == null ? void 0 : wallet.balance) || 0;
  const displayDecimals = isTokenSend ? currentToken.decimals || 9 : networkConfig.decimals;
  isTokenSend ? currentToken.name : network.includes("Solana") ? "Solana" : "X1 Native Token";
  reactExports.useEffect(() => {
    const loadData = async () => {
      var _a3;
      try {
        const wallets = (wallet == null ? void 0 : wallet.wallets) || [];
        const currentPublicKey = (_a3 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _a3.publicKey;
        console.log("[SendFlow] Loading wallets from hook:", wallets.length, "current:", currentPublicKey);
        const allAddresses = [];
        const seenPublicKeys = /* @__PURE__ */ new Set();
        wallets.forEach((w2, walletIndex) => {
          if (w2.addresses && Array.isArray(w2.addresses) && w2.addresses.length > 0) {
            w2.addresses.forEach((addr, addrIndex) => {
              const pk2 = addr.publicKey || addr.address;
              if (pk2 && !seenPublicKeys.has(pk2)) {
                seenPublicKeys.add(pk2);
                const displayName2 = w2.name || addr.name || `Wallet ${walletIndex + 1}`;
                allAddresses.push({
                  publicKey: pk2,
                  name: displayName2,
                  avatar: w2.avatar,
                  isHardware: w2.isHardware,
                  type: w2.type,
                  isCurrent: pk2 === currentPublicKey
                  // Mark if this is current wallet
                });
              }
            });
          }
          const walletPk = w2.publicKey;
          if (walletPk && !seenPublicKeys.has(walletPk)) {
            seenPublicKeys.add(walletPk);
            allAddresses.push({
              publicKey: walletPk,
              name: w2.name || `Wallet ${walletIndex + 1}`,
              avatar: w2.avatar,
              isHardware: w2.isHardware,
              type: w2.type,
              isCurrent: walletPk === currentPublicKey
            });
          }
        });
        console.log("[SendFlow] Final addresses list:", allAddresses.map((a) => {
          var _a4;
          return { name: a.name, pk: (_a4 = a.publicKey) == null ? void 0 : _a4.slice(0, 8), isCurrent: a.isCurrent };
        }));
        setMyWallets(allAddresses);
        const recentStored = localStorage.getItem("x1_recent_addresses");
        if (recentStored) {
          const recent = JSON.parse(recentStored);
          const enrichedRecent = recent.map((r2) => {
            const matchedWallet = allAddresses.find((w2) => w2.publicKey === r2.address);
            if (matchedWallet && matchedWallet.name) {
              return { ...r2, name: matchedWallet.name };
            }
            return r2;
          });
          setRecentAddresses(enrichedRecent);
        }
      } catch (e) {
        console.error("[SendFlow] Failed to load data:", e);
      }
    };
    loadData();
  }, [(_c = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _c.publicKey, wallet == null ? void 0 : wallet.wallets]);
  const saveRecentAddress = (address, name = null) => {
    try {
      const recent = JSON.parse(localStorage.getItem("x1_recent_addresses") || "[]");
      const filtered = recent.filter((r2) => r2.address !== address);
      const newRecent = [{ address, name, timestamp: Date.now() }, ...filtered].slice(0, 10);
      localStorage.setItem("x1_recent_addresses", JSON.stringify(newRecent));
    } catch (e) {
      logger$1.warn("[SendFlow] Failed to save recent address");
    }
  };
  reactExports.useEffect(() => {
    if (!currentToken) {
      setCurrentToken(initialToken || nativeToken);
    }
  }, [initialToken]);
  reactExports.useEffect(() => {
    var _a3;
    if (recipient && recipient.trim()) {
      const result = validateAddress(recipient.trim());
      if (!result.valid) {
        setAddressWarning(result.error);
      } else {
        setAddressWarning("");
        if (recipient.trim() === ((_a3 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _a3.publicKey)) {
          if (currentToken && currentToken.mint) {
            setAddressWarning("Warning: Sending tokens to yourself");
          } else {
            setAddressWarning("Warning: Sending to your own address");
          }
        }
      }
    } else {
      setAddressWarning("");
    }
  }, [recipient, (_d = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _d.publicKey]);
  const goToStep = (newStep, direction = null) => {
    const dir = direction || (newStep > step ? "right" : "left");
    setSlideDirection(dir);
    setError("");
    setStep(newStep);
  };
  const handleBack = () => {
    if (step === STEPS.TOKEN) {
      onBack();
    } else if (step === STEPS.RECIPIENT) {
      if (initialToken) {
        onBack();
      } else {
        setRecipient("");
        setRecipientName("");
        goToStep(STEPS.TOKEN, "left");
      }
    } else if (step === STEPS.AMOUNT) {
      setRecipient("");
      setRecipientName("");
      goToStep(STEPS.RECIPIENT, "left");
    } else {
      goToStep(step - 1, "left");
    }
  };
  const selectToken = (token) => {
    logger$1.log("[SendFlow] selectToken called:", token == null ? void 0 : token.symbol);
    setCurrentToken(token);
    setAmount("");
    goToStep(STEPS.RECIPIENT, "right");
  };
  const selectRecipient = (address, name = null) => {
    logger$1.log("[SendFlow] selectRecipient called:", { address, name });
    if (!address) {
      logger$1.error("[SendFlow] No address provided to selectRecipient");
      return;
    }
    if (!currentToken) {
      logger$1.log("[SendFlow] No current token, setting to native");
      setCurrentToken(nativeToken);
    }
    setRecipient(address);
    setRecipientName(name || "");
    setSlideDirection("left");
    setError("");
    setStep(STEPS.AMOUNT);
  };
  const proceedToAmount = () => {
    const result = validateAddress(recipient.trim());
    if (result.valid) {
      goToStep(STEPS.AMOUNT, "up");
    } else {
      setAddressWarning(result.error);
    }
  };
  const setMax = () => {
    if (isTokenSend) {
      setAmount(displayBalance.toString());
    } else {
      const max = Math.max(0, displayBalance - 1e-5);
      setAmount(max.toString());
    }
  };
  const validateAndProceed = () => {
    setError("");
    const sendAmount = parseFloat(amount);
    if (!amount || isNaN(sendAmount) || sendAmount <= 0) {
      setError("Please enter a valid amount");
      return;
    }
    const multiplier = Math.pow(10, displayDecimals);
    const requiredAmount = Math.round(sendAmount * multiplier);
    const availableAmount = Math.round(displayBalance * multiplier);
    if (requiredAmount > availableAmount) {
      setError(`Insufficient balance. Required: ${amount} ${displaySymbol}, Available: ${displayBalance} ${displaySymbol}`);
      return;
    }
    goToStep(STEPS.CONFIRM, "left");
  };
  const getTimeAgo = (timestamp) => {
    const now = Date.now();
    const diff = now - timestamp;
    const minutes = Math.floor(diff / 6e4);
    const hours = Math.floor(diff / 36e5);
    const days = Math.floor(diff / 864e5);
    if (minutes < 60) return `${minutes}m ago`;
    if (hours < 24) return `${hours}h ago`;
    if (days === 1) return "yesterday";
    return `${days} days ago`;
  };
  const signWithHardware = async (txMessage) => {
    var _a3, _b3, _c2, _d2, _e, _f, _g, _h, _i, _j, _k;
    try {
      setHwStatus("Connecting to Ledger...");
      const derivationPath = (_a3 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _a3.derivationPath;
      logger$1.log("[SendFlow] Signing with derivation path:", derivationPath);
      logger$1.log("[SendFlow] wallet.wallet object:", JSON.stringify({
        name: (_b3 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _b3.name,
        type: (_c2 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _c2.type,
        isHardware: (_d2 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _d2.isHardware,
        derivationPath: (_e = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _e.derivationPath,
        publicKey: (_f = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _f.publicKey
      }));
      if (!hardwareWallet.isReady()) {
        try {
          await hardwareWallet.connect();
        } catch (connectErr) {
          if ((_g = connectErr.message) == null ? void 0 : _g.includes("already open")) {
            logger$1.log("[SendFlow] Device already open, disconnecting and retrying...");
            await hardwareWallet.disconnect();
            await hardwareWallet.connect();
          } else {
            throw connectErr;
          }
        }
        await hardwareWallet.openApp();
      }
      setHwStatus("Please confirm transaction on Ledger...");
      const signature = await hardwareWallet.signTransaction(txMessage, derivationPath);
      return signature;
    } catch (err) {
      logger$1.error("[SendFlow] Hardware signing error:", err);
      if ((_h = err.message) == null ? void 0 : _h.includes("rejected")) {
        throw new Error("Transaction rejected on Ledger");
      }
      if (((_i = err.message) == null ? void 0 : _i.includes("cancelled")) || ((_j = err.message) == null ? void 0 : _j.includes("No device"))) {
        throw new Error("Ledger connection failed. Please make sure your Ledger is connected and the Solana app is open.");
      }
      if ((_k = err.message) == null ? void 0 : _k.includes("already open")) {
        try {
          await hardwareWallet.disconnect();
        } catch (e) {
        }
        throw new Error("Ledger connection conflict. Please try again.");
      }
      throw new Error(`Ledger signing failed: ${err.message}`);
    }
  };
  const sendNative = async (sendAmount) => {
    var _a3, _b3, _c2, _d2, _e;
    const lamports = Math.floor(sendAmount * Math.pow(10, networkConfig.decimals));
    const priorityFee = priority === "custom" ? parseFloat(customFee) || 0 : ((_a3 = getPriorityOptions$2(network).find((p2) => p2.id === priority)) == null ? void 0 : _a3.fee) || 0;
    const priorityMicroLamports = Math.floor(priorityFee * 1e9);
    const skipSimulation = (() => {
      try {
        return JSON.parse(localStorage.getItem("x1wallet_skipSimulation")) ?? false;
      } catch {
        return false;
      }
    })();
    console.log("[SendFlow] sendNative - Fast Mode (skipSimulation):", skipSimulation);
    const response = await fetch(networkConfig.rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "getLatestBlockhash",
        params: [{ commitment: "finalized" }]
      })
    });
    const data = await response.json();
    if (data.error) throw new Error(data.error.message);
    const blockhash = (_c2 = (_b3 = data.result) == null ? void 0 : _b3.value) == null ? void 0 : _c2.blockhash;
    if (!blockhash) throw new Error("Failed to get blockhash");
    let tx;
    if (isHardwareWallet) {
      const { buildTransferMessage: buildTransferMessage2, serializeTransaction: serializeTransaction2 } = await __vitePreload(async () => {
        const { buildTransferMessage: buildTransferMessage3, serializeTransaction: serializeTransaction3 } = await Promise.resolve().then(() => transaction);
        return { buildTransferMessage: buildTransferMessage3, serializeTransaction: serializeTransaction3 };
      }, true ? void 0 : void 0);
      const message = buildTransferMessage2(
        wallet.wallet.publicKey,
        recipient.trim(),
        lamports,
        blockhash,
        priorityMicroLamports
        // Pass priority fee
      );
      setHwStatus("Please confirm on your Ledger...");
      const signature = await signWithHardware(message);
      const serializedTx = serializeTransaction2(signature, message);
      tx = btoa(String.fromCharCode(...serializedTx));
    } else {
      const { createTransferTransaction: createTransferTransaction2 } = await __vitePreload(async () => {
        const { createTransferTransaction: createTransferTransaction3 } = await Promise.resolve().then(() => transaction);
        return { createTransferTransaction: createTransferTransaction3 };
      }, true ? void 0 : void 0);
      tx = await createTransferTransaction2({
        fromPubkey: wallet.wallet.publicKey,
        toPubkey: recipient.trim(),
        lamports,
        recentBlockhash: blockhash,
        privateKey: wallet.wallet.privateKey,
        priorityFee: priorityMicroLamports
        // Pass priority fee
      });
    }
    const isSelfSend = wallet.wallet.publicKey === recipient.trim();
    if (!skipSimulation && !isSelfSend) {
      console.log("[SendFlow] Running transaction simulation...");
      const simResponse = await fetch(networkConfig.rpcUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "simulateTransaction",
          params: [tx, {
            encoding: "base64",
            commitment: "confirmed",
            replaceRecentBlockhash: true
          }]
        })
      });
      const simData = await simResponse.json();
      if ((_e = (_d2 = simData.result) == null ? void 0 : _d2.value) == null ? void 0 : _e.err) {
        const err = simData.result.value.err;
        logger$1.error("[SendFlow] Simulation error:", JSON.stringify(err));
        let errorMsg = "Transaction simulation failed";
        if (typeof err === "object" && err.InstructionError) {
          const [idx, errDetail] = err.InstructionError;
          if (errDetail === "InsufficientFunds") {
            errorMsg = "Insufficient funds for this transaction";
          } else if (typeof errDetail === "object" && errDetail.Custom !== void 0) {
            errorMsg = `Transaction failed: Custom error ${errDetail.Custom}`;
          } else {
            errorMsg = `Transaction failed: ${JSON.stringify(errDetail)}`;
          }
        }
        throw new Error(errorMsg);
      }
    } else {
      console.log("[SendFlow] Skipping simulation - Fast Mode:", skipSimulation, "Self-send:", isSelfSend);
    }
    const sendResponse = await fetch(networkConfig.rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "sendTransaction",
        params: [tx, {
          encoding: "base64",
          preflightCommitment: "confirmed",
          skipPreflight: skipSimulation || isSelfSend
          // Skip preflight for Fast Mode or self-sends
        }]
      })
    });
    const sendData = await sendResponse.json();
    if (sendData.error) throw new Error(sendData.error.message);
    return sendData.result;
  };
  const sendSPLToken = async (sendAmount, privateKey) => {
    var _a3, _b3, _c2;
    console.log("[SendFlow] sendSPLToken called");
    console.log("[SendFlow] isHardwareWallet:", isHardwareWallet);
    console.log("[SendFlow] wallet.wallet:", wallet == null ? void 0 : wallet.wallet);
    console.log("[SendFlow] wallet.wallet.isHardware:", (_a3 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _a3.isHardware);
    console.log("[SendFlow] currentToken:", currentToken);
    console.log("[SendFlow] network:", network);
    if (!currentToken.mint) {
      throw new Error("Token mint address is required");
    }
    if (!currentToken.address) {
      throw new Error("Token account address not found. Please refresh your wallet.");
    }
    if (!isHardwareWallet && !privateKey) {
      throw new Error("Wallet is locked. Please unlock your wallet first.");
    }
    const tokenAmount = Math.floor(sendAmount * Math.pow(10, currentToken.decimals));
    console.log("[SendFlow] Token send details:", {
      from: wallet.wallet.publicKey,
      to: recipient.trim(),
      mint: currentToken.mint,
      programId: currentToken.programId,
      isToken2022: currentToken.isToken2022,
      sourceATA: currentToken.address,
      isSelfSend: wallet.wallet.publicKey === recipient.trim(),
      isToMint: recipient.trim() === currentToken.mint
    });
    if (recipient.trim() === currentToken.mint) {
      throw new Error("Cannot send tokens to the token mint address. Please enter a wallet address.");
    }
    if (wallet.wallet.publicKey === recipient.trim()) {
      console.log("[SendFlow] Self-transfer detected - returning no-op success");
      return "self-transfer-no-op";
    }
    const response = await fetch(networkConfig.rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "getLatestBlockhash",
        params: [{ commitment: "finalized" }]
      })
    });
    const data = await response.json();
    if (data.error) throw new Error(data.error.message);
    const blockhash = (_c2 = (_b3 = data.result) == null ? void 0 : _b3.value) == null ? void 0 : _c2.blockhash;
    if (!blockhash) throw new Error("Failed to get blockhash");
    let tx;
    if (isHardwareWallet) {
      const { buildTokenTransferMessageForHardware: buildTokenTransferMessageForHardware2, serializeTransaction: serializeTransaction2, findExistingATA: findExistingATA2, deriveATAAddressStandard: deriveATAAddressStandard2 } = await __vitePreload(async () => {
        const { buildTokenTransferMessageForHardware: buildTokenTransferMessageForHardware3, serializeTransaction: serializeTransaction3, findExistingATA: findExistingATA3, deriveATAAddressStandard: deriveATAAddressStandard3 } = await Promise.resolve().then(() => transaction);
        return { buildTokenTransferMessageForHardware: buildTokenTransferMessageForHardware3, serializeTransaction: serializeTransaction3, findExistingATA: findExistingATA3, deriveATAAddressStandard: deriveATAAddressStandard3 };
      }, true ? void 0 : void 0);
      let toTokenAccount = await findExistingATA2(networkConfig.rpcUrl, recipient.trim(), currentToken.mint);
      let needsCreateATA = false;
      if (!toTokenAccount) {
        toTokenAccount = await deriveATAAddressStandard2(
          recipient.trim(),
          currentToken.mint,
          currentToken.programId,
          networkConfig.rpcUrl,
          wallet.wallet.publicKey
          // Use sender as payer for simulation
        );
        needsCreateATA = true;
      }
      setHwStatus("Please confirm on your Ledger...");
      const message = buildTokenTransferMessageForHardware2({
        fromPubkey: wallet.wallet.publicKey,
        toPubkey: recipient.trim(),
        fromTokenAccount: currentToken.address,
        toTokenAccount,
        mint: currentToken.mint,
        amount: tokenAmount,
        recentBlockhash: blockhash,
        tokenProgramId: currentToken.programId,
        needsCreateATA
      });
      const signature = await signWithHardware(message);
      const serializedTx = serializeTransaction2(signature, message);
      tx = btoa(String.fromCharCode(...serializedTx));
    } else {
      const { createTokenTransferTransaction: createTokenTransferTransaction2 } = await __vitePreload(async () => {
        const { createTokenTransferTransaction: createTokenTransferTransaction3 } = await Promise.resolve().then(() => transaction);
        return { createTokenTransferTransaction: createTokenTransferTransaction3 };
      }, true ? void 0 : void 0);
      tx = await createTokenTransferTransaction2({
        fromPubkey: wallet.wallet.publicKey,
        toPubkey: recipient.trim(),
        mint: currentToken.mint,
        amount: tokenAmount,
        decimals: currentToken.decimals,
        fromTokenAccount: currentToken.address,
        recentBlockhash: blockhash,
        privateKey,
        programId: currentToken.programId,
        rpcUrl: networkConfig.rpcUrl
      });
    }
    const sendResponse = await fetch(networkConfig.rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "sendTransaction",
        params: [tx, { encoding: "base64", preflightCommitment: "confirmed" }]
      })
    });
    const sendData = await sendResponse.json();
    if (sendData.error) throw new Error(sendData.error.message);
    return sendData.result;
  };
  const handleSend = async () => {
    var _a3;
    setError("");
    const privateKey = (_a3 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _a3.privateKey;
    if (!isHardwareWallet && (!privateKey || typeof privateKey !== "string" || privateKey.length < 32)) {
      setError("Wallet is locked or not available. Please unlock your wallet first.");
      return;
    }
    setSending(true);
    if (isHardwareWallet) {
      setHwStatus("Connecting to Ledger...");
    }
    try {
      const sendAmount = parseFloat(amount);
      let signature;
      if (isTokenSend) {
        signature = await sendSPLToken(sendAmount, privateKey);
      } else {
        signature = await sendNative(sendAmount);
      }
      setTxHash(signature);
      if (signature !== "self-transfer-no-op") {
        const { addTransaction: addTransaction2 } = await __vitePreload(async () => {
          const { addTransaction: addTransaction3 } = await Promise.resolve().then(() => transaction);
          return { addTransaction: addTransaction3 };
        }, true ? void 0 : void 0);
        addTransaction2({
          signature,
          type: "send",
          amount: sendAmount,
          symbol: displaySymbol,
          from: wallet.wallet.publicKey,
          to: recipient.trim(),
          timestamp: Date.now(),
          status: "confirmed",
          network,
          isToken: isTokenSend,
          mint: currentToken == null ? void 0 : currentToken.mint,
          tokenName: (currentToken == null ? void 0 : currentToken.name) || (currentToken == null ? void 0 : currentToken.symbol)
        });
        const { trackSendXP: trackSendXP2 } = await __vitePreload(async () => {
          const { trackSendXP: trackSendXP3 } = await Promise.resolve().then(() => xp);
          return { trackSendXP: trackSendXP3 };
        }, true ? void 0 : void 0);
        trackSendXP2({
          user: wallet.wallet.publicKey,
          network,
          transactionSignature: signature,
          mint: (currentToken == null ? void 0 : currentToken.mint) || "So11111111111111111111111111111111111111112",
          amount: sendAmount,
          recipient: recipient.trim()
        }).catch(() => {
        });
      }
      saveRecentAddress(recipient.trim(), recipientName || null);
      if (onSuccess) onSuccess(signature);
      goToStep(STEPS.SUCCESS, "up");
    } catch (err) {
      logger$1.error("[SendFlow] Send error:", err.message || err);
      setError(getUserFriendlyError(err, ErrorMessages.transaction.failed));
    } finally {
      setSending(false);
      setHwStatus("");
    }
  };
  const getHeaderTitle = () => {
    switch (step) {
      case STEPS.TOKEN:
        return "Send";
      case STEPS.RECIPIENT:
        return "Send";
      case STEPS.AMOUNT:
        return `Send ${displaySymbol}`;
      case STEPS.CONFIRM:
        return "Confirm";
      case STEPS.SUCCESS:
        return "Success";
      default:
        return "Send";
    }
  };
  const renderStep = () => {
    var _a3, _b3;
    switch (step) {
      case STEPS.TOKEN:
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-step-content", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-section-label", children: "SELECT TOKEN TO SEND" }),
          availableTokens.map((token, i) => {
            var _a4;
            const balance = parseFloat(token.balance || token.uiAmount || 0);
            let price = token.price || 0;
            if (token.isNative) {
              price = (network == null ? void 0 : network.includes("Solana")) ? 150 : 1;
            } else if (token.symbol === "USDC" || token.symbol === "USDT" || token.symbol === "USDC.X") {
              price = 1;
            }
            const usdValue = balance * price;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: "send-token-row",
                onClick: () => selectToken(token),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-token-icon", children: token.isNative ? /* @__PURE__ */ jsxRuntimeExports.jsx(NetworkLogo$1, { network, size: 32 }) : token.logoURI ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: token.logoURI, alt: token.symbol, style: { width: 26, height: 26, objectFit: "contain" } }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-token-initial", children: ((_a4 = token.symbol) == null ? void 0 : _a4.charAt(0)) || "?" }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-token-info", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-token-symbol", children: token.symbol }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-token-name", children: token.name })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-token-balance-col", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-token-balance-amount", children: balance.toLocaleString(void 0, { maximumFractionDigits: 6 }) }),
                    usdValue > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "send-token-balance-usd", children: [
                      "$",
                      usdValue.toLocaleString(void 0, { minimumFractionDigits: 2, maximumFractionDigits: 2 })
                    ] })
                  ] })
                ]
              },
              token.mint || "native"
            );
          })
        ] }) });
      case STEPS.RECIPIENT:
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-step-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-address-input-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                className: "form-input send-address-input",
                placeholder: "Enter address",
                value: recipient,
                onChange: (e) => setRecipient(e.target.value),
                autoComplete: "off",
                spellCheck: "false"
              }
            ),
            recipient && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "send-address-clear",
                onClick: () => {
                  setRecipient("");
                  setRecipientName("");
                },
                type: "button",
                children: ""
              }
            )
          ] }),
          addressWarning && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-address-warning", children: addressWarning }),
          recentAddresses.length > 0 && !recipient && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-section-label", children: "Recent addresses" }),
            recentAddresses.map((addr, i) => {
              const isGenericName = addr.name && /^(Address|Wallet)\s*\d*$/i.test(addr.name);
              const displayName2 = addr.name && !isGenericName ? addr.name : null;
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: "send-address-row",
                  onClick: () => selectRecipient(addr.address, displayName2),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-address-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "12 6 12 12 16 14" })
                    ] }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-address-info", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-address-main", children: displayName2 || `${addr.address.slice(0, 12)}...` }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-address-meta", children: getTimeAgo(addr.timestamp) })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "send-address-short", children: [
                      addr.address.slice(0, 4),
                      "...",
                      addr.address.slice(-4)
                    ] })
                  ]
                },
                i
              );
            })
          ] }),
          myWallets.length > 0 && !recipient && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-section-label", children: "YOUR ADDRESSES" }),
            myWallets.map((w2, i) => {
              var _a4, _b4, _c2, _d2;
              const hasImage = w2.avatar && (w2.avatar.startsWith("data:image") || w2.avatar.startsWith("http"));
              const isHardware = w2.isHardware || w2.type === "ledger";
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: "send-address-row",
                  onClick: () => selectRecipient(w2.publicKey, w2.name),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-wallet-avatar", children: hasImage ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: w2.avatar, alt: w2.name }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallet-avatar-initials", children: isHardware ? "L" : ((_b4 = (_a4 = w2.name) == null ? void 0 : _a4.charAt(0)) == null ? void 0 : _b4.toUpperCase()) || "W" }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-wallet-info", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "send-wallet-name", children: [
                        w2.name || `Wallet ${i + 1}`,
                        w2.isCurrent && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "var(--text-muted)", fontSize: 11, marginLeft: 6 }, children: "(Current)" })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "send-wallet-address", children: [
                        (_c2 = w2.publicKey) == null ? void 0 : _c2.slice(0, 6),
                        "...",
                        (_d2 = w2.publicKey) == null ? void 0 : _d2.slice(-4)
                      ] })
                    ] })
                  ]
                },
                w2.publicKey || i
              );
            })
          ] }),
          myWallets.length === 0 && recentAddresses.length === 0 && !recipient && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-empty-state", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Enter a wallet address above or add more wallets to see them here." }) }),
          recipient && (!addressWarning || addressWarning.startsWith("Warning:")) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-bottom-action", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-primary",
              onClick: proceedToAmount,
              children: "Next"
            }
          ) })
        ] });
      case STEPS.AMOUNT:
        if (!recipient) {
          logger$1.warn("[SendFlow] No recipient in AMOUNT step");
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-step-content", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-empty-state", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No recipient selected. Please go back and select a recipient." }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-bottom-action", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: () => goToStep(STEPS.RECIPIENT, "left"), children: "Go Back" }) })
          ] });
        }
        if (!currentToken && !initialToken) {
          logger$1.warn("[SendFlow] No token selected in AMOUNT step");
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-step-content", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-empty-state", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "No token selected. Please go back and select a token." }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-bottom-action", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: () => goToStep(STEPS.TOKEN, "left"), children: "Go Back" }) })
          ] });
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-step-content send-amount-step", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-recipient-display", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-recipient-label", children: recipientName && !recipientName.match(/^(Address|Wallet)\s*\d*$/i) ? recipientName : "Recipient" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-recipient-pill", children: [
              recipient.slice(0, 6),
              "...",
              recipient.slice(-4)
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-amount-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                inputMode: "decimal",
                className: "send-amount-input",
                placeholder: "0",
                value: amount,
                onChange: (e) => setAmount(e.target.value.replace(/[^0-9.]/g, "")),
                autoComplete: "off"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-amount-token", children: [
              isTokenSend && currentToken ? currentToken.logoURI ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: currentToken.logoURI, alt: currentToken.symbol, style: { width: 24, height: 24, borderRadius: "50%" } }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-token-mini", children: (_a3 = currentToken.symbol) == null ? void 0 : _a3.charAt(0) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(NetworkLogo$1, { network, size: 24 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: displaySymbol })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "send-max-pill", onClick: setMax, type: "button", children: [
            "Max: ",
            displayBalance.toLocaleString(void 0, { maximumFractionDigits: 6 }),
            " ",
            displaySymbol
          ] }),
          error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", style: { marginTop: 16 }, children: error }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-bottom-action", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-primary",
              onClick: validateAndProceed,
              disabled: !amount || parseFloat(amount) <= 0,
              children: "Review"
            }
          ) })
        ] });
      case STEPS.CONFIRM:
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-step-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-summary-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-summary-row", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-summary-label", children: "Sending" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "send-summary-value", children: [
                amount,
                " ",
                displaySymbol
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-summary-row", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-summary-label", children: "To" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-summary-value", children: recipientName && !recipientName.match(/^(Address|Wallet)\s*\d*$/i) ? recipientName : `${recipient.slice(0, 6)}...${recipient.slice(-4)}` })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-summary-row", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-summary-label", children: "Network Fee" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "send-summary-value", children: [
                "~",
                (getBaseFee$2(network) + (priority === "custom" ? parseFloat(customFee) || 0 : ((_b3 = getPriorityOptions$2(network).find((p2) => p2.id === priority)) == null ? void 0 : _b3.fee) || 0)).toFixed(6),
                " ",
                networkConfig.symbol
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-priority-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-priority-label", children: "Transaction Priority" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-priority-selector", children: [
              getPriorityOptions$2(network).filter((opt) => opt.id !== "custom").map((opt) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `send-priority-btn ${priority === opt.id ? "active" : ""}`,
                  onClick: () => {
                    setPriority(opt.id);
                    setCustomFee("");
                  },
                  type: "button",
                  disabled: sending,
                  children: opt.name
                },
                opt.id
              )),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `send-priority-btn ${priority === "custom" ? "active" : ""}`,
                  onClick: () => setPriority("custom"),
                  type: "button",
                  disabled: sending,
                  children: ""
                }
              )
            ] }),
            priority === "custom" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 12, display: "flex", alignItems: "center", justifyContent: "center", gap: 8 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "number",
                  min: "0",
                  style: {
                    width: 100,
                    padding: "8px 12px",
                    background: "var(--bg-tertiary)",
                    border: "1px solid var(--border-color)",
                    borderRadius: 8,
                    color: "var(--text-primary)",
                    fontSize: 13,
                    textAlign: "right"
                  },
                  placeholder: "0.0001",
                  value: customFee,
                  onChange: (e) => {
                    const value = e.target.value;
                    if (value.startsWith("-") || parseFloat(value) < 0) return;
                    setCustomFee(value);
                  },
                  step: "0.0001",
                  min: "0",
                  disabled: sending
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "var(--text-muted)", fontSize: 13 }, children: networkConfig.symbol })
            ] })
          ] }),
          hwStatus && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-hw-status", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner", style: { width: 20, height: 20 } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: hwStatus })
          ] }),
          error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: error }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-confirm-actions", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "btn-secondary send-deny-btn",
                onClick: () => goToStep(STEPS.AMOUNT, "left"),
                disabled: sending,
                children: "Deny"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "btn-primary send-approve-btn",
                onClick: handleSend,
                disabled: sending,
                children: sending ? "Sending..." : "Approve"
              }
            )
          ] })
        ] });
      case STEPS.SUCCESS:
        const isSelfTransferNoOp = txHash === "self-transfer-no-op";
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-step-content send-success", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "success-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: "var(--success)", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M22 11.08V12a10 10 0 1 1-5.93-9.14" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "22 4 12 14.01 9 11.01" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "send-success-title", children: isSelfTransferNoOp ? "Complete!" : "Sent!" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "send-success-amount", children: [
            amount,
            " ",
            displaySymbol
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "send-success-to", children: [
            "to ",
            recipient.slice(0, 6),
            "...",
            recipient.slice(-4)
          ] }),
          isSelfTransferNoOp && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "var(--text-muted)", fontSize: 12, marginTop: 8 }, children: "Self-transfer - no blockchain transaction needed" }),
          txHash && !isSelfTransferNoOp && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-secondary",
              onClick: () => window.open(getTxExplorerUrl(network, txHash), "_blank"),
              style: { marginTop: 16 },
              children: "View on Explorer"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: onBack, style: { marginTop: 12 }, children: "Done" })
        ] });
      default:
        return null;
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen send-screen send-flow-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: step !== STEPS.SUCCESS && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: handleBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: step === STEPS.TOKEN ? /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18 6L6 18M6 6l12 12" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: getHeaderTitle() }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-right" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `send-flow-content slide-${slideDirection}`,
        children: renderStep()
      },
      step
    )
  ] });
}
const SOLANA_LOGO_URL$1 = "/icons/48-sol.png";
function NetworkLogo({ network, size = 40 }) {
  const solanaLogoSize = Math.round(size * 0.95);
  if (network == null ? void 0 : network.includes("Solana")) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: size, height: size, minWidth: size, minHeight: size, borderRadius: "50%", background: "#000", display: "flex", alignItems: "center", justifyContent: "center", flexShrink: 0, overflow: "hidden" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: SOLANA_LOGO_URL$1, alt: "Solana", style: { width: solanaLogoSize, height: solanaLogoSize, objectFit: "contain", display: "block" } }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(X1Logo, { size });
}
function ReceiveScreen({ wallet, onBack }) {
  var _a2;
  const [copied, setCopied] = reactExports.useState(false);
  const canvasRef = reactExports.useRef(null);
  const address = ((_a2 = wallet.wallet) == null ? void 0 : _a2.publicKey) || "";
  reactExports.useEffect(() => {
    if (!canvasRef.current || !address) return;
    const qrData = `solana:${address}`;
    __vitePreload(() => import("./browser.js").then((n2) => n2.b), true ? [] : void 0).then((QRCode) => {
      QRCode.toCanvas(canvasRef.current, qrData, {
        width: 200,
        margin: 2,
        color: {
          dark: "#000000",
          light: "#ffffff"
        },
        errorCorrectionLevel: "M"
      }, (err) => {
        if (err) logger$1.error("QR generation failed:", err);
      });
    }).catch((err) => {
      logger$1.error("Failed to load QR library:", err);
    });
  }, [address]);
  const copyAddress = () => {
    navigator.clipboard.writeText(address);
    setCopied(true);
    setTimeout(() => setCopied(false), 2e3);
  };
  const shareAddress = async () => {
    try {
      if (navigator.share) {
        await navigator.share({ title: `${wallet.network} Address`, text: address });
      } else {
        copyAddress();
      }
    } catch (err) {
      if (err.name !== "AbortError") copyAddress();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen receive-screen", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sub-screen-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: onBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Receive" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "receive-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "receive-token", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(NetworkLogo, { network: wallet.network, size: 40 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: wallet.network })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "qr-container", style: { marginBottom: 24 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("canvas", { ref: canvasRef, className: "qr-code", style: { borderRadius: 12 } }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "receive-instructions", style: { marginBottom: 16 }, children: "Scan the QR code or copy the address below" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "address-display", style: { textAlign: "center", marginBottom: 20 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: address }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "receive-buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "receive-btn", onClick: copyAddress, children: copied ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }),
          "Copied!"
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })
          ] }),
          "Copy"
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "receive-btn secondary", onClick: shareAddress, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "18", cy: "5", r: "3" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "6", cy: "12", r: "3" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "18", cy: "19", r: "3" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "8.59", y1: "13.51", x2: "15.42", y2: "17.49" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "15.41", y1: "6.51", x2: "8.59", y2: "10.49" })
          ] }),
          "Share"
        ] })
      ] })
    ] })
  ] });
}
function getPriorityOptions$1(network) {
  const isX1 = network == null ? void 0 : network.includes("X1");
  if (isX1) {
    return [
      { id: "auto", name: "Auto", microLamports: 0, fee: 0, description: "Use API default" },
      { id: "fast", name: "Fast", microLamports: 1e3, fee: 15e-5, description: "~0.00015 XNT extra" },
      { id: "turbo", name: "Turbo", microLamports: 1e4, fee: 15e-4, description: "~0.0015 XNT extra" },
      { id: "degen", name: "Degen", microLamports: 1e5, fee: 0.015, description: "~0.015 XNT extra" },
      { id: "custom", name: "Custom", microLamports: 0, fee: 0, description: "Custom fee" }
    ];
  }
  return [
    { id: "auto", name: "Auto", microLamports: 0, fee: 0, description: "Use API default" },
    { id: "fast", name: "Fast", microLamports: 1e4, fee: 15e-4, description: "~0.0015 SOL extra" },
    { id: "turbo", name: "Turbo", microLamports: 1e5, fee: 0.015, description: "~0.015 SOL extra" },
    { id: "degen", name: "Degen", microLamports: 1e6, fee: 0.15, description: "~0.15 SOL extra" },
    { id: "custom", name: "Custom", microLamports: 0, fee: 0, description: "Custom fee" }
  ];
}
function customFeeToMicroLamports(feeInSol, computeUnits = 15e4) {
  if (!feeInSol || feeInSol <= 0) return 0;
  const lamports = Math.floor(feeInSol * 1e9);
  const microLamports = Math.floor(lamports * 1e6 / computeUnits);
  return microLamports;
}
function getBaseFee$1(network) {
  const isX1 = network == null ? void 0 : network.includes("X1");
  return isX1 ? 2e-3 : 5e-6;
}
const imageCache = /* @__PURE__ */ new Map();
function preloadImage(url) {
  if (!url || imageCache.has(url)) return;
  const img = new Image();
  img.src = url;
  imageCache.set(url, img);
}
function preloadImages(tokens2) {
  if (!tokens2) return;
  tokens2.forEach((token) => {
    if (token.logoURI) preloadImage(token.logoURI);
  });
}
const CUSTOM_TOKENS_KEY = "x1wallet_custom_tokens";
function loadCustomTokens(network) {
  try {
    const stored = localStorage.getItem(CUSTOM_TOKENS_KEY);
    logger$1.log("[CustomTokens] Loading for network:", network, "Raw stored:", stored);
    if (stored) {
      const all = JSON.parse(stored);
      const tokens2 = all[network] || [];
      logger$1.log("[CustomTokens] Found tokens for network:", tokens2.length, tokens2);
      const seen2 = /* @__PURE__ */ new Set();
      const deduplicated = tokens2.filter((t2) => {
        const key = t2.mint || t2.symbol;
        if (seen2.has(key) || seen2.has(t2.symbol)) {
          return false;
        }
        seen2.add(t2.mint);
        seen2.add(t2.symbol);
        return true;
      });
      if (deduplicated.length !== tokens2.length) {
        all[network] = deduplicated;
        localStorage.setItem(CUSTOM_TOKENS_KEY, JSON.stringify(all));
        logger$1.log("[CustomTokens] Deduplicated and saved:", deduplicated.length);
      }
      return deduplicated;
    }
  } catch (e) {
    logger$1.error("Failed to load custom tokens:", e);
  }
  return [];
}
function saveCustomTokens(network, tokens2) {
  try {
    logger$1.log("[CustomTokens] Saving for network:", network, "Tokens:", tokens2);
    const stored = localStorage.getItem(CUSTOM_TOKENS_KEY);
    const all = stored ? JSON.parse(stored) : {};
    all[network] = tokens2;
    localStorage.setItem(CUSTOM_TOKENS_KEY, JSON.stringify(all));
    logger$1.log("[CustomTokens] Saved. New stored:", localStorage.getItem(CUSTOM_TOKENS_KEY));
  } catch (e) {
    logger$1.error("Failed to save custom tokens:", e);
  }
}
function forceResetCustomTokens() {
  try {
    localStorage.removeItem(CUSTOM_TOKENS_KEY);
    logger$1.log("[CustomTokens] Force reset - removed all custom tokens");
  } catch (e) {
    logger$1.error("Failed to force reset custom tokens:", e);
  }
}
function isTokenAddress(str) {
  if (!str || typeof str !== "string") return false;
  if (str.length < 32 || str.length > 44) return false;
  const base58Regex = /^[1-9A-HJ-NP-Za-km-z]+$/;
  if (!base58Regex.test(str)) return false;
  try {
    const BASE58_ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    const bytes = [0];
    for (let i = 0; i < str.length; i++) {
      const char = str[i];
      let value = BASE58_ALPHABET2.indexOf(char);
      if (value < 0) return false;
      for (let j = 0; j < bytes.length; j++) {
        value += bytes[j] * 58;
        bytes[j] = value & 255;
        value >>= 8;
      }
      while (value > 0) {
        bytes.push(value & 255);
        value >>= 8;
      }
    }
    for (let i = 0; i < str.length && str[i] === BASE58_ALPHABET2[0]; i++) {
      bytes.push(0);
    }
    const decoded = new Uint8Array(bytes.reverse());
    if (decoded.length !== 32) return false;
    return true;
  } catch (e) {
    return false;
  }
}
function SwapScreen({ wallet, onBack, onSwapComplete, userTokens = [], initialFromToken = null }) {
  var _a2, _b2, _c, _d;
  const [tokens$1, setTokens] = reactExports.useState([]);
  const [fromToken, setFromToken] = reactExports.useState(null);
  const [toToken, setToToken] = reactExports.useState(null);
  const [fromAmount, setFromAmount] = reactExports.useState("");
  const [toAmount, setToAmount] = reactExports.useState("");
  const [inputMode, setInputMode] = reactExports.useState("from");
  const [selectingToken, setSelectingToken] = reactExports.useState(null);
  const [slippage, setSlippage] = reactExports.useState(() => {
    const savedNetwork = localStorage.getItem("x1wallet_network") || "";
    return savedNetwork.includes("X1") ? 1 : 0.5;
  });
  const [customSlippage, setCustomSlippage] = reactExports.useState("");
  const slippageOptions = [0.5, 1, 2, 5];
  const [loading, setLoading] = reactExports.useState(false);
  const [quoteLoading, setQuoteLoading] = reactExports.useState(false);
  const [quote, setQuote] = reactExports.useState(null);
  const [quoteTimestamp, setQuoteTimestamp] = reactExports.useState(null);
  const [error, setError] = reactExports.useState("");
  const [swapStatus, setSwapStatus] = reactExports.useState("");
  const [hwStatus, setHwStatus] = reactExports.useState("");
  const [showConfirm, setShowConfirm] = reactExports.useState(false);
  const [txHash, setTxHash] = reactExports.useState("");
  const [swapPriority, setSwapPriority] = reactExports.useState("auto");
  const [customFee, setCustomFee] = reactExports.useState("");
  const isHardwareWallet = ((_a2 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _a2.isHardware) || ((_b2 = wallet == null ? void 0 : wallet.activeWallet) == null ? void 0 : _b2.isHardware) || (wallet == null ? void 0 : wallet.isHardware) || false;
  const [showManageTokens, setShowManageTokens] = reactExports.useState(false);
  const [customTokens, setCustomTokens] = reactExports.useState([]);
  const [newTokenAddress, setNewTokenAddress] = reactExports.useState("");
  const [addingToken, setAddingToken] = reactExports.useState(false);
  const [tokenSearchQuery, setTokenSearchQuery] = reactExports.useState("");
  const [confirmClearAll, setConfirmClearAll] = reactExports.useState(false);
  const [searchResults, setSearchResults] = reactExports.useState([]);
  const [searching, setSearching] = reactExports.useState(false);
  const [poolTokens, setPoolTokens] = reactExports.useState([]);
  const [poolTokensLoading, setPoolTokensLoading] = reactExports.useState(false);
  const [localTokens, setLocalTokens] = reactExports.useState([]);
  const [fetchingLocalTokens, setFetchingLocalTokens] = reactExports.useState(false);
  const localTokensFetchedRef = reactExports.useRef(false);
  const [initialTokenSet, setInitialTokenSet] = reactExports.useState(false);
  const lastOptimisticUpdate = reactExports.useRef(0);
  const walletReady = !!(wallet && wallet.network);
  const currentNetwork2 = (wallet == null ? void 0 : wallet.network) || "X1 Mainnet";
  const getNetworkConfig2 = () => {
    if (NETWORKS[currentNetwork2]) {
      return NETWORKS[currentNetwork2];
    }
    try {
      const customNetworks = JSON.parse(localStorage.getItem("x1wallet_customRpcs") || "[]");
      const customNet = customNetworks.find((n2) => n2.name === currentNetwork2);
      if (customNet) {
        return {
          name: customNet.name,
          rpcUrl: customNet.url,
          symbol: customNet.symbol || "XNT",
          decimals: customNet.decimals || 9,
          explorer: customNet.explorer || "",
          isX1: true,
          // Custom networks are assumed to be X1-based
          isSVM: true
        };
      }
    } catch (e) {
      logger$1.warn("[SwapScreen] Failed to load custom networks:", e);
    }
    return NETWORKS["X1 Mainnet"];
  };
  const networkConfig = getNetworkConfig2();
  const nativeSymbol = (networkConfig == null ? void 0 : networkConfig.symbol) || "XNT";
  const isSolana = isSolanaNetwork(currentNetwork2);
  const walletBalance = (wallet == null ? void 0 : wallet.balance) ?? 0;
  reactExports.useEffect(() => {
    if (initialFromToken && !initialTokenSet && tokens$1.length > 0) {
      logger$1.log("[SwapScreen] Setting initial from token:", initialFromToken.symbol);
      const matchedToken = tokens$1.find(
        (t2) => t2.mint === initialFromToken.mint || t2.address === initialFromToken.address || t2.symbol === initialFromToken.symbol && t2.isNative === initialFromToken.isNative
      );
      if (matchedToken) {
        setFromToken(matchedToken);
        setInitialTokenSet(true);
      } else if (initialFromToken.isNative) {
        const nativeToken = {
          symbol: nativeSymbol,
          name: (networkConfig == null ? void 0 : networkConfig.name) || "Native Token",
          mint: "native",
          isNative: true,
          decimals: (networkConfig == null ? void 0 : networkConfig.decimals) || 9,
          balance: walletBalance,
          logoURI: null
        };
        setFromToken(nativeToken);
        setInitialTokenSet(true);
      }
    }
  }, [initialFromToken, tokens$1, initialTokenSet, nativeSymbol, networkConfig, walletBalance]);
  reactExports.useEffect(() => {
    logger$1.log("[SwapScreen] userTokens prop changed:", userTokens == null ? void 0 : userTokens.length, userTokens == null ? void 0 : userTokens.map((t2) => {
      var _a3;
      return t2.symbol || ((_a3 = t2.mint) == null ? void 0 : _a3.slice(0, 6));
    }));
  }, [userTokens]);
  reactExports.useEffect(() => {
    logger$1.log("[SwapScreen] Network changed to:", currentNetwork2, "- resetting swap state");
    setFromToken(null);
    setToToken(null);
    setFromAmount("");
    setToAmount("");
    setQuote(null);
    setTokens([]);
    setPoolTokens([]);
    setSearchResults([]);
    setError("");
    setInitialTokenSet(false);
    setLocalTokens([]);
    localTokensFetchedRef.current = false;
  }, [currentNetwork2]);
  const SOLANA_ONLY_SYMBOLS = ["SOL", "WSOL", "RAY", "SRM", "ORCA", "MNGO", "STEP", "COPE", "FIDA", "MAPS", "OXY", "mSOL", "stSOL", "jitoSOL", "bSOL"];
  const X1_ONLY_SYMBOLS = ["XNT", "WXNT", "pXNT"];
  reactExports.useEffect(() => {
    var _a3;
    if (userTokens && userTokens.length > 0) {
      logger$1.log("[SwapScreen] Using userTokens from parent:", userTokens.length);
      localTokensFetchedRef.current = false;
      return;
    }
    if (!walletReady || !(networkConfig == null ? void 0 : networkConfig.rpcUrl) || !((_a3 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _a3.publicKey)) {
      return;
    }
    if (fetchingLocalTokens || localTokensFetchedRef.current) {
      return;
    }
    const fetchLocalTokens = async () => {
      logger$1.log("[SwapScreen] Fetching token balances directly (userTokens empty)");
      setFetchingLocalTokens(true);
      try {
        const { fetchTokenAccounts: fetchTokenAccounts2 } = await __vitePreload(async () => {
          const { fetchTokenAccounts: fetchTokenAccounts3 } = await Promise.resolve().then(() => tokens);
          return { fetchTokenAccounts: fetchTokenAccounts3 };
        }, true ? void 0 : void 0);
        const allTokens = await fetchTokenAccounts2(
          networkConfig.rpcUrl,
          wallet.wallet.publicKey,
          currentNetwork2
        );
        const tokenList = allTokens.filter((token) => {
          const isNFT = token.decimals === 0 && token.uiAmount === 1;
          return !isNFT;
        });
        logger$1.log("[SwapScreen] Directly fetched tokens:", tokenList.length, tokenList.map((t2) => `${t2.symbol}:${t2.balance || t2.uiAmount}`));
        setLocalTokens(tokenList);
        localTokensFetchedRef.current = true;
      } catch (err) {
        logger$1.error("[SwapScreen] Failed to fetch tokens directly:", err);
      } finally {
        setFetchingLocalTokens(false);
      }
    };
    fetchLocalTokens();
  }, [userTokens, walletReady, networkConfig == null ? void 0 : networkConfig.rpcUrl, (_c = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _c.publicKey, currentNetwork2, fetchingLocalTokens]);
  const effectiveUserTokens = React.useMemo(() => {
    if (userTokens && userTokens.length > 0) {
      return userTokens;
    }
    return localTokens;
  }, [userTokens, localTokens]);
  const filteredUserTokens = React.useMemo(() => {
    if (!effectiveUserTokens || effectiveUserTokens.length === 0) return [];
    return effectiveUserTokens.filter((token) => {
      var _a3;
      const symbol = ((_a3 = token.symbol) == null ? void 0 : _a3.toUpperCase()) || "";
      if (!isSolana) {
        if (SOLANA_ONLY_SYMBOLS.includes(symbol)) {
          logger$1.log("[SwapScreen] Filtering out Solana token on X1:", symbol);
          return false;
        }
      }
      if (isSolana) {
        if (X1_ONLY_SYMBOLS.includes(symbol)) {
          logger$1.log("[SwapScreen] Filtering out X1 token on Solana:", symbol);
          return false;
        }
      }
      return true;
    });
  }, [effectiveUserTokens, isSolana]);
  reactExports.useEffect(() => {
    logger$1.log("[SwapScreen] Pool tokens useEffect triggered - network:", currentNetwork2, "isSolana:", isSolana, "walletReady:", walletReady);
    const fetchPoolTokens = async () => {
      var _a3;
      logger$1.log("[SwapScreen] fetchPoolTokens called - network:", currentNetwork2);
      if (!walletReady) {
        logger$1.log("[SwapScreen] Skipping pool fetch - wallet not ready");
        return;
      }
      if (isSolana) {
        logger$1.log("[SwapScreen] Loading Solana tokens from getSwapTokens");
        setPoolTokensLoading(true);
        try {
          const solanaTokens = await getSwapTokens(currentNetwork2);
          logger$1.log("[SwapScreen] Solana tokens loaded:", solanaTokens.length, solanaTokens.map((t2) => t2.symbol));
          const nonNativeTokens = solanaTokens.filter((t2) => t2.symbol !== "SOL" && t2.mint !== "native" && !t2.isNative);
          setPoolTokens(nonNativeTokens.map((t2) => ({ ...t2, isPoolToken: true })));
        } catch (e) {
          logger$1.error("[SwapScreen] Failed to load Solana tokens:", e);
          setPoolTokens([]);
        }
        setPoolTokensLoading(false);
        return;
      }
      logger$1.log("[SwapScreen] Starting pool tokens fetch for:", currentNetwork2);
      setPoolTokensLoading(true);
      const networkParam = currentNetwork2 === "X1 Testnet" ? "X1 Testnet" : "X1 Mainnet";
      const encodedNetwork = encodeURIComponent(networkParam);
      const endpoints = [
        { url: `https://devapi.xdex.xyz/api/xendex/wallet/tokens/pool?network=${encodedNetwork}`, name: "devapi-pool" },
        { url: `https://api.xdex.xyz/api/xendex/wallet/tokens/pool?network=${encodedNetwork}`, name: "api-pool" }
      ];
      let tokenList = [];
      let succeeded = false;
      for (const endpoint of endpoints) {
        if (succeeded) break;
        try {
          logger$1.log("[SwapScreen] Trying pool tokens from:", endpoint.name, endpoint.url);
          const response = await fetch(endpoint.url, {
            method: "GET",
            headers: {
              "Accept": "application/json",
              "Content-Type": "application/json"
            }
          });
          logger$1.log("[SwapScreen] Response status:", response.status, "from", endpoint.name);
          if (response.ok) {
            const data = await response.json();
            logger$1.log("[SwapScreen] Raw response:", JSON.stringify(data).slice(0, 500));
            if (Array.isArray(data)) {
              tokenList = data;
            } else if (((_a3 = data.data) == null ? void 0 : _a3.tokens) && Array.isArray(data.data.tokens)) {
              tokenList = data.data.tokens;
            } else if (data.data && Array.isArray(data.data)) {
              tokenList = data.data;
            } else if (data.tokens && Array.isArray(data.tokens)) {
              tokenList = data.tokens;
            } else if (data.result && Array.isArray(data.result)) {
              tokenList = data.result;
            } else {
              logger$1.log("[SwapScreen] Unknown response format, keys:", Object.keys(data), "data keys:", data.data ? Object.keys(data.data) : "N/A");
              continue;
            }
            if (tokenList.length > 0) {
              succeeded = true;
              logger$1.log("[SwapScreen] Token list from API:", tokenList.length);
            }
          }
        } catch (e) {
          logger$1.log("[SwapScreen] API error:", endpoint.name, e.message);
        }
      }
      if (succeeded && tokenList.length > 0) {
        const normalized = tokenList.map((t2) => {
          let logoURI = t2.logoURI || t2.imageUrl || t2.logo || t2.image || t2.LogoURI || t2.Icon || "";
          if (logoURI && logoURI.startsWith("/")) {
            logoURI = `https://xdex.xyz${logoURI}`;
          }
          return {
            symbol: t2.symbol || t2.ticker || t2.Symbol || "UNK",
            name: t2.name || t2.Name || t2.symbol || "Unknown",
            mint: t2.mint || t2.address || t2.tokenAddress || t2.Mint || t2.Address,
            logoURI,
            decimals: t2.decimals || t2.Decimals || 9,
            isPoolToken: true
          };
        }).filter((t2) => t2.mint);
        logger$1.log("[SwapScreen] Normalized pool tokens:", normalized.length, normalized.map((t2) => t2.symbol));
        setPoolTokens(normalized);
      } else {
        logger$1.warn("[SwapScreen] All API endpoints failed, using fallback");
        try {
          const baseTokens = await getSwapTokens(currentNetwork2);
          const poolFallback = baseTokens.filter((t2) => !t2.isNative && t2.mint !== "native");
          logger$1.log("[SwapScreen] Using fallback tokens:", poolFallback.length);
          setPoolTokens(poolFallback.map((t2) => ({ ...t2, isPoolToken: true })));
        } catch (e2) {
          logger$1.error("[SwapScreen] Fallback also failed:", e2);
          setPoolTokens([]);
        }
      }
      setPoolTokensLoading(false);
    };
    fetchPoolTokens();
  }, [currentNetwork2, isSolana, walletReady]);
  const formatBalance2 = (balance, maxDecimals = 6) => {
    if (balance === 0 || balance === null || balance === void 0) return "0";
    if (balance < 1e-6) return balance.toExponential(2);
    return parseFloat(balance.toFixed(maxDecimals)).toString();
  };
  reactExports.useEffect(() => {
    const custom = loadCustomTokens(currentNetwork2);
    logger$1.log("[SwapScreen] Loaded custom tokens:", custom.length, custom);
    setCustomTokens(custom);
  }, [currentNetwork2]);
  reactExports.useEffect(() => {
    if (!walletReady) {
      logger$1.log("[SwapScreen] Skipping token load - wallet not ready");
      return;
    }
    const loadTokens = async () => {
      var _a3, _b3;
      logger$1.log("[SwapScreen] Loading tokens for network:", currentNetwork2, "filteredUserTokens:", filteredUserTokens == null ? void 0 : filteredUserTokens.length);
      logger$1.log("[SwapScreen] UserTokens detail:", filteredUserTokens == null ? void 0 : filteredUserTokens.map((t2) => {
        var _a4;
        return { symbol: t2.symbol, mint: (_a4 = t2.mint) == null ? void 0 : _a4.slice(0, 8), balance: t2.balance || t2.uiAmount };
      }));
      const swapTokens = await getSwapTokens(currentNetwork2);
      logger$1.log("[SwapScreen] Base swap tokens:", swapTokens.length, swapTokens.map((t2) => t2.symbol));
      const custom = loadCustomTokens(currentNetwork2);
      logger$1.log("[SwapScreen] Custom tokens from storage:", custom.length, custom.map((t2) => t2.symbol));
      const tokenMap = /* @__PURE__ */ new Map();
      for (const token of swapTokens) {
        const key = token.mint || token.symbol;
        tokenMap.set(key, { ...token });
      }
      for (const ct of custom) {
        const key = ct.mint || ct.symbol;
        if (!tokenMap.has(key)) {
          tokenMap.set(key, { ...ct, isCustom: true });
        }
      }
      if (filteredUserTokens && filteredUserTokens.length > 0) {
        for (const ut of filteredUserTokens) {
          const key = ut.mint || ut.symbol;
          const existing = tokenMap.get(key) || tokenMap.get(ut.symbol);
          const balance = parseFloat(ut.balance || ut.uiAmount) || 0;
          if (existing) {
            existing.balance = balance;
            existing.logoURI = ut.logoURI || existing.logoURI;
            existing.name = ut.name || existing.name;
            existing.isToken2022 = ut.isToken2022 || existing.isToken2022 || false;
          } else {
            logger$1.log("[SwapScreen] Adding user token:", ut.symbol || ((_a3 = ut.mint) == null ? void 0 : _a3.slice(0, 8)), "balance:", balance);
            tokenMap.set(key, {
              symbol: ut.symbol || ((_b3 = ut.mint) == null ? void 0 : _b3.slice(0, 4).toUpperCase()),
              name: ut.name || ut.symbol || "Token",
              mint: ut.mint,
              logoURI: ut.logoURI,
              decimals: ut.decimals,
              isToken2022: ut.isToken2022 || false,
              balance
            });
          }
        }
      }
      const tokensWithBalances = Array.from(tokenMap.values()).map((token) => {
        if (token.symbol === nativeSymbol || token.mint === "native") {
          return { ...token, balance: walletBalance };
        }
        return token;
      });
      logger$1.log("[SwapScreen] Final tokens:", tokensWithBalances.length, tokensWithBalances.map((t2) => `${t2.symbol}:${t2.balance}`));
      setTokens(tokensWithBalances);
      preloadImages(tokensWithBalances);
      if (tokensWithBalances.length >= 2) {
        const nativeToken = tokensWithBalances.find(
          (t2) => t2.isNative || t2.mint === "native" || t2.symbol === nativeSymbol || t2.symbol === "SOL" || t2.symbol === "XNT"
        ) || tokensWithBalances[0];
        const isX1Network2 = currentNetwork2 == null ? void 0 : currentNetwork2.startsWith("X1");
        let otherToken;
        if (isX1Network2) {
          otherToken = tokensWithBalances.find((t2) => t2.symbol === "USDC.X");
        }
        if (!otherToken) {
          const usdcToken = tokensWithBalances.find(
            (t2) => {
              var _a4;
              return t2.symbol === "USDC" || t2.symbol === "USDC.X" || ((_a4 = t2.symbol) == null ? void 0 : _a4.toUpperCase()) === "USDC";
            }
          );
          otherToken = usdcToken || tokensWithBalances.find(
            (t2) => t2.symbol !== nativeSymbol && t2.mint !== "native" && t2.symbol !== "SOL" && t2.symbol !== "XNT" && !t2.isNative
          ) || tokensWithBalances[1];
        }
        setFromToken((prev) => prev || nativeToken);
        setToToken((prev) => prev || otherToken);
      }
    };
    loadTokens();
  }, [currentNetwork2, walletBalance, nativeSymbol, filteredUserTokens, walletReady]);
  reactExports.useEffect(() => {
    if (Date.now() - lastOptimisticUpdate.current < 5e3) {
      return;
    }
    if (fromToken && tokens$1.length > 0) {
      const updatedFrom = tokens$1.find((t2) => t2.mint === fromToken.mint || t2.symbol === fromToken.symbol);
      if (updatedFrom && updatedFrom.balance !== fromToken.balance) {
        setFromToken((prev) => ({ ...prev, balance: updatedFrom.balance }));
      }
    }
    if (toToken && tokens$1.length > 0) {
      const updatedTo = tokens$1.find((t2) => t2.mint === toToken.mint || t2.symbol === toToken.symbol);
      if (updatedTo && updatedTo.balance !== toToken.balance) {
        setToToken((prev) => ({ ...prev, balance: updatedTo.balance }));
      }
    }
  }, [tokens$1]);
  reactExports.useEffect(() => {
    if (Date.now() - lastOptimisticUpdate.current < 5e3) {
      return;
    }
    if (!filteredUserTokens || filteredUserTokens.length === 0) return;
    if (fromToken && fromToken.symbol !== nativeSymbol) {
      const userToken = filteredUserTokens.find(
        (ut) => ut.mint === fromToken.mint || ut.symbol === fromToken.symbol
      );
      if (userToken) {
        const newBalance = parseFloat(userToken.balance || userToken.uiAmount) || 0;
        if (newBalance !== fromToken.balance) {
          logger$1.log("[SwapScreen] Syncing fromToken balance from userTokens:", fromToken.symbol, newBalance);
          setFromToken((prev) => ({ ...prev, balance: newBalance }));
        }
      }
    }
    if (toToken && toToken.symbol !== nativeSymbol) {
      const userToken = filteredUserTokens.find(
        (ut) => ut.mint === toToken.mint || ut.symbol === toToken.symbol
      );
      if (userToken) {
        const newBalance = parseFloat(userToken.balance || userToken.uiAmount) || 0;
        if (newBalance !== toToken.balance) {
          logger$1.log("[SwapScreen] Syncing toToken balance from userTokens:", toToken.symbol, newBalance);
          setToToken((prev) => ({ ...prev, balance: newBalance }));
        }
      }
    }
  }, [filteredUserTokens, nativeSymbol]);
  reactExports.useEffect(() => {
    if (Date.now() - lastOptimisticUpdate.current < 5e3) {
      return;
    }
    if (fromToken && (fromToken.mint === "native" || fromToken.isNative || fromToken.symbol === nativeSymbol)) {
      if (fromToken.balance !== walletBalance) {
        setFromToken((prev) => ({ ...prev, balance: walletBalance }));
      }
    }
    if (toToken && (toToken.mint === "native" || toToken.isNative || toToken.symbol === nativeSymbol)) {
      if (toToken.balance !== walletBalance) {
        setToToken((prev) => ({ ...prev, balance: walletBalance }));
      }
    }
  }, [walletBalance, nativeSymbol]);
  reactExports.useEffect(() => {
    if (!tokenSearchQuery || tokenSearchQuery.length < 2) {
      setSearchResults([]);
      setSearching(false);
      return;
    }
    const searchTokens2 = async () => {
      var _a3, _b3, _c2, _d2;
      setSearching(true);
      try {
        const enrichWithUserData = (token) => {
          const userToken = filteredUserTokens == null ? void 0 : filteredUserTokens.find(
            (ut) => ut.mint === token.mint || ut.symbol === token.symbol
          );
          if (userToken) {
            return {
              ...token,
              balance: parseFloat(userToken.balance || userToken.uiAmount) || token.balance || 0,
              logoURI: userToken.logoURI || token.logoURI,
              name: token.name || userToken.name
            };
          }
          return token;
        };
        if (isTokenAddress(tokenSearchQuery)) {
          logger$1.log("[Swap] Searching by address:", tokenSearchQuery, "on", currentNetwork2);
          const existingToken = tokens$1.find((t2) => t2.mint === tokenSearchQuery);
          if (existingToken) {
            setSearchResults([existingToken]);
            setSearching(false);
            return;
          }
          try {
            const tokenInfo = await fetchTokenMetadata(networkConfig.rpcUrl, tokenSearchQuery, currentNetwork2);
            if (tokenInfo) {
              setSearchResults([enrichWithUserData(tokenInfo)]);
              setSearching(false);
              return;
            }
          } catch (e) {
            logger$1.log("[Swap] Address lookup failed:", e.message);
            setError(e.message);
          }
        }
        const xdexResults = await searchXDEXTokens(tokenSearchQuery, currentNetwork2);
        if (xdexResults && xdexResults.length > 0) {
          setSearchResults(xdexResults.map(enrichWithUserData));
          setSearching(false);
          return;
        }
        if (isSolana) {
          const { searchTokens: searchJupiter } = await __vitePreload(async () => {
            const { searchTokens: searchJupiter2 } = await Promise.resolve().then(() => xdex);
            return { searchTokens: searchJupiter2 };
          }, true ? void 0 : void 0);
          const jupResults = await searchJupiter(tokenSearchQuery, currentNetwork2);
          if (jupResults && jupResults.length > 0) {
            setSearchResults(jupResults.map(enrichWithUserData));
            setSearching(false);
            return;
          }
        }
        const query = tokenSearchQuery.toLowerCase();
        const seen2 = /* @__PURE__ */ new Set();
        const localResults = [];
        for (const t2 of tokens$1) {
          if ((((_a3 = t2.symbol) == null ? void 0 : _a3.toLowerCase().includes(query)) || ((_b3 = t2.name) == null ? void 0 : _b3.toLowerCase().includes(query))) && !seen2.has(t2.mint)) {
            seen2.add(t2.mint);
            localResults.push(enrichWithUserData(t2));
          }
        }
        for (const t2 of poolTokens) {
          if ((((_c2 = t2.symbol) == null ? void 0 : _c2.toLowerCase().includes(query)) || ((_d2 = t2.name) == null ? void 0 : _d2.toLowerCase().includes(query))) && !seen2.has(t2.mint)) {
            seen2.add(t2.mint);
            localResults.push(enrichWithUserData(t2));
          }
        }
        if (localResults.length > 0) {
          setSearchResults(localResults);
          setSearching(false);
          return;
        }
        setSearchResults([]);
      } catch (err) {
        logger$1.error("[Swap] Search error:", err);
        setSearchResults([]);
      } finally {
        setSearching(false);
      }
    };
    const timeoutId = setTimeout(searchTokens2, 300);
    return () => clearTimeout(timeoutId);
  }, [tokenSearchQuery, currentNetwork2, networkConfig.rpcUrl, isSolana, filteredUserTokens, tokens$1, poolTokens]);
  const isWrapUnwrap = (from, to) => {
    if (!from || !to) return false;
    const isFromNativeXNT = from.symbol === "XNT" && (from.isNative || !from.mint || from.mint === "native");
    const isToWXNT = to.symbol === "WXNT";
    const isFromWXNT = from.symbol === "WXNT";
    const isToNativeXNT = to.symbol === "XNT" && (to.isNative || !to.mint || to.mint === "native");
    return isFromNativeXNT && isToWXNT || isFromWXNT && isToNativeXNT;
  };
  const getWrapDirection = (from, to) => {
    if (!from || !to) return null;
    const isFromNativeXNT = from.symbol === "XNT" && (from.isNative || !from.mint || from.mint === "native");
    const isToWXNT = to.symbol === "WXNT";
    const isFromWXNT = from.symbol === "WXNT";
    const isToNativeXNT = to.symbol === "XNT" && (to.isNative || !to.mint || to.mint === "native");
    if (isFromNativeXNT && isToWXNT) return "wrap";
    if (isFromWXNT && isToNativeXNT) return "unwrap";
    return null;
  };
  const wrapDirection = getWrapDirection(fromToken, toToken);
  const isWrapOperation = wrapDirection !== null;
  const activeAmount = inputMode === "from" ? fromAmount : toAmount;
  reactExports.useEffect(() => {
    if (!activeAmount || !fromToken || !toToken || parseFloat(activeAmount) <= 0) {
      setQuote(null);
      setQuoteTimestamp(null);
      return;
    }
    if (isWrapUnwrap(fromToken, toToken)) {
      logger$1.log("[Swap] Wrap/Unwrap detected - 1:1 rate");
      setQuote({
        isWrapUnwrap: true,
        direction: getWrapDirection(fromToken, toToken),
        rate: 1,
        data: { rate: 1, outputAmount: parseFloat(activeAmount) }
      });
      setQuoteTimestamp(Date.now());
      if (inputMode === "from") setToAmount(activeAmount);
      else setFromAmount(activeAmount);
      setQuoteLoading(false);
      return;
    }
    const fetchQuote = async () => {
      var _a3, _b3, _c2;
      setQuoteLoading(true);
      setError("");
      try {
        const quoteFromToken = inputMode === "from" ? fromToken : toToken;
        const quoteToToken = inputMode === "from" ? toToken : fromToken;
        const quoteAmount = parseFloat(activeAmount);
        const quoteData = await getQuote(
          quoteFromToken.symbol,
          quoteToToken.symbol,
          quoteAmount,
          currentNetwork2,
          quoteFromToken,
          quoteToToken
        );
        logger$1.log("[Swap] Quote data received:", quoteData);
        setQuote(quoteData);
        setQuoteTimestamp(Date.now());
        const outputAmount = ((_a3 = quoteData == null ? void 0 : quoteData.data) == null ? void 0 : _a3.outputAmount) || ((_b3 = quoteData == null ? void 0 : quoteData.data) == null ? void 0 : _b3.token_out_amount) || (quoteData == null ? void 0 : quoteData.outputAmount) || (quoteData == null ? void 0 : quoteData.token_out_amount) || (quoteData == null ? void 0 : quoteData.estimatedOutput) || (quoteData == null ? void 0 : quoteData.outAmount);
        logger$1.log("[Swap] Output amount:", outputAmount);
        if (outputAmount !== void 0 && outputAmount !== null) {
          if (inputMode === "from") {
            setToAmount(parseFloat(parseFloat(outputAmount).toFixed(4)).toString());
          } else {
            setFromAmount(parseFloat(parseFloat(outputAmount).toFixed(4)).toString());
          }
        } else {
          const rate = ((_c2 = quoteData == null ? void 0 : quoteData.data) == null ? void 0 : _c2.rate) || (quoteData == null ? void 0 : quoteData.rate);
          if (rate) {
            const calculated = quoteAmount * rate;
            logger$1.log("[Swap] Calculated from rate:", calculated);
            if (inputMode === "from") {
              setToAmount(parseFloat(calculated.toFixed(4)).toString());
            } else {
              setFromAmount(parseFloat(calculated.toFixed(4)).toString());
            }
          }
        }
      } catch (err) {
        logger$1.error("[Swap] Quote error:", err);
        const errMsg = (err == null ? void 0 : err.message) || "";
        if (errMsg.includes("429") || errMsg.includes("Too Many Requests")) {
          setError("Rate limited. Please wait a moment...");
        } else {
          setError(getUserFriendlyError(err, ErrorMessages.swap.quoteFailed));
        }
        if (inputMode === "from") setToAmount("");
        else setFromAmount("");
      } finally {
        setQuoteLoading(false);
      }
    };
    const timeoutId = setTimeout(fetchQuote, 150);
    return () => clearTimeout(timeoutId);
  }, [activeAmount, inputMode, fromToken, toToken, currentNetwork2]);
  if (!walletReady) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-button", onClick: onBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Swap" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-body", style: { display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", padding: 40, minHeight: 200 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { marginTop: 12, color: "var(--text-muted)" }, children: "Loading wallet..." })
      ] })
    ] });
  }
  const handleFromAmountChange = (value) => {
    if (value.startsWith("-") || parseFloat(value) < 0) {
      return;
    }
    setFromAmount(value);
    setError("");
  };
  const handleSwapTokens = () => {
    const getLatestBalance = (t2) => {
      if (!t2) return 0;
      if (t2.symbol === nativeSymbol || t2.mint === "native" || t2.isNative) {
        return walletBalance;
      }
      const userToken = filteredUserTokens == null ? void 0 : filteredUserTokens.find(
        (ut) => ut.mint === t2.mint || ut.symbol === t2.symbol
      );
      if (userToken) {
        return parseFloat(userToken.balance || userToken.uiAmount) || 0;
      }
      const tokenInList = tokens$1.find((lt) => lt.mint === t2.mint || lt.symbol === t2.symbol);
      if (tokenInList == null ? void 0 : tokenInList.balance) {
        return tokenInList.balance;
      }
      return t2.balance || 0;
    };
    const newFromToken = toToken ? { ...toToken, balance: getLatestBalance(toToken) } : null;
    const newToToken = fromToken ? { ...fromToken, balance: getLatestBalance(fromToken) } : null;
    setFromToken(newFromToken);
    setToToken(newToToken);
    setFromAmount("");
    setToAmount("");
    setQuote(null);
    setError("");
  };
  const setMaxAmount = () => {
    const gasReserve = 2e-3;
    const rawMax = fromToken.symbol === nativeSymbol ? Math.max(0, (fromToken.balance || walletBalance) - gasReserve) : fromToken.balance || 0;
    const decimals = fromToken.decimals || 9;
    const maxAmount = Math.floor(rawMax * Math.pow(10, decimals)) / Math.pow(10, decimals);
    handleFromAmountChange(maxAmount.toString());
  };
  const handleAddToken = async () => {
    var _a3;
    if (!newTokenAddress.trim()) return;
    setAddingToken(true);
    setError("");
    try {
      const mintAddress = newTokenAddress.trim();
      if (mintAddress.length < 32 || mintAddress.length > 50) {
        throw new Error("Invalid token address");
      }
      if (customTokens.find((t2) => t2.mint === mintAddress)) {
        throw new Error("Token already added");
      }
      if (tokens$1.find((t2) => t2.mint === mintAddress)) {
        throw new Error("Token already exists in list");
      }
      logger$1.log("[AddToken] Fetching metadata for:", mintAddress);
      let tokenInfo = {
        symbol: mintAddress.slice(0, 4).toUpperCase(),
        name: "Unknown Token",
        mint: mintAddress,
        logoURI: null,
        decimals: 9,
        isCustom: true
      };
      try {
        const fetchedInfo = await fetchTokenMetadata(networkConfig.rpcUrl, mintAddress, currentNetwork2);
        logger$1.log("[AddToken] Fetched metadata:", fetchedInfo);
        if (fetchedInfo) {
          tokenInfo = {
            symbol: fetchedInfo.symbol || tokenInfo.symbol,
            name: fetchedInfo.name || tokenInfo.name,
            mint: mintAddress,
            logoURI: fetchedInfo.logoURI || null,
            decimals: fetchedInfo.decimals || 9,
            isToken2022: fetchedInfo.isToken2022 || false,
            isCustom: true
          };
        }
      } catch (e) {
        logger$1.warn("[AddToken] Could not fetch token metadata:", e);
        try {
          const checkResponse = await fetch(networkConfig.rpcUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              jsonrpc: "2.0",
              id: 1,
              method: "getAccountInfo",
              params: [mintAddress, { encoding: "base64" }]
            })
          });
          const checkData = await checkResponse.json();
          if (!((_a3 = checkData.result) == null ? void 0 : _a3.value)) {
            throw new Error("Token not found on this network");
          }
        } catch (checkErr) {
          throw new Error("Token not found on this network");
        }
      }
      if (isSolana && (!tokenInfo.logoURI || tokenInfo.name === "Unknown Token")) {
        try {
          const response = await fetch(`https://lite-api.jup.ag/tokens/v2/tag?query=verified`);
          const jupTokens = await response.json();
          const found = jupTokens.find((t2) => (t2.id || t2.address) === mintAddress);
          if (found) {
            tokenInfo = {
              symbol: found.symbol,
              name: found.name,
              mint: found.id || found.address,
              logoURI: found.icon || found.logoURI,
              decimals: found.decimals,
              isCustom: true
            };
          }
        } catch (e) {
          logger$1.warn("[AddToken] Could not fetch Jupiter token info:", e);
        }
      }
      if (tokenInfo.symbol && tokenInfo.symbol.length < 10) {
        const existsBySymbol = tokens$1.find((t2) => t2.symbol === tokenInfo.symbol && t2.mint !== mintAddress) || customTokens.find((t2) => t2.symbol === tokenInfo.symbol && t2.mint !== mintAddress);
        if (existsBySymbol) {
          throw new Error(`Token ${tokenInfo.symbol} already exists in list`);
        }
      }
      logger$1.log("[AddToken] Adding token:", tokenInfo);
      const newCustomTokens = [...customTokens, tokenInfo];
      setCustomTokens(newCustomTokens);
      saveCustomTokens(currentNetwork2, newCustomTokens);
      setTokens((prev) => [...prev, { ...tokenInfo, balance: 0 }]);
      setNewTokenAddress("");
    } catch (err) {
      logger$1.error("[AddToken] Error:", err.message || err);
      setError(err.message || "Failed to add token. Please verify the address.");
    } finally {
      setAddingToken(false);
    }
  };
  const handleRemoveToken = (mint) => {
    const newCustomTokens = customTokens.filter((t2) => t2.mint !== mint);
    setCustomTokens(newCustomTokens);
    saveCustomTokens(currentNetwork2, newCustomTokens);
    setTokens((prev) => prev.filter((t2) => t2.mint !== mint || !t2.isCustom));
  };
  const showSwapConfirm = () => {
    if (!fromAmount || parseFloat(fromAmount) <= 0) {
      setError("Please enter a valid amount");
      return;
    }
    if (!isWrapOperation && !quote) {
      setError("Please wait for quote");
      return;
    }
    const quoteAge = quoteTimestamp ? (Date.now() - quoteTimestamp) / 1e3 : 0;
    if (!isWrapOperation && quoteAge > 30) {
      logger$1.log("[Swap] Quote is stale:", quoteAge, "seconds old");
    }
    const decimals = (fromToken == null ? void 0 : fromToken.decimals) || 9;
    const multiplier = Math.pow(10, decimals);
    const requiredAmount = Math.round(parseFloat(fromAmount) * multiplier);
    const availableAmount = Math.round(((fromToken == null ? void 0 : fromToken.balance) || 0) * multiplier);
    if (requiredAmount > availableAmount) {
      setError(`Insufficient balance. Required: ${fromAmount} tokens, Available: ${(fromToken == null ? void 0 : fromToken.balance) || 0} tokens`);
      return;
    }
    setError("");
    setShowConfirm(true);
  };
  const handleSwap = async () => {
    var _a3, _b3, _c2, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    if (loading) {
      logger$1.log("[Swap] Already processing, ignoring duplicate call");
      return;
    }
    logger$1.log("[Swap] Executing swap...");
    logger$1.log("[Swap] isHardwareWallet:", isHardwareWallet);
    logger$1.log("[Swap] wallet?.wallet?.isHardware:", (_a3 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _a3.isHardware);
    logger$1.log("[Swap] wallet?.activeWallet?.isHardware:", (_b3 = wallet == null ? void 0 : wallet.activeWallet) == null ? void 0 : _b3.isHardware);
    logger$1.log("[Swap] wallet?.isHardware:", wallet == null ? void 0 : wallet.isHardware);
    logger$1.log("[Swap] wallet structure:", JSON.stringify(Object.keys(wallet || {})));
    logger$1.log("[Swap] wallet.wallet structure:", JSON.stringify(Object.keys((wallet == null ? void 0 : wallet.wallet) || {})));
    setLoading(true);
    setSwapStatus("confirming");
    setError("");
    setHwStatus("");
    logger$1.log("[Swap] === BUILD VERSION: 2025-01-05-hw-v2 ===");
    logger$1.log("[Swap] Wallet object keys:", Object.keys(wallet || {}));
    logger$1.log("[Swap] wallet.wallet keys:", Object.keys((wallet == null ? void 0 : wallet.wallet) || {}));
    try {
      const walletPublicKey = ((_c2 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _c2.publicKey) || ((_d2 = wallet == null ? void 0 : wallet.activeAddress) == null ? void 0 : _d2.publicKey);
      const privateKey = ((_e = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _e.privateKey) || ((_f = wallet == null ? void 0 : wallet.activeAddress) == null ? void 0 : _f.privateKey);
      logger$1.log("[Swap] Found publicKey:", walletPublicKey ? walletPublicKey.slice(0, 8) + "..." : "null");
      logger$1.log("[Swap] privateKey available:", !!privateKey);
      logger$1.log("[Swap] Final isHardwareWallet check:", isHardwareWallet);
      if (!walletPublicKey || typeof walletPublicKey !== "string") {
        throw new Error("Could not find wallet public key");
      }
      if (walletPublicKey.includes(" ")) {
        logger$1.error("[Swap] SECURITY: Detected mnemonic instead of public key!");
        throw new Error("Invalid wallet address format");
      }
      if (walletPublicKey.length < 32 || walletPublicKey.length > 50) {
        logger$1.error("[Swap] Invalid wallet address length:", walletPublicKey.length);
        throw new Error("Invalid wallet address");
      }
      if (!isHardwareWallet && !privateKey) {
        logger$1.error("[Swap] No private key and not hardware wallet!");
        throw new Error("Wallet private key not available");
      }
      if (isWrapOperation) {
        console.log("[Swap] Starting wrap operation:", wrapDirection);
        console.log("[Swap] networkConfig.rpcUrl:", networkConfig == null ? void 0 : networkConfig.rpcUrl);
        console.log("[Swap] isHardwareWallet:", isHardwareWallet);
        try {
          let signature2;
          if (isHardwareWallet) {
            setHwStatus("Connecting to Ledger...");
            if (!hardwareWallet.isReady()) {
              await hardwareWallet.connect("hid");
              await hardwareWallet.openApp();
            }
            setHwStatus("Please confirm on your Ledger...");
            const derivationPath = ((_g = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _g.derivationPath) || (wallet == null ? void 0 : wallet.derivationPath) || ((_h = wallet == null ? void 0 : wallet.activeWallet) == null ? void 0 : _h.derivationPath) || ((_j = (_i = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _i.activeAddress) == null ? void 0 : _j.derivationPath) || "44'/501'/0'/0'";
            logger$1.log("[Swap Wrap/Unwrap] Using derivation path:", derivationPath);
            logger$1.log("[Swap Wrap/Unwrap] Wallet structure:", {
              hasWalletWallet: !!(wallet == null ? void 0 : wallet.wallet),
              walletDerivPath: (_k = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _k.derivationPath,
              directDerivPath: wallet == null ? void 0 : wallet.derivationPath,
              activeWalletDerivPath: (_l = wallet == null ? void 0 : wallet.activeWallet) == null ? void 0 : _l.derivationPath
            });
            if (wrapDirection === "wrap") {
              signature2 = await createWrapTransactionHardware({
                owner: walletPublicKey,
                amount: parseFloat(fromAmount),
                rpcUrl: networkConfig.rpcUrl,
                hardwareWallet,
                derivationPath
              });
            } else {
              signature2 = await createUnwrapTransactionHardware({
                owner: walletPublicKey,
                amount: parseFloat(fromAmount),
                rpcUrl: networkConfig.rpcUrl,
                hardwareWallet,
                derivationPath
              });
            }
            setHwStatus("");
          } else {
            let secretKey = privateKey;
            if (typeof privateKey === "string") {
              const { decodeBase58: decodeBase582 } = await __vitePreload(async () => {
                const { decodeBase58: decodeBase583 } = await Promise.resolve().then(() => base58);
                return { decodeBase58: decodeBase583 };
              }, true ? void 0 : void 0);
              secretKey = decodeBase582(privateKey);
            }
            if (wrapDirection === "wrap") {
              signature2 = await createWrapTransaction({
                owner: walletPublicKey,
                amount: parseFloat(fromAmount),
                rpcUrl: networkConfig.rpcUrl,
                privateKey: secretKey
              });
            } else {
              signature2 = await createUnwrapTransaction({
                owner: walletPublicKey,
                amount: parseFloat(fromAmount),
                rpcUrl: networkConfig.rpcUrl,
                privateKey: secretKey
              });
            }
          }
          console.log("[Swap] Transaction sent:", signature2);
          addTransaction({
            signature: signature2,
            type: wrapDirection === "wrap" ? "wrap" : "unwrap",
            amount: parseFloat(fromAmount),
            symbol: fromToken.symbol,
            toSymbol: toToken.symbol,
            toAmount: parseFloat(toAmount),
            from: walletPublicKey,
            to: walletPublicKey,
            timestamp: Date.now(),
            status: "confirmed",
            network: currentNetwork2,
            isSwap: true
          });
          setTxHash(signature2);
          setSwapStatus("success");
          setShowConfirm(false);
          setLoading(false);
          const swappedFromAmount2 = parseFloat(fromAmount);
          const swappedToAmount2 = parseFloat(toAmount);
          const swappedFromToken2 = { ...fromToken };
          const swappedToToken2 = { ...toToken };
          lastOptimisticUpdate.current = Date.now();
          setTokens((prev) => prev.map((t2) => {
            if (t2.symbol === swappedFromToken2.symbol || t2.mint === swappedFromToken2.mint) {
              return { ...t2, balance: Math.max(0, (t2.balance || 0) - swappedFromAmount2) };
            }
            if (t2.symbol === swappedToToken2.symbol || t2.mint === swappedToToken2.mint) {
              return { ...t2, balance: (t2.balance || 0) + swappedToAmount2 };
            }
            return t2;
          }));
          setFromToken((prev) => {
            if (!prev) return prev;
            if (prev.symbol === swappedFromToken2.symbol || prev.mint === swappedFromToken2.mint) {
              return { ...prev, balance: Math.max(0, (prev.balance || 0) - swappedFromAmount2) };
            }
            return prev;
          });
          setToToken((prev) => {
            if (!prev) return prev;
            if (prev.symbol === swappedToToken2.symbol || prev.mint === swappedToToken2.mint) {
              return { ...prev, balance: (prev.balance || 0) + swappedToAmount2 };
            }
            return prev;
          });
          const updatedTokensForParent2 = userTokens.map((t2) => {
            if (t2.symbol === swappedFromToken2.symbol || t2.mint === swappedFromToken2.mint) {
              return { ...t2, balance: Math.max(0, (t2.balance || t2.uiAmount || 0) - swappedFromAmount2), uiAmount: Math.max(0, (t2.uiAmount || t2.balance || 0) - swappedFromAmount2) };
            }
            if (t2.symbol === swappedToToken2.symbol || t2.mint === swappedToToken2.mint) {
              return { ...t2, balance: (t2.balance || t2.uiAmount || 0) + swappedToAmount2, uiAmount: (t2.uiAmount || t2.balance || 0) + swappedToAmount2 };
            }
            return t2;
          });
          if (onSwapComplete) onSwapComplete(updatedTokensForParent2);
          if (wallet.refreshBalance) {
            wallet.refreshBalance();
          }
          return;
        } catch (wrapErr) {
          console.error("[Swap] RAW ERROR:", wrapErr);
          console.error("[Swap] Error type:", typeof wrapErr);
          console.error("[Swap] Error message:", wrapErr == null ? void 0 : wrapErr.message);
          console.error("[Swap] Error stack:", wrapErr == null ? void 0 : wrapErr.stack);
          let errorMsg = "Transaction failed";
          if (wrapErr == null ? void 0 : wrapErr.message) {
            errorMsg = wrapErr.message;
          } else if (typeof wrapErr === "string") {
            errorMsg = wrapErr;
          }
          setError(`${wrapDirection === "wrap" ? "Wrap" : "Unwrap"} failed: ${errorMsg}`);
          setLoading(false);
          setSwapStatus("");
          return;
        }
      }
      const NATIVE_TOKEN_ADDRESS2 = "So11111111111111111111111111111111111111112";
      let tokenInParam = fromToken.symbol;
      let tokenOutParam = toToken.symbol;
      const isFromNative = fromToken.mint === "native" || fromToken.isNative || !fromToken.mint || fromToken.mint.startsWith("native_");
      const isToNative = toToken.mint === "native" || toToken.isNative || !toToken.mint || toToken.mint.startsWith("native_");
      if (fromToken.symbol === "WXNT") {
        tokenInParam = NATIVE_TOKEN_ADDRESS2;
      } else if (isFromNative) {
        tokenInParam = NATIVE_TOKEN_ADDRESS2;
      } else if (fromToken.mint) {
        tokenInParam = fromToken.mint;
      }
      if (toToken.symbol === "WXNT") {
        tokenOutParam = NATIVE_TOKEN_ADDRESS2;
      } else if (isToNative) {
        tokenOutParam = NATIVE_TOKEN_ADDRESS2;
      } else if (toToken.mint) {
        tokenOutParam = toToken.mint;
      }
      logger$1.log("[Swap] Preparing with tokens:", { tokenIn: tokenInParam, tokenOut: tokenOutParam, slippage });
      const slippageBps = Math.round(slippage * 100);
      const txData = await prepareSwap(
        walletPublicKey,
        tokenInParam,
        tokenOutParam,
        parseFloat(fromAmount),
        currentNetwork2,
        slippageBps
      );
      logger$1.log("[Swap] Transaction prepared:", txData);
      let transactions = [];
      if (Array.isArray((_m = txData == null ? void 0 : txData.data) == null ? void 0 : _m.transaction)) {
        transactions = txData.data.transaction;
        logger$1.log("[Swap] Received array of", transactions.length, "transactions");
      } else if (Array.isArray(txData == null ? void 0 : txData.transaction)) {
        transactions = txData.transaction;
        logger$1.log("[Swap] Received array of", transactions.length, "transactions");
      } else if (typeof (txData == null ? void 0 : txData.transaction) === "string") {
        transactions = [txData.transaction];
      } else if (typeof ((_n = txData == null ? void 0 : txData.data) == null ? void 0 : _n.transaction) === "string") {
        transactions = [txData.data.transaction];
      } else if (typeof ((_o = txData == null ? void 0 : txData.transaction) == null ? void 0 : _o.serializedTransaction) === "string") {
        transactions = [txData.transaction.serializedTransaction];
      } else if (typeof ((_q = (_p = txData == null ? void 0 : txData.data) == null ? void 0 : _p.transaction) == null ? void 0 : _q.serializedTransaction) === "string") {
        transactions = [txData.data.transaction.serializedTransaction];
      } else if (typeof (txData == null ? void 0 : txData.swapTransaction) === "string") {
        transactions = [txData.swapTransaction];
      } else if (typeof ((_r = txData == null ? void 0 : txData.data) == null ? void 0 : _r.swapTransaction) === "string") {
        transactions = [txData.data.swapTransaction];
      }
      if (transactions.length === 0) {
        logger$1.error("[Swap] Could not find transaction string in response");
        logger$1.error("[Swap] Full API response:", JSON.stringify(txData));
        throw new Error("No transaction data received from API");
      }
      for (let i = 0; i < transactions.length; i++) {
        if (typeof transactions[i] !== "string") {
          logger$1.error("[Swap] Transaction", i, "is not a string:", typeof transactions[i]);
          throw new Error("Invalid transaction format from API");
        }
      }
      logger$1.log("[Swap] Processing", transactions.length, "transaction(s)");
      logger$1.log("[Swap] isHardwareWallet:", isHardwareWallet);
      logger$1.log("[Swap] Private key available:", !!privateKey);
      let lastSignature = null;
      if (isHardwareWallet) {
        setHwStatus("Connecting to Ledger...");
        const derivationPath = ((_s = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _s.derivationPath) || (wallet == null ? void 0 : wallet.derivationPath) || ((_t = wallet == null ? void 0 : wallet.activeWallet) == null ? void 0 : _t.derivationPath) || ((_v = (_u = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _u.activeAddress) == null ? void 0 : _v.derivationPath) || "44'/501'/0'/0'";
        logger$1.log("[Swap] Using derivation path:", derivationPath);
        logger$1.log("[Swap] Wallet structure:", {
          hasWalletWallet: !!(wallet == null ? void 0 : wallet.wallet),
          walletDerivPath: (_w = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _w.derivationPath,
          directDerivPath: wallet == null ? void 0 : wallet.derivationPath,
          activeWalletDerivPath: (_x = wallet == null ? void 0 : wallet.activeWallet) == null ? void 0 : _x.derivationPath
        });
        const priorityOption = getPriorityOptions$1(currentNetwork2).find((p2) => p2.id === swapPriority);
        const priorityMicroLamports = swapPriority === "custom" ? customFeeToMicroLamports(parseFloat(customFee) || 0) : (priorityOption == null ? void 0 : priorityOption.microLamports) || 0;
        if (priorityMicroLamports > 0) {
          logger$1.log(`[Swap] Using priority fee: ${priorityMicroLamports} microlamports/CU (${swapPriority})`);
        }
        if (!hardwareWallet.isReady()) {
          await hardwareWallet.connect("hid");
          await hardwareWallet.openApp();
        }
        for (let i = 0; i < transactions.length; i++) {
          const tx = transactions[i];
          logger$1.log(`[Swap] Signing transaction ${i + 1}/${transactions.length} with Ledger`);
          setHwStatus(`Please confirm transaction ${i + 1}/${transactions.length} on your Ledger...`);
          try {
            const signature2 = await signAndSendExternalTransactionHardware(
              tx,
              hardwareWallet,
              networkConfig.rpcUrl,
              derivationPath,
              priorityMicroLamports
            );
            logger$1.log(`[Swap] Transaction ${i + 1} sent! Signature:`, signature2);
            lastSignature = signature2;
            if (i < transactions.length - 1) {
              setHwStatus("Waiting for confirmation...");
              await new Promise((resolve) => setTimeout(resolve, 200));
            }
          } catch (txErr) {
            logger$1.error(`[Swap] Transaction ${i + 1} failed:`, txErr);
            if (i === 0 && transactions.length > 1) {
              logger$1.log("[Swap] ATA creation may have failed (account might exist), trying swap transaction...");
              continue;
            }
            throw txErr;
          }
        }
        setHwStatus("");
      } else {
        const priorityOption = getPriorityOptions$1(currentNetwork2).find((p2) => p2.id === swapPriority);
        const priorityMicroLamports = swapPriority === "custom" ? customFeeToMicroLamports(parseFloat(customFee) || 0) : (priorityOption == null ? void 0 : priorityOption.microLamports) || 0;
        if (priorityMicroLamports > 0) {
          logger$1.log(`[Swap] Using priority fee: ${priorityMicroLamports} microlamports/CU (${swapPriority})`);
        }
        for (let i = 0; i < transactions.length; i++) {
          const tx = transactions[i];
          logger$1.log(`[Swap] Signing transaction ${i + 1}/${transactions.length}, length:`, tx.length);
          logger$1.log("[Swap] Transaction preview:", tx.substring(0, 80) + "...");
          try {
            const signature2 = await signAndSendExternalTransaction(
              tx,
              privateKey,
              networkConfig.rpcUrl,
              priorityMicroLamports
            );
            logger$1.log(`[Swap] Transaction ${i + 1} sent! Signature:`, signature2);
            lastSignature = signature2;
            if (i < transactions.length - 1) {
              logger$1.log("[Swap] Waiting for transaction to be processed before next...");
              await new Promise((resolve) => setTimeout(resolve, 200));
            }
          } catch (txErr) {
            logger$1.error(`[Swap] Transaction ${i + 1} failed:`, txErr);
            if (i === 0 && transactions.length > 1) {
              logger$1.log("[Swap] ATA creation may have failed (account might exist), trying swap transaction...");
              continue;
            }
            throw txErr;
          }
        }
      }
      if (!lastSignature) {
        throw new Error("No transactions were successfully sent");
      }
      const signature = lastSignature;
      logger$1.log("[Swap] All transactions complete! Final signature:", signature);
      addTransaction({
        signature,
        type: isWrapOperation ? wrapDirection : "swap",
        amount: parseFloat(fromAmount),
        symbol: fromToken.symbol,
        toSymbol: toToken.symbol,
        toAmount: parseFloat(toAmount),
        from: walletPublicKey,
        to: walletPublicKey,
        timestamp: Date.now(),
        status: "confirmed",
        network: currentNetwork2,
        isSwap: true
      });
      trackSwapXP({
        user: walletPublicKey,
        network: currentNetwork2,
        transactionSignature: signature,
        inputMint: tokenInParam,
        outputMint: tokenOutParam,
        inputAmount: parseFloat(fromAmount),
        outputAmount: parseFloat(toAmount)
      }).then((result) => {
        if (result == null ? void 0 : result.success) {
          logger$1.log("[Swap] XP tracked successfully");
        }
      }).catch((err) => {
        logger$1.warn("[Swap] XP tracking failed:", err);
      });
      const swappedFromAmount = parseFloat(fromAmount);
      const swappedToAmount = parseFloat(toAmount);
      const swappedFromToken = { ...fromToken };
      const swappedToToken = { ...toToken };
      lastOptimisticUpdate.current = Date.now();
      setTokens((prev) => prev.map((t2) => {
        if (t2.symbol === swappedFromToken.symbol || t2.mint === swappedFromToken.mint) {
          return { ...t2, balance: Math.max(0, (t2.balance || 0) - swappedFromAmount) };
        }
        if (t2.symbol === swappedToToken.symbol || t2.mint === swappedToToken.mint) {
          return { ...t2, balance: (t2.balance || 0) + swappedToAmount };
        }
        return t2;
      }));
      setFromToken((prev) => {
        if (!prev) return prev;
        if (prev.symbol === swappedFromToken.symbol || prev.mint === swappedFromToken.mint) {
          return { ...prev, balance: Math.max(0, (prev.balance || 0) - swappedFromAmount) };
        }
        return prev;
      });
      setToToken((prev) => {
        if (!prev) return prev;
        if (prev.symbol === swappedToToken.symbol || prev.mint === swappedToToken.mint) {
          return { ...prev, balance: (prev.balance || 0) + swappedToAmount };
        }
        return prev;
      });
      setTxHash(signature);
      setSwapStatus("success");
      setShowConfirm(false);
      const updatedTokensForParent = userTokens.map((t2) => {
        if (t2.symbol === swappedFromToken.symbol || t2.mint === swappedFromToken.mint) {
          return { ...t2, balance: Math.max(0, (t2.balance || t2.uiAmount || 0) - swappedFromAmount), uiAmount: Math.max(0, (t2.uiAmount || t2.balance || 0) - swappedFromAmount) };
        }
        if (t2.symbol === swappedToToken.symbol || t2.mint === swappedToToken.mint) {
          return { ...t2, balance: (t2.balance || t2.uiAmount || 0) + swappedToAmount, uiAmount: (t2.uiAmount || t2.balance || 0) + swappedToAmount };
        }
        return t2;
      });
      if (onSwapComplete) {
        onSwapComplete(updatedTokensForParent);
      }
      if (wallet.refreshBalance) {
        wallet.refreshBalance();
      }
    } catch (err) {
      logger$1.error("[Swap] Error:", err);
      logger$1.error("[Swap] Error message:", err == null ? void 0 : err.message);
      logger$1.error("[Swap] Error details:", JSON.stringify(err, Object.getOwnPropertyNames(err)));
      let userMessage = (err == null ? void 0 : err.message) || getUserFriendlyError(err, ErrorMessages.swap.failed);
      if (userMessage.includes("429") || userMessage.includes("Too Many Requests") || userMessage.includes("rate limit")) {
        userMessage = "Too many requests. Please wait a few seconds and try again.";
      } else if (userMessage.includes("Failed to create fee token account")) {
        userMessage = "Swap service temporarily unavailable. The XDEX API is experiencing issues with fee account creation. Please try again later or contact XDEX support.";
      } else if (userMessage.includes("insufficient lamports")) {
        const match = userMessage.match(/insufficient lamports (\d+), need (\d+)/);
        if (match) {
          const have = parseInt(match[1]) / 1e9;
          const need = parseInt(match[2]) / 1e9;
          const shortfall = (need - have).toFixed(6);
          userMessage = `Insufficient SOL for transaction fees. You need approximately ${shortfall} more SOL to cover token account creation costs. Please add more SOL and try again.`;
        } else {
          userMessage = "Insufficient SOL for transaction fees. Please add more SOL to cover network fees and token account creation costs.";
        }
      } else if (userMessage.includes("Simulation failed") || userMessage.includes("custom program error")) {
        if (userMessage.includes("0x1787") || userMessage.includes("6023")) {
          userMessage = "Swap route expired or liquidity changed. Please try again. If the issue persists, try a smaller amount or different slippage.";
        } else if (userMessage.includes("0x1786") || userMessage.includes("6022")) {
          userMessage = "Invalid market state. The liquidity pool may be temporarily unavailable. Please try again later.";
        } else if (userMessage.includes("0xbc4") || userMessage.includes("3012")) {
          const suggestedSlippage = Math.min(slippage * 2, 10);
          userMessage = `Price moved beyond ${slippage}% slippage tolerance. Try increasing slippage to ${suggestedSlippage}% or higher, or use a smaller amount.`;
        } else if (userMessage.includes("0x1771") || userMessage.includes("6001")) {
          userMessage = "Insufficient liquidity in the pool for this swap size. Try a smaller amount.";
        } else if (userMessage.includes("0x1") && !userMessage.includes("0x1786") && !userMessage.includes("0x1787") && !userMessage.includes("0x1771")) {
          userMessage = "Slippage tolerance exceeded. Try increasing slippage or reducing the swap amount.";
        } else if (userMessage.includes("0x0")) {
          userMessage = "Transaction simulation failed. This may be a temporary API issue. Please try again in a few minutes.";
        } else {
          const errorCodeMatch = userMessage.match(/0x[0-9a-fA-F]+/);
          const errorCode = errorCodeMatch ? ` (Error: ${errorCodeMatch[0]})` : "";
          userMessage = `Swap failed${errorCode}. This may be due to network congestion, expired quote, or liquidity changes. Please try again.`;
        }
      } else if (userMessage.includes("blockhash") || userMessage.includes("Blockhash")) {
        userMessage = "Transaction expired. Please try again - quotes are time-sensitive.";
      }
      setError(userMessage);
      setSwapStatus("error");
    } finally {
      setLoading(false);
    }
  };
  const TokenIcon = ({ token, size = 24 }) => {
    var _a3;
    const [imgError, setImgError] = React.useState(false);
    const logoSize = Math.round(size * 0.8);
    if (!token) return null;
    if (token.symbol === "XNT" || token.symbol === nativeSymbol && !isSolana) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(X1Logo, { size });
    }
    if (token.logoURI && !imgError) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
        width: size,
        height: size,
        minWidth: size,
        minHeight: size,
        borderRadius: "50%",
        background: "#000",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        overflow: "hidden",
        flexShrink: 0
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: token.logoURI,
          alt: token.symbol,
          style: {
            width: logoSize,
            height: logoSize,
            objectFit: "contain"
          },
          onError: () => setImgError(true)
        }
      ) });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
      width: size,
      height: size,
      fontSize: size * 0.4,
      background: "#000000",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      borderRadius: "50%",
      color: "white",
      fontWeight: 600,
      flexShrink: 0
    }, children: ((_a3 = token.symbol) == null ? void 0 : _a3[0]) || "?" });
  };
  const filteredTokens = tokens$1.filter((t2) => {
    var _a3, _b3;
    if (!tokenSearchQuery) return true;
    const q2 = tokenSearchQuery.toLowerCase();
    return t2.symbol.toLowerCase().includes(q2) || ((_a3 = t2.name) == null ? void 0 : _a3.toLowerCase().includes(q2)) || ((_b3 = t2.mint) == null ? void 0 : _b3.toLowerCase().includes(q2));
  });
  const fromTokenOptions = filteredTokens.filter((t2) => {
    if (t2.symbol === nativeSymbol) return true;
    if (t2.balance > 0) return true;
    if (t2.isCustom) return true;
    return false;
  });
  if (showManageTokens) {
    const handleClearAllCustomTokens = () => {
      logger$1.log("[ClearAll] Clearing all custom tokens for network:", currentNetwork2);
      try {
        const stored = localStorage.getItem(CUSTOM_TOKENS_KEY);
        if (stored) {
          const all = JSON.parse(stored);
          delete all[currentNetwork2];
          localStorage.setItem(CUSTOM_TOKENS_KEY, JSON.stringify(all));
          logger$1.log("[ClearAll] Cleared from localStorage");
        }
      } catch (e) {
        logger$1.error("[ClearAll] Error clearing localStorage:", e);
      }
      setCustomTokens([]);
      getSwapTokens(currentNetwork2).then((baseTokens) => {
        const cleanTokens = baseTokens.filter((t2) => !t2.isCustom);
        const tokensWithBalances = cleanTokens.map((token) => {
          if (token.symbol === nativeSymbol || token.mint === "native") {
            return { ...token, balance: walletBalance };
          }
          const userToken = userTokens.find((ut) => ut.mint === token.mint || ut.symbol === token.symbol);
          return {
            ...token,
            balance: userToken ? parseFloat(userToken.balance || userToken.uiAmount) : 0
          };
        });
        setTokens(tokensWithBalances);
        logger$1.log("[ClearAll] Reset to base tokens:", tokensWithBalances.length);
      });
      setConfirmClearAll(false);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen swap-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => {
          setShowManageTokens(false);
          setConfirmClearAll(false);
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "Manage Tokens" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-right", children: [
          customTokens.length > 0 && !confirmClearAll && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "header-btn",
              onClick: () => setConfirmClearAll(true),
              style: { color: "#ff3b30", fontSize: 12 },
              children: "Clear All"
            }
          ),
          confirmClearAll && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: handleClearAllCustomTokens,
                style: {
                  background: "#ff3b30",
                  border: "none",
                  color: "white",
                  fontSize: 11,
                  cursor: "pointer",
                  padding: "4px 10px",
                  borderRadius: 4
                },
                children: "Confirm"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setConfirmClearAll(false),
                style: {
                  background: "transparent",
                  border: "1px solid var(--border-color)",
                  color: "var(--text-muted)",
                  fontSize: 11,
                  cursor: "pointer",
                  padding: "4px 10px",
                  borderRadius: 4
                },
                children: "Cancel"
              }
            )
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: 16 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontSize: 12, color: "var(--text-muted)", marginBottom: 6, display: "block" }, children: "Add Token by Address" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                placeholder: "Token mint address...",
                value: newTokenAddress,
                onChange: (e) => setNewTokenAddress(e.target.value),
                style: {
                  flex: 1,
                  background: "var(--bg-secondary)",
                  border: "1px solid var(--border-color)",
                  borderRadius: 8,
                  padding: "10px 12px",
                  color: "var(--text-primary)",
                  fontSize: 13
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: handleAddToken,
                disabled: addingToken || !newTokenAddress.trim(),
                style: {
                  background: "var(--x1-blue)",
                  border: "none",
                  borderRadius: 8,
                  padding: "10px 16px",
                  color: "white",
                  fontWeight: 600,
                  cursor: "pointer",
                  opacity: addingToken || !newTokenAddress.trim() ? 0.5 : 1
                },
                children: addingToken ? "..." : "Add"
              }
            )
          ] })
        ] }),
        error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
          background: "rgba(255, 59, 48, 0.1)",
          border: "1px solid rgba(255, 59, 48, 0.3)",
          borderRadius: 8,
          padding: "10px 12px",
          marginBottom: 16,
          color: "#ff3b30",
          fontSize: 13
        }, children: error }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "var(--text-muted)", marginBottom: 8 }, children: [
          "Custom Tokens (",
          customTokens.length,
          ")"
        ] }),
        customTokens.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
          padding: 20,
          textAlign: "center",
          color: "var(--text-muted)",
          fontSize: 13
        }, children: [
          "No custom tokens added yet",
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 12 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => {
                forceResetCustomTokens();
                setCustomTokens([]);
                getSwapTokens(currentNetwork2).then((baseTokens) => {
                  setTokens(baseTokens.map((t2) => ({
                    ...t2,
                    balance: t2.symbol === nativeSymbol ? walletBalance : 0
                  })));
                });
              },
              style: {
                background: "transparent",
                border: "1px solid var(--border-color)",
                borderRadius: 6,
                padding: "6px 12px",
                color: "var(--text-muted)",
                fontSize: 11,
                cursor: "pointer"
              },
              children: "Reset Token Cache"
            }
          ) })
        ] }) : customTokens.map((token, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              display: "flex",
              alignItems: "center",
              gap: 12,
              padding: "12px",
              background: "var(--bg-secondary)",
              borderRadius: 8,
              marginBottom: 8
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TokenIcon, { token, size: 40 }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: 600, fontSize: 14 }, children: token.symbol }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 11, color: "var(--text-muted)", fontFamily: "monospace" }, children: [
                  token.mint.slice(0, 8),
                  "...",
                  token.mint.slice(-6)
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => handleRemoveToken(token.mint),
                  style: {
                    background: "rgba(255, 59, 48, 0.15)",
                    border: "none",
                    borderRadius: 6,
                    padding: "6px 12px",
                    color: "#ff3b30",
                    fontSize: 12,
                    cursor: "pointer"
                  },
                  children: "Remove"
                }
              )
            ]
          },
          i
        ))
      ] })
    ] });
  }
  if (selectingToken) {
    let displayTokens = [];
    if (tokenSearchQuery.length >= 2) {
      if (searchResults.length > 0) {
        displayTokens = searchResults;
      } else if (!searching) {
        displayTokens = selectingToken === "from" ? fromTokenOptions.filter((t2) => t2.symbol !== (toToken == null ? void 0 : toToken.symbol)) : filteredTokens.filter((t2) => t2.symbol !== (fromToken == null ? void 0 : fromToken.symbol));
      }
    } else {
      displayTokens = selectingToken === "from" ? fromTokenOptions.filter((t2) => t2.symbol !== (toToken == null ? void 0 : toToken.symbol)) : filteredTokens.filter((t2) => t2.symbol !== (fromToken == null ? void 0 : fromToken.symbol));
    }
    const handleSelectToken = (token) => {
      const isFromSearch = searchResults.find((t2) => t2.mint === token.mint);
      const existsInTokens = tokens$1.find((t2) => t2.mint === token.mint || t2.symbol === token.symbol);
      const existsInCustom = customTokens.find((t2) => t2.mint === token.mint || t2.symbol === token.symbol);
      if (isFromSearch && !existsInTokens && !existsInCustom) {
        const newCustomTokens = [...customTokens, { ...token, isCustom: true }];
        setCustomTokens(newCustomTokens);
        saveCustomTokens(currentNetwork2, newCustomTokens);
        setTokens((prev) => [...prev, { ...token, balance: 0, isCustom: true }]);
      }
      const getLatestBalance = (t2) => {
        if (t2.symbol === nativeSymbol || t2.mint === "native" || t2.isNative) {
          return walletBalance;
        }
        const userToken = filteredUserTokens == null ? void 0 : filteredUserTokens.find(
          (ut) => ut.mint === t2.mint || ut.symbol === t2.symbol
        );
        if (userToken) {
          return parseFloat(userToken.balance || userToken.uiAmount) || 0;
        }
        const tokenInList = tokens$1.find((lt) => lt.mint === t2.mint || lt.symbol === t2.symbol);
        if (tokenInList == null ? void 0 : tokenInList.balance) {
          return tokenInList.balance;
        }
        return t2.balance || 0;
      };
      const latestBalance = getLatestBalance(token);
      if (selectingToken === "from") {
        setFromToken({ ...token, balance: latestBalance });
      } else {
        setToToken({ ...token, balance: latestBalance });
      }
      setSelectingToken(null);
      setTokenSearchQuery("");
      setSearchResults([]);
      setFromAmount("");
      setToAmount("");
      setQuote(null);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen swap-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => {
          setSelectingToken(null);
          setTokenSearchQuery("");
          setSearchResults([]);
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "Select Token" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-right", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "header-btn primary",
            onClick: () => {
              setSelectingToken(null);
              setShowManageTokens(true);
              setTokenSearchQuery("");
              setSearchResults([]);
            },
            title: "Add Token",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 5v14M5 12h14" }) })
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel-content", style: { padding: "16px 20px 24px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { margin: "0 -20px 16px", padding: "0 16px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            placeholder: "Search by name, symbol, or paste address...",
            value: tokenSearchQuery,
            onChange: (e) => setTokenSearchQuery(e.target.value),
            style: {
              width: "100%",
              background: "var(--bg-secondary)",
              border: "1px solid var(--border-color)",
              borderRadius: 8,
              padding: "10px 12px",
              color: "var(--text-primary)",
              fontSize: 14,
              boxSizing: "border-box"
            }
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { margin: "0 -20px" }, children: [
          searching && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", justifyContent: "center", padding: 20, gap: 8 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner-small" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "var(--text-muted)", fontSize: 13 }, children: "Searching..." })
          ] }),
          tokenSearchQuery.length >= 2 && !searching && searchResults.length === 0 && isTokenAddress(tokenSearchQuery) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            padding: "12px 20px",
            background: "rgba(2, 116, 251, 0.1)",
            fontSize: 12,
            color: "var(--text-muted)"
          }, children: "Looking up token by address..." }),
          searchResults.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 11, color: "var(--text-muted)", padding: "12px 16px 8px", fontWeight: 600 }, children: [
              "Search Results (",
              searchResults.length,
              ")"
            ] }),
            searchResults.map((token, i) => {
              var _a3;
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `token-select-option ${((_a3 = selectingToken === "from" ? fromToken : toToken) == null ? void 0 : _a3.symbol) === token.symbol ? "selected" : ""}`,
                  onClick: () => handleSelectToken(token),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-select-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TokenIcon, { token, size: 32 }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-select-info", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-select-symbol", children: token.symbol }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-select-name", children: token.name })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-select-balance", children: formatBalance2(token.balance || 0) })
                  ]
                },
                token.mint || i
              );
            })
          ] }),
          !searching && !tokenSearchQuery && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "var(--text-muted)", padding: "12px 16px 8px", fontWeight: 600, marginTop: searchResults.length > 0 ? 8 : 0 }, children: "Your Tokens" }),
            fromTokenOptions.filter((t2) => {
              var _a3;
              return t2.symbol !== ((_a3 = selectingToken === "from" ? toToken : fromToken) == null ? void 0 : _a3.symbol);
            }).map((token, i) => {
              var _a3;
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `token-select-option ${((_a3 = selectingToken === "from" ? fromToken : toToken) == null ? void 0 : _a3.symbol) === token.symbol ? "selected" : ""}`,
                  onClick: () => handleSelectToken(token),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-select-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TokenIcon, { token, size: 32 }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-select-info", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "token-select-symbol", children: [
                        token.symbol,
                        (token.isNative || token.mint === "native") && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-badge spl", style: { marginLeft: 6 }, children: "Native" }),
                        token.isToken2022 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-badge token-2022", style: { marginLeft: 6 }, children: "Token-2022" })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-select-name", children: token.name })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-select-balance", children: formatBalance2(token.balance || 0) }),
                    token.isCustom && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        onClick: (e) => {
                          e.stopPropagation();
                          handleRemoveToken(token.mint);
                        },
                        style: {
                          background: "transparent",
                          border: "none",
                          padding: "4px",
                          cursor: "pointer",
                          color: "#ff3b30",
                          marginLeft: 4
                        },
                        title: "Remove token",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18 6L6 18M6 6l12 12" }) })
                      }
                    )
                  ]
                },
                token.mint || `wallet-${i}`
              );
            }),
            fromTokenOptions.filter((t2) => {
              var _a3;
              return t2.symbol !== ((_a3 = selectingToken === "from" ? toToken : fromToken) == null ? void 0 : _a3.symbol);
            }).length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "16px", textAlign: "center", color: "var(--text-muted)", fontSize: 13 }, children: "No tokens in wallet" })
          ] }),
          !searching && !tokenSearchQuery && selectingToken === "to" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 11, color: "var(--text-muted)", padding: "12px 16px 8px", fontWeight: 600 }, children: [
              "All Tokens ",
              poolTokens.length > 0 && `(${poolTokens.length})`
            ] }),
            poolTokensLoading && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", justifyContent: "center", padding: 20, gap: 8 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner-small" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "var(--text-muted)", fontSize: 13 }, children: "Loading tokens..." })
            ] }),
            !poolTokensLoading && poolTokens.length > 0 && poolTokens.filter((t2) => {
              if ((fromToken == null ? void 0 : fromToken.symbol) === t2.symbol || (fromToken == null ? void 0 : fromToken.mint) === t2.mint) return false;
              const inWallet = fromTokenOptions.find(
                (wt) => wt.mint && t2.mint && wt.mint === t2.mint || wt.symbol === t2.symbol && wt.balance > 0
              );
              return !inWallet;
            }).map((token, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: `token-select-option ${(toToken == null ? void 0 : toToken.symbol) === token.symbol ? "selected" : ""}`,
                onClick: () => handleSelectToken(token),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-select-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TokenIcon, { token, size: 32 }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-select-info", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-select-symbol", children: token.symbol }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-select-name", children: token.name })
                  ] })
                ]
              },
              token.mint || `pool-${i}`
            )),
            !poolTokensLoading && poolTokens.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "16px", textAlign: "center", color: "var(--text-muted)", fontSize: 13 }, children: "No additional tokens available" })
          ] }),
          !searching && tokenSearchQuery.length >= 2 && searchResults.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            displayTokens.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "var(--text-muted)", padding: "12px 16px 8px", fontWeight: 600 }, children: "Matching Tokens" }),
            displayTokens.map((token, i) => {
              var _a3;
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `token-select-option ${((_a3 = selectingToken === "from" ? fromToken : toToken) == null ? void 0 : _a3.symbol) === token.symbol ? "selected" : ""}`,
                  onClick: () => handleSelectToken(token),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-select-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TokenIcon, { token, size: 32 }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-select-info", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "token-select-symbol", children: [
                        token.symbol,
                        (token.isNative || token.mint === "native") && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-badge spl", style: { marginLeft: 6 }, children: "Native" }),
                        token.isToken2022 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-badge token-2022", style: { marginLeft: 6 }, children: "Token-2022" }),
                        token.isCustom && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-badge spl", style: { marginLeft: 6 }, children: "Custom" })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-select-name", children: token.name })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-select-balance", children: formatBalance2(token.balance || 0) }),
                    token.isCustom && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        onClick: (e) => {
                          e.stopPropagation();
                          handleRemoveToken(token.mint);
                        },
                        style: {
                          background: "transparent",
                          border: "none",
                          padding: "4px",
                          cursor: "pointer",
                          color: "#ff3b30",
                          marginLeft: 4
                        },
                        title: "Remove token",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18 6L6 18M6 6l12 12" }) })
                      }
                    )
                  ]
                },
                token.mint || i
              );
            }),
            displayTokens.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: "16px", textAlign: "center", color: "var(--text-muted)", fontSize: 13 }, children: [
              'No tokens found for "',
              tokenSearchQuery,
              '"'
            ] })
          ] })
        ] })
      ] })
    ] });
  }
  if (!fromToken || !toToken) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen swap-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: onBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Swap" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "slide-panel-content", style: { display: "flex", justifyContent: "center", alignItems: "center", minHeight: 200 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }) })
    ] });
  }
  if (swapStatus === "success") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen swap-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "page-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "Swap" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "slide-panel-content", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-step-content send-success", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "success-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: "var(--success)", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M22 11.08V12a10 10 0 1 1-5.93-9.14" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "22 4 12 14.01 9 11.01" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "send-success-title", children: isWrapOperation ? wrapDirection === "wrap" ? "Wrapped!" : "Unwrapped!" : "Swapped!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "send-success-amount", children: [
          fromAmount,
          " ",
          fromToken == null ? void 0 : fromToken.symbol
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "send-success-to", children: [
          "to ",
          toAmount,
          " ",
          toToken == null ? void 0 : toToken.symbol
        ] }),
        txHash && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn-secondary",
            onClick: () => window.open(`${networkConfig.explorerTx}/${txHash}`, "_blank"),
            style: { marginTop: 16 },
            children: "View on Explorer"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn-primary",
            onClick: () => {
              setSwapStatus("");
              setTxHash("");
              setFromAmount("");
              setToAmount("");
              setQuote(null);
            },
            style: { marginTop: 12 },
            children: "Done"
          }
        )
      ] }) })
    ] });
  }
  if (showConfirm) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen swap-screen", style: { display: "flex", flexDirection: "column", height: "100%" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: () => setShowConfirm(false), children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "header-title", children: [
          "Confirm ",
          isWrapOperation ? wrapDirection === "wrap" ? "Wrap" : "Unwrap" : "Swap"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-right" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "slide-panel-content", style: { flex: 1, display: "flex", flexDirection: "column", overflow: "hidden" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-step-content", style: { flex: 1, overflowY: "auto", paddingBottom: 20 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-summary-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-summary-row", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-summary-label", children: "From" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "send-summary-value", children: [
                fromAmount,
                " ",
                fromToken == null ? void 0 : fromToken.symbol
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-summary-row", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-summary-label", children: "To" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "send-summary-value", children: [
                toAmount,
                " ",
                toToken == null ? void 0 : toToken.symbol
              ] })
            ] }),
            !isWrapOperation && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-summary-row", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-summary-label", children: "Rate" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "send-summary-value", children: [
                "1 ",
                fromToken == null ? void 0 : fromToken.symbol,
                "  ",
                (parseFloat(toAmount) / parseFloat(fromAmount)).toFixed(6),
                " ",
                toToken == null ? void 0 : toToken.symbol
              ] })
            ] }),
            isWrapOperation && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-summary-row", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-summary-label", children: "Type" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "send-summary-value", style: { color: "#34c759" }, children: [
                "1:1 ",
                wrapDirection === "wrap" ? "Wrap" : "Unwrap"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-summary-row", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "send-summary-label", children: "Network Fee" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "send-summary-value", children: [
                "~",
                (getBaseFee$1(currentNetwork2) + (swapPriority === "custom" ? parseFloat(customFee) || 0 : ((_d = getPriorityOptions$1(currentNetwork2).find((p2) => p2.id === swapPriority)) == null ? void 0 : _d.fee) || 0)).toFixed(6),
                " ",
                networkConfig.symbol
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-priority-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-priority-label", children: "Transaction Priority" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-priority-selector", children: [
              getPriorityOptions$1(currentNetwork2).filter((opt) => opt.id !== "custom").map((opt) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `send-priority-btn ${swapPriority === opt.id ? "active" : ""}`,
                  onClick: () => {
                    setSwapPriority(opt.id);
                    setCustomFee("");
                  },
                  type: "button",
                  disabled: loading,
                  children: opt.name
                },
                opt.id
              )),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `send-priority-btn ${swapPriority === "custom" ? "active" : ""}`,
                  onClick: () => setSwapPriority("custom"),
                  type: "button",
                  disabled: loading,
                  children: ""
                }
              )
            ] }),
            swapPriority === "custom" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 12, display: "flex", alignItems: "center", justifyContent: "center", gap: 8 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "number",
                  min: "0",
                  style: {
                    width: 100,
                    padding: "8px 12px",
                    background: "var(--bg-tertiary)",
                    border: "1px solid var(--border-color)",
                    borderRadius: 8,
                    color: "var(--text-primary)",
                    fontSize: 13,
                    textAlign: "right"
                  },
                  placeholder: "0.0001",
                  value: customFee,
                  onChange: (e) => {
                    const value = e.target.value;
                    if (value.startsWith("-") || parseFloat(value) < 0) return;
                    setCustomFee(value);
                  },
                  step: "0.0001",
                  disabled: loading
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "var(--text-muted)", fontSize: 13 }, children: networkConfig.symbol })
            ] })
          ] }),
          !isWrapOperation && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-priority-section", style: { marginTop: 16 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-priority-label", children: "Slippage Tolerance" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-priority-selector", children: [
              slippageOptions.map((opt) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  className: `send-priority-btn ${slippage === opt && !customSlippage ? "active" : ""}`,
                  onClick: () => {
                    setSlippage(opt);
                    setCustomSlippage("");
                  },
                  type: "button",
                  children: [
                    opt,
                    "%"
                  ]
                },
                opt
              )),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: `send-priority-btn ${customSlippage ? "active" : ""}`,
                  onClick: () => {
                    const input = document.getElementById("slippage-custom-input");
                    if (input) input.focus();
                  },
                  type: "button",
                  style: { padding: 0, minWidth: 60 },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      id: "slippage-custom-input",
                      type: "number",
                      min: "0",
                      value: customSlippage,
                      onChange: (e) => {
                        const val = e.target.value;
                        if (val.startsWith("-") || parseFloat(val) < 0) return;
                        setCustomSlippage(val);
                        if (val && !isNaN(parseFloat(val))) {
                          setSlippage(parseFloat(val));
                        }
                      },
                      placeholder: "Custom",
                      style: {
                        width: "100%",
                        padding: "8px 4px",
                        border: "none",
                        background: "transparent",
                        color: "var(--text-primary)",
                        fontSize: 12,
                        textAlign: "center",
                        outline: "none"
                      }
                    }
                  )
                }
              )
            ] }),
            slippage > 5 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 8, fontSize: 11, color: "var(--warning)", textAlign: "center" }, children: " High slippage may result in unfavorable trades" })
          ] }),
          error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", style: {
            marginTop: 16,
            padding: "12px 16px",
            background: "rgba(255, 59, 48, 0.1)",
            border: "1px solid rgba(255, 59, 48, 0.3)",
            borderRadius: 8,
            fontSize: 12,
            lineHeight: 1.4,
            whiteSpace: "pre-line"
          }, children: error })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-confirm-actions", style: {
          flexShrink: 0,
          padding: "16px 20px",
          background: "var(--bg-primary)",
          borderTop: "1px solid var(--border-color)"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-secondary send-deny-btn",
              onClick: () => {
                setShowConfirm(false);
                setError("");
              },
              disabled: loading,
              children: "Deny"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn-primary send-approve-btn",
              onClick: handleSwap,
              disabled: loading,
              children: loading ? "Processing..." : "Approve"
            }
          )
        ] })
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen swap-screen", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "Swap" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-right", style: { display: "flex", gap: 8, alignItems: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "header-btn primary",
          onClick: () => setShowManageTokens(true),
          title: "Add Token",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 5v14M5 12h14" }) })
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "slide-panel-content", children: !walletReady ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", padding: 40, minHeight: 200 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { marginTop: 12, color: "var(--text-muted)" }, children: "Loading wallet..." })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
        background: "rgba(255, 59, 48, 0.1)",
        border: "1px solid rgba(255, 59, 48, 0.3)",
        borderRadius: 8,
        padding: "10px 12px",
        marginBottom: 16,
        color: "#ff3b30",
        fontSize: 13
      }, children: error }),
      swapStatus === "success" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
        background: "rgba(52, 199, 89, 0.1)",
        border: "1px solid rgba(52, 199, 89, 0.3)",
        borderRadius: 8,
        padding: "10px 12px",
        marginBottom: 16,
        color: "#34c759",
        fontSize: 13
      }, children: " Swap successful!" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-box", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-box-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Balance" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "swap-balance", style: { display: "flex", alignItems: "center", gap: 8 }, children: [
            formatBalance2(fromToken.balance || 0),
            " ",
            fromToken.symbol,
            (fromToken.balance || 0) > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: setMaxAmount,
                disabled: loading,
                style: {
                  background: "rgba(2, 116, 251, 0.2)",
                  border: "none",
                  borderRadius: 4,
                  padding: "2px 6px",
                  color: "var(--x1-blue)",
                  fontSize: 10,
                  fontWeight: 600,
                  cursor: "pointer"
                },
                children: "MAX"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-box-main", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "swap-token-icon", onClick: () => !loading && setSelectingToken("from"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(TokenIcon, { token: fromToken, size: 32 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-token-info", onClick: () => !loading && setSelectingToken("from"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "swap-token-symbol", children: [
              fromToken.symbol,
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "10", height: "10", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6 9l6 6 6-6" }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "swap-token-name", children: fromToken.name })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "swap-input-area", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "number",
              min: "0",
              className: "swap-amount-input",
              placeholder: quoteLoading && inputMode === "to" ? "..." : "0.00",
              value: quoteLoading && inputMode === "to" ? "" : fromAmount,
              onChange: (e) => {
                const value = e.target.value;
                if (value.startsWith("-") || parseFloat(value) < 0) return;
                setInputMode("from");
                handleFromAmountChange(value);
              },
              onFocus: () => setInputMode("from"),
              disabled: loading
            }
          ) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "swap-direction-wrapper", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "swap-direction-btn", onClick: handleSwapTokens, disabled: loading, title: "Swap direction", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2.5", strokeLinecap: "round", strokeLinejoin: "round", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 10l5-5 5 5" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 14l5 5 5-5" })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-box", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-box-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Balance" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "swap-balance", children: [
            formatBalance2(toToken.balance || 0),
            " ",
            toToken.symbol
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-box-main", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "swap-token-icon", onClick: () => !loading && setSelectingToken("to"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(TokenIcon, { token: toToken, size: 32 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-token-info", onClick: () => !loading && setSelectingToken("to"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "swap-token-symbol", children: [
              toToken.symbol,
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "10", height: "10", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6 9l6 6 6-6" }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "swap-token-name", children: toToken.name })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "swap-input-area", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "number",
              min: "0",
              className: "swap-amount-input",
              placeholder: quoteLoading && inputMode === "from" ? "..." : "0.00",
              value: quoteLoading && inputMode === "from" ? "" : toAmount,
              onChange: (e) => {
                const value = e.target.value;
                if (value.startsWith("-") || parseFloat(value) < 0) return;
                setInputMode("to");
                setToAmount(value);
              },
              onFocus: () => setInputMode("to")
            }
          ) })
        ] })
      ] }),
      quote && fromAmount && toAmount && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "swap-details", style: { marginTop: 16 }, children: [
        !isWrapOperation && quoteTimestamp && Date.now() - quoteTimestamp > 3e4 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
          background: "rgba(255, 149, 0, 0.1)",
          border: "1px solid rgba(255, 149, 0, 0.3)",
          borderRadius: 8,
          padding: "8px 12px",
          marginBottom: 8,
          display: "flex",
          alignItems: "center",
          gap: 8,
          fontSize: 11
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "#ff9500", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "8", x2: "12", y2: "12" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "16", x2: "12.01", y2: "16" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#ff9500" }, children: "Quote may be outdated. Price will refresh when you confirm." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
          display: "grid",
          gridTemplateColumns: "repeat(4, 1fr)",
          gap: 8,
          padding: "8px 0",
          marginBottom: 0
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 10, color: "var(--text-muted)", marginBottom: 4 }, children: isWrapOperation ? "Type" : "Rate" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, fontWeight: 500 }, children: isWrapOperation ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "#34c759" }, children: [
              "1:1 ",
              wrapDirection === "wrap" ? "Wrap" : "Unwrap"
            ] }) : `1 ${fromToken.symbol}  ${(parseFloat(toAmount) / parseFloat(fromAmount)).toFixed(2)} ${toToken.symbol}` })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center", borderLeft: "1px solid var(--border-color)" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 10, color: "var(--text-muted)", marginBottom: 4 }, children: "Price Impact" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
              fontSize: 11,
              fontWeight: 500,
              color: (() => {
                var _a3, _b3;
                if (isWrapOperation) return "#34c759";
                const xntVariants = ["XNT", "WXNT", "pXNT"];
                const fromIsXntVariant = xntVariants.includes(fromToken == null ? void 0 : fromToken.symbol);
                const toIsXntVariant = xntVariants.includes(toToken == null ? void 0 : toToken.symbol);
                const isPeggedPair = fromIsXntVariant && toIsXntVariant;
                let impact = 0;
                if (isPeggedPair) {
                  const actualRate = parseFloat(toAmount) / parseFloat(fromAmount);
                  if (actualRate > 0) {
                    impact = Math.abs(1 - actualRate);
                  }
                } else {
                  let apiImpact = ((_a3 = quote == null ? void 0 : quote.data) == null ? void 0 : _a3.priceImpactPct) || (quote == null ? void 0 : quote.priceImpact) || ((_b3 = quote == null ? void 0 : quote.data) == null ? void 0 : _b3.price_impact) || 0;
                  if (apiImpact > 0) {
                    impact = apiImpact / 100;
                  }
                }
                if (impact < 0.01) return "#34c759";
                if (impact < 0.05) return "#ff9500";
                return "#ff3b30";
              })()
            }, children: (() => {
              var _a3, _b3;
              if (isWrapOperation) return "0%";
              const xntVariants = ["XNT", "WXNT", "pXNT"];
              const fromIsXntVariant = xntVariants.includes(fromToken == null ? void 0 : fromToken.symbol);
              const toIsXntVariant = xntVariants.includes(toToken == null ? void 0 : toToken.symbol);
              const isPeggedPair = fromIsXntVariant && toIsXntVariant;
              let impact = 0;
              if (isPeggedPair) {
                const actualRate = parseFloat(toAmount) / parseFloat(fromAmount);
                if (actualRate > 0) {
                  impact = Math.abs(1 - actualRate);
                }
              } else {
                let apiImpact = ((_a3 = quote == null ? void 0 : quote.data) == null ? void 0 : _a3.priceImpactPct) || (quote == null ? void 0 : quote.priceImpact) || ((_b3 = quote == null ? void 0 : quote.data) == null ? void 0 : _b3.price_impact) || 0;
                if (apiImpact > 0) {
                  impact = apiImpact / 100;
                }
              }
              return `${(impact * 100).toFixed(2)}%`;
            })() })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center", borderLeft: "1px solid var(--border-color)" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 10, color: "var(--text-muted)", marginBottom: 4 }, children: "Est. Gas" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 11, fontWeight: 500 }, children: [
              "~",
              getBaseFee$1(currentNetwork2),
              " ",
              nativeSymbol
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                textAlign: "center",
                borderLeft: "1px solid var(--border-color)",
                cursor: isWrapOperation ? "default" : "pointer"
              },
              onClick: () => !isWrapOperation && setShowSlippageSettings(true),
              title: isWrapOperation ? "" : "Click to change slippage",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 10, color: "var(--text-muted)", marginBottom: 4 }, children: "Slippage" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                  fontSize: 11,
                  fontWeight: 500,
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  gap: 4
                }, children: [
                  isWrapOperation ? "N/A" : `${slippage}%`,
                  !isWrapOperation && /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "10", height: "10", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z" }) })
                ] })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          gap: 8,
          padding: "8px 0"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
            display: "flex",
            alignItems: "center",
            gap: 6,
            background: "var(--bg-secondary)",
            padding: "6px 10px",
            borderRadius: 8
          }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TokenIcon, { token: fromToken, size: 20 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 12, fontWeight: 500 }, children: fromToken.symbol })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 12h14M12 5l7 7-7 7" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            display: "flex",
            alignItems: "center",
            gap: 6,
            background: "var(--bg-secondary)",
            padding: "6px 10px",
            borderRadius: 8
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 12, fontWeight: 500 }, children: "Pool" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 12h14M12 5l7 7-7 7" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
            display: "flex",
            alignItems: "center",
            gap: 6,
            background: "var(--bg-secondary)",
            padding: "6px 10px",
            borderRadius: 8
          }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TokenIcon, { token: toToken, size: 20 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 12, fontWeight: 500 }, children: toToken.symbol })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-bottom-action", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "btn-primary",
          onClick: showSwapConfirm,
          disabled: loading || quoteLoading || !fromAmount || parseFloat(fromAmount) <= 0 || !isWrapOperation && !quote,
          children: loading ? swapStatus === "confirming" ? "Confirming..." : "Processing..." : quoteLoading ? "Getting Quote..." : !quote && !isWrapOperation && fromAmount ? "No Route Found" : isWrapOperation ? `${wrapDirection === "wrap" ? "Wrap" : "Unwrap"} XNT` : "Review Swap"
        }
      ) })
    ] }) })
  ] });
}
const BRIDGE_API_URL = "https://bridge-alpha.x1.xyz";
const SOLANA_RPC_URL = "https://mainnet.helius-rpc.com/?api-key=0d4a8095-4e0c-4895-a4d3-a336c2057db3";
const BRIDGE_DEPOSIT_ADDRESS = "6ob9XW6f6mweGu5sGh3JwW2Vp6UNQApjuPvrubXMQXyi";
const USDC_SOLANA_MINT = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";
const USDC_DECIMALS = 6;
const USDC_LOGO = "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v/logo.png";
const TOKEN_PROGRAM_ID$1 = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
const X1_LOGO_URL = "/icons/48-x1.png";
const SOLANA_LOGO_URL = "/icons/48-sol.png";
const BASE58_ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function decodeBase58Local(str) {
  const bytes = [];
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    const value = BASE58_ALPHABET.indexOf(char);
    if (value === -1) throw new Error(`Invalid base58 character: ${char}`);
    let carry = value;
    for (let j = 0; j < bytes.length; j++) {
      carry += bytes[j] * 58;
      bytes[j] = carry & 255;
      carry >>= 8;
    }
    while (carry > 0) {
      bytes.push(carry & 255);
      carry >>= 8;
    }
  }
  for (let i = 0; i < str.length && str[i] === "1"; i++) {
    bytes.push(0);
  }
  return new Uint8Array(bytes.reverse());
}
function decodeToFixedSize(base58Str, size) {
  const decoded = decodeBase58Local(base58Str);
  if (decoded.length === size) {
    return decoded;
  }
  if (decoded.length < size) {
    const padded = new Uint8Array(size);
    padded.set(decoded, size - decoded.length);
    return padded;
  }
  return decoded.slice(0, size);
}
function SolanaLogo({ size = 24 }) {
  const [error, setError] = reactExports.useState(false);
  const logoSize = Math.round(size * 0.5);
  if (error) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
      width: size,
      height: size,
      minWidth: size,
      minHeight: size,
      borderRadius: "50%",
      background: "linear-gradient(135deg, #9945FF 0%, #14F195 100%)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: logoSize * 0.7, height: logoSize * 0.7, viewBox: "0 0 397 311", fill: "white", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M64.6 237.9c2.4-2.4 5.7-3.8 9.2-3.8h317.4c5.8 0 8.7 7 4.6 11.1l-62.7 62.7c-2.4 2.4-5.7 3.8-9.2 3.8H6.5c-5.8 0-8.7-7-4.6-11.1l62.7-62.7z" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M64.6 3.8C67.1 1.4 70.4 0 73.8 0h317.4c5.8 0 8.7 7 4.6 11.1l-62.7 62.7c-2.4 2.4-5.7 3.8-9.2 3.8H6.5c-5.8 0-8.7-7-4.6-11.1L64.6 3.8z" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M332.6 120.8c-2.4-2.4-5.7-3.8-9.2-3.8H6.5c-5.8 0-8.7 7-4.6 11.1l62.7 62.7c2.4 2.4 5.7 3.8 9.2 3.8h317.4c5.8 0 8.7-7 4.6-11.1l-62.7-62.7z" })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
    width: size,
    height: size,
    minWidth: size,
    minHeight: size,
    borderRadius: "50%",
    background: "#000",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0
  }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      src: SOLANA_LOGO_URL,
      alt: "Solana",
      style: {
        width: logoSize,
        height: logoSize,
        objectFit: "contain",
        display: "block"
      },
      onError: () => setError(true)
    }
  ) });
}
function X1LogoSmall({ size = 20 }) {
  const [error, setError] = reactExports.useState(false);
  const logoSize = Math.round(size * 0.85);
  if (error) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
      width: size,
      height: size,
      minWidth: size,
      minHeight: size,
      borderRadius: "50%",
      background: "#000",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: "white",
      fontSize: size * 0.35,
      fontWeight: 700,
      flexShrink: 0
    }, children: "X1" });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
    width: size,
    height: size,
    minWidth: size,
    minHeight: size,
    borderRadius: "50%",
    background: "#000",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    overflow: "hidden"
  }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      src: X1_LOGO_URL,
      alt: "X1",
      width: logoSize,
      height: logoSize,
      style: { objectFit: "contain" },
      onError: () => setError(true)
    }
  ) });
}
function UsdcLogo({ size = 24 }) {
  const [hasError, setHasError] = reactExports.useState(false);
  if (hasError) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
      width: size,
      height: size,
      borderRadius: "50%",
      background: "#2775CA",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: "white",
      fontSize: size * 0.5,
      fontWeight: 700,
      flexShrink: 0
    }, children: "$" });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
    width: size,
    height: size,
    minWidth: size,
    minHeight: size,
    borderRadius: "50%",
    overflow: "hidden",
    flexShrink: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      src: USDC_LOGO,
      alt: "USDC",
      style: {
        width: size,
        height: size,
        objectFit: "contain"
      },
      onError: () => setHasError(true)
    }
  ) });
}
function BridgeScreen({ wallet, onBack }) {
  var _a2, _b2, _c, _d, _e, _f;
  const [amount, setAmount] = reactExports.useState("");
  const [loading, setLoading] = reactExports.useState(false);
  const [bridgeStatus, setBridgeStatus] = reactExports.useState({ status: "checking", message: "Checking..." });
  const [dailyCap, setDailyCap] = reactExports.useState(0);
  const [dailyCapRemaining, setDailyCapRemaining] = reactExports.useState(0);
  const [userUsdcBalance, setUserUsdcBalance] = reactExports.useState(0);
  const [userUsdcTokenAccount, setUserUsdcTokenAccount] = reactExports.useState(null);
  const [error, setError] = reactExports.useState("");
  const [fetchingBalance, setFetchingBalance] = reactExports.useState(false);
  const [threshold, setThreshold] = reactExports.useState(3);
  const [healthyGuardians, setHealthyGuardians] = reactExports.useState(3);
  const [totalGuardians, setTotalGuardians] = reactExports.useState(3);
  const [txSignature, setTxSignature] = reactExports.useState(null);
  const [txStatus, setTxStatus] = reactExports.useState({ stage: "idle" });
  const [bridgeDepositAddress, setBridgeDepositAddress] = reactExports.useState(BRIDGE_DEPOSIT_ADDRESS);
  const eventSourceRef = reactExports.useRef(null);
  const walletAddress = (_a2 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _a2.publicKey;
  const privateKey = (_b2 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _b2.privateKey;
  const isHardwareWallet = ((_c = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _c.isHardware) || ((_d = wallet == null ? void 0 : wallet.activeWallet) == null ? void 0 : _d.isHardware) || false;
  const derivationPath = (_e = wallet == null ? void 0 : wallet.activeWallet) == null ? void 0 : _e.derivationPath;
  const inputAmount = parseFloat(amount) || 0;
  const fetchBridgeConfig = reactExports.useCallback(async () => {
    var _a3, _b3, _c2, _d2, _e2, _f2, _g;
    try {
      const [configRes, guardiansRes] = await Promise.all([
        fetch(`${BRIDGE_API_URL}/config`),
        fetch(`${BRIDGE_API_URL}/guardians`)
      ]);
      if (!configRes.ok || !guardiansRes.ok) {
        setBridgeStatus({ status: "offline", message: "API offline" });
        return;
      }
      const config = await configRes.json();
      const guardians = await guardiansRes.json();
      logger$1.log("[Bridge] Config:", config);
      if ((_a3 = config.config) == null ? void 0 : _a3.depositAddress) {
        logger$1.log("[Bridge] Got deposit address from API:", config.config.depositAddress);
        setBridgeDepositAddress(config.config.depositAddress);
      } else if ((_b3 = config.config) == null ? void 0 : _b3.usdcTokenAccount) {
        logger$1.log("[Bridge] Got USDC token account from API:", config.config.usdcTokenAccount);
        setBridgeDepositAddress(config.config.usdcTokenAccount);
      }
      const capValue = BigInt(((_c2 = config.config) == null ? void 0 : _c2.dailyCap) || "0");
      const releasedValue = BigInt(((_d2 = config.config) == null ? void 0 : _d2.releasedToday) || "0");
      const remaining = capValue - releasedValue;
      setDailyCap(Number(capValue) / 1e6);
      setDailyCapRemaining(Number(remaining) / 1e6);
      setThreshold(((_e2 = config.config) == null ? void 0 : _e2.threshold) || 2);
      const healthy = guardians.healthyCount || 0;
      const total = guardians.totalGuardians || 3;
      setHealthyGuardians(healthy);
      setTotalGuardians(total);
      if ((_f2 = config.config) == null ? void 0 : _f2.paused) {
        setBridgeStatus({ status: "paused", message: "Bridge paused" });
        return;
      }
      const requiredThreshold = ((_g = config.config) == null ? void 0 : _g.threshold) || 2;
      if (healthy > requiredThreshold) {
        setBridgeStatus({ status: "live", message: `${healthy}/${total} guardians healthy` });
      } else if (healthy === requiredThreshold) {
        setBridgeStatus({ status: "degraded", message: `${healthy}/${total} guardians healthy` });
      } else {
        setBridgeStatus({ status: "offline", message: `${healthy}/${total} guardians healthy` });
      }
    } catch (err) {
      logger$1.error("[Bridge] Config fetch error:", err);
      setBridgeStatus({ status: "offline", message: "Unable to connect" });
    }
  }, []);
  const fetchUsdcBalance = reactExports.useCallback(async () => {
    var _a3, _b3, _c2, _d2, _e2, _f2, _g;
    if (!walletAddress) {
      setUserUsdcBalance(0);
      return;
    }
    logger$1.log("[Bridge] Fetching USDC balance for:", walletAddress);
    setFetchingBalance(true);
    try {
      const response = await fetch(SOLANA_RPC_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "getTokenAccountsByOwner",
          params: [
            walletAddress,
            { mint: USDC_SOLANA_MINT },
            { encoding: "jsonParsed", commitment: "confirmed" }
          ]
        })
      });
      const data = await response.json();
      logger$1.log("[Bridge] USDC balance response:", JSON.stringify(data).slice(0, 300));
      if (((_b3 = (_a3 = data.result) == null ? void 0 : _a3.value) == null ? void 0 : _b3.length) > 0) {
        const tokenAccount = data.result.value[0];
        const balance = parseFloat(
          ((_g = (_f2 = (_e2 = (_d2 = (_c2 = tokenAccount.account) == null ? void 0 : _c2.data) == null ? void 0 : _d2.parsed) == null ? void 0 : _e2.info) == null ? void 0 : _f2.tokenAmount) == null ? void 0 : _g.uiAmount) || 0
        );
        const tokenAccountAddress = tokenAccount.pubkey;
        logger$1.log("[Bridge] USDC balance:", balance, "Token Account:", tokenAccountAddress);
        setUserUsdcBalance(balance);
        setUserUsdcTokenAccount(tokenAccountAddress);
      } else {
        logger$1.log("[Bridge] No USDC token account found");
        setUserUsdcBalance(0);
        setUserUsdcTokenAccount(null);
      }
    } catch (err) {
      logger$1.error("[Bridge] Failed to fetch USDC balance:", err);
    } finally {
      setFetchingBalance(false);
    }
  }, [walletAddress]);
  reactExports.useEffect(() => {
    fetchBridgeConfig();
    fetchUsdcBalance();
    const configInterval = setInterval(fetchBridgeConfig, 3e4);
    const balanceInterval = setInterval(fetchUsdcBalance, 15e3);
    return () => {
      clearInterval(configInterval);
      clearInterval(balanceInterval);
    };
  }, [fetchBridgeConfig, fetchUsdcBalance]);
  reactExports.useEffect(() => {
    if (!txSignature) return;
    logger$1.log("[Bridge] Starting SSE listener for:", txSignature.slice(0, 8));
    const eventSource = new EventSource(`${BRIDGE_API_URL}/transactions/stream`);
    eventSourceRef.current = eventSource;
    eventSource.onopen = () => {
      logger$1.log("[Bridge] SSE connection opened");
    };
    eventSource.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.txSig === txSignature) {
          logger$1.log("[Bridge] SSE event:", data.type);
          switch (data.type) {
            case "transaction_detected":
              setTxStatus({
                stage: "detected",
                message: "Transaction detected by guardians"
              });
              break;
            case "signature_added":
              setTxStatus({
                stage: "signing",
                signatures: data.signatureCount,
                threshold: data.threshold,
                message: `Guardian ${data.signatureCount}/${data.threshold} signed`
              });
              break;
            case "threshold_reached":
              setTxStatus({
                stage: "threshold",
                signatures: data.signatureCount,
                threshold: data.threshold,
                message: "Threshold reached! Submitting to X1..."
              });
              break;
            case "transaction_submitted":
              setTxStatus({
                stage: "confirming",
                x1TxSig: data.x1TxSig,
                message: "Submitted to X1, confirming..."
              });
              break;
            case "transaction_executed":
              setTxStatus({
                stage: "executed",
                x1TxSig: data.x1TxSig,
                message: "Complete! USDC.X received on X1."
              });
              setLoading(false);
              eventSource.close();
              fetchUsdcBalance();
              break;
          }
        }
      } catch (err) {
        logger$1.error("[Bridge] SSE parse error:", err);
      }
    };
    eventSource.onerror = () => {
      logger$1.error("[Bridge] SSE connection error");
    };
    return () => {
      eventSource.close();
    };
  }, [txSignature, fetchUsdcBalance]);
  const handleBridge = async () => {
    var _a3, _b3;
    if (!walletAddress || !privateKey && !isHardwareWallet) {
      setError("Wallet not connected");
      return;
    }
    if (!userUsdcTokenAccount) {
      setError("No USDC token account found. Please refresh balance.");
      return;
    }
    const solBalance = (wallet == null ? void 0 : wallet.balance) || 0;
    if (solBalance < 5e-6) {
      setError("Insufficient SOL for transaction fee. You need ~0.00001 SOL.");
      return;
    }
    if (!amount || inputAmount <= 0) {
      setError("Enter an amount to bridge");
      return;
    }
    if (inputAmount < 0.01) {
      setError("Minimum amount is 0.01 USDC");
      return;
    }
    const multiplier = Math.pow(10, USDC_DECIMALS);
    const requiredAmount = Math.round(inputAmount * multiplier);
    const availableAmount = Math.round(userUsdcBalance * multiplier);
    if (requiredAmount > availableAmount) {
      setError(`Insufficient USDC balance. Required: ${inputAmount} USDC, Available: ${userUsdcBalance} USDC`);
      return;
    }
    if (inputAmount > dailyCapRemaining) {
      setError("Exceeds daily bridge capacity");
      return;
    }
    if (bridgeStatus.status !== "live" && bridgeStatus.status !== "degraded") {
      setError("Bridge is not available");
      return;
    }
    setLoading(true);
    setError("");
    setTxStatus({ stage: "idle", message: "Preparing transaction..." });
    try {
      logger$1.log("[Bridge] Getting blockhash from Solana...");
      const blockhashResponse = await fetch(SOLANA_RPC_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "getLatestBlockhash",
          params: [{ commitment: "finalized" }]
        })
      });
      const blockhashData = await blockhashResponse.json();
      if (blockhashData.error) {
        throw new Error(blockhashData.error.message || "Failed to get blockhash");
      }
      const blockhash = (_b3 = (_a3 = blockhashData.result) == null ? void 0 : _a3.value) == null ? void 0 : _b3.blockhash;
      if (!blockhash) {
        throw new Error("Failed to get blockhash");
      }
      logger$1.log("[Bridge] Blockhash:", blockhash);
      const tokenAmount = Math.floor(inputAmount * Math.pow(10, USDC_DECIMALS));
      logger$1.log("[Bridge] Token amount:", tokenAmount);
      logger$1.log("[Bridge] User token account:", userUsdcTokenAccount);
      logger$1.log("[Bridge] Bridge deposit address:", bridgeDepositAddress);
      const { sign: sign2 } = await __vitePreload(async () => {
        const { sign: sign3 } = await Promise.resolve().then(() => bip44);
        return { sign: sign3 };
      }, true ? void 0 : void 0);
      const ownerBytes = decodeToFixedSize(walletAddress, 32);
      const sourceBytes = decodeToFixedSize(userUsdcTokenAccount, 32);
      const destBytes = decodeToFixedSize(bridgeDepositAddress, 32);
      const programBytes = decodeToFixedSize(TOKEN_PROGRAM_ID$1, 32);
      const blockhashBytes = decodeToFixedSize(blockhash, 32);
      const header = new Uint8Array([1, 0, 1]);
      const accountKeys = new Uint8Array(32 * 4);
      accountKeys.set(ownerBytes, 0);
      accountKeys.set(sourceBytes, 32);
      accountKeys.set(destBytes, 64);
      accountKeys.set(programBytes, 96);
      const instructionData = new Uint8Array(9);
      instructionData[0] = 3;
      const amountBI = BigInt(tokenAmount);
      for (let i = 0; i < 8; i++) {
        instructionData[1 + i] = Number(amountBI >> BigInt(i * 8) & BigInt(255));
      }
      const instruction = new Uint8Array([
        3,
        3,
        1,
        2,
        0,
        9,
        ...instructionData
      ]);
      const messageLength = 3 + 1 + 128 + 32 + 1 + instruction.length;
      const message = new Uint8Array(messageLength);
      let offset = 0;
      message.set(header, offset);
      offset += 3;
      message[offset] = 4;
      offset += 1;
      message.set(accountKeys, offset);
      offset += 128;
      message.set(blockhashBytes, offset);
      offset += 32;
      message[offset] = 1;
      offset += 1;
      message.set(instruction, offset);
      logger$1.log("[Bridge] Message built, length:", message.length);
      let ed25519Signature;
      if (isHardwareWallet) {
        logger$1.log("[Bridge] Signing with hardware wallet...");
        setTxStatus({ stage: "idle", message: "Please confirm on your Ledger device..." });
        ed25519Signature = await hardwareWallet.signTransaction(message, derivationPath);
      } else {
        let secretKey;
        if (typeof privateKey === "string") {
          secretKey = decodeBase58Local(privateKey);
        } else {
          secretKey = privateKey;
        }
        if (secretKey.length !== 64) {
          throw new Error(`Invalid secret key length: ${secretKey.length}`);
        }
        ed25519Signature = await sign2(message, secretKey);
      }
      const signedTx = new Uint8Array(1 + 64 + message.length);
      signedTx[0] = 1;
      signedTx.set(ed25519Signature, 1);
      signedTx.set(message, 65);
      const tx = btoa(String.fromCharCode(...signedTx));
      logger$1.log("[Bridge] Transaction ready, sending...");
      setTxStatus({ stage: "idle", message: "Sending transaction..." });
      const sendResponse = await fetch(SOLANA_RPC_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "sendTransaction",
          params: [tx, {
            encoding: "base64",
            skipPreflight: false,
            preflightCommitment: "confirmed"
          }]
        })
      });
      const sendData = await sendResponse.json();
      if (sendData.error) {
        logger$1.error("[Bridge] Transaction error:", sendData.error);
        throw new Error(sendData.error.message || "Transaction failed");
      }
      const signature = sendData.result;
      logger$1.log("[Bridge] Transaction sent:", signature);
      setTxSignature(signature);
      setTxStatus({
        stage: "detected",
        txSig: signature,
        message: "Transaction sent! Waiting for guardians..."
      });
      setTimeout(() => fetchUsdcBalance(), 3e3);
    } catch (err) {
      logger$1.error("[Bridge] Transaction error:", err);
      setError(err.message || "Transaction failed");
      setTxStatus({ stage: "failed", message: err.message });
      setLoading(false);
    }
  };
  const setMaxAmount = () => {
    if (userUsdcBalance > 0) {
      const maxAmount = Math.min(userUsdcBalance, dailyCapRemaining);
      setAmount(maxAmount.toFixed(2));
    }
  };
  const formatNumber = (val, dec = 2) => {
    return (val || 0).toLocaleString(void 0, {
      minimumFractionDigits: dec,
      maximumFractionDigits: dec
    });
  };
  const getTxStageInfo = () => {
    const stages = {
      idle: { label: "Ready", color: "#8b8b8b" },
      detected: { label: "Detected", color: "#0274fb" },
      signing: { label: "Signing", color: "#f59e0b" },
      threshold: { label: "Threshold Reached", color: "#f97316" },
      confirming: { label: "Confirming", color: "#0274fb" },
      executed: { label: "Complete", color: "#22c55e" },
      failed: { label: "Failed", color: "#ef4444" }
    };
    return stages[txStatus.stage] || stages.idle;
  };
  const styles = {
    screen: {
      display: "flex",
      flexDirection: "column",
      height: "100%",
      background: "#000000"
    },
    content: {
      flex: 1,
      overflowY: "auto",
      padding: "20px"
    }
  };
  const isSolana = (_f = wallet == null ? void 0 : wallet.network) == null ? void 0 : _f.includes("Solana");
  if (!isSolana) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.screen, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: onBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "X1 Bridge" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles.content, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
        padding: 24,
        textAlign: "center"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
          width: 64,
          height: 64,
          borderRadius: "50%",
          background: "rgba(239, 68, 68, 0.1)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          margin: "0 auto 16px"
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "32", height: "32", viewBox: "0 0 24 24", fill: "none", stroke: "#ef4444", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "8", x2: "12", y2: "12" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "16", x2: "12.01", y2: "16" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { color: "#fff", fontSize: 18, marginBottom: 8 }, children: "Switch to Solana Network" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { color: "#8b8b8b", fontSize: 14, lineHeight: 1.5, marginBottom: 20 }, children: [
          "The bridge transfers USDC from ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { style: { color: "#fff" }, children: "Solana" }),
          " to ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { style: { color: "#fff" }, children: "X1" }),
          ". Please switch to Solana Mainnet to use the bridge."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
          display: "flex",
          gap: 12,
          justifyContent: "center",
          marginBottom: 16
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
            display: "flex",
            alignItems: "center",
            gap: 8,
            padding: "8px 16px",
            background: "#111",
            borderRadius: 8
          }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SolanaLogo, { size: 20 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#fff", fontSize: 14 }, children: "Solana" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: "#6b6b6b", alignSelf: "center" }, children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
            display: "flex",
            alignItems: "center",
            gap: 8,
            padding: "8px 16px",
            background: "#111",
            borderRadius: 8
          }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(X1LogoSmall, { size: 20 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#fff", fontSize: 14 }, children: "X1" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { color: "#6b6b6b", fontSize: 12, marginBottom: 24 }, children: [
          "Current network: ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#ef4444" }, children: (wallet == null ? void 0 : wallet.network) || "Unknown" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn-primary",
            onClick: () => onBack && onBack("network"),
            style: { width: "auto", padding: "12px 32px" },
            children: "Switch to Solana Mainnet"
          }
        )
      ] }) })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen bridge-screen", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: onBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "Bridge" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-right" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "main-content", style: { padding: "0 20px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-step-content send-amount-step", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bridge-route-display", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bridge-route-chain", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(SolanaLogo, { size: 24 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Solana" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bridge-route-arrow", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 12h14M12 5l7 7-7 7" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bridge-route-chain", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(X1LogoSmall, { size: 24 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "X1" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-amount-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            inputMode: "decimal",
            className: "send-amount-input",
            placeholder: "0",
            value: amount,
            onChange: (e) => {
              setAmount(e.target.value.replace(/[^0-9.]/g, ""));
              setError("");
            },
            disabled: loading
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-amount-token", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(UsdcLogo, { size: 24 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "USDC" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "send-max-pill",
          onClick: setMaxAmount,
          type: "button",
          disabled: fetchingBalance,
          children: fetchingBalance ? "Loading..." : `Balance: ${formatNumber(userUsdcBalance)} USDC`
        }
      ),
      amount && parseFloat(amount) > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bridge-arrow-down", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 5v14M5 12l7 7 7-7" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bridge-receive-preview", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "bridge-receive-value", children: [
            amount,
            " USDC.X"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bridge-receive-chain", children: "on X1 Mainnet" })
        ] })
      ] }),
      txStatus.stage !== "idle" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bridge-tx-status", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bridge-tx-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Status" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: getTxStageInfo().color }, children: getTxStageInfo().label })
        ] }),
        txStatus.signatures !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bridge-signatures", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bridge-sig-label", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Guardian Signatures" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              txStatus.signatures,
              "/",
              txStatus.threshold || threshold
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bridge-sig-dots", children: Array.from({ length: txStatus.threshold || threshold }).map((_, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `bridge-sig-dot ${i < txStatus.signatures ? "filled" : ""}`
            },
            i
          )) })
        ] }),
        txStatus.x1TxSig && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            href: getTxExplorerUrl("X1 Mainnet", txStatus.x1TxSig),
            target: "_blank",
            rel: "noopener noreferrer",
            className: "bridge-tx-link",
            children: "View on Explorer "
          }
        ),
        txStatus.message && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bridge-tx-message", children: txStatus.message })
      ] }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "send-bottom-action", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "btn-primary",
          onClick: handleBridge,
          disabled: loading || !amount || parseFloat(amount) <= 0 || bridgeStatus.status !== "live" && bridgeStatus.status !== "degraded",
          children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "btn-loading", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "spinner-small" }) }) : bridgeStatus.status === "offline" || bridgeStatus.status === "paused" ? "Bridge Unavailable" : "Bridge to X1"
        }
      ) })
    ] }) })
  ] });
}
const LAMPORTS_PER_SOL = 1e9;
const SYSTEM_PROGRAM_ID = "11111111111111111111111111111111";
const TOKEN_PROGRAM_ID = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
const ASSOCIATED_TOKEN_PROGRAM_ID = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
const STAKE_POOL_PROGRAM_ID = "XPoo1Fx6KNgeAzFcq2dPTo95bWGUSj5KdPVqYj9CZux";
const STAKE_POOL_ADDRESS = "X1SPaMUM1A8E1vKL8XQAB5rxKarJbqtWFFSNFs8f7Av";
const SYSVAR_CLOCK_PUBKEY = "SysvarC1ock11111111111111111111111111111111";
const SYSVAR_STAKE_HISTORY_PUBKEY = "SysvarStakeHistory1111111111111111111111111";
const STAKE_PROGRAM_ID = "Stake11111111111111111111111111111111111111";
function pubkeyToBytes(base58Str) {
  const decoded = decodeBase58(base58Str);
  if (decoded.length === 32) return decoded;
  const result = new Uint8Array(32);
  result.set(decoded, 32 - decoded.length);
  return result;
}
async function findProgramAddress(seeds, programId) {
  const programIdBytes = pubkeyToBytes(programId);
  const PDA_MARKER = new TextEncoder().encode("ProgramDerivedAddress");
  for (let bump = 255; bump >= 0; bump--) {
    const seedsWithBump = [...seeds, new Uint8Array([bump])];
    const totalSeedsLen = seedsWithBump.reduce((acc, seed) => acc + seed.length, 0);
    const buffer2 = new Uint8Array(totalSeedsLen + 32 + PDA_MARKER.length);
    let offset = 0;
    for (const seed of seedsWithBump) {
      buffer2.set(seed, offset);
      offset += seed.length;
    }
    buffer2.set(programIdBytes, offset);
    offset += 32;
    buffer2.set(PDA_MARKER, offset);
    const hash = await crypto.subtle.digest("SHA-256", buffer2);
    const hashArray = new Uint8Array(hash);
    const isLikelyOffCurve = isOffCurve(hashArray);
    if (isLikelyOffCurve) {
      const pubkey = encodeBase58(hashArray);
      logger$1.log("[PDA] Found at bump", bump, ":", pubkey);
      return { pubkey, bump };
    }
  }
  throw new Error("Could not find PDA");
}
function isOffCurve(bytes) {
  const p2 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
  const d = BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555");
  let y2 = BigInt(0);
  for (let i = 0; i < 32; i++) {
    y2 |= BigInt(bytes[i]) << BigInt(i * 8);
  }
  y2 &= (BigInt(1) << BigInt(255)) - BigInt(1);
  if (y2 >= p2) return true;
  const y22 = y2 * y2 % p2;
  const num = (y22 - BigInt(1) + p2) % p2;
  const den = (d * y22 + BigInt(1)) % p2;
  const denInv = modPow(den, p2 - BigInt(2), p2);
  const x2 = num * denInv % p2;
  const exp = (p2 - BigInt(1)) / BigInt(2);
  const legendre = modPow(x2, exp, p2);
  return legendre !== BigInt(1) && legendre !== BigInt(0);
}
function modPow(base, exp, mod) {
  let result = BigInt(1);
  base = base % mod;
  while (exp > 0) {
    if (exp % BigInt(2) === BigInt(1)) {
      result = result * base % mod;
    }
    exp = exp / BigInt(2);
    base = base * base % mod;
  }
  return result;
}
async function getAssociatedTokenAddress(mint, owner, tokenProgramId = TOKEN_PROGRAM_ID) {
  const mintBytes = pubkeyToBytes(mint);
  const ownerBytes = pubkeyToBytes(owner);
  const programBytes = pubkeyToBytes(tokenProgramId);
  const { pubkey } = await findProgramAddress(
    [ownerBytes, programBytes, mintBytes],
    ASSOCIATED_TOKEN_PROGRAM_ID
  );
  return pubkey;
}
function parseStakePoolAccount(base64Data) {
  const data = Uint8Array.from(atob(base64Data), (c) => c.charCodeAt(0));
  logger$1.log("[Stake] Raw pool data length:", data.length);
  if (data.length < 300) {
    throw new Error("Invalid stake pool data length");
  }
  const getPubkey = (offset) => {
    try {
      const bytes = data.slice(offset, offset + 32);
      return encodeBase58(bytes);
    } catch {
      return null;
    }
  };
  const dataView = new DataView(data.buffer);
  const parsed = {
    version: data[0],
    accountType: data[1],
    manager: getPubkey(2),
    staker: getPubkey(34),
    stakeDepositAuthority: getPubkey(66),
    stakeWithdrawBumpSeed: data[98],
    validatorList: getPubkey(99),
    reserveStake: getPubkey(131),
    poolMint: getPubkey(163),
    managerFeeAccount: getPubkey(195),
    tokenProgramId: getPubkey(227),
    totalLamports: Number(dataView.getBigUint64(259, true)),
    poolTokenSupply: Number(dataView.getBigUint64(267, true)),
    lastUpdateEpoch: Number(dataView.getBigUint64(275, true))
  };
  logger$1.log("[Stake] Parsed version:", parsed.version);
  logger$1.log("[Stake] Parsed accountType:", parsed.accountType);
  logger$1.log("[Stake] Parsed poolMint:", parsed.poolMint);
  logger$1.log("[Stake] Parsed tokenProgramId:", parsed.tokenProgramId);
  return parsed;
}
function StakeScreen({ wallet, onBack, onRefreshBalance }) {
  var _a2, _b2, _c, _d;
  const [amount, setAmount] = reactExports.useState("");
  const [unstakeAll, setUnstakeAll] = reactExports.useState(false);
  const [unstakeAllAmount, setUnstakeAllAmount] = reactExports.useState(0);
  const [loading, setLoading] = reactExports.useState(false);
  const [loadingAction, setLoadingAction] = reactExports.useState("");
  const [poolLoading, setPoolLoading] = reactExports.useState(true);
  const [poolInfo, setPoolInfo] = reactExports.useState(null);
  const [poolData, setPoolData] = reactExports.useState(null);
  const [userStake, setUserStake] = reactExports.useState({ stakedAmount: 0, poolTokenBalance: 0 });
  const [epochInfo, setEpochInfo] = reactExports.useState(null);
  const [showPoolInfo, setShowPoolInfo] = reactExports.useState(false);
  const [error, setError] = reactExports.useState("");
  const [success, setSuccess] = reactExports.useState("");
  const [txSignature, setTxSignature] = reactExports.useState("");
  const [localBalance, setLocalBalance] = reactExports.useState(null);
  const [hwStatus, setHwStatus] = reactExports.useState("");
  const isFetchingRef = reactExports.useRef(false);
  const lastFetchKeyRef = reactExports.useRef(null);
  const network = (wallet == null ? void 0 : wallet.network) || "X1 Mainnet";
  const networkConfig = NETWORKS[network] || NETWORKS["X1 Mainnet"];
  const walletAddress = (_a2 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _a2.publicKey;
  const propBalance = (wallet == null ? void 0 : wallet.balance) || 0;
  const balance = localBalance !== null ? localBalance : propBalance;
  const privateKey = (_b2 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _b2.privateKey;
  const isHardwareWallet = ((_c = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _c.isHardware) || ((_d = wallet == null ? void 0 : wallet.activeWallet) == null ? void 0 : _d.isHardware) || false;
  reactExports.useEffect(() => {
    if (localBalance === null && propBalance > 0) {
      setLocalBalance(propBalance);
    }
  }, [propBalance, localBalance]);
  const isX1Mainnet = network === "X1 Mainnet";
  const rpcCall = reactExports.useCallback(async (method, params = []) => {
    if (!(networkConfig == null ? void 0 : networkConfig.rpcUrl)) throw new Error("No RPC URL");
    const response = await fetch(networkConfig.rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ jsonrpc: "2.0", id: 1, method, params })
    });
    const data = await response.json();
    if (data.error) throw new Error(data.error.message);
    return data.result;
  }, [networkConfig == null ? void 0 : networkConfig.rpcUrl]);
  const refreshLocalBalance = reactExports.useCallback(async () => {
    var _a3;
    const rpcUrl = networkConfig == null ? void 0 : networkConfig.rpcUrl;
    if (!walletAddress || !rpcUrl) return;
    try {
      logger$1.log("[Stake] Refreshing local balance from:", rpcUrl);
      const response = await fetch(rpcUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: Date.now(),
          method: "getBalance",
          params: [walletAddress, { commitment: "confirmed" }]
        })
      });
      const data = await response.json();
      if (((_a3 = data.result) == null ? void 0 : _a3.value) !== void 0) {
        const bal = data.result.value / Math.pow(10, networkConfig.decimals || 9);
        logger$1.log("[Stake] Updated local balance:", bal);
        setLocalBalance(bal);
      }
    } catch (e) {
      logger$1.warn("[Stake] Failed to refresh local balance:", e);
    }
  }, [walletAddress, networkConfig == null ? void 0 : networkConfig.rpcUrl, networkConfig == null ? void 0 : networkConfig.decimals]);
  const fetchPoolInfo = reactExports.useCallback(async () => {
    var _a3, _b3, _c2, _d2, _e, _f, _g, _h;
    if (!isX1Mainnet) {
      setPoolLoading(false);
      return;
    }
    try {
      setPoolLoading(true);
      setError("");
      logger$1.log("[Stake] Fetching pool info...");
      const accountData = await rpcCall("getAccountInfo", [
        STAKE_POOL_ADDRESS,
        { encoding: "base64", commitment: "confirmed" }
      ]);
      if (!((_b3 = (_a3 = accountData == null ? void 0 : accountData.value) == null ? void 0 : _a3.data) == null ? void 0 : _b3[0])) {
        throw new Error("Stake pool not found");
      }
      const parsed = parseStakePoolAccount(accountData.value.data[0]);
      logger$1.log("[Stake] Parsed pool:", parsed);
      logger$1.log("[Stake] Pool mint:", parsed.poolMint);
      logger$1.log("[Stake] Reserve stake:", parsed.reserveStake);
      logger$1.log("[Stake] Manager fee account:", parsed.managerFeeAccount);
      logger$1.log("[Stake] Pool tokenProgramId:", parsed.tokenProgramId);
      setPoolData(parsed);
      const exchangeRate = 1;
      setPoolInfo({
        address: STAKE_POOL_ADDRESS,
        programId: STAKE_POOL_PROGRAM_ID,
        totalStaked: parsed.totalLamports / LAMPORTS_PER_SOL,
        poolTokenSupply: parsed.poolTokenSupply / LAMPORTS_PER_SOL,
        exchangeRate,
        apy: 8,
        poolMint: parsed.poolMint,
        reserveStake: parsed.reserveStake,
        managerFeeAccount: parsed.managerFeeAccount
      });
      if (walletAddress && parsed.poolMint) {
        try {
          const tokenAccounts = await rpcCall("getTokenAccountsByOwner", [
            walletAddress,
            { mint: parsed.poolMint },
            { encoding: "jsonParsed", commitment: "confirmed" }
          ]);
          if (((_c2 = tokenAccounts == null ? void 0 : tokenAccounts.value) == null ? void 0 : _c2.length) > 0) {
            const poolTokenBalance = parseFloat(
              ((_h = (_g = (_f = (_e = (_d2 = tokenAccounts.value[0].account) == null ? void 0 : _d2.data) == null ? void 0 : _e.parsed) == null ? void 0 : _f.info) == null ? void 0 : _g.tokenAmount) == null ? void 0 : _h.uiAmount) || 0
            );
            setUserStake({
              stakedAmount: poolTokenBalance * exchangeRate,
              poolTokenBalance,
              poolTokenAccount: tokenAccounts.value[0].pubkey
            });
          }
        } catch (e) {
          logger$1.warn("[Stake] Could not fetch user stake:", e);
        }
      }
      try {
        const epoch = await rpcCall("getEpochInfo", [{ commitment: "confirmed" }]);
        if (epoch) {
          const slotsRemaining = epoch.slotsInEpoch - epoch.slotIndex;
          const secondsRemaining = Math.floor(slotsRemaining * 0.4);
          const hoursRemaining = Math.floor(secondsRemaining / 3600);
          const minutesRemaining = Math.floor(secondsRemaining % 3600 / 60);
          setEpochInfo({
            epoch: epoch.epoch,
            slotIndex: epoch.slotIndex,
            slotsInEpoch: epoch.slotsInEpoch,
            progress: (epoch.slotIndex / epoch.slotsInEpoch * 100).toFixed(1),
            timeRemaining: hoursRemaining > 0 ? `~${hoursRemaining}h ${minutesRemaining}m` : `~${minutesRemaining}m`
          });
        }
      } catch (e) {
        logger$1.warn("[Stake] Could not fetch epoch info:", e);
      }
    } catch (err) {
      logger$1.error("[Stake] Failed to fetch pool:", err);
      setError("Failed to load stake pool: " + err.message);
      setPoolInfo({
        address: STAKE_POOL_ADDRESS,
        programId: STAKE_POOL_PROGRAM_ID,
        totalStaked: 0,
        poolTokenSupply: 0,
        exchangeRate: 1,
        apy: 8
      });
    } finally {
      setPoolLoading(false);
    }
  }, [isX1Mainnet, rpcCall, walletAddress]);
  reactExports.useEffect(() => {
    let mounted = true;
    const doFetch = async () => {
      const fetchKey = `${walletAddress}-${network}`;
      if (isFetchingRef.current) {
        logger$1.log("[Stake] Already fetching, skipping");
        return;
      }
      if (lastFetchKeyRef.current === fetchKey && poolInfo) {
        logger$1.log("[Stake] Already fetched for:", fetchKey);
        return;
      }
      if (mounted && isX1Mainnet && walletAddress && (networkConfig == null ? void 0 : networkConfig.rpcUrl)) {
        isFetchingRef.current = true;
        lastFetchKeyRef.current = fetchKey;
        try {
          await fetchPoolInfo();
        } finally {
          isFetchingRef.current = false;
        }
      }
    };
    doFetch();
    return () => {
      mounted = false;
    };
  }, [isX1Mainnet, walletAddress]);
  const handleStake = async () => {
    var _a3, _b3, _c2, _d2, _e, _f, _g, _h, _i, _j;
    logger$1.log("[Stake] ===== handleStake START =====");
    logger$1.log("[Stake] amount:", amount);
    logger$1.log("[Stake] balance:", balance);
    logger$1.log("[Stake] privateKey exists:", !!privateKey);
    logger$1.log("[Stake] isHardwareWallet:", isHardwareWallet);
    logger$1.log("[Stake] walletAddress:", walletAddress);
    logger$1.log("[Stake] poolData:", poolData);
    logger$1.log("[Stake] poolData?.poolMint:", poolData == null ? void 0 : poolData.poolMint);
    if (!amount || parseFloat(amount) <= 0) {
      logger$1.log("[Stake] FAIL: Invalid amount");
      setError("Enter a valid amount");
      return;
    }
    const stakeAmount = parseFloat(amount);
    logger$1.log("[Stake] stakeAmount:", stakeAmount);
    const decimals = (networkConfig == null ? void 0 : networkConfig.decimals) || 9;
    const multiplier = Math.pow(10, decimals);
    const requiredAmount = Math.round(stakeAmount * multiplier);
    const availableAmount = Math.round((balance - 0.01) * multiplier);
    if (requiredAmount > availableAmount) {
      logger$1.log("[Stake] FAIL: Insufficient balance");
      setError("Insufficient balance (reserve 0.01 XNT for fees)");
      return;
    }
    if (!walletAddress) {
      logger$1.log("[Stake] FAIL: No wallet address");
      setError("Wallet not available");
      return;
    }
    if (!isHardwareWallet && !privateKey) {
      logger$1.log("[Stake] FAIL: No private key for software wallet");
      setError("Wallet not available");
      return;
    }
    if (!(poolData == null ? void 0 : poolData.poolMint)) {
      logger$1.log("[Stake] FAIL: No pool mint");
      setError("Pool data not loaded - please refresh");
      return;
    }
    logger$1.log("[Stake] All checks PASSED, starting transaction...");
    setTxSignature("");
    setHwStatus("");
    try {
      logger$1.log("[Stake] Building transaction for", stakeAmount, "XNT");
      const { buildTransaction: buildTransaction2, signTransaction: signTransaction2, sendTransaction: sendTransaction2 } = await __vitePreload(async () => {
        const { buildTransaction: buildTransaction3, signTransaction: signTransaction3, sendTransaction: sendTransaction3 } = await Promise.resolve().then(() => transaction);
        return { buildTransaction: buildTransaction3, signTransaction: signTransaction3, sendTransaction: sendTransaction3 };
      }, true ? void 0 : void 0);
      logger$1.log("[Stake] Transaction utils imported");
      const poolTokenProgram = poolData.tokenProgramId;
      logger$1.log("[Stake] Using pool token program:", poolTokenProgram);
      let userPoolTokenATA = null;
      let ataExists = false;
      try {
        logger$1.log("[Stake] Searching for existing token account...");
        const tokenAccounts = await rpcCall("getTokenAccountsByOwner", [
          walletAddress,
          { mint: poolData.poolMint },
          { encoding: "jsonParsed", commitment: "confirmed" }
        ]);
        logger$1.log("[Stake] Token accounts response:", tokenAccounts);
        if (((_a3 = tokenAccounts == null ? void 0 : tokenAccounts.value) == null ? void 0 : _a3.length) > 0) {
          userPoolTokenATA = tokenAccounts.value[0].pubkey;
          ataExists = true;
          logger$1.log("[Stake] Found existing ATA:", userPoolTokenATA);
        }
      } catch (err) {
        logger$1.log("[Stake] Error searching token accounts:", err);
      }
      if (!userPoolTokenATA) {
        logger$1.log("[Stake] No existing ATA found, deriving address...");
        logger$1.log("[Stake] Deriving ATA for mint:", poolData.poolMint, "owner:", walletAddress, "tokenProgram:", poolTokenProgram);
        userPoolTokenATA = await getAssociatedTokenAddress(poolData.poolMint, walletAddress, poolTokenProgram);
        logger$1.log("[Stake] Derived ATA:", userPoolTokenATA);
      }
      logger$1.log("[Stake] Final ATA to use:", userPoolTokenATA);
      logger$1.log("[Stake] Deriving withdraw authority...");
      const stakePoolBytes = pubkeyToBytes(STAKE_POOL_ADDRESS);
      logger$1.log("[Stake] stakePoolBytes length:", stakePoolBytes.length);
      const withdrawAuthority = await findProgramAddress(
        [stakePoolBytes, new TextEncoder().encode("withdraw")],
        STAKE_POOL_PROGRAM_ID
      );
      logger$1.log("[Stake] Withdraw authority:", withdrawAuthority.pubkey);
      logger$1.log("[Stake] Getting blockhash...");
      const blockhashResult = await rpcCall("getLatestBlockhash", [{ commitment: "confirmed" }]);
      logger$1.log("[Stake] Blockhash result:", blockhashResult);
      const blockhash = (_b3 = blockhashResult == null ? void 0 : blockhashResult.value) == null ? void 0 : _b3.blockhash;
      if (!blockhash) {
        throw new Error("Failed to get blockhash");
      }
      logger$1.log("[Stake] Blockhash:", blockhash);
      const lamports = BigInt(Math.floor(stakeAmount * LAMPORTS_PER_SOL));
      const instructionData = new Uint8Array(9);
      instructionData[0] = 14;
      const dataView = new DataView(instructionData.buffer);
      dataView.setBigUint64(1, lamports, true);
      const instruction = {
        programId: STAKE_POOL_PROGRAM_ID,
        keys: [
          { pubkey: STAKE_POOL_ADDRESS, isSigner: false, isWritable: true },
          { pubkey: withdrawAuthority.pubkey, isSigner: false, isWritable: false },
          { pubkey: poolData.reserveStake, isSigner: false, isWritable: true },
          { pubkey: walletAddress, isSigner: true, isWritable: true },
          { pubkey: userPoolTokenATA, isSigner: false, isWritable: true },
          { pubkey: poolData.managerFeeAccount, isSigner: false, isWritable: true },
          { pubkey: userPoolTokenATA, isSigner: false, isWritable: true },
          // Referral = user
          { pubkey: poolData.poolMint, isSigner: false, isWritable: true },
          { pubkey: SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
          { pubkey: poolTokenProgram, isSigner: false, isWritable: false }
        ],
        data: instructionData
      };
      logger$1.log("[Stake] ATA exists (from search):", ataExists);
      const instructions = [];
      if (!ataExists) {
        logger$1.log("[Stake] Creating ATA instruction for token program:", poolTokenProgram);
        logger$1.log("[Stake] ATA Create accounts:");
        logger$1.log("[Stake]   0. Payer:", walletAddress);
        logger$1.log("[Stake]   1. ATA:", userPoolTokenATA);
        logger$1.log("[Stake]   2. Owner:", walletAddress);
        logger$1.log("[Stake]   3. Mint:", poolData.poolMint);
        logger$1.log("[Stake]   4. System:", SYSTEM_PROGRAM_ID);
        logger$1.log("[Stake]   5. Token:", poolTokenProgram);
        const createATAInstruction = {
          programId: ASSOCIATED_TOKEN_PROGRAM_ID,
          keys: [
            { pubkey: walletAddress, isSigner: true, isWritable: true },
            // Payer
            { pubkey: userPoolTokenATA, isSigner: false, isWritable: true },
            // ATA to create
            { pubkey: walletAddress, isSigner: false, isWritable: false },
            // Wallet owner
            { pubkey: poolData.poolMint, isSigner: false, isWritable: false },
            // Mint
            { pubkey: SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
            // System program
            { pubkey: poolTokenProgram, isSigner: false, isWritable: false }
            // Token program
          ],
          data: new Uint8Array([])
          // Empty data = Create instruction
        };
        instructions.push(createATAInstruction);
        logger$1.log("[Stake] ATA instruction programId:", ASSOCIATED_TOKEN_PROGRAM_ID);
      }
      logger$1.log("[Stake] DepositSol accounts:");
      logger$1.log("[Stake]   0. Pool:", STAKE_POOL_ADDRESS);
      logger$1.log("[Stake]   1. Withdraw Auth:", withdrawAuthority.pubkey);
      logger$1.log("[Stake]   2. Reserve:", poolData.reserveStake);
      logger$1.log("[Stake]   3. Funder:", walletAddress);
      logger$1.log("[Stake]   4. User ATA:", userPoolTokenATA);
      logger$1.log("[Stake]   5. Fee Acct:", poolData.managerFeeAccount);
      logger$1.log("[Stake]   6. Referral:", userPoolTokenATA);
      logger$1.log("[Stake]   7. Mint:", poolData.poolMint);
      logger$1.log("[Stake]   8. System:", SYSTEM_PROGRAM_ID);
      logger$1.log("[Stake]   9. Token:", poolTokenProgram);
      instructions.push(instruction);
      logger$1.log("[Stake] Instructions array:", instructions);
      logger$1.log("[Stake] Instructions length:", instructions.length);
      logger$1.log("[Stake] Calling buildTransaction with:");
      logger$1.log("[Stake]   feePayer:", walletAddress);
      logger$1.log("[Stake]   blockhash:", blockhash);
      logger$1.log("[Stake]   instructions count:", instructions.length);
      const tx = await buildTransaction2({
        feePayer: walletAddress,
        recentBlockhash: blockhash,
        instructions
      });
      logger$1.log("[Stake] Transaction built, tx length:", tx == null ? void 0 : tx.length);
      let signature;
      if (isHardwareWallet) {
        logger$1.log("[Stake] Using hardware wallet for signing");
        setHwStatus("Connecting to Ledger...");
        const derivationPath = ((_c2 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _c2.derivationPath) || (wallet == null ? void 0 : wallet.derivationPath) || ((_d2 = wallet == null ? void 0 : wallet.activeWallet) == null ? void 0 : _d2.derivationPath) || "44'/501'/0'/0'";
        logger$1.log("[Stake] Using derivation path:", derivationPath);
        try {
          if (!hardwareWallet.isReady()) {
            await hardwareWallet.connect("hid");
            await hardwareWallet.openApp();
          }
          setHwStatus("Please confirm on your Ledger...");
          const unsignedTx = new Uint8Array(1 + 64 + tx.length);
          unsignedTx[0] = 1;
          unsignedTx.set(tx, 65);
          const txBase64 = btoa(String.fromCharCode(...unsignedTx));
          logger$1.log("[Stake] Transaction base64 length:", txBase64.length);
          const { signAndSendExternalTransactionHardware: signAndSendExternalTransactionHardware2 } = await __vitePreload(async () => {
            const { signAndSendExternalTransactionHardware: signAndSendExternalTransactionHardware3 } = await Promise.resolve().then(() => transaction);
            return { signAndSendExternalTransactionHardware: signAndSendExternalTransactionHardware3 };
          }, true ? void 0 : void 0);
          signature = await signAndSendExternalTransactionHardware2(
            txBase64,
            hardwareWallet,
            networkConfig.rpcUrl,
            derivationPath
          );
          setHwStatus("");
        } catch (hwErr) {
          setHwStatus("");
          logger$1.error("[Stake] Hardware wallet error:", hwErr);
          if (((_e = hwErr.message) == null ? void 0 : _e.includes("0x6a81")) || ((_f = hwErr.message) == null ? void 0 : _f.includes("Solana app"))) {
            throw new Error("Please open the Solana app on your Ledger");
          } else if (((_g = hwErr.message) == null ? void 0 : _g.includes("denied")) || ((_h = hwErr.message) == null ? void 0 : _h.includes("rejected"))) {
            throw new Error("Transaction rejected on Ledger");
          } else if (((_i = hwErr.message) == null ? void 0 : _i.includes("not connected")) || ((_j = hwErr.message) == null ? void 0 : _j.includes("Could not connect"))) {
            throw new Error("Ledger not connected. Please connect and try again.");
          }
          throw hwErr;
        }
      } else {
        const signedTx = await signTransaction2(tx, privateKey);
        logger$1.log("[Stake] Sending transaction...");
        signature = await sendTransaction2(signedTx, networkConfig.rpcUrl);
      }
      logger$1.log("[Stake] Transaction sent:", signature);
      setTxSignature(signature);
      const pXNTReceived = (poolData == null ? void 0 : poolData.exchangeRate) ? (stakeAmount / poolData.exchangeRate).toFixed(4) : stakeAmount;
      setSuccess(`Staked ${stakeAmount} XNT  Received ~${pXNTReceived} pXNT`);
      setAmount("");
      try {
        const { addTransaction: addTransaction2 } = await __vitePreload(async () => {
          const { addTransaction: addTransaction3 } = await Promise.resolve().then(() => transaction);
          return { addTransaction: addTransaction3 };
        }, true ? void 0 : void 0);
        addTransaction2({
          signature,
          type: "stake",
          amount: stakeAmount,
          symbol: "XNT",
          from: walletAddress,
          to: STAKE_POOL_ADDRESS,
          timestamp: Date.now(),
          status: "confirmed",
          network: "X1 Mainnet",
          isToken: false,
          description: `Staked ${stakeAmount} XNT  ${pXNTReceived} pXNT`
        });
      } catch (e) {
        logger$1.warn("[Stake] Failed to record transaction:", e);
      }
      try {
        const { trackStakeXP: trackStakeXP2 } = await __vitePreload(async () => {
          const { trackStakeXP: trackStakeXP3 } = await Promise.resolve().then(() => xp);
          return { trackStakeXP: trackStakeXP3 };
        }, true ? void 0 : void 0);
        trackStakeXP2({
          user: walletAddress,
          network: "X1 Mainnet",
          transactionSignature: signature,
          amount: stakeAmount,
          stakePool: STAKE_POOL_ADDRESS,
          action: "stake"
        }).catch(() => {
        });
      } catch (e) {
      }
      setTimeout(() => {
        fetchPoolInfo();
        refreshLocalBalance();
        if (onRefreshBalance) onRefreshBalance();
      }, 3e3);
    } catch (err) {
      logger$1.error("[Stake] Transaction failed:", err);
      setHwStatus("");
      throw err;
    }
  };
  const handleUnstake = async () => {
    var _a3, _b3, _c2, _d2, _e, _f, _g, _h, _i;
    logger$1.log("[Unstake] ===== handleUnstake START =====");
    logger$1.log("[Unstake] isHardwareWallet:", isHardwareWallet);
    const unstakeAmount = parseFloat(amount);
    if (!amount || unstakeAmount <= 0) {
      setError("Enter a valid amount");
      return;
    }
    if (!userStake.poolTokenAccount || userStake.poolTokenBalance <= 0) {
      setError("No staked balance to withdraw");
      return;
    }
    const poolTokensToWithdraw = unstakeAll && unstakeAllAmount > 0 ? unstakeAllAmount : unstakeAmount / ((poolInfo == null ? void 0 : poolInfo.exchangeRate) || 1);
    if (!unstakeAll && poolTokensToWithdraw > userStake.poolTokenBalance) {
      setError(`Insufficient staked balance. Max: ${(userStake.poolTokenBalance * ((poolInfo == null ? void 0 : poolInfo.exchangeRate) || 1)).toFixed(4)} XNT`);
      return;
    }
    if (!walletAddress || !poolData) {
      setError("Wallet or pool data not loaded");
      return;
    }
    if (!isHardwareWallet && !privateKey) {
      setError("Wallet not available");
      return;
    }
    setTxSignature("");
    setHwStatus("");
    try {
      logger$1.log("[Unstake] Withdrawing", unstakeAmount, "XNT (~", poolTokensToWithdraw, "pool tokens)");
      const { buildTransaction: buildTransaction2, signTransaction: signTransaction2, sendTransaction: sendTransaction2 } = await __vitePreload(async () => {
        const { buildTransaction: buildTransaction3, signTransaction: signTransaction3, sendTransaction: sendTransaction3 } = await Promise.resolve().then(() => transaction);
        return { buildTransaction: buildTransaction3, signTransaction: signTransaction3, sendTransaction: sendTransaction3 };
      }, true ? void 0 : void 0);
      const withdrawAuthority = await findProgramAddress(
        [pubkeyToBytes(STAKE_POOL_ADDRESS), new TextEncoder().encode("withdraw")],
        STAKE_POOL_PROGRAM_ID
      );
      logger$1.log("[Unstake] Withdraw authority:", withdrawAuthority.pubkey);
      const blockhashResult = await rpcCall("getLatestBlockhash", [{ commitment: "confirmed" }]);
      const blockhash = (_a3 = blockhashResult == null ? void 0 : blockhashResult.value) == null ? void 0 : _a3.blockhash;
      if (!blockhash) throw new Error("Failed to get blockhash");
      const poolTokenProgram = poolData.tokenProgramId;
      const poolTokensLamports = BigInt(Math.floor(poolTokensToWithdraw * LAMPORTS_PER_SOL));
      const instructionData = new Uint8Array(9);
      instructionData[0] = 16;
      const dataView = new DataView(instructionData.buffer);
      dataView.setBigUint64(1, poolTokensLamports, true);
      const withdrawSolInstruction = {
        programId: STAKE_POOL_PROGRAM_ID,
        keys: [
          { pubkey: STAKE_POOL_ADDRESS, isSigner: false, isWritable: true },
          { pubkey: withdrawAuthority.pubkey, isSigner: false, isWritable: false },
          { pubkey: walletAddress, isSigner: true, isWritable: false },
          { pubkey: userStake.poolTokenAccount, isSigner: false, isWritable: true },
          { pubkey: poolData.reserveStake, isSigner: false, isWritable: true },
          { pubkey: walletAddress, isSigner: false, isWritable: true },
          { pubkey: poolData.managerFeeAccount, isSigner: false, isWritable: true },
          { pubkey: poolData.poolMint, isSigner: false, isWritable: true },
          { pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
          { pubkey: SYSVAR_STAKE_HISTORY_PUBKEY, isSigner: false, isWritable: false },
          { pubkey: STAKE_PROGRAM_ID, isSigner: false, isWritable: false },
          { pubkey: poolTokenProgram, isSigner: false, isWritable: false }
        ],
        data: instructionData
      };
      logger$1.log("[Unstake] Building transaction...");
      const tx = await buildTransaction2({
        feePayer: walletAddress,
        recentBlockhash: blockhash,
        instructions: [withdrawSolInstruction]
      });
      let signature;
      if (isHardwareWallet) {
        logger$1.log("[Unstake] Using hardware wallet for signing");
        setHwStatus("Connecting to Ledger...");
        const derivationPath = ((_b3 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _b3.derivationPath) || (wallet == null ? void 0 : wallet.derivationPath) || ((_c2 = wallet == null ? void 0 : wallet.activeWallet) == null ? void 0 : _c2.derivationPath) || "44'/501'/0'/0'";
        logger$1.log("[Unstake] Using derivation path:", derivationPath);
        try {
          if (!hardwareWallet.isReady()) {
            await hardwareWallet.connect("hid");
            await hardwareWallet.openApp();
          }
          setHwStatus("Please confirm on your Ledger...");
          const unsignedTx = new Uint8Array(1 + 64 + tx.length);
          unsignedTx[0] = 1;
          unsignedTx.set(tx, 65);
          const txBase64 = btoa(String.fromCharCode(...unsignedTx));
          logger$1.log("[Unstake] Transaction base64 length:", txBase64.length);
          const { signAndSendExternalTransactionHardware: signAndSendExternalTransactionHardware2 } = await __vitePreload(async () => {
            const { signAndSendExternalTransactionHardware: signAndSendExternalTransactionHardware3 } = await Promise.resolve().then(() => transaction);
            return { signAndSendExternalTransactionHardware: signAndSendExternalTransactionHardware3 };
          }, true ? void 0 : void 0);
          signature = await signAndSendExternalTransactionHardware2(
            txBase64,
            hardwareWallet,
            networkConfig.rpcUrl,
            derivationPath
          );
          setHwStatus("");
        } catch (hwErr) {
          setHwStatus("");
          logger$1.error("[Unstake] Hardware wallet error:", hwErr);
          if (((_d2 = hwErr.message) == null ? void 0 : _d2.includes("0x6a81")) || ((_e = hwErr.message) == null ? void 0 : _e.includes("Solana app"))) {
            throw new Error("Please open the Solana app on your Ledger");
          } else if (((_f = hwErr.message) == null ? void 0 : _f.includes("denied")) || ((_g = hwErr.message) == null ? void 0 : _g.includes("rejected"))) {
            throw new Error("Transaction rejected on Ledger");
          } else if (((_h = hwErr.message) == null ? void 0 : _h.includes("not connected")) || ((_i = hwErr.message) == null ? void 0 : _i.includes("Could not connect"))) {
            throw new Error("Ledger not connected. Please connect and try again.");
          }
          throw hwErr;
        }
      } else {
        const signedTx = await signTransaction2(tx, privateKey);
        logger$1.log("[Unstake] Sending transaction...");
        signature = await sendTransaction2(signedTx, networkConfig.rpcUrl);
      }
      logger$1.log("[Unstake] Transaction sent:", signature);
      setTxSignature(signature);
      const pXNTBurned = (poolData == null ? void 0 : poolData.exchangeRate) ? (unstakeAmount / poolData.exchangeRate).toFixed(4) : unstakeAmount;
      setSuccess(`Unstaked ${unstakeAmount} XNT  Burned ~${pXNTBurned} pXNT`);
      setAmount("");
      try {
        const { addTransaction: addTransaction2 } = await __vitePreload(async () => {
          const { addTransaction: addTransaction3 } = await Promise.resolve().then(() => transaction);
          return { addTransaction: addTransaction3 };
        }, true ? void 0 : void 0);
        addTransaction2({
          signature,
          type: "unstake",
          amount: unstakeAmount,
          symbol: "XNT",
          from: STAKE_POOL_ADDRESS,
          to: walletAddress,
          timestamp: Date.now(),
          status: "confirmed",
          network: "X1 Mainnet",
          isToken: false,
          description: `Unstaked ${unstakeAmount} XNT  ${pXNTBurned} pXNT`
        });
      } catch (e) {
        logger$1.warn("[Unstake] Failed to record transaction:", e);
      }
      try {
        const { trackStakeXP: trackStakeXP2 } = await __vitePreload(async () => {
          const { trackStakeXP: trackStakeXP3 } = await Promise.resolve().then(() => xp);
          return { trackStakeXP: trackStakeXP3 };
        }, true ? void 0 : void 0);
        trackStakeXP2({
          user: walletAddress,
          network: "X1 Mainnet",
          transactionSignature: signature,
          amount: unstakeAmount,
          stakePool: STAKE_POOL_ADDRESS,
          action: "unstake"
        }).catch(() => {
        });
      } catch (e) {
      }
      setTimeout(() => {
        fetchPoolInfo();
        refreshLocalBalance();
        if (onRefreshBalance) onRefreshBalance();
      }, 3e3);
    } catch (err) {
      logger$1.error("[Unstake] Transaction failed:", err);
      setHwStatus("");
      throw err;
    }
  };
  const formatNum = (num, dec = 4) => {
    if (num === null || num === void 0 || isNaN(num)) return "0.00";
    const decimals = Math.max(0, Math.min(20, Math.floor(dec) || 2));
    return parseFloat(num).toLocaleString(void 0, {
      minimumFractionDigits: 2,
      maximumFractionDigits: decimals
    });
  };
  if (!isX1Mainnet) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen stake-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: onBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "Stake XNT" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen-content", style: { display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", padding: 40 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: 64, height: 64, borderRadius: "50%", background: "var(--bg-tertiary)", display: "flex", alignItems: "center", justifyContent: "center", marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "28", height: "28", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 8v4M12 16h.01" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { margin: "0 0 8px", fontSize: 16, color: "var(--text-primary)" }, children: "Staking Unavailable" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "var(--text-muted)", fontSize: 13, textAlign: "center", margin: "0 0 24px" }, children: "Staking is only available on X1 Mainnet." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn-primary",
            onClick: () => onBack && onBack("network"),
            style: { width: "auto", padding: "12px 32px" },
            children: "Switch to X1 Mainnet"
          }
        )
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen stake-screen", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: onBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "Stake XNT" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-right", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "header-btn",
          onClick: () => fetchPoolInfo(),
          disabled: poolLoading,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", style: { animation: poolLoading ? "spin 1s linear infinite" : "none" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M23 4v6h-6M1 20v-6h6" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15" })
          ] })
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "screen-content stake-simple-content", children: poolLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", alignItems: "center", padding: "60px 20px" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner", style: { marginBottom: 16 } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "var(--text-muted)", fontSize: 13 }, children: "Loading stake pool..." })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-step-content send-amount-step", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stake-balance-display", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stake-balance-label", children: "Your Staked Balance" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stake-balance-value", children: [
          formatNum(userStake.poolTokenBalance * ((poolInfo == null ? void 0 : poolInfo.exchangeRate) || 1), 4),
          " XNT"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "stake-balance-sub", children: [
          formatNum(userStake.poolTokenBalance || 0, 2),
          " pXNT"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-amount-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            inputMode: "decimal",
            className: "send-amount-input",
            placeholder: "0",
            value: amount,
            onChange: (e) => {
              setAmount(e.target.value.replace(/[^0-9.]/g, ""));
              setUnstakeAll(false);
              setUnstakeAllAmount(0);
            },
            disabled: loading
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-amount-token", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(X1Logo, { size: 24 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "XNT" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: "send-max-pill",
          onClick: () => {
            const max = Math.max(0, balance - 0.01);
            setAmount(max > 0 ? max.toFixed(6) : "");
            setUnstakeAll(false);
            setUnstakeAllAmount(0);
          },
          type: "button",
          children: [
            "Max: ",
            formatNum(balance),
            " XNT"
          ]
        }
      ),
      hwStatus && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hw-status", style: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        gap: 8,
        padding: "12px 16px",
        background: "var(--bg-tertiary)",
        borderRadius: 8,
        marginBottom: 12,
        color: "var(--x1-blue)"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner-small" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: hwStatus })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-confirm-actions stake-actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn-primary send-deny-btn",
            onClick: async () => {
              if (!amount || parseFloat(amount) <= 0) {
                setError("Enter an amount");
                return;
              }
              const decimals = (networkConfig == null ? void 0 : networkConfig.decimals) || 9;
              const multiplier = Math.pow(10, decimals);
              const requiredAmount = Math.round(parseFloat(amount) * multiplier);
              const availableAmount = Math.round(balance * multiplier);
              if (requiredAmount > availableAmount) {
                setError(`Insufficient balance. Required: ${amount} XNT, Available: ${balance} XNT`);
                return;
              }
              setLoading(true);
              setLoadingAction("stake");
              setError("");
              setSuccess("");
              try {
                await handleStake();
              } catch (err) {
                setError(err.message || "Staking failed");
              } finally {
                setLoading(false);
                setLoadingAction("");
              }
            },
            disabled: loading || !amount || parseFloat(amount) <= 0,
            children: loadingAction === "stake" ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "btn-loading", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "spinner-small" }) }) : "Stake"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn-secondary send-approve-btn",
            onClick: async () => {
              if (!amount || parseFloat(amount) <= 0) {
                setError("Enter an amount");
                return;
              }
              const maxXntValue = userStake.poolTokenBalance * ((poolInfo == null ? void 0 : poolInfo.exchangeRate) || 1);
              if (parseFloat(amount) > maxXntValue) {
                setError("Exceeds staked amount");
                return;
              }
              setLoading(true);
              setLoadingAction("unstake");
              setError("");
              setSuccess("");
              try {
                await handleUnstake();
              } catch (err) {
                setError(err.message || "Unstaking failed");
              } finally {
                setLoading(false);
                setLoadingAction("");
              }
            },
            disabled: loading || !amount || parseFloat(amount) <= 0 || userStake.poolTokenBalance <= 0,
            children: loadingAction === "unstake" ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "btn-loading", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "spinner-small" }) }) : "Unstake"
          }
        )
      ] }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: error }),
      success && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stake-success", children: [
        success,
        txSignature && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            href: getTxExplorerUrl(wallet.network, txSignature),
            target: "_blank",
            rel: "noopener noreferrer",
            className: "tx-link",
            children: "View Transaction "
          }
        )
      ] })
    ] }) })
  ] });
}
const JUPITER_PRICE_API = "https://price.jup.ag/v6/price";
const COINGECKO_API = "https://api.coingecko.com/api/v3/simple/price";
const XDEX_API = "https://api.xdex.xyz/api/xendex";
const XNT_PEGGED_PRICE = 1;
const getXNTPrice = () => {
  return XNT_PEGGED_PRICE;
};
function TokenDetail({
  token,
  wallet,
  onBack,
  onSend,
  onReceive,
  onSwap,
  onBridge,
  onStake
}) {
  const [currentPrice, setCurrentPrice] = reactExports.useState(null);
  const [priceChange24h, setPriceChange24h] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [mintCopied, setMintCopied] = reactExports.useState(false);
  const network = (wallet == null ? void 0 : wallet.network) || "X1 Mainnet";
  const networkConfig = NETWORKS[network] || {
    symbol: "XNT",
    explorer: "https://explorer.x1.xyz"
  };
  const isNative = !(token == null ? void 0 : token.mint);
  const isX1Network2 = network.includes("X1");
  const isSolana = network.includes("Solana");
  const symbol = (token == null ? void 0 : token.symbol) || networkConfig.symbol;
  const name = (token == null ? void 0 : token.name) || (isSolana ? "Solana" : "X1 Native Token");
  const balance = parseFloat((token == null ? void 0 : token.balance) || (token == null ? void 0 : token.uiAmount) || 0);
  const logoURI = token == null ? void 0 : token.logoURI;
  const mint = token == null ? void 0 : token.mint;
  reactExports.useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        if (isSolana) {
          await fetchSolanaPrice();
        } else if (isX1Network2) {
          await fetchX1Price();
        }
      } catch (err) {
        logger$1.error("[TokenDetail] Failed to fetch data:", err);
      }
      setLoading(false);
    };
    fetchData();
  }, [mint, symbol, network, token == null ? void 0 : token.price]);
  const fetchSolanaPrice = async () => {
    const tokenAddress = mint || "So11111111111111111111111111111111111111112";
    const isNativeSOL = !mint || tokenAddress === "So11111111111111111111111111111111111111112";
    let price = null;
    if ((token == null ? void 0 : token.price) !== void 0 && (token == null ? void 0 : token.price) !== null && !isNaN(token.price)) {
      price = parseFloat(token.price);
      logger$1.log("[TokenDetail] Using existing token.price for Solana:", price, "for", symbol);
    }
    if (!price) {
      try {
        const response = await fetch(`${JUPITER_PRICE_API}?ids=${tokenAddress}`);
        if (response.ok) {
          const data = await response.json();
          logger$1.log("[TokenDetail] Jupiter response:", data);
          if (data.data && data.data[tokenAddress]) {
            price = data.data[tokenAddress].price;
          }
        }
      } catch (e) {
        logger$1.warn("[TokenDetail] Jupiter fetch failed:", e.message);
      }
    }
    if (!price && isNativeSOL) {
      try {
        const response = await fetch(`${COINGECKO_API}?ids=solana&vs_currencies=usd&include_24hr_change=true`);
        if (response.ok) {
          const data = await response.json();
          logger$1.log("[TokenDetail] CoinGecko response:", data);
          if (data.solana && data.solana.usd) {
            price = data.solana.usd;
            if (data.solana.usd_24h_change) {
              setPriceChange24h(data.solana.usd_24h_change);
            }
          }
        }
      } catch (e) {
        logger$1.warn("[TokenDetail] CoinGecko fetch failed:", e.message);
      }
    }
    if (!price && isNativeSOL) {
      logger$1.warn("[TokenDetail] Using fallback SOL price");
      price = await getFallbackSolPrice();
    }
    if (price && price > 0) {
      setCurrentPrice(price);
      if (priceChange24h === null) {
        setPriceChange24h(0);
      }
    } else {
      logger$1.warn("[TokenDetail] No price data available for Solana token");
      setCurrentPrice(null);
    }
  };
  const getFallbackSolPrice = async () => {
    try {
      const response = await fetch("https://api.binance.com/api/v3/ticker/price?symbol=SOLUSDT");
      if (response.ok) {
        const data = await response.json();
        if (data.price) {
          return parseFloat(data.price);
        }
      }
    } catch (e) {
      logger$1.warn("[TokenDetail] Binance fallback failed");
    }
    return null;
  };
  const fetchX1Price = async () => {
    var _a2;
    try {
      let price = null;
      if ((token == null ? void 0 : token.price) !== void 0 && (token == null ? void 0 : token.price) !== null && !isNaN(token.price)) {
        price = parseFloat(token.price);
        logger$1.log("[TokenDetail] Using existing token.price:", price, "for", symbol);
      } else if (isNative) {
        price = getXNTPrice();
      } else if (symbol === "USDC.X" || symbol === "USDC" || symbol === "USDT") {
        price = 1;
      } else if (symbol === "pXNT") {
        price = getXNTPrice();
      } else if (symbol === "WXNT") {
        price = getXNTPrice();
      } else if (mint) {
        try {
          const tokenResponse = await fetch(`${XDEX_API}/tokens/${mint}`, {
            signal: AbortSignal.timeout(3e3)
          });
          if (tokenResponse.ok) {
            const tokenData = await tokenResponse.json();
            logger$1.log("[TokenDetail] XDEX token data for", symbol, ":", tokenData);
            const tokenPrice = tokenData.price ?? tokenData.priceUsd ?? tokenData.price_usd;
            if (tokenPrice !== void 0 && tokenPrice !== null) {
              price = parseFloat(tokenPrice);
              logger$1.log("[TokenDetail] Got price from XDEX token endpoint:", price);
            }
          }
        } catch (e) {
          logger$1.log("[TokenDetail] XDEX token endpoint failed:", e.message);
        }
        if (!price) {
          try {
            const response = await fetch(`${XDEX_API}/pools`, {
              signal: AbortSignal.timeout(3e3)
            });
            if (response.ok) {
              const pools = await response.json();
              logger$1.log("[TokenDetail] XDEX pools:", (pools == null ? void 0 : pools.length) || 0);
              const tokenPool = pools.find(
                (p2) => {
                  var _a3, _b2;
                  return ((_a3 = p2.tokenA) == null ? void 0 : _a3.mint) === mint || ((_b2 = p2.tokenB) == null ? void 0 : _b2.mint) === mint;
                }
              );
              if (tokenPool) {
                const isTokenA = ((_a2 = tokenPool.tokenA) == null ? void 0 : _a2.mint) === mint;
                const reserveToken = parseFloat(isTokenA ? tokenPool.reserveA : tokenPool.reserveB) || 0;
                const reserveOther = parseFloat(isTokenA ? tokenPool.reserveB : tokenPool.reserveA) || 0;
                if (reserveToken > 0 && reserveOther > 0) {
                  price = reserveOther / reserveToken;
                }
              }
            }
          } catch (e) {
            logger$1.log("[TokenDetail] XDEX pools endpoint failed:", e.message);
          }
        }
      }
      if (price && price > 0) {
        setCurrentPrice(price);
        setPriceChange24h(0);
      } else {
        setCurrentPrice(null);
      }
    } catch (e) {
      logger$1.error("[TokenDetail] X1 price fetch error:", e);
      setCurrentPrice(null);
    }
  };
  const renderPriceDisplay = () => {
    if (loading) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-price-display", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner-small" }) });
    }
    if (!currentPrice) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-price-display", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-price-unavailable", children: "Price unavailable" }) });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-price-display", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-price-label", children: "Current Price" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-current-price", children: formatUsd(currentPrice) }),
      priceChange24h !== null && priceChange24h !== 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `token-price-change ${priceChange24h >= 0 ? "positive" : "negative"}`, children: [
        priceChange24h >= 0 ? "+" : "",
        priceChange24h.toFixed(2),
        "%"
      ] })
    ] });
  };
  const formatUsd = (value) => {
    if (value === null || value === void 0 || isNaN(value)) return "--";
    if (value < 1e-4) return `$${value.toFixed(8)}`;
    if (value < 0.01) return `$${value.toFixed(6)}`;
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD",
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(value);
  };
  const formatBalance2 = (value) => {
    if (!value || isNaN(value)) return "0";
    return value.toLocaleString(void 0, { maximumFractionDigits: 6 });
  };
  const usdValue = currentPrice ? balance * currentPrice : null;
  const openExplorer = () => {
    if (mint) {
      const baseUrl = networkConfig.explorer || "https://explorer.x1.xyz";
      const addressPath = baseUrl.includes("solscan") ? "/token/" : "/address/";
      window.open(`${baseUrl}${addressPath}${mint}`, "_blank");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen token-detail-screen", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "page-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "back-btn", onClick: onBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 12H5M12 19l-7-7 7-7" }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-detail-header-title", children: [
        isNative ? isSolana ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "/icons/48-sol.png", alt: "SOL", className: "token-detail-header-icon" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(X1Logo, { size: 24 }) : logoURI ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: logoURI, alt: symbol, className: "token-detail-header-icon" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-detail-header-initial", children: symbol == null ? void 0 : symbol.charAt(0) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-detail-symbol", children: symbol })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-right" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-detail-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-price-section", children: renderPriceDisplay() }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-detail-actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "token-action-btn", onClick: onReceive, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-action-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 5v14M5 12l7 7 7-7" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Receive" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "token-action-btn", onClick: () => onSend(token), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-action-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 19V5M5 12l7-7 7 7" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Send" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "token-action-btn", onClick: () => onSwap(token), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-action-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17 2l4 4-4 4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3 11V9a4 4 0 0 1 4-4h14" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 22l-4-4 4-4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 13v2a4 4 0 0 1-4 4H3" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Swap" })
        ] }),
        isSolana && onBridge && /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "token-action-btn", onClick: onBridge, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-action-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "4", y1: "22", x2: "4", y2: "15" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Bridge" })
        ] }),
        isX1Network2 && isNative && onStake && /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "token-action-btn", onClick: onStake, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-action-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2L2 7l10 5 10-5-10-5z" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2 17l10 5 10-5" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2 12l10 5 10-5" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Stake" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-detail-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-section-header", children: "Your Balance" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-balance-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-balance-left", children: [
            isNative ? isSolana ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "/icons/48-sol.png", alt: "SOL", className: "token-balance-icon" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(X1Logo, { size: 40 }) : logoURI ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: logoURI, alt: symbol, className: "token-balance-icon" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-balance-initial", children: symbol == null ? void 0 : symbol.charAt(0) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-balance-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-balance-name", children: name }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "token-balance-amount", children: [
                formatBalance2(balance),
                " ",
                symbol
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-balance-right", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-balance-usd", children: formatUsd(usdValue) }),
            priceChange24h !== null && priceChange24h !== 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `token-balance-change ${priceChange24h >= 0 ? "positive" : "negative"}`, children: [
              priceChange24h >= 0 ? "+" : "",
              priceChange24h.toFixed(2),
              "%"
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-detail-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "token-section-header", children: "Market & Additional Info" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-info-card", children: [
          mint && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-info-row", onClick: openExplorer, style: { cursor: "pointer" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-info-label", children: "Token" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "token-info-value token-info-link", children: [
              name,
              " (",
              symbol,
              ")",
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 17L17 7M17 7H7M17 7v10" }) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-info-row", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-info-label", children: "Price" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-info-value", children: loading ? "Loading..." : formatUsd(currentPrice) })
          ] }),
          priceChange24h !== null && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "token-info-row", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-info-label", children: "24h Change" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `token-info-value ${priceChange24h >= 0 ? "positive" : "negative"}`, children: [
              priceChange24h >= 0 ? "+" : "",
              priceChange24h.toFixed(2),
              "%"
            ] })
          ] }),
          mint && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "token-info-row",
              onClick: () => {
                navigator.clipboard.writeText(mint);
                setMintCopied(true);
                setTimeout(() => setMintCopied(false), 2e3);
              },
              style: { cursor: "pointer" },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "token-info-label", children: "Mint" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "token-info-value token-info-address", style: { display: "flex", alignItems: "center", gap: 6 }, children: [
                  mint.slice(0, 8),
                  "...",
                  mint.slice(-8),
                  mintCopied ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "var(--success)", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1" })
                  ] })
                ] })
              ]
            }
          )
        ] })
      ] })
    ] })
  ] });
}
function getPriorityOptions(network) {
  const isX1 = network == null ? void 0 : network.includes("X1");
  if (isX1) {
    return [
      { id: "auto", name: "Auto", fee: 0, description: "Standard speed" },
      { id: "fast", name: "Fast", fee: 1e-3, description: "Higher priority" },
      { id: "turbo", name: "Turbo", fee: 5e-3, description: "Very high priority" },
      { id: "degen", name: "Degen", fee: 0.01, description: "Maximum priority" },
      { id: "custom", name: "Custom", fee: 0, description: "Set your own fee" }
    ];
  }
  return [
    { id: "auto", name: "Auto", fee: 0, description: "Standard speed" },
    { id: "fast", name: "Fast", fee: 5e-6, description: "Higher priority" },
    { id: "turbo", name: "Turbo", fee: 5e-5, description: "Very high priority" },
    { id: "degen", name: "Degen", fee: 1e-3, description: "Maximum priority" },
    { id: "custom", name: "Custom", fee: 0, description: "Set your own fee" }
  ];
}
function getBaseFee(network) {
  const isX1 = network == null ? void 0 : network.includes("X1");
  return isX1 ? 2e-3 : 5e-6;
}
const KNOWN_PROGRAMS = {
  "11111111111111111111111111111111": { name: "System Program", safe: true },
  "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA": { name: "Token Program", safe: true },
  "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb": { name: "Token-2022 Program", safe: true },
  "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL": { name: "Associated Token Program", safe: true },
  "ComputeBudget111111111111111111111111111111": { name: "Compute Budget", safe: true },
  "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr": { name: "Memo Program", safe: true },
  "Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo": { name: "Memo Program v1", safe: true },
  // Wrapped SOL mint (used in XNT wrapping/unwrapping)
  "So11111111111111111111111111111111111111112": { name: "Wrapped SOL/XNT", safe: true }
};
const TRUSTED_DAPP_ORIGINS = [
  "x1.xyz",
  // Matches all *.x1.xyz
  "xdex.xyz"
  // Matches all *.xdex.xyz
];
const SYSTEM_INSTRUCTIONS = {
  0: "Create Account",
  1: "Assign",
  2: "Transfer",
  3: "Create Account with Seed",
  4: "Advance Nonce",
  5: "Withdraw Nonce",
  6: "Initialize Nonce",
  7: "Authorize Nonce",
  8: "Allocate",
  9: "Allocate with Seed",
  10: "Assign with Seed",
  11: "Transfer with Seed",
  12: "Upgrade Nonceless Account"
};
const TOKEN_INSTRUCTIONS = {
  0: "Initialize Mint",
  1: "Initialize Account",
  2: "Initialize Multisig",
  3: "Transfer",
  4: "Approve",
  5: "Revoke",
  6: "Set Authority",
  7: "Mint To",
  8: "Burn",
  9: "Close Account",
  10: "Freeze Account",
  11: "Thaw Account",
  12: "Transfer Checked",
  13: "Approve Checked",
  14: "Mint To Checked",
  15: "Burn Checked",
  16: "Initialize Account 2",
  17: "Sync Native",
  18: "Initialize Account 3"
};
const COMPUTE_BUDGET_INSTRUCTIONS = {
  0: "Request Heap Frame",
  1: "Set Compute Unit Limit",
  // Legacy
  2: "Set Compute Unit Limit",
  3: "Set Compute Unit Price"
};
function readCompactU16(buffer2, offset) {
  let value = 0;
  let shift = 0;
  let bytesRead = 0;
  while (offset + bytesRead < buffer2.length) {
    const byte = buffer2[offset + bytesRead];
    bytesRead++;
    value |= (byte & 127) << shift;
    if ((byte & 128) === 0) {
      break;
    }
    shift += 7;
    if (bytesRead > 3) break;
  }
  return { value, bytesRead };
}
function isVersionedTransaction(txBytes, messageStart) {
  const firstMessageByte = txBytes[messageStart];
  return (firstMessageByte & 128) !== 0;
}
function decodeTransaction(txBytes) {
  try {
    const sigCountResult = readCompactU16(txBytes, 0);
    const numSignatures = sigCountResult.value;
    const messageStart = sigCountResult.bytesRead + numSignatures * 64;
    if (messageStart >= txBytes.length) {
      return { success: false, error: "Invalid transaction: message start beyond buffer", raw: true };
    }
    const message = txBytes.slice(messageStart);
    const isVersioned = isVersionedTransaction(txBytes, messageStart);
    let accountKeys = [];
    let instructions = [];
    let offset = 0;
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;
    let hasAddressLookupTables = false;
    if (isVersioned) {
      const version = message[0] & 127;
      offset = 1;
      if (version !== 0) {
        return {
          success: true,
          isVersioned: true,
          version,
          instructions: [{ programName: `Versioned Transaction (V${version})`, isKnownSafe: true }],
          hasUnknownPrograms: false,
          note: `Transaction version ${version} - details not fully decoded`
        };
      }
      numRequiredSignatures = message[offset];
      numReadonlySignedAccounts = message[offset + 1];
      numReadonlyUnsignedAccounts = message[offset + 2];
      offset += 3;
      const staticKeysResult = readCompactU16(message, offset);
      const numStaticKeys = staticKeysResult.value;
      offset += staticKeysResult.bytesRead;
      for (let i = 0; i < numStaticKeys && offset + 32 <= message.length; i++) {
        const key = message.slice(offset, offset + 32);
        accountKeys.push(encode(key));
        offset += 32;
      }
      offset += 32;
      const numInstructionsResult = readCompactU16(message, offset);
      const numInstructions = numInstructionsResult.value;
      offset += numInstructionsResult.bytesRead;
      for (let i = 0; i < numInstructions && offset < message.length; i++) {
        const programIdIndex = message[offset];
        offset += 1;
        const numAccountsResult = readCompactU16(message, offset);
        const numAccounts = numAccountsResult.value;
        offset += numAccountsResult.bytesRead;
        const accountIndices = [];
        for (let j = 0; j < numAccounts && offset < message.length; j++) {
          accountIndices.push(message[offset]);
          offset += 1;
        }
        const dataLenResult = readCompactU16(message, offset);
        const dataLen = dataLenResult.value;
        offset += dataLenResult.bytesRead;
        const data = message.slice(offset, offset + dataLen);
        offset += dataLen;
        const programId = programIdIndex < accountKeys.length ? accountKeys[programIdIndex] : null;
        const instruction = decodeInstruction(programId, accountIndices, data, accountKeys);
        instructions.push(instruction);
      }
      if (offset < message.length) {
        const numALTsResult = readCompactU16(message, offset);
        hasAddressLookupTables = numALTsResult.value > 0;
      }
    } else {
      numRequiredSignatures = message[0];
      numReadonlySignedAccounts = message[1];
      numReadonlyUnsignedAccounts = message[2];
      const numAccountsResult = readCompactU16(message, 3);
      const numAccounts = numAccountsResult.value;
      offset = 3 + numAccountsResult.bytesRead;
      for (let i = 0; i < numAccounts && offset + 32 <= message.length; i++) {
        const key = message.slice(offset, offset + 32);
        accountKeys.push(encode(key));
        offset += 32;
      }
      offset += 32;
      const numInstructionsResult = readCompactU16(message, offset);
      const numInstructions = numInstructionsResult.value;
      offset += numInstructionsResult.bytesRead;
      for (let i = 0; i < numInstructions && offset < message.length; i++) {
        const programIdIndex = message[offset];
        offset += 1;
        const numAccountsResult2 = readCompactU16(message, offset);
        const numAccountIndices = numAccountsResult2.value;
        offset += numAccountsResult2.bytesRead;
        const accountIndices = [];
        for (let j = 0; j < numAccountIndices && offset < message.length; j++) {
          accountIndices.push(message[offset]);
          offset += 1;
        }
        const dataLenResult = readCompactU16(message, offset);
        const dataLen = dataLenResult.value;
        offset += dataLenResult.bytesRead;
        const data = message.slice(offset, offset + dataLen);
        offset += dataLen;
        const programId = programIdIndex < accountKeys.length ? accountKeys[programIdIndex] : null;
        const instruction = decodeInstruction(programId, accountIndices, data, accountKeys);
        instructions.push(instruction);
      }
    }
    return {
      success: true,
      isVersioned,
      numSignatures,
      numAccounts: accountKeys.length,
      accounts: accountKeys,
      instructions,
      hasUnknownPrograms: instructions.some((i) => !i.isKnownSafe),
      hasAddressLookupTables,
      estimatedFee: null
      // Will be calculated in display using getBaseFee(network) * numSignatures
    };
  } catch (e) {
    logger$1.error("[decodeTransaction] Error:", e);
    return {
      success: false,
      error: "Could not decode transaction",
      raw: true
    };
  }
}
function isSystemProgram(programId) {
  if (!programId) return false;
  if (programId === "11111111111111111111111111111111") return true;
  if (/^1+$/.test(programId) && programId.length >= 30 && programId.length <= 44) return true;
  return false;
}
function decodeInstruction(programId, accountIndices, data, accountKeys) {
  if (!programId) {
    return {
      programId: "Lookup Table Reference",
      programName: "External Program (via Lookup Table)",
      isKnownSafe: true,
      // Don't warn for lookup table references in standard ops
      accounts: accountIndices.map((idx) => accountKeys[idx] || `Index ${idx}`),
      data,
      note: "Program resolved via Address Lookup Table"
    };
  }
  const isSysProgram = isSystemProgram(programId);
  const programInfo = isSysProgram ? { name: "System Program", safe: true } : KNOWN_PROGRAMS[programId];
  const instruction = {
    programId,
    programName: (programInfo == null ? void 0 : programInfo.name) || "Unknown Program",
    isKnownSafe: (programInfo == null ? void 0 : programInfo.safe) || false,
    accounts: accountIndices.map((idx) => accountKeys[idx] || `Index ${idx}`),
    data
  };
  if (isSysProgram && data.length >= 4) {
    const instructionType = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;
    instruction.instructionType = SYSTEM_INSTRUCTIONS[instructionType] || `System Instruction ${instructionType}`;
    if (instructionType === 2 && data.length >= 12) {
      try {
        const lamports = new DataView(data.buffer, data.byteOffset + 4, 8).getBigUint64(0, true);
        instruction.amount = Number(lamports) / 1e9;
        instruction.recipient = instruction.accounts[1];
      } catch (e) {
      }
    }
  }
  if ((programId === "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" || programId === "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb") && data.length >= 1) {
    const instructionType = data[0];
    instruction.instructionType = TOKEN_INSTRUCTIONS[instructionType] || `Token Instruction ${instructionType}`;
    if ((instructionType === 3 || instructionType === 12) && data.length >= 9) {
      try {
        const amount = new DataView(data.buffer, data.byteOffset + 1, 8).getBigUint64(0, true);
        instruction.tokenAmount = amount.toString();
      } catch (e) {
      }
    }
  }
  if (programId === "ComputeBudget111111111111111111111111111111" && data.length >= 1) {
    const instructionType = data[0];
    instruction.instructionType = COMPUTE_BUDGET_INSTRUCTIONS[instructionType] || `Compute Budget ${instructionType}`;
  }
  if (programId === "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL") {
    instruction.instructionType = "Create Associated Token Account";
  }
  return instruction;
}
function DAppApproval({ wallet, onComplete }) {
  var _a2, _b2, _c, _d, _e, _f, _g, _h;
  const [pendingRequest, setPendingRequest] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [processing, setProcessing] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(null);
  const [currentNetwork2, setCurrentNetwork] = reactExports.useState(wallet.network || "X1 Mainnet");
  const [decodedTx, setDecodedTx] = reactExports.useState(null);
  const [priority, setPriority] = reactExports.useState("auto");
  const [customFee, setCustomFee] = reactExports.useState("");
  const [hwStatus, setHwStatus] = reactExports.useState("");
  const [ledgerPopupError, setLedgerPopupError] = reactExports.useState(false);
  const signingInProgress = reactExports.useRef(false);
  const lastSignAttempt = reactExports.useRef(0);
  reactExports.useEffect(() => {
    const loadNetwork = async () => {
      try {
        const result = await chrome.storage.local.get("x1wallet_network");
        if (result.x1wallet_network) {
          setCurrentNetwork(result.x1wallet_network);
        } else {
          const localNetwork = localStorage.getItem("x1wallet_network");
          setCurrentNetwork(localNetwork || "X1 Mainnet");
        }
      } catch (e) {
        logger$1.warn("[DAppApproval] Error loading network:", e);
      }
    };
    loadNetwork();
  }, []);
  reactExports.useEffect(() => {
    const checkPendingRequest = async () => {
      try {
        const response = await chrome.runtime.sendMessage({ type: "get-pending-request" });
        const request = (response == null ? void 0 : response.request) || response;
        logger$1.log("[DAppApproval] Pending request type:", request == null ? void 0 : request.type);
        if (request && request.type) {
          setPendingRequest(request);
          if (request.transaction) {
            try {
              const txBytes = Uint8Array.from(atob(request.transaction), (c) => c.charCodeAt(0));
              const decoded = decodeTransaction(txBytes);
              setDecodedTx(decoded);
              logger$1.log("[DAppApproval] Decoded transaction:", decoded);
            } catch (e) {
              logger$1.error("[DAppApproval] Failed to decode transaction");
              setDecodedTx({ success: false, raw: true });
            }
          } else if (request.transactions && request.transactions.length > 0) {
            try {
              const txBytes = Uint8Array.from(atob(request.transactions[0]), (c) => c.charCodeAt(0));
              const decoded = decodeTransaction(txBytes);
              decoded.totalTransactions = request.transactions.length;
              setDecodedTx(decoded);
            } catch (e) {
              setDecodedTx({ success: false, raw: true, totalTransactions: request.transactions.length });
            }
          }
        } else {
          setPendingRequest(null);
          setDecodedTx(null);
        }
      } catch (err) {
        logger$1.error("[DAppApproval] Error checking pending request");
        setPendingRequest(null);
      }
      setLoading(false);
    };
    checkPendingRequest();
    const interval = setInterval(checkPendingRequest, 1e3);
    return () => clearInterval(interval);
  }, []);
  const isHardwareWallet = ((_a2 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _a2.isHardware) || ((_b2 = wallet == null ? void 0 : wallet.activeWallet) == null ? void 0 : _b2.isHardware) || (wallet == null ? void 0 : wallet.isHardware) || false;
  const getSecretKey = () => {
    var _a3;
    if (isHardwareWallet) {
      throw new Error("Hardware wallet - use signWithHardware instead");
    }
    const privateKey = (_a3 = wallet.wallet) == null ? void 0 : _a3.privateKey;
    if (!privateKey) throw new Error("No private key");
    try {
      return decode(privateKey);
    } catch {
      try {
        return new Uint8Array(JSON.parse(privateKey));
      } catch {
        throw new Error("Invalid private key format");
      }
    }
  };
  const signWithHardware = async (message, derivationPath = null) => {
    var _a3, _b3, _c2, _d2, _e2, _f2, _g2, _h2, _i, _j, _k, _l, _m, _n, _o;
    try {
      setHwStatus("Connecting to Ledger...");
      logger$1.log("[DAppApproval] signWithHardware using derivation path:", derivationPath);
      if (!hardwareWallet.isReady()) {
        logger$1.log("[DAppApproval] Hardware wallet not ready, attempting connection...");
        try {
          const TransportModule = await __vitePreload(() => import("./TransportWebHID.js"), true ? __vite__mapDeps([5,1,2,3,6]) : void 0);
          const Transport = TransportModule.default;
          let transport = null;
          try {
            transport = await Transport.openConnected();
            logger$1.log("[DAppApproval] openConnected succeeded");
          } catch (e) {
            logger$1.log("[DAppApproval] openConnected failed:", e.message);
          }
          if (!transport) {
            throw new Error("LEDGER_POPUP_LIMITATION");
          }
          hardwareWallet.transport = transport;
          hardwareWallet.state = "connected";
        } catch (connectErr) {
          logger$1.error("[DAppApproval] Transport connection failed:", connectErr);
          if (connectErr.message === "LEDGER_POPUP_LIMITATION" || ((_a3 = connectErr.message) == null ? void 0 : _a3.includes("Access denied")) || ((_b3 = connectErr.message) == null ? void 0 : _b3.includes("cancelled")) || connectErr.name === "TransportOpenUserCancelled") {
            throw new Error("LEDGER_POPUP_LIMITATION");
          }
          throw connectErr;
        }
        await hardwareWallet.openApp();
      }
      setHwStatus("Please confirm transaction on Ledger...");
      const signature = await hardwareWallet.signTransaction(message, derivationPath);
      return signature;
    } catch (err) {
      logger$1.error("[DAppApproval] Hardware signing error:", err);
      if (err.message === "LEDGER_POPUP_LIMITATION") {
        throw new Error("LEDGER_POPUP_LIMITATION");
      }
      if ((_c2 = err.message) == null ? void 0 : _c2.includes("rejected")) {
        throw new Error("Transaction rejected on Ledger");
      }
      if (((_d2 = err.message) == null ? void 0 : _d2.includes("cancelled")) || ((_e2 = err.message) == null ? void 0 : _e2.includes("No device")) || ((_f2 = err.message) == null ? void 0 : _f2.includes("Access denied"))) {
        throw new Error("LEDGER_POPUP_LIMITATION");
      }
      if (((_g2 = err.message) == null ? void 0 : _g2.includes("session expired")) || ((_h2 = err.message) == null ? void 0 : _h2.includes("Ledger session"))) {
        throw new Error("LEDGER_POPUP_LIMITATION");
      }
      const shouldDisconnect = ((_i = err.message) == null ? void 0 : _i.includes("already open")) || ((_j = err.message) == null ? void 0 : _j.includes("0x6a81")) || ((_k = err.message) == null ? void 0 : _k.includes("UNKNOWN_ERROR")) || ((_l = err.message) == null ? void 0 : _l.includes("Could not connect")) || ((_m = err.message) == null ? void 0 : _m.includes("Solana app")) || ((_n = err.message) == null ? void 0 : _n.includes("not ready")) || err.statusCode === 27265 || // 0x6a81
      err.statusCode === 27265 || err.name === "TransportStatusError";
      if (shouldDisconnect) {
        logger$1.log("[DAppApproval] Disconnecting Ledger due to transport error");
        try {
          await hardwareWallet.disconnect();
        } catch (e) {
        }
        if ((_o = err.message) == null ? void 0 : _o.includes("already open")) {
          throw new Error("Ledger connection conflict. Please try again.");
        }
        throw new Error("LEDGER_POPUP_LIMITATION");
      }
      throw new Error(`Ledger signing failed: ${err.message}`);
    } finally {
      setHwStatus("");
    }
  };
  const handleReject = async () => {
    setProcessing(true);
    try {
      await chrome.runtime.sendMessage({
        type: "approve-sign",
        error: "User rejected the request"
      });
    } catch (e) {
    }
    if (onComplete) onComplete();
    setTimeout(() => window.close(), 300);
  };
  const handleApproveConnect = async () => {
    var _a3;
    setProcessing(true);
    setError(null);
    try {
      const publicKey = (_a3 = wallet.wallet) == null ? void 0 : _a3.publicKey;
      const network = currentNetwork2;
      const chain = networkToChain(network);
      if (!publicKey) throw new Error("No wallet available");
      logger$1.log("[DAppApproval] Connecting with network:", network, "chain:", chain);
      localStorage.setItem("x1wallet_network", network);
      if (typeof chrome !== "undefined" && chrome.storage && chrome.storage.local) {
        await chrome.storage.local.set({ "x1wallet_network": network });
      }
      if (wallet.setNetwork) {
        wallet.setNetwork(network);
      }
      await chrome.runtime.sendMessage({
        type: "provider-response",
        payload: { result: { publicKey, network, chain } }
      });
      try {
        const { trackConnectXP: trackConnectXP2 } = await __vitePreload(async () => {
          const { trackConnectXP: trackConnectXP3 } = await Promise.resolve().then(() => xp);
          return { trackConnectXP: trackConnectXP3 };
        }, true ? void 0 : void 0);
        trackConnectXP2({
          user: publicKey,
          network,
          dapp: (pendingRequest == null ? void 0 : pendingRequest.origin) || "unknown"
        }).catch(() => {
        });
      } catch (e) {
      }
      if (onComplete) onComplete();
      setTimeout(() => window.close(), 300);
    } catch (err) {
      setError(getUserFriendlyError(err, ErrorMessages.wallet.loadFailed));
      setProcessing(false);
    }
  };
  const networkToChain = (network) => {
    const map = {
      "X1 Mainnet": "x1:mainnet",
      "X1 Testnet": "x1:testnet",
      "Solana Mainnet": "solana:mainnet",
      "Solana Devnet": "solana:devnet",
      "Solana Testnet": "solana:testnet"
    };
    return map[network] || "x1:mainnet";
  };
  const chainToNetwork = (chain) => {
    const map = {
      "x1:mainnet": "X1 Mainnet",
      "x1:testnet": "X1 Testnet",
      "solana:mainnet": "Solana Mainnet",
      "solana:devnet": "Solana Devnet",
      "solana:testnet": "Solana Testnet"
    };
    return map[chain] || null;
  };
  const handleSignTransaction = async () => {
    var _a3;
    if (signingInProgress.current) {
      logger$1.warn("[DAppApproval] Sign already in progress, ignoring");
      return;
    }
    const now = Date.now();
    if (now - lastSignAttempt.current < 2e3) {
      logger$1.warn("[DAppApproval] Sign attempt too soon, ignoring");
      return;
    }
    lastSignAttempt.current = now;
    signingInProgress.current = true;
    setProcessing(true);
    setError(null);
    if (isHardwareWallet) {
      try {
        await chrome.runtime.sendMessage({
          type: "ledger-busy",
          busy: true,
          origin: pendingRequest == null ? void 0 : pendingRequest.origin
        });
      } catch (e) {
        logger$1.warn("[DAppApproval] Failed to set ledger-busy:", e);
      }
    }
    try {
      const txBytes = Uint8Array.from(atob(pendingRequest.transaction), (c) => c.charCodeAt(0));
      logger$1.log("[DAppApproval] Transaction length:", txBytes.length);
      const sigCountResult = readCompactU16(txBytes, 0);
      const numSigSlots = sigCountResult.value;
      const sigSlotsStart = sigCountResult.bytesRead;
      const messageStart = sigSlotsStart + numSigSlots * 64;
      const message = txBytes.slice(messageStart);
      logger$1.log("[DAppApproval] Num sig slots:", numSigSlots, "Message start:", messageStart);
      let signature;
      if (isHardwareWallet) {
        const derivationPath = (_a3 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _a3.derivationPath;
        logger$1.log("[DAppApproval] Using derivation path:", derivationPath);
        signature = await signWithHardware(message, derivationPath);
      } else {
        const secretKey = getSecretKey();
        signature = await sign(message, secretKey);
      }
      const signedTx = new Uint8Array(txBytes.length);
      signedTx.set(txBytes);
      signedTx.set(signature, sigSlotsStart);
      const signedTxBase64 = btoa(String.fromCharCode(...signedTx));
      logger$1.log("[DAppApproval] Transaction signed successfully");
      await chrome.runtime.sendMessage({
        type: "approve-sign",
        signedTransaction: signedTxBase64
      });
      if (onComplete) onComplete();
      setTimeout(() => window.close(), 300);
    } catch (err) {
      logger$1.error("[DAppApproval] Sign error:", err);
      if (err.message === "LEDGER_POPUP_LIMITATION") {
        setLedgerPopupError(true);
        setProcessing(false);
        return;
      }
      try {
        await chrome.runtime.sendMessage({
          type: "approve-sign",
          error: (err == null ? void 0 : err.message) || "Transaction signing failed"
        });
      } catch (e) {
        logger$1.warn("[DAppApproval] Failed to send error to background:", e);
      }
      setError(getUserFriendlyError(err, ErrorMessages.transaction.signFailed));
      setProcessing(false);
    } finally {
      signingInProgress.current = false;
      if (isHardwareWallet) {
        try {
          await chrome.runtime.sendMessage({ type: "ledger-busy", busy: false });
        } catch (e) {
          logger$1.warn("[DAppApproval] Failed to clear ledger-busy:", e);
        }
      }
    }
  };
  const handleSignAllTransactions = async () => {
    var _a3;
    if (signingInProgress.current) {
      logger$1.warn("[DAppApproval] Sign already in progress, ignoring");
      return;
    }
    const now = Date.now();
    if (now - lastSignAttempt.current < 2e3) {
      logger$1.warn("[DAppApproval] Sign attempt too soon, ignoring");
      return;
    }
    lastSignAttempt.current = now;
    signingInProgress.current = true;
    setProcessing(true);
    setError(null);
    if (isHardwareWallet) {
      try {
        await chrome.runtime.sendMessage({
          type: "ledger-busy",
          busy: true,
          origin: pendingRequest == null ? void 0 : pendingRequest.origin
        });
      } catch (e) {
        logger$1.warn("[DAppApproval] Failed to set ledger-busy:", e);
      }
    }
    try {
      const signedTxs = [];
      const secretKey = isHardwareWallet ? null : getSecretKey();
      for (let i = 0; i < pendingRequest.transactions.length; i++) {
        const tx = pendingRequest.transactions[i];
        const txBytes = Uint8Array.from(atob(tx), (c) => c.charCodeAt(0));
        const sigCountResult = readCompactU16(txBytes, 0);
        const numSigSlots = sigCountResult.value;
        const sigSlotsStart = sigCountResult.bytesRead;
        const messageStart = sigSlotsStart + numSigSlots * 64;
        const message = txBytes.slice(messageStart);
        let signature;
        if (isHardwareWallet) {
          if (i === 0) {
            setHwStatus(`Please confirm transaction ${i + 1} of ${pendingRequest.transactions.length} on Ledger...`);
          } else {
            setHwStatus(`Signing transaction ${i + 1} of ${pendingRequest.transactions.length}...`);
          }
          const derivationPath = (_a3 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _a3.derivationPath;
          signature = await signWithHardware(message, derivationPath);
        } else {
          signature = await sign(message, secretKey);
        }
        const signedTx = new Uint8Array(txBytes.length);
        signedTx.set(txBytes);
        signedTx.set(signature, sigSlotsStart);
        signedTxs.push(btoa(String.fromCharCode(...signedTx)));
      }
      setHwStatus("");
      await chrome.runtime.sendMessage({
        type: "approve-sign",
        signedTransactions: signedTxs
      });
      if (onComplete) onComplete();
      setTimeout(() => window.close(), 300);
    } catch (err) {
      logger$1.error("[DAppApproval] Sign all error:", err);
      if (err.message === "LEDGER_POPUP_LIMITATION") {
        setLedgerPopupError(true);
        setProcessing(false);
        return;
      }
      try {
        await chrome.runtime.sendMessage({
          type: "approve-sign",
          error: (err == null ? void 0 : err.message) || "Transaction signing failed"
        });
      } catch (e) {
        logger$1.warn("[DAppApproval] Failed to send error to background:", e);
      }
      setError(getUserFriendlyError(err, ErrorMessages.transaction.signFailed));
      setProcessing(false);
    } finally {
      signingInProgress.current = false;
      if (isHardwareWallet) {
        try {
          await chrome.runtime.sendMessage({ type: "ledger-busy", busy: false });
        } catch (e) {
          logger$1.warn("[DAppApproval] Failed to clear ledger-busy:", e);
        }
      }
    }
  };
  const handleSignAndSendTransaction = async () => {
    var _a3, _b3, _c2, _d2, _e2, _f2;
    if (signingInProgress.current) {
      logger$1.warn("[DAppApproval] Sign already in progress, ignoring");
      return;
    }
    const now = Date.now();
    if (now - lastSignAttempt.current < 2e3) {
      logger$1.warn("[DAppApproval] Sign attempt too soon, ignoring");
      return;
    }
    lastSignAttempt.current = now;
    signingInProgress.current = true;
    setProcessing(true);
    setError(null);
    if (isHardwareWallet) {
      try {
        await chrome.runtime.sendMessage({
          type: "ledger-busy",
          busy: true,
          origin: pendingRequest == null ? void 0 : pendingRequest.origin
        });
      } catch (e) {
        logger$1.warn("[DAppApproval] Failed to set ledger-busy:", e);
      }
    }
    try {
      const txBytes = Uint8Array.from(atob(pendingRequest.transaction), (c) => c.charCodeAt(0));
      const priorityFeeNative = priority === "custom" ? parseFloat(customFee) || 0 : ((_a3 = getPriorityOptions(currentNetwork2).find((p2) => p2.id === priority)) == null ? void 0 : _a3.fee) || 0;
      if (priorityFeeNative > 0) {
        logger$1.log("[DAppApproval] User selected priority fee:", priorityFeeNative, (currentNetwork2 == null ? void 0 : currentNetwork2.includes("Solana")) ? "SOL" : "XNT");
      }
      let rpcUrl;
      if (currentNetwork2 === "X1 Mainnet") {
        rpcUrl = "https://rpc.mainnet.x1.xyz";
      } else if (currentNetwork2 === "X1 Testnet") {
        rpcUrl = "https://rpc.testnet.x1.xyz";
      } else if (currentNetwork2 === "Solana Mainnet") {
        rpcUrl = "https://jessamine-463apc-fast-mainnet.helius-rpc.com";
      } else if (currentNetwork2 === "Solana Devnet") {
        rpcUrl = "https://rose-l3rk46-fast-devnet.helius-rpc.com";
      } else {
        try {
          const customNetworks = JSON.parse(localStorage.getItem("x1wallet_customRpcs") || "[]");
          const customNet = customNetworks.find((n2) => n2.name === currentNetwork2);
          if (customNet) {
            rpcUrl = customNet.url;
          } else {
            rpcUrl = "https://rpc.mainnet.x1.xyz";
          }
        } catch {
          rpcUrl = "https://rpc.mainnet.x1.xyz";
        }
      }
      const walletPubKey = (_b3 = wallet.wallet) == null ? void 0 : _b3.publicKey;
      logger$1.log("[DAppApproval] Wallet public key:", walletPubKey);
      logger$1.log("[DAppApproval] Checking balance...");
      const balanceResponse = await fetch(rpcUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "getBalance",
          params: [walletPubKey, { commitment: "confirmed" }]
        })
      });
      const balanceData = await balanceResponse.json();
      if (balanceData.error) {
        throw new Error("Failed to check balance: " + (balanceData.error.message || JSON.stringify(balanceData.error)));
      }
      const balanceLamports = ((_c2 = balanceData.result) == null ? void 0 : _c2.value) || 0;
      const balanceSOL = balanceLamports / 1e9;
      const symbol = (currentNetwork2 == null ? void 0 : currentNetwork2.includes("Solana")) ? "SOL" : "XNT";
      logger$1.log("[DAppApproval] Current balance:", balanceSOL, symbol);
      const MIN_BALANCE = 1e-3;
      if (balanceSOL < MIN_BALANCE) {
        throw new Error(`Insufficient ${symbol} balance. You have ${balanceSOL.toFixed(6)} ${symbol} but need at least ${MIN_BALANCE} ${symbol} for transaction fees.`);
      }
      const sigCountResult = readCompactU16(txBytes, 0);
      const numSigSlots = sigCountResult.value;
      const sigSlotsStart = sigCountResult.bytesRead;
      const messageStart = sigSlotsStart + numSigSlots * 64;
      const message = txBytes.slice(messageStart);
      const isVersioned = (message[0] & 128) !== 0;
      logger$1.log(
        "[DAppApproval] Tx parsing: numSigSlots=",
        numSigSlots,
        "messageStart=",
        messageStart,
        "isVersioned=",
        isVersioned,
        "messageLen=",
        message.length
      );
      let feePayerOffset;
      if (isVersioned) {
        let tempOffset = 4;
        const acctResult = readCompactU16(message, tempOffset);
        feePayerOffset = tempOffset + acctResult.bytesRead;
      } else {
        let tempOffset = 3;
        const acctResult = readCompactU16(message, tempOffset);
        feePayerOffset = tempOffset + acctResult.bytesRead;
      }
      const feePayerBytes = message.slice(feePayerOffset, feePayerOffset + 32);
      const feePayerKey = encode(feePayerBytes);
      logger$1.log("[DAppApproval] Fee payer in transaction:", feePayerKey);
      if (feePayerKey !== walletPubKey) {
        logger$1.warn("[DAppApproval] Fee payer mismatch! Wallet:", walletPubKey, "Fee payer:", feePayerKey);
      }
      logger$1.log("[DAppApproval] Signing message... isHardware:", isHardwareWallet);
      let signature;
      if (isHardwareWallet) {
        const derivationPath = (_d2 = wallet == null ? void 0 : wallet.wallet) == null ? void 0 : _d2.derivationPath;
        logger$1.log("[DAppApproval] Using derivation path:", derivationPath);
        signature = await signWithHardware(message, derivationPath);
      } else {
        const secretKey = getSecretKey();
        signature = await sign(message, secretKey);
      }
      logger$1.log("[DAppApproval] Signature generated, length:", signature.length);
      const signedTx = new Uint8Array(txBytes.length);
      signedTx.set(txBytes);
      signedTx.set(signature, sigSlotsStart);
      logger$1.log("[DAppApproval] Signed tx length:", signedTx.length);
      logger$1.log("[DAppApproval] Sending to RPC:", rpcUrl);
      let response = await fetch(rpcUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "sendTransaction",
          params: [btoa(String.fromCharCode(...signedTx)), {
            encoding: "base64",
            skipPreflight: false,
            preflightCommitment: "confirmed",
            maxRetries: 5
          }]
        })
      });
      let data = await response.json();
      logger$1.log("[DAppApproval] RPC response:", JSON.stringify(data));
      if (data.error && data.error.message && data.error.message.includes("Blockhash not found")) {
        logger$1.log("[DAppApproval] Blockhash expired, retrying with skipPreflight...");
        response = await fetch(rpcUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            jsonrpc: "2.0",
            id: 1,
            method: "sendTransaction",
            params: [btoa(String.fromCharCode(...signedTx)), {
              encoding: "base64",
              skipPreflight: true,
              preflightCommitment: "confirmed",
              maxRetries: 5
            }]
          })
        });
        data = await response.json();
        logger$1.log("[DAppApproval] Retry RPC response:", JSON.stringify(data));
      }
      if (data.error) {
        logger$1.error("[DAppApproval] RPC error:", data.error);
        throw new Error(data.error.message || JSON.stringify(data.error));
      }
      const txSignature = data.result;
      logger$1.log("[DAppApproval] Transaction signature:", txSignature);
      try {
        const walletAddress = (_e2 = wallet.wallet) == null ? void 0 : _e2.publicKey;
        const nativeSymbol = (currentNetwork2 == null ? void 0 : currentNetwork2.includes("Solana")) ? "SOL" : "XNT";
        const dappName = ((_f2 = pendingRequest.origin) == null ? void 0 : _f2.replace(/^https?:\/\//, "").split("/")[0]) || "DApp";
        let txType = "dapp";
        if (decodedTx == null ? void 0 : decodedTx.instructions) {
          const hasWrap = decodedTx.instructions.some(
            (i) => i.instructionType === "Sync Native" || i.programName === "Token Program" && i.instructionType === "Close Account"
          );
          const hasSwap = decodedTx.instructions.length > 3;
          if (hasWrap || hasSwap) {
            txType = "swap";
          }
        }
        logger$1.log("[DAppApproval] Transaction completed:", txSignature, "type:", txType);
      } catch (e) {
        logger$1.warn("[DAppApproval] Failed to record transaction:", e);
      }
      logger$1.log("[DAppApproval] Sending signature to background:", txSignature);
      await chrome.runtime.sendMessage({
        type: "approve-sign",
        signature: txSignature
      });
      logger$1.log("[DAppApproval] Response sent, closing popup");
      if (onComplete) onComplete();
      setTimeout(() => window.close(), 300);
    } catch (err) {
      logger$1.error("[DAppApproval] Send error:", err.message || err);
      if (err.message === "LEDGER_POPUP_LIMITATION") {
        setLedgerPopupError(true);
        setProcessing(false);
        return;
      }
      try {
        await chrome.runtime.sendMessage({
          type: "approve-sign",
          error: (err == null ? void 0 : err.message) || "Transaction failed"
        });
      } catch (e) {
        logger$1.warn("[DAppApproval] Failed to send error to background:", e);
      }
      setError(getUserFriendlyError(err, ErrorMessages.transaction.failed));
      setProcessing(false);
    } finally {
      signingInProgress.current = false;
      if (isHardwareWallet) {
        try {
          await chrome.runtime.sendMessage({ type: "ledger-busy", busy: false });
        } catch (e) {
          logger$1.warn("[DAppApproval] Failed to clear ledger-busy:", e);
        }
      }
    }
  };
  const handleSignMessage = async () => {
    var _a3, _b3, _c2, _d2, _e2, _f2, _g2, _h2, _i, _j, _k;
    if (signingInProgress.current) {
      logger$1.warn("[DAppApproval] Sign already in progress, ignoring duplicate call");
      return;
    }
    const now = Date.now();
    if (now - lastSignAttempt.current < 2e3) {
      logger$1.warn("[DAppApproval] Sign attempt too soon after last attempt, ignoring");
      return;
    }
    lastSignAttempt.current = now;
    signingInProgress.current = true;
    setProcessing(true);
    setError(null);
    if (isHardwareWallet) {
      try {
        await chrome.runtime.sendMessage({
          type: "ledger-busy",
          busy: true,
          origin: pendingRequest == null ? void 0 : pendingRequest.origin
        });
      } catch (e) {
        logger$1.warn("[DAppApproval] Failed to set ledger-busy:", e);
      }
    }
    try {
      const messageBytes = Uint8Array.from(atob(pendingRequest.message), (c) => c.charCodeAt(0));
      let signature;
      if (isHardwareWallet) {
        logger$1.log("[DAppApproval] Signing message with hardware wallet, bytes:", messageBytes.length);
        signature = await hardwareWallet.signMessage(messageBytes, (_a3 = wallet == null ? void 0 : wallet.activeWallet) == null ? void 0 : _a3.derivationPath);
        logger$1.log("[DAppApproval] Hardware signature received:", (signature == null ? void 0 : signature.length) || "null");
      } else {
        const secretKey = getSecretKey();
        signature = await sign(messageBytes, secretKey);
      }
      const signatureBase64 = btoa(String.fromCharCode(...signature));
      await chrome.runtime.sendMessage({
        type: "approve-sign-message",
        signature: signatureBase64
      });
      if (onComplete) onComplete();
      setTimeout(() => window.close(), 300);
    } catch (err) {
      logger$1.error("[DAppApproval] Sign message error:", {
        message: err == null ? void 0 : err.message,
        name: err == null ? void 0 : err.name,
        stack: err == null ? void 0 : err.stack,
        statusCode: err == null ? void 0 : err.statusCode
      });
      const isLedgerReconnectError = isHardwareWallet && (((_b3 = err.message) == null ? void 0 : _b3.includes("Could not connect")) || ((_c2 = err.message) == null ? void 0 : _c2.includes("Solana app")) || ((_d2 = err.message) == null ? void 0 : _d2.includes("session expired")) || ((_e2 = err.message) == null ? void 0 : _e2.includes("Ledger session")) || ((_f2 = err.message) == null ? void 0 : _f2.includes("not ready")) || ((_g2 = err.message) == null ? void 0 : _g2.includes("0x6a81")) || ((_h2 = err.message) == null ? void 0 : _h2.includes("UNKNOWN_ERROR")) || ((_i = err.message) == null ? void 0 : _i.includes("Please open")) || ((_j = err.message) == null ? void 0 : _j.includes("unlock")) || ((_k = err.message) == null ? void 0 : _k.includes("Ledger not connected")) || err.statusCode === 27265 || // 0x6a81
      err.statusCode === 27265 || err.name === "TransportStatusError");
      if (isLedgerReconnectError) {
        logger$1.log("[DAppApproval] Ledger needs reconnection, showing connect UI");
        try {
          await hardwareWallet.disconnect();
        } catch (e) {
        }
        setLedgerPopupError(true);
        setProcessing(false);
        return;
      }
      try {
        await chrome.runtime.sendMessage({
          type: "approve-sign-message",
          error: (err == null ? void 0 : err.message) || "Signing failed"
        });
      } catch (e) {
        logger$1.warn("[DAppApproval] Failed to send error to background:", e);
      }
      setError(getUserFriendlyError(err, ErrorMessages.transaction.signFailed));
      setProcessing(false);
    } finally {
      signingInProgress.current = false;
      if (isHardwareWallet) {
        try {
          await chrome.runtime.sendMessage({ type: "ledger-busy", busy: false });
        } catch (e) {
          logger$1.warn("[DAppApproval] Failed to clear ledger-busy:", e);
        }
      }
    }
  };
  if (loading) return null;
  if (!pendingRequest) {
    if (error) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dapp-approval", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-error-screen", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: "var(--error)", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "15", y1: "9", x2: "9", y2: "15" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "9", y1: "9", x2: "15", y2: "15" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-title", children: "Transaction Failed" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: error }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "dapp-btn-primary", onClick: () => window.close(), children: "Close" })
      ] }) });
    }
    return null;
  }
  const originDisplay = ((_c = pendingRequest.origin) == null ? void 0 : _c.replace(/^https?:\/\//, "").split("/")[0]) || "Unknown";
  const knownLogos = {
    "xdex.xyz": "/icons/48-xdex.png",
    "app.xdex.xyz": "/icons/48-xdex.png",
    "dev.xdex.xyz": "/icons/48-xdex.png",
    "degen.fyi": "/icons/48-degen.png",
    "x1.xyz": "/icons/48-x1.png",
    "bridge.x1.xyz": "/icons/48-x1.png",
    "vero.x1.xyz": "/icons/48-x1.png"
  };
  const getIconUrl = () => {
    if (knownLogos[originDisplay]) {
      return knownLogos[originDisplay];
    }
    return pendingRequest.favicon;
  };
  const iconUrl = getIconUrl();
  const handleApproveClick = async () => {
    if (processing || signingInProgress.current) {
      console.log("[DAppApproval] Ignoring click - already processing");
      return;
    }
    const now = Date.now();
    if (now - lastSignAttempt.current < 2e3) {
      console.log("[DAppApproval] Ignoring click - too soon after last attempt");
      return;
    }
    const handler = getHandler();
    if (handler) {
      await handler();
    }
  };
  const getHandler = () => {
    switch (pendingRequest.type) {
      case "connect":
        return handleApproveConnect;
      case "signTransaction":
        return handleSignTransaction;
      case "signAllTransactions":
        return handleSignAllTransactions;
      case "signAndSendTransaction":
        return handleSignAndSendTransaction;
      case "signMessage":
        return handleSignMessage;
      default:
        return handleReject;
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dapp-approval-overlay", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-approval-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-site-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-site-icon", children: [
        iconUrl ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: iconUrl,
            alt: "",
            onError: (e) => {
              e.target.style.display = "none";
              if (e.target.nextSibling) e.target.nextSibling.style.display = "flex";
            }
          }
        ) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dapp-site-icon-fallback", style: iconUrl ? { display: "none" } : {}, children: originDisplay.charAt(0).toUpperCase() })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-site-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-site-name", children: originDisplay }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-site-url", children: pendingRequest.origin })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `dapp-action-badge ${pendingRequest.type === "connect" ? "connect" : "sign"}`, children: [
      pendingRequest.type === "connect" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "10 17 15 12 10 7" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "15", y1: "12", x2: "3", y2: "12" })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "9 12 11 14 15 10" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: pendingRequest.type === "connect" ? "Connect Wallet" : pendingRequest.type === "signMessage" ? "Sign Message" : pendingRequest.type === "signAndSendTransaction" ? "Sign & Send Transaction" : "Sign Transaction" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "dapp-description", children: pendingRequest.type === "connect" ? pendingRequest.chain ? `This site is requesting to connect to your wallet on ${chainToNetwork(pendingRequest.chain) || pendingRequest.chain}.` : "This site is requesting access to view your wallet address and request transaction approvals." : "This site is requesting your signature for a transaction." }),
    pendingRequest.type === "connect" && pendingRequest.chain && networkToChain(currentNetwork2) !== pendingRequest.chain && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-chain-warning", style: {
      background: "rgba(251, 191, 36, 0.1)",
      border: "1px solid rgba(251, 191, 36, 0.3)",
      borderRadius: "8px",
      padding: "12px",
      marginBottom: "16px",
      display: "flex",
      alignItems: "center",
      gap: "8px"
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "#fbbf24", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "#fbbf24", fontSize: "13px" }, children: [
        "Will switch from ",
        currentNetwork2,
        " to ",
        chainToNetwork(pendingRequest.chain)
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-wallet-card", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-wallet-row", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-wallet-label", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "7", r: "4" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Account" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "dapp-wallet-value", children: [
          (_e = (_d = wallet.wallet) == null ? void 0 : _d.publicKey) == null ? void 0 : _e.slice(0, 4),
          "...",
          (_g = (_f = wallet.wallet) == null ? void 0 : _f.publicKey) == null ? void 0 : _g.slice(-4)
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-wallet-row", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-wallet-label", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "2", y1: "12", x2: "22", y2: "12" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Network" })
        ] }),
        pendingRequest.type === "connect" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "select",
          {
            className: "dapp-network-select",
            value: currentNetwork2,
            onChange: (e) => setCurrentNetwork(e.target.value),
            style: {
              background: "var(--bg-tertiary)",
              border: "1px solid var(--border-color)",
              borderRadius: "6px",
              padding: "4px 28px 4px 8px",
              color: "var(--text-primary)",
              fontSize: "13px",
              fontWeight: "normal",
              cursor: "pointer",
              minWidth: "140px",
              textAlign: "center",
              textAlignLast: "center"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("optgroup", { label: "X1 Networks", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "X1 Mainnet", children: "X1 Mainnet" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "X1 Testnet", children: "X1 Testnet" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("optgroup", { label: "Solana Networks", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Solana Mainnet", children: "Solana Mainnet" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Solana Devnet", children: "Solana Devnet" })
              ] })
            ]
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "dapp-wallet-value network", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "network-dot" }),
          currentNetwork2
        ] })
      ] })
    ] }),
    pendingRequest.type === "signMessage" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-message-preview", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-message-label", children: "Message to sign:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("code", { className: "dapp-message-content", children: (() => {
        try {
          return atob(pendingRequest.message).slice(0, 150);
        } catch {
          return "(Binary data)";
        }
      })() })
    ] }),
    (pendingRequest.type === "signTransaction" || pendingRequest.type === "signAndSendTransaction" || pendingRequest.type === "signAllTransactions") && decodedTx && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-tx-grid", children: [
      decodedTx.totalTransactions > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-tx-warning batch", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "Batch: ",
          decodedTx.totalTransactions,
          " transactions"
        ] })
      ] }),
      decodedTx.hasUnknownPrograms && !TRUSTED_DAPP_ORIGINS.some((domain) => {
        var _a3;
        return (_a3 = pendingRequest == null ? void 0 : pendingRequest.origin) == null ? void 0 : _a3.includes(domain);
      }) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-tx-warning", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Contains unknown program calls" })
      ] }),
      decodedTx.success && decodedTx.instructions && /* @__PURE__ */ jsxRuntimeExports.jsxs("details", { className: "dapp-tx-row-details", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("summary", { className: "dapp-tx-row clickable", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-tx-row-label", children: "Transaction" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "dapp-tx-row-value", children: [
            decodedTx.instructions.length,
            " operation",
            decodedTx.instructions.length !== 1 ? "s" : ""
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "dapp-tx-row-arrow", width: "14", height: "14", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "6 9 12 15 18 9" }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dapp-tx-details-expanded", children: decodedTx.instructions.map((instr, idx) => {
          const isTrustedOrigin = TRUSTED_DAPP_ORIGINS.some((domain) => {
            var _a3;
            return (_a3 = pendingRequest == null ? void 0 : pendingRequest.origin) == null ? void 0 : _a3.includes(domain);
          });
          const displayName = instr.instructionType || (instr.programName === "Unknown Program" && isTrustedOrigin ? "dApp Operation" : instr.programName);
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `dapp-tx-instruction-item ${instr.isKnownSafe || isTrustedOrigin ? "safe" : "unknown"}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-tx-instr-num", children: idx + 1 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-tx-instr-name", children: displayName }),
            !instr.isKnownSafe && !isTrustedOrigin && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-tx-instr-badge", children: "!" }),
            instr.amount !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-tx-instr-amount", children: instr.amount.toFixed(4) })
          ] }, idx);
        }) })
      ] }),
      !decodedTx.success && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-tx-warning raw", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 8v4m0 4h.01" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Could not decode transaction." })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-tx-row", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-tx-row-label", children: "Estimated Fee" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "dapp-tx-row-value", children: [
          (getBaseFee(currentNetwork2) * (decodedTx.numSignatures || 1)).toFixed(6),
          " ",
          (currentNetwork2 == null ? void 0 : currentNetwork2.includes("Solana")) ? "SOL" : "XNT"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-tx-row priority-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-tx-row-label", children: "Priority" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-priority-chips", children: [
          getPriorityOptions(currentNetwork2).filter((opt) => opt.id !== "custom").map((opt) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `dapp-priority-chip ${priority === opt.id ? "active" : ""}`,
              onClick: () => {
                setPriority(opt.id);
                setCustomFee("");
              },
              type: "button",
              disabled: processing,
              children: opt.name
            },
            opt.id
          )),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: `dapp-priority-chip ${priority === "custom" ? "active" : ""}`,
              onClick: () => setPriority("custom"),
              type: "button",
              disabled: processing,
              children: ""
            }
          )
        ] })
      ] }),
      priority === "custom" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-tx-row", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-tx-row-label", children: "Custom Fee" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-custom-fee-wrapper", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "number",
              min: "0",
              className: "dapp-custom-fee-input",
              placeholder: "0.0001",
              value: customFee,
              onChange: (e) => {
                const value = e.target.value;
                if (value.startsWith("-") || parseFloat(value) < 0) return;
                setCustomFee(value);
              },
              step: "0.0001",
              disabled: processing
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-custom-fee-symbol", children: (currentNetwork2 == null ? void 0 : currentNetwork2.includes("Solana")) ? "SOL" : "XNT" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-tx-row total", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-tx-row-label", children: "Total Fee" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "dapp-tx-row-value highlight", children: [
          (getBaseFee(currentNetwork2) * (decodedTx.numSignatures || 1) + (priority === "custom" ? parseFloat(customFee) || 0 : ((_h = getPriorityOptions(currentNetwork2).find((p2) => p2.id === priority)) == null ? void 0 : _h.fee) || 0)).toFixed(6),
          " ",
          (currentNetwork2 == null ? void 0 : currentNetwork2.includes("Solana")) ? "SOL" : "XNT"
        ] })
      ] })
    ] }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: error }),
    ledgerPopupError && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
      background: "rgba(255, 193, 7, 0.1)",
      border: "1px solid rgba(255, 193, 7, 0.3)",
      borderRadius: 12,
      padding: 16,
      marginBottom: 16
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "flex-start", gap: 12 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "#FFC107", strokeWidth: "2", style: { flexShrink: 0, marginTop: 2 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 8v4M12 16h.01" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: 600, marginBottom: 8, color: "var(--text-primary)" }, children: "Ledger Authorization Required" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 13, color: "var(--text-secondary)", lineHeight: 1.5 }, children: "Your Ledger needs to be authorized in Chrome. Click below to connect your Ledger, then click Approve again." })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8, marginTop: 16 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: async () => {
              var _a3, _b3, _c2, _d2, _e2, _f2, _g2, _h2, _i;
              try {
                setError(null);
                setHwStatus("Connecting to Ledger...");
                setProcessing(true);
                try {
                  await hardwareWallet.disconnect();
                } catch (e) {
                }
                hardwareWallet.sessionInvalid = false;
                try {
                  logger$1.log("[DAppApproval] Calling hardwareWallet.connect()...");
                  await hardwareWallet.connect("usb");
                  logger$1.log("[DAppApproval] Connect succeeded, transport:", !!hardwareWallet.transport);
                } catch (connectErr) {
                  logger$1.error("[DAppApproval] hardwareWallet.connect() failed:", connectErr);
                  if (((_a3 = connectErr.message) == null ? void 0 : _a3.includes("No device selected")) || ((_b3 = connectErr.message) == null ? void 0 : _b3.includes("cancelled"))) {
                    throw connectErr;
                  }
                  if ((_c2 = connectErr.message) == null ? void 0 : _c2.includes("NotAllowedError")) {
                    throw new Error("Chrome blocked device access. Please ensure the popup has focus and try again.");
                  }
                  throw connectErr;
                }
                if (hardwareWallet.transport) {
                  setHwStatus("Opening Solana app...");
                  await hardwareWallet.openApp();
                  setHwStatus("");
                  setProcessing(false);
                  setLedgerPopupError(false);
                } else {
                  throw new Error("Failed to establish transport connection");
                }
              } catch (err) {
                logger$1.error("[DAppApproval] Ledger authorization failed:", err);
                logger$1.error("[DAppApproval] Error details:", {
                  name: err == null ? void 0 : err.name,
                  message: err == null ? void 0 : err.message,
                  stack: err == null ? void 0 : err.stack
                });
                setHwStatus("");
                setProcessing(false);
                if (err.name === "TransportOpenUserCancelled" || ((_d2 = err.message) == null ? void 0 : _d2.includes("cancelled"))) {
                  setError("Ledger connection was cancelled. Please try again.");
                } else if ((_e2 = err.message) == null ? void 0 : _e2.includes("No device")) {
                  setError("No Ledger device found. Make sure it is connected and unlocked.");
                } else if (((_f2 = err.message) == null ? void 0 : _f2.includes("Solana app")) || ((_g2 = err.message) == null ? void 0 : _g2.includes("open the"))) {
                  setError("Please open the Solana app on your Ledger, then try again.");
                } else if (((_h2 = err.message) == null ? void 0 : _h2.includes("NotAllowedError")) || ((_i = err.message) == null ? void 0 : _i.includes("blocked"))) {
                  setError("Chrome blocked device access. Click this window to give it focus, then try again.");
                } else {
                  setError(`Failed to connect: ${err.message}`);
                }
              }
            },
            disabled: processing,
            style: {
              flex: 1,
              padding: "12px 16px",
              background: "var(--x1-blue)",
              border: "none",
              borderRadius: 8,
              color: "#ffffff",
              fontSize: 14,
              fontWeight: 500,
              cursor: processing ? "not-allowed" : "pointer",
              opacity: processing ? 0.7 : 1
            },
            children: processing ? "Connecting..." : "Connect Ledger"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: handleReject,
            disabled: processing,
            style: {
              flex: 1,
              padding: "12px 16px",
              background: "var(--bg-secondary)",
              border: "1px solid var(--border-color)",
              borderRadius: 8,
              color: "var(--text-primary)",
              fontSize: 14,
              fontWeight: 500,
              cursor: processing ? "not-allowed" : "pointer",
              opacity: processing ? 0.7 : 1
            },
            children: "Cancel"
          }
        )
      ] })
    ] }),
    hwStatus && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "send-hw-status", style: { marginBottom: 16 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner", style: { width: 20, height: 20 } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: hwStatus })
    ] }),
    !ledgerPopupError && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-approval-actions", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "dapp-btn-reject", onClick: handleReject, disabled: processing, children: pendingRequest.type === "connect" ? "Cancel" : "Deny" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "dapp-btn-approve", onClick: handleApproveClick, disabled: processing, children: processing ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "btn-spinner" }),
        "Processing..."
      ] }) : pendingRequest.type === "connect" ? "Connect" : "Approve" })
    ] })
  ] }) });
}
class ErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    __publicField(this, "handleReload", () => {
      window.location.reload();
    });
    this.state = { hasError: false, error: null };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, errorInfo) {
    console.error("[ErrorBoundary] Caught error:", error);
    console.error("[ErrorBoundary] Error info:", errorInfo);
  }
  render() {
    if (this.state.hasError) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", style: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        padding: 24,
        textAlign: "center",
        minHeight: "100vh",
        background: "var(--bg-primary)"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
          width: 64,
          height: 64,
          borderRadius: "50%",
          background: "rgba(255, 107, 107, 0.1)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          marginBottom: 16
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "32", height: "32", viewBox: "0 0 24 24", fill: "none", stroke: "#ff6b6b", strokeWidth: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "8", x2: "12", y2: "12" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "16", x2: "12.01", y2: "16" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { color: "var(--text-primary)", marginBottom: 8 }, children: "Something went wrong" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "var(--text-muted)", marginBottom: 24, fontSize: 14 }, children: "The wallet encountered an error. Please reload to continue." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: this.handleReload,
            style: {
              background: "var(--x1-blue)",
              color: "white",
              border: "none",
              padding: "12px 32px",
              borderRadius: 12,
              cursor: "pointer",
              fontWeight: 600,
              fontSize: 14
            },
            children: "Reload Wallet"
          }
        )
      ] });
    }
    return this.props.children;
  }
}
function isExtensionContextValid() {
  try {
    if (typeof chrome === "undefined" || !chrome.runtime) {
      return false;
    }
    const id2 = chrome.runtime.id;
    return !!id2;
  } catch (e) {
    return false;
  }
}
async function safeSendMessage(message) {
  var _a2;
  if (!isExtensionContextValid()) {
    console.warn("[App] Extension context invalid, cannot send message");
    return null;
  }
  try {
    return await chrome.runtime.sendMessage(message);
  } catch (e) {
    if ((_a2 = e.message) == null ? void 0 : _a2.includes("Extension context invalidated")) {
      console.warn("[App] Extension context invalidated");
      return null;
    }
    throw e;
  }
}
const storage = {
  get: (key, defaultValue) => {
    try {
      return JSON.parse(localStorage.getItem(`x1wallet_${key}`)) ?? defaultValue;
    } catch {
      return defaultValue;
    }
  },
  set: (key, value) => {
    localStorage.setItem(`x1wallet_${key}`, JSON.stringify(value));
    if (isExtensionContextValid() && chrome.storage) {
      chrome.storage.local.set({ [`x1wallet_${key}`]: value }).catch(() => {
      });
    }
  }
};
function AlertModal({ title, message, onClose, type = "error" }) {
  if (!message) return null;
  const iconColor = type === "error" ? "var(--error)" : type === "warning" ? "var(--warning)" : "var(--x1-blue)";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "alert-modal-overlay", onClick: onClose, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "alert-modal-content", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "alert-modal-icon", children: type === "error" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: iconColor, strokeWidth: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "15", y1: "9", x2: "9", y2: "15" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "9", y1: "9", x2: "15", y2: "15" })
      ] }) : type === "warning" ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: iconColor, strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "48", height: "48", viewBox: "0 0 24 24", fill: "none", stroke: iconColor, strokeWidth: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "16", x2: "12", y2: "12" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "8", x2: "12.01", y2: "8" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "alert-modal-title", children: title || (type === "error" ? "Error" : type === "warning" ? "Warning" : "Notice") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "alert-modal-message", children: message }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary alert-modal-btn", onClick: onClose, children: "OK" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
        .alert-modal-overlay {
          position: fixed;
          inset: 0;
          background: rgba(0,0,0,0.75);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 9999;
          padding: 20px;
          animation: fadeIn 0.15s ease-out;
        }
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes slideUp {
          from { opacity: 0; transform: translateY(20px) scale(0.95); }
          to { opacity: 1; transform: translateY(0) scale(1); }
        }
        .alert-modal-content {
          background: var(--bg-secondary);
          border-radius: 20px;
          width: 100%;
          max-width: 320px;
          padding: 32px 24px 24px;
          display: flex;
          flex-direction: column;
          align-items: center;
          text-align: center;
          box-shadow: 0 20px 60px rgba(0,0,0,0.4);
          animation: slideUp 0.2s ease-out;
        }
        .alert-modal-icon {
          margin-bottom: 16px;
        }
        .alert-modal-title {
          margin: 0 0 8px 0;
          font-size: 18px;
          font-weight: 600;
          color: var(--text-primary);
        }
        .alert-modal-message {
          margin: 0 0 24px 0;
          font-size: 14px;
          line-height: 1.5;
          color: var(--text-secondary);
        }
        .alert-modal-btn {
          width: 100%;
          padding: 14px 24px;
          font-size: 15px;
          font-weight: 600;
        }
      ` })
  ] });
}
const applySavedTheme = () => {
  try {
    const saved = localStorage.getItem("x1wallet_darkMode");
    const isDark = saved === null ? true : JSON.parse(saved);
    document.documentElement.setAttribute("data-theme", isDark ? "dark" : "light");
  } catch {
    document.documentElement.setAttribute("data-theme", "dark");
  }
};
applySavedTheme();
function LockScreen({ onUnlock, walletUnlock }) {
  const [password, setPassword] = reactExports.useState("");
  const [error, setError] = reactExports.useState("");
  const [attempts, setAttempts] = reactExports.useState(0);
  const [unlocking, setUnlocking] = reactExports.useState(false);
  const handleUnlock = async () => {
    if (!password || unlocking) return;
    setUnlocking(true);
    setError("");
    try {
      if (walletUnlock) {
        await walletUnlock(password);
        onUnlock(password);
        return;
      }
      const { checkPassword } = await __vitePreload(async () => {
        const { checkPassword: checkPassword2 } = await import("./wallet.js");
        return { checkPassword: checkPassword2 };
      }, true ? [] : void 0);
      const isValid = await checkPassword(password);
      if (isValid) {
        onUnlock(password);
      } else {
        throw new Error("Incorrect password");
      }
    } catch (e) {
      setAttempts((a) => a + 1);
      const msg = e.message || "Incorrect password";
      setError(`${msg}${attempts >= 2 ? `. ${5 - attempts} attempts remaining.` : ""}`);
      if (attempts >= 4) {
        setError("Too many failed attempts. Please wait 30 seconds.");
        setTimeout(() => setAttempts(0), 3e4);
      }
    } finally {
      setUnlocking(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen lock-screen", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(X1Logo, { size: 80 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lock-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "32", height: "32", viewBox: "0 0 24 24", fill: "none", stroke: "var(--x1-blue)", strokeWidth: "2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "11", width: "18", height: "11", rx: "2", ry: "2" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Wallet Locked" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "lock-subtitle", children: "Enter your password to unlock" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "form-group", style: { marginTop: 24, width: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "password",
        className: "form-input",
        placeholder: "Enter password",
        value: password,
        onChange: (e) => setPassword(e.target.value),
        onKeyDown: (e) => e.key === "Enter" && handleUnlock(),
        autoFocus: true,
        disabled: attempts >= 5 || unlocking
      }
    ) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-message", children: error }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: "btn-primary",
        onClick: handleUnlock,
        disabled: !password || attempts >= 5 || unlocking,
        style: { marginTop: 16 },
        children: unlocking ? "Unlocking..." : "Unlock"
      }
    )
  ] });
}
function App() {
  var _a2, _b2, _c, _d, _e;
  console.log("[App] Rendering...");
  const wallet = useWallet();
  console.log("[App] wallet.wallets:", (_a2 = wallet.wallets) == null ? void 0 : _a2.length, "wallet.loading:", wallet.loading, "wallet.isEncrypted:", wallet.isEncrypted);
  const [screen, setScreen] = reactExports.useState("loading");
  const [returnScreen, setReturnScreen] = reactExports.useState("main");
  const [isLocked, setIsLocked] = reactExports.useState(false);
  const [initialCheckDone, setInitialCheckDone] = reactExports.useState(false);
  const [selectedToken, setSelectedToken] = reactExports.useState(null);
  const [activityRefreshKey, setActivityRefreshKey] = reactExports.useState(0);
  const [balanceRefreshKey, setBalanceRefreshKey] = reactExports.useState(0);
  const [userTokens, setUserTokens] = reactExports.useState([]);
  const [hasDAppRequest, setHasDAppRequest] = reactExports.useState(false);
  const [alertModal, setAlertModal] = reactExports.useState({ show: false, title: "", message: "", type: "error" });
  const lastActivityRef = reactExports.useRef(Date.now());
  const lockTimerRef = reactExports.useRef(null);
  const showAlert = reactExports.useCallback((message, title = "", type = "error") => {
    setAlertModal({ show: true, title, message, type });
  }, []);
  const closeAlert = reactExports.useCallback(() => {
    setAlertModal({ show: false, title: "", message: "", type: "error" });
  }, []);
  const triggerActivityRefresh = reactExports.useCallback(() => {
    setActivityRefreshKey((prev) => prev + 1);
  }, []);
  const triggerBalanceRefresh = reactExports.useCallback(() => {
    setBalanceRefreshKey((prev) => prev + 1);
  }, []);
  reactExports.useEffect(() => {
    let port = null;
    let isApprovalWindow = false;
    const checkDAppRequest = async () => {
      var _a3;
      try {
        if (!isExtensionContextValid()) {
          logger$1.log("[App] Extension context invalid, skipping dApp request check");
          return;
        }
        const urlParams2 = new URLSearchParams(window.location.search);
        isApprovalWindow = urlParams2.has("request");
        if (isApprovalWindow) {
          const response = await safeSendMessage({ type: "get-pending-request" });
          if (response) {
            const pendingReq = (response == null ? void 0 : response.request) || response;
            setHasDAppRequest(pendingReq && pendingReq.type ? true : false);
          }
          return;
        }
      } catch (err) {
        if (!((_a3 = err.message) == null ? void 0 : _a3.includes("Extension context invalidated"))) {
          logger$1.log("[App] Error checking dApp request:", err.message);
        }
      }
    };
    const connectPort = () => {
      var _a3;
      if (!isExtensionContextValid()) return;
      try {
        port = chrome.runtime.connect({ name: "x1-wallet-popup" });
        port.onMessage.addListener((message) => {
          if (message.type === "pending-request" && message.request) {
            logger$1.log("[App] Received pending request via port:", message.request.type);
            setHasDAppRequest(true);
          }
        });
        port.onDisconnect.addListener(() => {
          logger$1.log("[App] Port disconnected from background");
          port = null;
        });
        logger$1.log("[App] Connected to background via port");
      } catch (err) {
        if (!((_a3 = err.message) == null ? void 0 : _a3.includes("Extension context invalidated"))) {
          logger$1.log("[App] Failed to connect port:", err.message);
        }
      }
    };
    connectPort();
    checkDAppRequest();
    let interval = null;
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("request")) {
      interval = setInterval(checkDAppRequest, 500);
    }
    return () => {
      if (interval) clearInterval(interval);
      if (port) {
        try {
          port.disconnect();
        } catch (e) {
        }
      }
    };
  }, []);
  reactExports.useCallback(async () => {
    var _a3;
    if (!((_a3 = wallet.wallet) == null ? void 0 : _a3.publicKey)) {
      logger$1.log("[App] Cannot fetch tokens - no publicKey");
      return;
    }
    if (!wallet.network) {
      logger$1.log("[App] Cannot fetch tokens - no network");
      return;
    }
  }, [(_b2 = wallet.wallet) == null ? void 0 : _b2.publicKey, wallet.network]);
  reactExports.useEffect(() => {
  }, [(_c = wallet.wallet) == null ? void 0 : _c.publicKey, wallet.network]);
  const [passwordProtection, setPasswordProtection] = reactExports.useState(() => storage.get("passwordProtection", false));
  const [hasPasswordAsync, setHasPasswordAsync] = reactExports.useState(false);
  const [autoLockMinutes, setAutoLockMinutes] = reactExports.useState(() => {
    const saved = storage.get("autoLock", 5);
    if (saved === -1) {
      storage.set("autoLock", 1440);
      return 1440;
    }
    return saved;
  });
  const [passwordCheckComplete, setPasswordCheckComplete] = reactExports.useState(false);
  const [sessionPassword, setSessionPassword] = reactExports.useState(null);
  reactExports.useEffect(() => {
    const checkHasPassword = async () => {
      try {
        const localProtection = localStorage.getItem("x1wallet_passwordProtection");
        const localAutoLock = localStorage.getItem("x1wallet_autoLock");
        console.log("[App] Password check - localStorage protection:", localProtection, "autoLock:", localAutoLock);
        if (typeof chrome !== "undefined" && chrome.storage) {
          try {
            const result2 = await chrome.storage.local.get(["x1wallet_passwordProtection", "x1wallet_autoLock"]);
            console.log("[App] chrome.storage values:", result2);
            if (localProtection === null && result2.x1wallet_passwordProtection !== void 0) {
              let protectionValue = result2.x1wallet_passwordProtection;
              if (typeof protectionValue === "string") {
                try {
                  protectionValue = JSON.parse(protectionValue);
                } catch {
                }
              }
              console.log("[App] Syncing protection from chrome.storage:", protectionValue);
              localStorage.setItem("x1wallet_passwordProtection", JSON.stringify(protectionValue));
            }
            if (localAutoLock === null && result2.x1wallet_autoLock !== void 0) {
              let autoLockValue = result2.x1wallet_autoLock;
              if (typeof autoLockValue === "string") {
                try {
                  autoLockValue = JSON.parse(autoLockValue);
                } catch {
                }
              }
              if (autoLockValue === -1) {
                autoLockValue = 1440;
              }
              localStorage.setItem("x1wallet_autoLock", JSON.stringify(autoLockValue));
            }
          } catch (e) {
          }
        }
        setPasswordProtection(storage.get("passwordProtection", false));
        let finalAutoLock = storage.get("autoLock", 5);
        if (finalAutoLock === -1) {
          finalAutoLock = 1440;
          storage.set("autoLock", 1440);
        }
        setAutoLockMinutes(finalAutoLock);
        const { hasPassword: checkHasPass } = await __vitePreload(async () => {
          const { hasPassword: checkHasPass2 } = await import("./wallet.js");
          return { hasPassword: checkHasPass2 };
        }, true ? [] : void 0);
        const result = await checkHasPass();
        setHasPasswordAsync(result);
        setPasswordCheckComplete(true);
      } catch {
        setHasPasswordAsync(
          storage.get("passwordHash", null) !== null || !!localStorage.getItem("x1wallet_auth")
        );
        setPasswordCheckComplete(true);
      }
    };
    checkHasPassword();
  }, []);
  const hasPassword = hasPasswordAsync;
  const updateActivity = reactExports.useCallback(() => {
    const now = Date.now();
    lastActivityRef.current = now;
    storage.set("lastActivity", now);
  }, []);
  reactExports.useEffect(() => {
    if (!passwordProtection || !hasPassword) {
      return;
    }
    if (autoLockMinutes < 0) {
      return;
    }
    const checkLock = () => {
      const activeScreens = ["settings", "send", "swap", "bridge", "stake", "tokenDetail", "create", "import", "hardware"];
      if (activeScreens.includes(screen)) return;
      if (autoLockMinutes === 0) return;
      const elapsed = (Date.now() - lastActivityRef.current) / 1e3 / 60;
      if (elapsed >= autoLockMinutes && !isLocked && screen !== "welcome" && screen !== "loading") {
        setIsLocked(true);
      }
    };
    lockTimerRef.current = setInterval(checkLock, 1e4);
    const events = ["mousedown", "keydown", "touchstart", "scroll"];
    events.forEach((e) => window.addEventListener(e, updateActivity));
    return () => {
      if (lockTimerRef.current) clearInterval(lockTimerRef.current);
      events.forEach((e) => window.removeEventListener(e, updateActivity));
    };
  }, [passwordProtection, hasPassword, autoLockMinutes, isLocked, screen, updateActivity]);
  reactExports.useEffect(() => {
    if (wallet.loading || initialCheckDone || !passwordCheckComplete) return;
    const checkWallet = async () => {
      var _a3;
      await new Promise((r2) => setTimeout(r2, 100));
      const urlParams = new URLSearchParams(window.location.search);
      const hwParam = urlParams.get("hw");
      const encryptedData = localStorage.getItem("x1wallet_wallets");
      const encryptedFlag = localStorage.getItem("x1wallet_encrypted");
      let isDataEncrypted = false;
      if (encryptedData && encryptedData.length > 0) {
        try {
          JSON.parse(encryptedData);
          console.log("[App] Wallet data is valid JSON (not encrypted)");
        } catch {
          isDataEncrypted = true;
          console.log("[App] Wallet data is NOT valid JSON (encrypted)");
        }
      }
      console.log("[App] State: wallets:", (_a3 = wallet.wallets) == null ? void 0 : _a3.length, "isDataEncrypted:", isDataEncrypted, "encryptedFlag:", encryptedFlag, "protection:", passwordProtection, "hasPassword:", hasPassword);
      if (wallet.wallets.length > 0) {
        logger$1.log("[App] Password check - protection:", passwordProtection, "hasPassword:", hasPassword, "autoLock:", autoLockMinutes);
        if (passwordProtection && hasPassword && autoLockMinutes >= 0) {
          const lastActivity = storage.get("lastActivity", 0);
          const elapsedMinutes = (Date.now() - lastActivity) / 1e3 / 60;
          if (lastActivity > 0 && elapsedMinutes >= autoLockMinutes) {
            setIsLocked(true);
          } else {
            const now = Date.now();
            lastActivityRef.current = now;
            storage.set("lastActivity", now);
          }
        } else if (!passwordProtection) {
          const now = Date.now();
          lastActivityRef.current = now;
          storage.set("lastActivity", now);
        }
        if (hwParam === "1") {
          setReturnScreen("main");
          setScreen("hardware");
        } else {
          setScreen("main");
        }
      } else if (isDataEncrypted) {
        if (passwordProtection) {
          logger$1.log("[App] Encrypted data found, protection ON - need unlock");
          setIsLocked(true);
          setScreen("main");
        } else {
          logger$1.log("[App] Encrypted data but protection OFF - clearing and going to welcome");
          localStorage.removeItem("x1wallet_encrypted");
          setScreen("welcome");
        }
      } else {
        if (hwParam === "1") {
          setReturnScreen("welcome");
          setScreen("hardware");
        } else {
          setScreen("welcome");
        }
      }
      setInitialCheckDone(true);
    };
    checkWallet();
  }, [wallet.loading, initialCheckDone, passwordCheckComplete, passwordProtection, hasPassword, autoLockMinutes]);
  reactExports.useEffect(() => {
    const encryptedData = localStorage.getItem("x1wallet_wallets");
    let isDataEncrypted = false;
    if (encryptedData && encryptedData.length > 0) {
      try {
        JSON.parse(encryptedData);
      } catch {
        isDataEncrypted = true;
      }
    }
    if (initialCheckDone && !wallet.loading && wallet.wallets.length === 0 && screen === "main" && !isDataEncrypted) {
      setScreen("welcome");
    }
  }, [wallet.wallets.length, wallet.loading, initialCheckDone, screen]);
  const handleUnlock = async (password) => {
    setIsLocked(false);
    setSessionPassword(password);
    const now = Date.now();
    lastActivityRef.current = now;
    storage.set("lastActivity", now);
  };
  const handleCreateComplete = async (mnemonic, name, password) => {
    try {
      if (!password) {
        throw new Error("Password is required to create a wallet");
      }
      setUserTokens([]);
      logger$1.log("[handleCreateComplete] Creating encrypted wallet");
      const { setupPassword, hasPassword: checkHasPassword } = await __vitePreload(async () => {
        const { setupPassword: setupPassword2, hasPassword: checkHasPassword2 } = await import("./wallet.js");
        return { setupPassword: setupPassword2, hasPassword: checkHasPassword2 };
      }, true ? [] : void 0);
      const passwordExists = await checkHasPassword();
      const hasWallets = wallet.wallets && wallet.wallets.length > 0;
      const effectivePasswordExists = passwordExists && hasWallets;
      await wallet.createWallet(mnemonic, name, password);
      if (!effectivePasswordExists) {
        await setupPassword(password);
      }
      setSessionPassword(password);
      setHasPasswordAsync(true);
      localStorage.setItem("x1wallet_encrypted", "true");
      storage.set("passwordProtection", true);
      storage.set("lastActivity", Date.now());
      setScreen("main");
      return;
    } catch (err) {
      logger$1.error("Failed to create wallet:", err);
      showAlert(err.message || "Failed to create wallet", "Creation Failed", "warning");
    }
  };
  const handleImportComplete = async (mnemonic, name, password) => {
    try {
      if (!password) {
        throw new Error("Password is required");
      }
      setUserTokens([]);
      const { setupPassword, hasPassword: checkHasPassword } = await __vitePreload(async () => {
        const { setupPassword: setupPassword2, hasPassword: checkHasPassword2 } = await import("./wallet.js");
        return { setupPassword: setupPassword2, hasPassword: checkHasPassword2 };
      }, true ? [] : void 0);
      const passwordExists = await checkHasPassword();
      const hasWallets = wallet.wallets && wallet.wallets.length > 0;
      const effectivePasswordExists = passwordExists && hasWallets;
      await wallet.importWallet(mnemonic, name, password);
      if (!effectivePasswordExists) {
        await setupPassword(password);
      }
      setSessionPassword(password);
      storage.set("passwordProtection", true);
      setPasswordProtection(true);
      setHasPasswordAsync(true);
      localStorage.setItem("x1wallet_encrypted", "true");
      storage.set("lastActivity", Date.now());
      setScreen("main");
      return;
    } catch (err) {
      logger$1.error("Failed to import wallet:", err);
      showAlert(err.message || "Failed to import wallet", "Import Failed", "warning");
    }
  };
  const handleImportPrivateKey = async (walletData) => {
    try {
      const password = walletData.password;
      if (!password) {
        showAlert("Password is required", "Security Error", "error");
        return;
      }
      const existingWallets = wallet.wallets || [];
      const existingMatch = existingWallets.find(
        (w2) => {
          var _a3;
          return w2.publicKey === walletData.publicKey || ((_a3 = w2.addresses) == null ? void 0 : _a3.some((a) => a.publicKey === walletData.publicKey));
        }
      );
      if (existingMatch) {
        showAlert(`This wallet has already been imported as "${existingMatch.name}"`, "Wallet Already Exists", "warning");
        return;
      }
      setUserTokens([]);
      const { setupPassword, hasPassword: checkHasPassword } = await __vitePreload(async () => {
        const { setupPassword: setupPassword2, hasPassword: checkHasPassword2 } = await import("./wallet.js");
        return { setupPassword: setupPassword2, hasPassword: checkHasPassword2 };
      }, true ? [] : void 0);
      const passwordExists = await checkHasPassword();
      const hasWallets = existingWallets.length > 0;
      const effectivePasswordExists = passwordExists && hasWallets;
      const newWallet = {
        id: Date.now().toString(),
        name: walletData.name || "Imported Wallet",
        publicKey: walletData.publicKey,
        privateKey: walletData.privateKey,
        mnemonic: null,
        type: "imported",
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        addresses: [{
          index: 0,
          publicKey: walletData.publicKey,
          privateKey: walletData.privateKey,
          name: "Address 1"
        }],
        activeAddressIndex: 0
      };
      await wallet.saveWallets([...existingWallets, newWallet], password);
      wallet.selectWallet(newWallet.id);
      if (!effectivePasswordExists) {
        await setupPassword(password);
      }
      setSessionPassword(password);
      storage.set("passwordProtection", true);
      setPasswordProtection(true);
      setHasPasswordAsync(true);
      localStorage.setItem("x1wallet_encrypted", "true");
      storage.set("lastActivity", Date.now());
      setScreen("main");
    } catch (err) {
      logger$1.error("Failed to import private key wallet:", err);
      showAlert("Failed to import wallet: " + err.message, "Import Failed", "error");
    }
  };
  const handleLock = () => {
    wallet.lockWallet();
    setSessionPassword(null);
    setIsLocked(true);
  };
  const handleManagerCreate = () => {
    setReturnScreen("main");
    setScreen("create");
  };
  const handleManagerImport = () => {
    setReturnScreen("main");
    setScreen("import");
  };
  const handleManagerHardware = () => {
    const isExtensionPopup = typeof chrome !== "undefined" && chrome.runtime && chrome.runtime.id && window.innerWidth < 500;
    if (isExtensionPopup) {
      const extensionUrl = chrome.runtime.getURL("index.html");
      chrome.tabs.create({ url: extensionUrl + "?hw=1" });
      window.close();
    } else {
      setReturnScreen("main");
      setScreen("hardware");
    }
  };
  const [hwImportInProgress, setHwImportInProgress] = reactExports.useState(false);
  const handleHardwareComplete = async (hwWalletOrArray) => {
    if (hwImportInProgress) {
      logger$1.warn("[App] Hardware wallet import already in progress, ignoring duplicate call");
      return;
    }
    setHwImportInProgress(true);
    try {
      let passwordUsed = null;
      if (Array.isArray(hwWalletOrArray)) {
        if (hwWalletOrArray.length > 0 && hwWalletOrArray[0].password) {
          passwordUsed = hwWalletOrArray[0].password;
        }
        for (let i = 0; i < hwWalletOrArray.length; i++) {
          const { password, ...walletData } = hwWalletOrArray[i];
          await wallet.addHardwareWallet(walletData, passwordUsed);
        }
      } else {
        const { password, ...walletData } = hwWalletOrArray;
        passwordUsed = password;
        await wallet.addHardwareWallet(walletData, password);
      }
      if (passwordUsed) {
        const { setupPassword, hasPassword: checkHasPassword } = await __vitePreload(async () => {
          const { setupPassword: setupPassword2, hasPassword: checkHasPassword2 } = await import("./wallet.js");
          return { setupPassword: setupPassword2, hasPassword: checkHasPassword2 };
        }, true ? [] : void 0);
        const passwordExists = await checkHasPassword();
        if (!passwordExists) {
          await setupPassword(passwordUsed);
        }
        storage.set("passwordProtection", true);
        setPasswordProtection(true);
        setHasPasswordAsync(true);
        localStorage.setItem("x1wallet_encrypted", "true");
      }
      storage.set("lastActivity", Date.now());
      const urlParams = new URLSearchParams(window.location.search);
      const isFullTab = urlParams.get("hw") === "1" && window.innerWidth >= 500;
      if (isFullTab) {
        setScreen("hardware-success");
      } else {
        setScreen("main");
      }
    } catch (err) {
      logger$1.error("Failed to add hardware wallet:", err);
      showAlert(err.message || "Failed to add hardware wallet", "Error", "warning");
    } finally {
      setHwImportInProgress(false);
    }
  };
  if (screen === "loading" || wallet.loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "app loading", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }) });
  }
  if (isLocked && screen !== "welcome") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "app", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      LockScreen,
      {
        onUnlock: handleUnlock,
        walletUnlock: wallet.isEncrypted ? wallet.unlockWallet : null
      }
    ) });
  }
  const BottomNav = () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bottom-nav", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: `nav-item ${screen === "main" ? "active" : ""}`, onClick: () => setScreen("main"), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "7", height: "7", rx: "1" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "14", y: "3", width: "7", height: "7", rx: "1" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "14", width: "7", height: "7", rx: "1" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "14", y: "14", width: "7", height: "7", rx: "1" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Assets" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: `nav-item ${screen === "swap" ? "active" : ""}`, onClick: () => setScreen("swap"), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17 2l4 4-4 4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3 11V9a4 4 0 0 1 4-4h14" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 22l-4-4 4-4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 13v2a4 4 0 0 1-4 4H3" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Swap" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: `nav-item ${screen === "browser" ? "active" : ""}`, onClick: () => setScreen("browser"), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "2", y1: "12", x2: "22", y2: "12" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Browse" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: `nav-item ${screen === "settings" ? "active" : ""}`, onClick: () => setScreen("settings"), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "3" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Settings" })
    ] })
  ] });
  if (screen === "welcome") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "app", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      WelcomeScreen,
      {
        onCreateWallet: () => {
          setReturnScreen("main");
          setScreen("create");
        },
        onImportWallet: () => {
          setReturnScreen("main");
          setScreen("import");
        },
        onHardwareWallet: () => {
          setReturnScreen("welcome");
          setScreen("hardware");
        },
        onBack: ((_d = wallet.wallets) == null ? void 0 : _d.length) > 0 ? () => setScreen("main") : null
      }
    ) });
  }
  if (screen === "create") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
      alertModal.show && /* @__PURE__ */ jsxRuntimeExports.jsx(
        AlertModal,
        {
          title: alertModal.title,
          message: alertModal.message,
          type: alertModal.type,
          onClose: closeAlert
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        CreateWallet,
        {
          onComplete: handleCreateComplete,
          onBack: () => setScreen(returnScreen === "manage" ? "manage" : "welcome"),
          passwordProtection,
          sessionPassword
        }
      )
    ] });
  }
  if (screen === "import") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
      alertModal.show && /* @__PURE__ */ jsxRuntimeExports.jsx(
        AlertModal,
        {
          title: alertModal.title,
          message: alertModal.message,
          type: alertModal.type,
          onClose: closeAlert
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ImportWallet,
        {
          onComplete: handleImportComplete,
          onCompletePrivateKey: handleImportPrivateKey,
          onBack: () => setScreen(returnScreen === "manage" ? "manage" : "welcome"),
          sessionPassword
        }
      )
    ] });
  }
  if (screen === "hardware") {
    const isFullTab = window.innerWidth >= 500;
    if (isFullTab) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-fullpage", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hardware-fullpage-bg" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hardware-fullpage-logo", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "/icons/128-x1.png", alt: "X1" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-fullpage-card", children: [
          alertModal.show && /* @__PURE__ */ jsxRuntimeExports.jsx(
            AlertModal,
            {
              title: alertModal.title,
              message: alertModal.message,
              type: alertModal.type,
              onClose: closeAlert
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            HardwareWallet,
            {
              onComplete: handleHardwareComplete,
              onBack: () => {
                if (wallet.wallets && wallet.wallets.length > 0) {
                  setScreen("main");
                } else {
                  setScreen("welcome");
                }
              },
              isFirstWallet: !wallet.wallets || wallet.wallets.length === 0,
              existingWallets: wallet.wallets || [],
              network: wallet.network,
              isFullTab: true
            }
          )
        ] })
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
      alertModal.show && /* @__PURE__ */ jsxRuntimeExports.jsx(
        AlertModal,
        {
          title: alertModal.title,
          message: alertModal.message,
          type: alertModal.type,
          onClose: closeAlert
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        HardwareWallet,
        {
          onComplete: handleHardwareComplete,
          onBack: () => setScreen(returnScreen === "manage" ? "manage" : "main"),
          isFirstWallet: !wallet.wallets || wallet.wallets.length === 0,
          existingWallets: wallet.wallets || [],
          network: wallet.network
        }
      )
    ] });
  }
  if (screen === "hardware-success") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-fullpage", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hardware-fullpage-bg" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hardware-fullpage-logo", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "/icons/128-x1.png", alt: "X1" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hardware-fullpage-card", style: { textAlign: "center", padding: "48px 32px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
          width: 80,
          height: 80,
          borderRadius: "50%",
          background: "rgba(34, 197, 94, 0.1)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          margin: "0 auto 24px"
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "40", height: "40", viewBox: "0 0 24 24", fill: "none", stroke: "var(--success)", strokeWidth: "3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { marginBottom: 12, fontSize: 24 }, children: "Wallet Imported!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "var(--text-muted)", marginBottom: 32, fontSize: 15, lineHeight: 1.5 }, children: "Your hardware wallet has been successfully connected. Click the X1 Wallet extension icon in your browser toolbar to access your wallet." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          gap: 12,
          padding: "16px 20px",
          background: "var(--bg-secondary)",
          borderRadius: 12,
          marginBottom: 32
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "/icons/128-x1.png", alt: "X1", style: { width: 40, height: 40, objectFit: "contain" } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 14, color: "var(--text-secondary)" }, children: "Click the extension icon to open your wallet" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 17L17 7M17 7H7M17 7V17" }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "btn-secondary",
            onClick: () => {
              if (typeof chrome !== "undefined" && chrome.tabs) {
                chrome.tabs.getCurrent((tab) => {
                  if (tab == null ? void 0 : tab.id) {
                    chrome.tabs.remove(tab.id);
                  }
                });
              } else {
                window.close();
              }
            },
            style: { width: "100%", height: 48 },
            children: "Close This Tab"
          }
        )
      ] })
    ] });
  }
  if (screen === "manage") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        WalletManager,
        {
          wallet,
          onBack: () => setScreen("main"),
          onCreateWallet: handleManagerCreate,
          onImportWallet: handleManagerImport
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BottomNav, {})
    ] });
  }
  if (screen === "settings") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsScreen,
        {
          wallet,
          onBack: () => setScreen("main"),
          onLock: handleLock,
          initialPasswordProtection: passwordProtection,
          onPasswordProtectionChange: (newValue) => {
            setPasswordProtection(newValue);
            if (!newValue) {
              setIsLocked(false);
              setHasPasswordAsync(false);
            }
          },
          onAutoLockChange: (newValue) => {
            setAutoLockMinutes(newValue);
          }
        },
        `settings-${passwordProtection}`
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BottomNav, {})
    ] });
  }
  if (screen === "send") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SendFlow,
        {
          wallet,
          selectedToken,
          userTokens,
          onBack: () => {
            setSelectedToken(null);
            setScreen("main");
            triggerBalanceRefresh();
          },
          onSuccess: () => {
            triggerActivityRefresh();
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BottomNav, {})
    ] });
  }
  if (screen === "tokenDetail") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TokenDetail,
        {
          token: selectedToken,
          wallet,
          onBack: () => {
            setSelectedToken(null);
            setScreen("main");
          },
          onSend: (token) => {
            setSelectedToken(token);
            setScreen("send");
          },
          onReceive: () => setScreen("receive"),
          onSwap: (token) => {
            setSelectedToken(token);
            setScreen("swap");
          },
          onBridge: () => setScreen("bridge"),
          onStake: () => setScreen("stake")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BottomNav, {})
    ] });
  }
  if (screen === "receive") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ReceiveScreen,
        {
          wallet,
          onBack: () => setScreen("main")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BottomNav, {})
    ] });
  }
  if (screen === "swap") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SwapScreen,
        {
          wallet,
          onBack: () => setScreen("main"),
          onSwapComplete: (updatedTokens) => {
            if (updatedTokens && updatedTokens.length > 0) {
              setUserTokens(updatedTokens);
            }
            triggerActivityRefresh();
            triggerBalanceRefresh();
          },
          userTokens,
          initialFromToken: selectedToken
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BottomNav, {})
    ] });
  }
  if (screen === "bridge") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        BridgeScreen,
        {
          wallet,
          onBack: (action) => {
            setScreen("main");
            if (action === "network") {
              sessionStorage.setItem("openNetworkPanel", "true");
            }
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BottomNav, {})
    ] });
  }
  if (screen === "stake") {
    logger$1.log("[App] Rendering stake screen");
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        StakeScreen,
        {
          wallet,
          onBack: (action) => {
            setScreen("main");
            if (action === "network") {
              sessionStorage.setItem("openNetworkPanel", "true");
            }
          },
          onRefreshBalance: () => wallet.refreshBalance()
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BottomNav, {})
    ] });
  }
  if (screen === "browser") {
    const dapps = [
      {
        name: "X1 Blockchain",
        url: "https://x1.xyz",
        logo: "/icons/48-x1.png",
        desc: "Layer-1 Blockchain"
      },
      {
        name: "XDEX",
        url: "https://xdex.xyz",
        logo: "/icons/48-xdex.png",
        desc: "X1 Native DEX"
      },
      {
        name: "Degen",
        url: "https://degen.fyi",
        logo: "/icons/48-degen.png",
        desc: "Launchpad"
      },
      {
        name: "Vero",
        url: "https://vero.x1.xyz/",
        letter: "V",
        color: "#8b5cf6",
        desc: "Predictive Markets"
      },
      {
        name: "Bridge",
        url: "https://bridge.x1.xyz/",
        letter: "B",
        color: "#14F195",
        desc: "Cross-Chain Bridge"
      }
    ];
    const renderIcon = (dapp) => {
      if (dapp.logo) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: dapp.logo, alt: dapp.name, style: { width: 36, height: 36, borderRadius: 10, objectFit: "cover" } });
      }
      if (dapp.letter) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
          width: 36,
          height: 36,
          borderRadius: 10,
          background: "#000",
          border: "1px solid var(--border-color)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 18, fontWeight: 700, color: dapp.color || "var(--text-primary)" }, children: dapp.letter }) });
      }
      if (dapp.svgIcon === "explorer") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
          width: 36,
          height: 36,
          borderRadius: 10,
          background: "#000",
          border: "1px solid var(--border-color)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-primary)", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "3", width: "7", height: "7", rx: "1" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "14", y: "3", width: "7", height: "7", rx: "1" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "14", width: "7", height: "7", rx: "1" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "14", y: "14", width: "7", height: "7", rx: "1" })
        ] }) });
      }
      return null;
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "screen browser-screen", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "page-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "header-title", children: "Explore dApps" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dapp-grid", children: dapps.map((dapp, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            className: "dapp-card",
            onClick: () => window.open(dapp.url, "_blank"),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dapp-card-icon", style: { background: "transparent" }, children: renderIcon(dapp) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dapp-card-info", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-card-name", children: dapp.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dapp-card-desc", children: dapp.desc })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "var(--text-muted)", strokeWidth: "2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "15 3 21 3 21 9" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "10", y1: "14", x2: "21", y2: "3" })
              ] })
            ]
          },
          i
        )) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BottomNav, {})
    ] });
  }
  if (hasDAppRequest && wallet.wallet) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "app", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      DAppApproval,
      {
        wallet,
        onComplete: () => setHasDAppRequest(false)
      }
    ) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
    alertModal.show && /* @__PURE__ */ jsxRuntimeExports.jsx(
      AlertModal,
      {
        title: alertModal.title,
        message: alertModal.message,
        type: alertModal.type,
        onClose: closeAlert
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      WalletMain,
      {
        wallet,
        userTokens,
        onTokensUpdate: setUserTokens,
        onSend: (token) => {
          setSelectedToken(token || null);
          setScreen("send");
        },
        onReceive: () => setScreen("receive"),
        onSwap: (token) => {
          setSelectedToken(token || null);
          setScreen("swap");
        },
        onBridge: () => setScreen("bridge"),
        onStake: () => {
          logger$1.log("[App] Setting screen to stake");
          setScreen("stake");
        },
        onSettings: () => setScreen("settings"),
        onCreateWallet: handleManagerCreate,
        onImportWallet: handleManagerImport,
        onHardwareWallet: handleManagerHardware,
        activityRefreshKey,
        balanceRefreshKey,
        onTokenClick: (token) => {
          setSelectedToken(token);
          setScreen("tokenDetail");
        }
      },
      `${(_e = wallet.wallet) == null ? void 0 : _e.publicKey}-${wallet.network}`
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BottomNav, {})
  ] });
}
function AppWithErrorBoundary() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) });
}
client.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppWithErrorBoundary, {}) })
);
export {
  getAugmentedNamespace as a,
  commonjsGlobal as c,
  getDefaultExportFromCjs as g,
  hashPassword as h,
  logger$1 as l,
  verifyPassword as v
};
